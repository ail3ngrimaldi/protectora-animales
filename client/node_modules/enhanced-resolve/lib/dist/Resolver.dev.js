/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var util = require("util");

var Tapable = require("tapable/lib/Tapable");

var SyncHook = require("tapable/lib/SyncHook");

var AsyncSeriesBailHook = require("tapable/lib/AsyncSeriesBailHook");

var AsyncSeriesHook = require("tapable/lib/AsyncSeriesHook");

var createInnerContext = require("./createInnerContext");

var REGEXP_NOT_MODULE = /^\.$|^\.[\\/]|^\.\.$|^\.\.[\\/]|^\/|^[A-Z]:[\\/]/i;
var REGEXP_DIRECTORY = /[\\/]$/i;

var memoryFsJoin = require("memory-fs/lib/join");

var memoizedJoin = new Map();

var memoryFsNormalize = require("memory-fs/lib/normalize");

function withName(name, hook) {
  hook.name = name;
  return hook;
}

function toCamelCase(str) {
  return str.replace(/-([a-z])/g, function (str) {
    return str.substr(1).toUpperCase();
  });
}

var deprecatedPushToMissing = util.deprecate(function (set, item) {
  set.add(item);
}, "Resolver: 'missing' is now a Set. Use add instead of push.");
var deprecatedResolveContextInCallback = util.deprecate(function (x) {
  return x;
}, "Resolver: The callback argument was splitted into resolveContext and callback.");
var deprecatedHookAsString = util.deprecate(function (x) {
  return x;
}, "Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.");

var Resolver =
/*#__PURE__*/
function (_Tapable) {
  _inherits(Resolver, _Tapable);

  function Resolver(fileSystem) {
    var _this;

    _classCallCheck(this, Resolver);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Resolver).call(this));
    _this.fileSystem = fileSystem;
    _this.hooks = {
      resolveStep: withName("resolveStep", new SyncHook(["hook", "request"])),
      noResolve: withName("noResolve", new SyncHook(["request", "error"])),
      resolve: withName("resolve", new AsyncSeriesBailHook(["request", "resolveContext"])),
      result: new AsyncSeriesHook(["result", "resolveContext"])
    };

    _this._pluginCompat.tap("Resolver: before/after", function (options) {
      if (/^before-/.test(options.name)) {
        options.name = options.name.substr(7);
        options.stage = -10;
      } else if (/^after-/.test(options.name)) {
        options.name = options.name.substr(6);
        options.stage = 10;
      }
    });

    _this._pluginCompat.tap("Resolver: step hooks", function (options) {
      var name = options.name;
      var stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);

      if (stepHook) {
        options.async = true;

        _this.ensureHook(name);

        var fn = options.fn;

        options.fn = function (request, resolverContext, callback) {
          var innerCallback = function innerCallback(err, result) {
            if (err) return callback(err);
            if (result !== undefined) return callback(null, result);
            callback();
          };

          for (var key in resolverContext) {
            innerCallback[key] = resolverContext[key];
          }

          fn.call(_assertThisInitialized(_this), request, innerCallback);
        };
      }
    });

    return _this;
  }

  _createClass(Resolver, [{
    key: "ensureHook",
    value: function ensureHook(name) {
      if (typeof name !== "string") return name;
      name = toCamelCase(name);

      if (/^before/.test(name)) {
        return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({
          stage: -10
        });
      }

      if (/^after/.test(name)) {
        return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({
          stage: 10
        });
      }

      var hook = this.hooks[name];

      if (!hook) {
        return this.hooks[name] = withName(name, new AsyncSeriesBailHook(["request", "resolveContext"]));
      }

      return hook;
    }
  }, {
    key: "getHook",
    value: function getHook(name) {
      if (typeof name !== "string") return name;
      name = toCamelCase(name);

      if (/^before/.test(name)) {
        return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({
          stage: -10
        });
      }

      if (/^after/.test(name)) {
        return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({
          stage: 10
        });
      }

      var hook = this.hooks[name];

      if (!hook) {
        throw new Error("Hook ".concat(name, " doesn't exist"));
      }

      return hook;
    }
  }, {
    key: "resolveSync",
    value: function resolveSync(context, path, request) {
      var err,
          result,
          sync = false;
      this.resolve(context, path, request, {}, function (e, r) {
        err = e;
        result = r;
        sync = true;
      });
      if (!sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
      if (err) throw err;
      return result;
    }
  }, {
    key: "resolve",
    value: function resolve(context, path, request, resolveContext, callback) {
      var _this2 = this;

      // TODO remove in enhanced-resolve 5
      // For backward compatiblity START
      if (typeof callback !== "function") {
        callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties
        // It's now used for resolveContext and callback
      } // END


      var obj = {
        context: context,
        path: path,
        request: request
      };
      var message = "resolve '" + request + "' in '" + path + "'"; // Try to resolve assuming there is no error
      // We don't log stuff in this case

      return this.doResolve(this.hooks.resolve, obj, message, {
        missing: resolveContext.missing,
        stack: resolveContext.stack
      }, function (err, result) {
        if (!err && result) {
          return callback(null, result.path === false ? false : result.path + (result.query || ""), result);
        }

        var localMissing = new Set(); // TODO remove in enhanced-resolve 5

        localMissing.push = function (item) {
          return deprecatedPushToMissing(localMissing, item);
        };

        var _log = [];
        return _this2.doResolve(_this2.hooks.resolve, obj, message, {
          log: function log(msg) {
            if (resolveContext.log) {
              resolveContext.log(msg);
            }

            _log.push(msg);
          },
          missing: localMissing,
          stack: resolveContext.stack
        }, function (err, result) {
          if (err) return callback(err);
          var error = new Error("Can't " + message);
          error.details = _log.join("\n");
          error.missing = Array.from(localMissing);

          _this2.hooks.noResolve.call(obj, error);

          return callback(error);
        });
      });
    }
  }, {
    key: "doResolve",
    value: function doResolve(hook, request, message, resolveContext, callback) {
      // TODO remove in enhanced-resolve 5
      // For backward compatiblity START
      if (typeof callback !== "function") {
        callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties
        // It's now used for resolveContext and callback
      }

      if (typeof hook === "string") {
        var name = toCamelCase(hook);
        hook = deprecatedHookAsString(this.hooks[name]);

        if (!hook) {
          throw new Error("Hook \"".concat(name, "\" doesn't exist"));
        }
      } // END


      if (typeof callback !== "function") throw new Error("callback is not a function " + Array.from(arguments));
      if (!resolveContext) throw new Error("resolveContext is not an object " + Array.from(arguments));
      var stackLine = hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
      var newStack;

      if (resolveContext.stack) {
        newStack = new Set(resolveContext.stack);

        if (resolveContext.stack.has(stackLine)) {
          // Prevent recursion
          var recursionError = new Error("Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  "));
          recursionError.recursion = true;
          if (resolveContext.log) resolveContext.log("abort resolving because of recursion");
          return callback(recursionError);
        }

        newStack.add(stackLine);
      } else {
        newStack = new Set([stackLine]);
      }

      this.hooks.resolveStep.call(hook, request);

      if (hook.isUsed()) {
        var innerContext = createInnerContext({
          log: resolveContext.log,
          missing: resolveContext.missing,
          stack: newStack
        }, message);
        return hook.callAsync(request, innerContext, function (err, result) {
          if (err) return callback(err);
          if (result) return callback(null, result);
          callback();
        });
      } else {
        callback();
      }
    }
  }, {
    key: "parse",
    value: function parse(identifier) {
      if (identifier === "") return null;
      var part = {
        request: "",
        query: "",
        module: false,
        directory: false,
        file: false
      };
      var idxQuery = identifier.indexOf("?");

      if (idxQuery === 0) {
        part.query = identifier;
      } else if (idxQuery > 0) {
        part.request = identifier.slice(0, idxQuery);
        part.query = identifier.slice(idxQuery);
      } else {
        part.request = identifier;
      }

      if (part.request) {
        part.module = this.isModule(part.request);
        part.directory = this.isDirectory(part.request);

        if (part.directory) {
          part.request = part.request.substr(0, part.request.length - 1);
        }
      }

      return part;
    }
  }, {
    key: "isModule",
    value: function isModule(path) {
      return !REGEXP_NOT_MODULE.test(path);
    }
  }, {
    key: "isDirectory",
    value: function isDirectory(path) {
      return REGEXP_DIRECTORY.test(path);
    }
  }, {
    key: "join",
    value: function join(path, request) {
      var cacheEntry;
      var pathCache = memoizedJoin.get(path);

      if (typeof pathCache === "undefined") {
        memoizedJoin.set(path, pathCache = new Map());
      } else {
        cacheEntry = pathCache.get(request);
        if (typeof cacheEntry !== "undefined") return cacheEntry;
      }

      cacheEntry = memoryFsJoin(path, request);
      pathCache.set(request, cacheEntry);
      return cacheEntry;
    }
  }, {
    key: "normalize",
    value: function normalize(path) {
      return memoryFsNormalize(path);
    }
  }]);

  return Resolver;
}(Tapable);

module.exports = Resolver;