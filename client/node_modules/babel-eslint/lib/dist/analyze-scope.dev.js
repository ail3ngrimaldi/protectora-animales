"use strict";

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var t = require("@babel/types");

var requireFromESLint = require("./require-from-eslint");

var escope = requireFromESLint("eslint-scope");
var Definition = requireFromESLint("eslint-scope/lib/definition").Definition;
var OriginalPatternVisitor = requireFromESLint("eslint-scope/lib/pattern-visitor");
var OriginalReferencer = requireFromESLint("eslint-scope/lib/referencer");

var fallback = require("eslint-visitor-keys").getKeys;

var childVisitorKeys = require("./visitor-keys");

var flowFlippedAliasKeys = t.FLIPPED_ALIAS_KEYS.Flow.concat(["ArrayPattern", "ClassDeclaration", "ClassExpression", "FunctionDeclaration", "FunctionExpression", "Identifier", "ObjectPattern", "RestElement"]);
var visitorKeysMap = Object.keys(t.VISITOR_KEYS).reduce(function (acc, key) {
  var value = t.VISITOR_KEYS[key];

  if (flowFlippedAliasKeys.indexOf(value) === -1) {
    acc[key] = value;
  }

  return acc;
}, {});
var propertyTypes = {
  // loops
  callProperties: {
    type: "loop",
    values: ["value"]
  },
  indexers: {
    type: "loop",
    values: ["key", "value"]
  },
  properties: {
    type: "loop",
    values: ["argument", "value"]
  },
  types: {
    type: "loop"
  },
  params: {
    type: "loop"
  },
  // single property
  argument: {
    type: "single"
  },
  elementType: {
    type: "single"
  },
  qualification: {
    type: "single"
  },
  rest: {
    type: "single"
  },
  returnType: {
    type: "single"
  },
  // others
  typeAnnotation: {
    type: "typeAnnotation"
  },
  typeParameters: {
    type: "typeParameters"
  },
  id: {
    type: "id"
  }
};

var PatternVisitor =
/*#__PURE__*/
function (_OriginalPatternVisit) {
  _inherits(PatternVisitor, _OriginalPatternVisit);

  function PatternVisitor() {
    _classCallCheck(this, PatternVisitor);

    return _possibleConstructorReturn(this, _getPrototypeOf(PatternVisitor).apply(this, arguments));
  }

  _createClass(PatternVisitor, [{
    key: "ArrayPattern",
    value: function ArrayPattern(node) {
      node.elements.forEach(this.visit, this);
    }
  }, {
    key: "ObjectPattern",
    value: function ObjectPattern(node) {
      node.properties.forEach(this.visit, this);
    }
  }]);

  return PatternVisitor;
}(OriginalPatternVisitor);

var Referencer =
/*#__PURE__*/
function (_OriginalReferencer) {
  _inherits(Referencer, _OriginalReferencer);

  function Referencer() {
    _classCallCheck(this, Referencer);

    return _possibleConstructorReturn(this, _getPrototypeOf(Referencer).apply(this, arguments));
  }

  _createClass(Referencer, [{
    key: "visitPattern",
    // inherits.
    value: function visitPattern(node, options, callback) {
      if (!node) {
        return;
      } // Visit type annotations.


      this._checkIdentifierOrVisit(node.typeAnnotation);

      if (t.isAssignmentPattern(node)) {
        this._checkIdentifierOrVisit(node.left.typeAnnotation);
      } // Overwrite `super.visitPattern(node, options, callback)` in order to not visit `ArrayPattern#typeAnnotation` and `ObjectPattern#typeAnnotation`.


      if (typeof options === "function") {
        callback = options;
        options = {
          processRightHandNodes: false
        };
      }

      var visitor = new PatternVisitor(this.options, node, callback);
      visitor.visit(node); // Process the right hand nodes recursively.

      if (options.processRightHandNodes) {
        visitor.rightHandNodes.forEach(this.visit, this);
      }
    } // inherits.

  }, {
    key: "visitClass",
    value: function visitClass(node) {
      // Decorators.
      this._visitArray(node.decorators); // Flow type parameters.


      var typeParamScope = this._nestTypeParamScope(node); // Flow super types.


      this._visitTypeAnnotation(node["implements"]);

      this._visitTypeAnnotation(node.superTypeParameters && node.superTypeParameters.params); // Basic.


      _get(_getPrototypeOf(Referencer.prototype), "visitClass", this).call(this, node); // Close the type parameter scope.


      if (typeParamScope) {
        this.close(node);
      }
    } // inherits.

  }, {
    key: "visitFunction",
    value: function visitFunction(node) {
      var typeParamScope = this._nestTypeParamScope(node); // Flow return types.


      this._checkIdentifierOrVisit(node.returnType); // Basic.


      _get(_getPrototypeOf(Referencer.prototype), "visitFunction", this).call(this, node); // Close the type parameter scope.


      if (typeParamScope) {
        this.close(node);
      }
    } // inherits.

  }, {
    key: "visitProperty",
    value: function visitProperty(node) {
      if (node.value && node.value.type === "TypeCastExpression") {
        this._visitTypeAnnotation(node.value);
      }

      this._visitArray(node.decorators);

      _get(_getPrototypeOf(Referencer.prototype), "visitProperty", this).call(this, node);
    }
  }, {
    key: "InterfaceDeclaration",
    value: function InterfaceDeclaration(node) {
      this._createScopeVariable(node, node.id);

      var typeParamScope = this._nestTypeParamScope(node); // TODO: Handle mixins


      this._visitArray(node["extends"]);

      this.visit(node.body);

      if (typeParamScope) {
        this.close(node);
      }
    }
  }, {
    key: "EnumDeclaration",
    value: function EnumDeclaration(node) {
      this._createScopeVariable(node, node.id);
    }
  }, {
    key: "TypeAlias",
    value: function TypeAlias(node) {
      this._createScopeVariable(node, node.id);

      var typeParamScope = this._nestTypeParamScope(node);

      this.visit(node.right);

      if (typeParamScope) {
        this.close(node);
      }
    }
  }, {
    key: "ClassProperty",
    value: function ClassProperty(node) {
      this._visitClassProperty(node);
    }
  }, {
    key: "ClassPrivateProperty",
    value: function ClassPrivateProperty(node) {
      this._visitClassProperty(node);
    }
  }, {
    key: "DeclareModule",
    value: function DeclareModule(node) {
      this._visitDeclareX(node);
    }
  }, {
    key: "DeclareFunction",
    value: function DeclareFunction(node) {
      this._visitDeclareX(node);
    }
  }, {
    key: "DeclareVariable",
    value: function DeclareVariable(node) {
      this._visitDeclareX(node);
    }
  }, {
    key: "DeclareClass",
    value: function DeclareClass(node) {
      this._visitDeclareX(node);
    } // visit OptionalMemberExpression as a MemberExpression.

  }, {
    key: "OptionalMemberExpression",
    value: function OptionalMemberExpression(node) {
      _get(_getPrototypeOf(Referencer.prototype), "MemberExpression", this).call(this, node);
    }
  }, {
    key: "_visitClassProperty",
    value: function _visitClassProperty(node) {
      this._visitTypeAnnotation(node.typeAnnotation);

      this.visitProperty(node);
    }
  }, {
    key: "_visitDeclareX",
    value: function _visitDeclareX(node) {
      if (node.id) {
        this._createScopeVariable(node, node.id);
      }

      var typeParamScope = this._nestTypeParamScope(node);

      if (typeParamScope) {
        this.close(node);
      }
    }
  }, {
    key: "_createScopeVariable",
    value: function _createScopeVariable(node, name) {
      this.currentScope().variableScope.__define(name, new Definition("Variable", name, node, null, null, null));
    }
  }, {
    key: "_nestTypeParamScope",
    value: function _nestTypeParamScope(node) {
      if (!node.typeParameters) {
        return null;
      }

      var parentScope = this.scopeManager.__currentScope;
      var scope = new escope.Scope(this.scopeManager, "type-parameters", parentScope, node, false);

      this.scopeManager.__nestScope(scope);

      for (var j = 0; j < node.typeParameters.params.length; j++) {
        var name = node.typeParameters.params[j];

        scope.__define(name, new Definition("TypeParameter", name, name));

        if (name.typeAnnotation) {
          this._checkIdentifierOrVisit(name);
        }
      }

      scope.__define = function () {
        return parentScope.__define.apply(parentScope, arguments);
      };

      return scope;
    }
  }, {
    key: "_visitTypeAnnotation",
    value: function _visitTypeAnnotation(node) {
      if (!node) {
        return;
      }

      if (Array.isArray(node)) {
        node.forEach(this._visitTypeAnnotation, this);
        return;
      } // get property to check (params, id, etc...)


      var visitorValues = visitorKeysMap[node.type];

      if (!visitorValues) {
        return;
      } // can have multiple properties


      for (var i = 0; i < visitorValues.length; i++) {
        var visitorValue = visitorValues[i];
        var propertyType = propertyTypes[visitorValue];
        var nodeProperty = node[visitorValue]; // check if property or type is defined

        if (propertyType == null || nodeProperty == null) {
          continue;
        }

        if (propertyType.type === "loop") {
          for (var j = 0; j < nodeProperty.length; j++) {
            if (Array.isArray(propertyType.values)) {
              for (var k = 0; k < propertyType.values.length; k++) {
                var loopPropertyNode = nodeProperty[j][propertyType.values[k]];

                if (loopPropertyNode) {
                  this._checkIdentifierOrVisit(loopPropertyNode);
                }
              }
            } else {
              this._checkIdentifierOrVisit(nodeProperty[j]);
            }
          }
        } else if (propertyType.type === "single") {
          this._checkIdentifierOrVisit(nodeProperty);
        } else if (propertyType.type === "typeAnnotation") {
          this._visitTypeAnnotation(node.typeAnnotation);
        } else if (propertyType.type === "typeParameters") {
          for (var l = 0; l < node.typeParameters.params.length; l++) {
            this._checkIdentifierOrVisit(node.typeParameters.params[l]);
          }
        } else if (propertyType.type === "id") {
          if (node.id.type === "Identifier") {
            this._checkIdentifierOrVisit(node.id);
          } else {
            this._visitTypeAnnotation(node.id);
          }
        }
      }
    }
  }, {
    key: "_checkIdentifierOrVisit",
    value: function _checkIdentifierOrVisit(node) {
      if (node && node.typeAnnotation) {
        this._visitTypeAnnotation(node.typeAnnotation);
      } else if (node && node.type === "Identifier") {
        this.visit(node);
      } else {
        this._visitTypeAnnotation(node);
      }
    }
  }, {
    key: "_visitArray",
    value: function _visitArray(nodeList) {
      if (nodeList) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodeList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;
            this.visit(node);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }
  }]);

  return Referencer;
}(OriginalReferencer);

module.exports = function (ast, parserOptions) {
  var options = {
    ignoreEval: true,
    optimistic: false,
    directive: false,
    nodejsScope: ast.sourceType === "script" && (parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) === true,
    impliedStrict: false,
    sourceType: ast.sourceType,
    ecmaVersion: parserOptions.ecmaVersion || 2018,
    fallback: fallback
  };
  options.childVisitorKeys = childVisitorKeys;
  var scopeManager = new escope.ScopeManager(options);
  var referencer = new Referencer(options, scopeManager);
  referencer.visit(ast);
  return scopeManager;
};