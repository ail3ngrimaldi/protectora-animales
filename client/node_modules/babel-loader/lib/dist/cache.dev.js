"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
/**
 * Filesystem Cache
 *
 * Given a file and a transform function, cache the result into files
 * or retrieve the previously cached files if the given file is already known.
 *
 * @see https://github.com/babel/babel-loader/issues/34
 * @see https://github.com/babel/babel-loader/pull/41
 */


var fs = require("fs");

var os = require("os");

var path = require("path");

var zlib = require("zlib");

var crypto = require("crypto");

var mkdirpOrig = require("mkdirp");

var findCacheDir = require("find-cache-dir");

var promisify = require("pify");

var transform = require("./transform"); // Lazily instantiated when needed


var defaultCacheDirectory = null;
var readFile = promisify(fs.readFile);
var writeFile = promisify(fs.writeFile);
var gunzip = promisify(zlib.gunzip);
var gzip = promisify(zlib.gzip);
var mkdirp = promisify(mkdirpOrig);
/**
 * Read the contents from the compressed file.
 *
 * @async
 * @params {String} filename
 */

var read =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(filename, compress) {
    var data, content;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return readFile(filename + (compress ? ".gz" : ""));

          case 2:
            data = _context.sent;

            if (!compress) {
              _context.next = 9;
              break;
            }

            _context.next = 6;
            return gunzip(data);

          case 6:
            _context.t0 = _context.sent;
            _context.next = 10;
            break;

          case 9:
            _context.t0 = data;

          case 10:
            content = _context.t0;
            return _context.abrupt("return", JSON.parse(content.toString()));

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function read(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Write contents into a compressed file.
 *
 * @async
 * @params {String} filename
 * @params {String} result
 */


var write =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(filename, compress, result) {
    var content, data;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            content = JSON.stringify(result);

            if (!compress) {
              _context2.next = 7;
              break;
            }

            _context2.next = 4;
            return gzip(content);

          case 4:
            _context2.t0 = _context2.sent;
            _context2.next = 8;
            break;

          case 7:
            _context2.t0 = content;

          case 8:
            data = _context2.t0;
            _context2.next = 11;
            return writeFile(filename + (compress ? ".gz" : ""), data);

          case 11:
            return _context2.abrupt("return", _context2.sent);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function write(_x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Build the filename for the cached file
 *
 * @params {String} source  File source code
 * @params {Object} options Options used
 *
 * @return {String}
 */


var filename = function filename(source, identifier, options) {
  var hash = crypto.createHash("md4");
  var contents = JSON.stringify({
    source: source,
    options: options,
    identifier: identifier
  });
  hash.update(contents);
  return hash.digest("hex") + ".json";
};
/**
 * Handle the cache
 *
 * @params {String} directory
 * @params {Object} params
 */


var handleCache =
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(directory, params) {
    var source, _params$options, options, cacheIdentifier, cacheDirectory, cacheCompression, file, fallback, result;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            source = params.source, _params$options = params.options, options = _params$options === void 0 ? {} : _params$options, cacheIdentifier = params.cacheIdentifier, cacheDirectory = params.cacheDirectory, cacheCompression = params.cacheCompression;
            file = path.join(directory, filename(source, cacheIdentifier, options));
            _context3.prev = 2;
            _context3.next = 5;
            return read(file, cacheCompression);

          case 5:
            return _context3.abrupt("return", _context3.sent);

          case 8:
            _context3.prev = 8;
            _context3.t0 = _context3["catch"](2);

          case 10:
            fallback = typeof cacheDirectory !== "string" && directory !== os.tmpdir(); // Make sure the directory exists.

            _context3.prev = 11;
            _context3.next = 14;
            return mkdirp(directory);

          case 14:
            _context3.next = 21;
            break;

          case 16:
            _context3.prev = 16;
            _context3.t1 = _context3["catch"](11);

            if (!fallback) {
              _context3.next = 20;
              break;
            }

            return _context3.abrupt("return", handleCache(os.tmpdir(), params));

          case 20:
            throw _context3.t1;

          case 21:
            _context3.next = 23;
            return transform(source, options);

          case 23:
            result = _context3.sent;
            _context3.prev = 24;
            _context3.next = 27;
            return write(file, cacheCompression, result);

          case 27:
            _context3.next = 34;
            break;

          case 29:
            _context3.prev = 29;
            _context3.t2 = _context3["catch"](24);

            if (!fallback) {
              _context3.next = 33;
              break;
            }

            return _context3.abrupt("return", handleCache(os.tmpdir(), params));

          case 33:
            throw _context3.t2;

          case 34:
            return _context3.abrupt("return", result);

          case 35:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[2, 8], [11, 16], [24, 29]]);
  }));

  return function handleCache(_x6, _x7) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Retrieve file from cache, or create a new one for future reads
 *
 * @async
 * @param  {Object}   params
 * @param  {String}   params.directory  Directory to store cached files
 * @param  {String}   params.identifier Unique identifier to bust cache
 * @param  {String}   params.source   Original contents of the file to be cached
 * @param  {Object}   params.options  Options to be given to the transform fn
 * @param  {Function} params.transform  Function that will transform the
 *                                      original file and whose result will be
 *                                      cached
 *
 * @example
 *
 *   cache({
 *     directory: '.tmp/cache',
 *     identifier: 'babel-loader-cachefile',
 *     cacheCompression: false,
 *     source: *source code from file*,
 *     options: {
 *       experimental: true,
 *       runtime: true
 *     },
 *     transform: function(source, options) {
 *       var content = *do what you need with the source*
 *       return content;
 *     }
 *   }, function(err, result) {
 *
 *   });
 */


module.exports =
/*#__PURE__*/
function () {
  var _ref4 = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(params) {
    var directory;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (typeof params.cacheDirectory === "string") {
              directory = params.cacheDirectory;
            } else {
              if (defaultCacheDirectory === null) {
                defaultCacheDirectory = findCacheDir({
                  name: "babel-loader"
                }) || os.tmpdir();
              }

              directory = defaultCacheDirectory;
            }

            _context4.next = 3;
            return handleCache(directory, params);

          case 3:
            return _context4.abrupt("return", _context4.sent);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x8) {
    return _ref4.apply(this, arguments);
  };
}();