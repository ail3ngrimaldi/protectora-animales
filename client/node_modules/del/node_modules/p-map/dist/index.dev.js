'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var pMap = function pMap(iterable, mapper, options) {
  return new Promise(function (resolve, reject) {
    options = Object.assign({
      concurrency: Infinity
    }, options);

    if (typeof mapper !== 'function') {
      throw new TypeError('Mapper function is required');
    }

    var _options = options,
        concurrency = _options.concurrency;

    if (!(typeof concurrency === 'number' && concurrency >= 1)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(concurrency, "` (").concat(_typeof(concurrency), ")"));
    }

    var ret = [];
    var iterator = iterable[Symbol.iterator]();
    var isRejected = false;
    var isIterableDone = false;
    var resolvingCount = 0;
    var currentIndex = 0;

    var next = function next() {
      if (isRejected) {
        return;
      }

      var nextItem = iterator.next();
      var i = currentIndex;
      currentIndex++;

      if (nextItem.done) {
        isIterableDone = true;

        if (resolvingCount === 0) {
          resolve(ret);
        }

        return;
      }

      resolvingCount++;
      Promise.resolve(nextItem.value).then(function (element) {
        return mapper(element, i);
      }).then(function (value) {
        ret[i] = value;
        resolvingCount--;
        next();
      }, function (error) {
        isRejected = true;
        reject(error);
      });
    };

    for (var i = 0; i < concurrency; i++) {
      next();

      if (isIterableDone) {
        break;
      }
    }
  });
};

module.exports = pMap; // TODO: Remove this for the next major release

module.exports["default"] = pMap;