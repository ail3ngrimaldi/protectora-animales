"use strict"; // Returns "Type(value) is Object" in ES terminology.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isObject(value) {
  return _typeof(value) === "object" && value !== null || typeof value === "function";
}

function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var getOwnPropertyDescriptors = typeof Object.getOwnPropertyDescriptors === "function" ? Object.getOwnPropertyDescriptors : // Polyfill exists until we require Node.js v8.x
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
function (obj) {
  if (obj === undefined || obj === null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }

  obj = Object(obj);
  var ownKeys = Reflect.ownKeys(obj);
  var descriptors = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = ownKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      var descriptor = Reflect.getOwnPropertyDescriptor(obj, key);

      if (descriptor !== undefined) {
        Reflect.defineProperty(descriptors, key, {
          value: descriptor,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return descriptors;
};
var wrapperSymbol = Symbol("wrapper");
var implSymbol = Symbol("impl");
var sameObjectCaches = Symbol("SameObject caches");

function getSameObject(wrapper, prop, creator) {
  if (!wrapper[sameObjectCaches]) {
    wrapper[sameObjectCaches] = Object.create(null);
  }

  if (prop in wrapper[sameObjectCaches]) {
    return wrapper[sameObjectCaches][prop];
  }

  wrapper[sameObjectCaches][prop] = creator();
  return wrapper[sameObjectCaches][prop];
}

function wrapperForImpl(impl) {
  return impl ? impl[wrapperSymbol] : null;
}

function implForWrapper(wrapper) {
  return wrapper ? wrapper[implSymbol] : null;
}

function tryWrapperForImpl(impl) {
  var wrapper = wrapperForImpl(impl);
  return wrapper ? wrapper : impl;
}

function tryImplForWrapper(wrapper) {
  var impl = implForWrapper(wrapper);
  return impl ? impl : wrapper;
}

var iterInternalSymbol = Symbol("internal");
var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));

function isArrayIndexPropName(P) {
  if (typeof P !== "string") {
    return false;
  }

  var i = P >>> 0;

  if (i === Math.pow(2, 32) - 1) {
    return false;
  }

  var s = "".concat(i);

  if (P !== s) {
    return false;
  }

  return true;
}

var supportsPropertyIndex = Symbol("supports property index");
var supportedPropertyIndices = Symbol("supported property indices");
var supportsPropertyName = Symbol("supports property name");
var supportedPropertyNames = Symbol("supported property names");
var indexedGet = Symbol("indexed property get");
var indexedSetNew = Symbol("indexed property set new");
var indexedSetExisting = Symbol("indexed property set existing");
var namedGet = Symbol("named property get");
var namedSetNew = Symbol("named property set new");
var namedSetExisting = Symbol("named property set existing");
var namedDelete = Symbol("named property delete");
module.exports = exports = {
  isObject: isObject,
  hasOwn: hasOwn,
  getOwnPropertyDescriptors: getOwnPropertyDescriptors,
  wrapperSymbol: wrapperSymbol,
  implSymbol: implSymbol,
  getSameObject: getSameObject,
  wrapperForImpl: wrapperForImpl,
  implForWrapper: implForWrapper,
  tryWrapperForImpl: tryWrapperForImpl,
  tryImplForWrapper: tryImplForWrapper,
  iterInternalSymbol: iterInternalSymbol,
  IteratorPrototype: IteratorPrototype,
  isArrayIndexPropName: isArrayIndexPropName,
  supportsPropertyIndex: supportsPropertyIndex,
  supportedPropertyIndices: supportedPropertyIndices,
  supportsPropertyName: supportsPropertyName,
  supportedPropertyNames: supportedPropertyNames,
  indexedGet: indexedGet,
  indexedSetNew: indexedSetNew,
  indexedSetExisting: indexedSetExisting,
  namedGet: namedGet,
  namedSetNew: namedSetNew,
  namedSetExisting: namedSetExisting,
  namedDelete: namedDelete
};