"use strict";

var _vue = require("@testing-library/vue");

require("@testing-library/jest-dom/extend-expect");

var _src = _interopRequireDefault(require("../../src"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

afterEach(_vue.cleanup);

var renderComponent = function renderComponent(type) {
  var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return (0, _vue.render)({
    render: function render(h) {
      return h(type, {
        attrs: _objectSpread({
          "data-testid": "input"
        }, attrs),
        on: events
      });
    }
  });
};

describe("userEvent.type", function () {
  it.each(["input", "textarea"])("should type text in <%s>", function (type) {
    var input = jest.fn();

    var _renderComponent = renderComponent(type, {
      input: input
    }),
        getByTestId = _renderComponent.getByTestId;

    var text = "Hello, world!";

    _src["default"].type(getByTestId("input"), text);

    expect(input).toHaveBeenCalledTimes(text.length);
    expect(getByTestId("input")).toHaveProperty("value", text);
  });
  it("should not type when event.preventDefault() is called", function () {
    var input = jest.fn();
    var change = jest.fn();
    var keydown = jest.fn().mockImplementation(function (event) {
      return event.preventDefault();
    });

    var _renderComponent2 = renderComponent("input", {
      input: input,
      keydown: keydown,
      change: change
    }),
        getByTestId = _renderComponent2.getByTestId;

    var text = "Hello, world!";

    _src["default"].type(getByTestId("input"), text);

    expect(keydown).toHaveBeenCalledTimes(text.length);
    expect(change).toHaveBeenCalledTimes(0);
    expect(input).toHaveBeenCalledTimes(0);
    expect(getByTestId("input")).not.toHaveProperty("value", text);
  });
  it.each(["input", "textarea"])("should not type when <%s> is disabled", function (type) {
    var change = jest.fn();

    var _renderComponent3 = renderComponent(type, {
      change: change
    }, {
      disabled: true
    }),
        getByTestId = _renderComponent3.getByTestId;

    var text = "Hello, world!";

    _src["default"].type(getByTestId("input"), text);

    expect(change).not.toHaveBeenCalled();
    expect(getByTestId("input")).toHaveProperty("value", "");
  });
  it.each(["input", "textarea"])("should not type when <%s> is readOnly", function (type) {
    var change = jest.fn();
    var keydown = jest.fn();
    var keypress = jest.fn();
    var keyup = jest.fn();

    var _renderComponent4 = renderComponent(type, {
      change: change,
      keydown: keydown,
      keypress: keypress,
      keyup: keyup
    }, {
      readOnly: true
    }),
        getByTestId = _renderComponent4.getByTestId;

    var text = "Hello, world!";

    _src["default"].type(getByTestId("input"), text);

    expect(keydown).toHaveBeenCalledTimes(text.length);
    expect(keypress).toHaveBeenCalledTimes(text.length);
    expect(keyup).toHaveBeenCalledTimes(text.length);
    expect(change).not.toHaveBeenCalled();
    expect(getByTestId("input")).toHaveProperty("value", "");
  });
  it("should delay the typing when opts.delay is not 0", function _callee() {
    var change, input, _renderComponent5, getByTestId, text, delay, _loop, i;

    return regeneratorRuntime.async(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            jest.useFakeTimers();
            change = jest.fn();
            input = jest.fn();
            _renderComponent5 = renderComponent("input", {
              change: change,
              input: input
            }), getByTestId = _renderComponent5.getByTestId;
            text = "Hello, world!";
            delay = 10;

            _src["default"].type(getByTestId("input"), text, {
              delay: delay
            });

            expect(input).not.toHaveBeenCalled();
            expect(getByTestId("input")).not.toHaveProperty("value", text);

            _loop = function _loop(i) {
              return regeneratorRuntime.async(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      jest.advanceTimersByTime(delay);
                      _context.next = 3;
                      return regeneratorRuntime.awrap((0, _vue.wait)(function () {
                        return expect(input).toHaveBeenCalledTimes(i + 1);
                      }));

                    case 3:
                      expect(getByTestId("input")).toHaveProperty("value", text.slice(0, i + 1));

                    case 4:
                    case "end":
                      return _context.stop();
                  }
                }
              });
            };

            i = 0;

          case 11:
            if (!(i < text.length)) {
              _context2.next = 17;
              break;
            }

            _context2.next = 14;
            return regeneratorRuntime.awrap(_loop(i));

          case 14:
            i++;
            _context2.next = 11;
            break;

          case 17:
            // Vue's change event is not emitted until blurring the input
            expect(change).not.toHaveBeenCalled();

            _vue.fireEvent.blur(getByTestId("input"));

            _context2.next = 21;
            return regeneratorRuntime.awrap((0, _vue.wait)(function () {
              return expect(change).toHaveBeenCalledTimes(1);
            }));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    });
  });
  it.each(["input", "textarea"])("should type text in <%s> all at once", function (type) {
    var input = jest.fn();

    var _renderComponent6 = renderComponent(type, {
      input: input
    }),
        getByTestId = _renderComponent6.getByTestId;

    var text = "Hello, world!";

    _src["default"].type(getByTestId("input"), text, {
      allAtOnce: true
    });

    expect(getByTestId("input")).toHaveProperty("value", text);
    expect(input).toHaveBeenCalledTimes(1);
  });
});