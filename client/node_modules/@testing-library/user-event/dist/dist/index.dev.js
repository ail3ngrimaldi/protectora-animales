"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _dom = require("@testing-library/dom");

function wait(time) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      return resolve();
    }, time);
  });
}

function findTagInParents(element, tagName) {
  if (element.parentNode == null) return undefined;
  if (element.parentNode.tagName === tagName) return element.parentNode;
  return findTagInParents(element.parentNode, tagName);
}

function clickLabel(label) {
  _dom.fireEvent.mouseOver(label);

  _dom.fireEvent.mouseMove(label);

  _dom.fireEvent.mouseDown(label);

  _dom.fireEvent.mouseUp(label);

  if (label.htmlFor) {
    var input = document.getElementById(label.htmlFor);
    input.focus();

    _dom.fireEvent.click(label);
  } else {
    var _input = label.querySelector("input,textarea,select");

    _input.focus();

    label.focus();

    _dom.fireEvent.click(label);
  }
}

function clickBooleanElement(element) {
  if (element.disabled) return;

  _dom.fireEvent.mouseOver(element);

  _dom.fireEvent.mouseMove(element);

  _dom.fireEvent.mouseDown(element);

  _dom.fireEvent.mouseUp(element);

  _dom.fireEvent.click(element);
}

function clickElement(element) {
  _dom.fireEvent.mouseOver(element);

  _dom.fireEvent.mouseMove(element);

  _dom.fireEvent.mouseDown(element);

  element.focus();

  _dom.fireEvent.mouseUp(element);

  _dom.fireEvent.click(element);

  var labelAncestor = findTagInParents(element, "LABEL");
  labelAncestor && clickLabel(labelAncestor);
}

function dblClickElement(element) {
  _dom.fireEvent.mouseOver(element);

  _dom.fireEvent.mouseMove(element);

  _dom.fireEvent.mouseDown(element);

  element.focus();

  _dom.fireEvent.mouseUp(element);

  _dom.fireEvent.click(element);

  _dom.fireEvent.mouseDown(element);

  _dom.fireEvent.mouseUp(element);

  _dom.fireEvent.click(element);

  _dom.fireEvent.dblClick(element);

  var labelAncestor = findTagInParents(element, "LABEL");
  labelAncestor && clickLabel(labelAncestor);
}

function dblClickCheckbox(checkbox) {
  _dom.fireEvent.mouseOver(checkbox);

  _dom.fireEvent.mouseMove(checkbox);

  _dom.fireEvent.mouseDown(checkbox);

  _dom.fireEvent.mouseUp(checkbox);

  _dom.fireEvent.click(checkbox);

  _dom.fireEvent.mouseDown(checkbox);

  _dom.fireEvent.mouseUp(checkbox);

  _dom.fireEvent.click(checkbox);
}

function selectOption(select, option) {
  _dom.fireEvent.mouseOver(option);

  _dom.fireEvent.mouseMove(option);

  _dom.fireEvent.mouseDown(option);

  _dom.fireEvent.focus(option);

  _dom.fireEvent.mouseUp(option);

  _dom.fireEvent.click(option);

  option.selected = true;

  _dom.fireEvent.change(select);
}

function fireChangeEvent(event) {
  _dom.fireEvent.change(event.target);

  event.target.removeEventListener("blur", fireChangeEvent);
}

var userEvent = {
  click: function click(element) {
    var focusedElement = element.ownerDocument.activeElement;
    var wasAnotherElementFocused = focusedElement !== element.ownerDocument.body && focusedElement !== element;

    if (wasAnotherElementFocused) {
      _dom.fireEvent.mouseMove(focusedElement);

      _dom.fireEvent.mouseLeave(focusedElement);
    }

    switch (element.tagName) {
      case "LABEL":
        clickLabel(element);
        break;

      case "INPUT":
        if (element.type === "checkbox" || element.type === "radio") {
          clickBooleanElement(element);
          break;
        }

      default:
        clickElement(element);
    }

    wasAnotherElementFocused && focusedElement.blur();
  },
  dblClick: function dblClick(element) {
    var focusedElement = document.activeElement;
    var wasAnotherElementFocused = focusedElement !== document.body && focusedElement !== element;

    if (wasAnotherElementFocused) {
      _dom.fireEvent.mouseMove(focusedElement);

      _dom.fireEvent.mouseLeave(focusedElement);
    }

    switch (element.tagName) {
      case "INPUT":
        if (element.type === "checkbox") {
          dblClickCheckbox(element);
          break;
        }

      default:
        dblClickElement(element);
    }

    wasAnotherElementFocused && focusedElement.blur();
  },
  selectOptions: function selectOptions(element, values) {
    var focusedElement = document.activeElement;
    var wasAnotherElementFocused = focusedElement !== document.body && focusedElement !== element;

    if (wasAnotherElementFocused) {
      _dom.fireEvent.mouseMove(focusedElement);

      _dom.fireEvent.mouseLeave(focusedElement);
    }

    clickElement(element);
    var valArray = Array.isArray(values) ? values : [values];
    var selectedOptions = Array.from(element.children).filter(function (opt) {
      return opt.tagName === "OPTION" && valArray.includes(opt.value);
    });

    if (selectedOptions.length > 0) {
      if (element.multiple) {
        selectedOptions.forEach(function (option) {
          return selectOption(element, option);
        });
      } else {
        selectOption(element, selectedOptions[0]);
      }
    }

    wasAnotherElementFocused && focusedElement.blur();
  },
  type: function type(element, text) {
    var userOpts,
        defaultOpts,
        opts,
        actuallyTyped,
        index,
        _char,
        key,
        keyCode,
        downEvent,
        pressEvent,
        _args = arguments;

    return regeneratorRuntime.async(function type$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            userOpts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

            if (!element.disabled) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return");

          case 3:
            defaultOpts = {
              allAtOnce: false,
              delay: 0
            };
            opts = Object.assign(defaultOpts, userOpts);

            if (!opts.allAtOnce) {
              _context.next = 11;
              break;
            }

            if (!element.readOnly) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return");

          case 8:
            _dom.fireEvent.input(element, {
              target: {
                value: text
              }
            });

            _context.next = 26;
            break;

          case 11:
            actuallyTyped = "";
            index = 0;

          case 13:
            if (!(index < text.length)) {
              _context.next = 26;
              break;
            }

            _char = text[index];
            key = _char; // TODO: check if this also valid for characters with diacritic markers e.g. úé etc

            keyCode = _char.charCodeAt(0);

            if (!(opts.delay > 0)) {
              _context.next = 20;
              break;
            }

            _context.next = 20;
            return regeneratorRuntime.awrap(wait(opts.delay));

          case 20:
            downEvent = _dom.fireEvent.keyDown(element, {
              key: key,
              keyCode: keyCode,
              which: keyCode
            });

            if (downEvent) {
              pressEvent = _dom.fireEvent.keyPress(element, {
                key: key,
                keyCode: keyCode,
                charCode: keyCode
              });

              if (pressEvent) {
                actuallyTyped += key;
                if (!element.readOnly) _dom.fireEvent.input(element, {
                  target: {
                    value: actuallyTyped
                  },
                  bubbles: true,
                  cancelable: true
                });
              }
            }

            _dom.fireEvent.keyUp(element, {
              key: key,
              keyCode: keyCode,
              which: keyCode
            });

          case 23:
            index++;
            _context.next = 13;
            break;

          case 26:
            element.addEventListener("blur", fireChangeEvent);

          case 27:
          case "end":
            return _context.stop();
        }
      }
    });
  },
  tab: function tab() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$shift = _ref.shift,
        shift = _ref$shift === void 0 ? false : _ref$shift,
        _ref$focusTrap = _ref.focusTrap,
        focusTrap = _ref$focusTrap === void 0 ? document : _ref$focusTrap;

    var focusableElements = focusTrap.querySelectorAll("input, button, select, textarea, a[href], [tabindex]");
    var list = Array.prototype.filter.call(focusableElements, function (item) {
      return item.getAttribute("tabindex") !== "-1";
    }).sort(function (a, b) {
      var tabIndexA = a.getAttribute("tabindex");
      var tabIndexB = b.getAttribute("tabindex");
      return tabIndexA < tabIndexB ? -1 : tabIndexA > tabIndexB ? 1 : 0;
    });
    var index = list.indexOf(document.activeElement);
    var nextIndex = shift ? index - 1 : index + 1;
    var defaultIndex = shift ? list.length - 1 : 0;
    var next = list[nextIndex] || list[defaultIndex];

    if (next.getAttribute("tabindex") === null) {
      next.setAttribute("tabindex", "0"); // jsdom requires tabIndex=0 for an item to become 'document.activeElement' (the browser does not)

      next.focus();
      next.removeAttribute("tabindex"); // leave no trace. :)
    } else {
      next.focus();
    }
  }
};
var _default = userEvent;
exports["default"] = _default;