"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryAllByLabelText = queryAllByLabelText;
exports.getAllByLabelText = getAllByLabelText;
exports.findByLabelText = exports.findAllByLabelText = exports.getByLabelText = exports.queryByLabelText = void 0;

var _config = require("../config");

var _allUtils = require("./all-utils");

var _text = require("./text");

function queryAllLabelsByText(container, text) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$exact = _ref.exact,
      exact = _ref$exact === void 0 ? true : _ref$exact,
      trim = _ref.trim,
      collapseWhitespace = _ref.collapseWhitespace,
      normalizer = _ref.normalizer;

  var matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;
  var matchNormalizer = (0, _allUtils.makeNormalizer)({
    collapseWhitespace: collapseWhitespace,
    trim: trim,
    normalizer: normalizer
  });
  return Array.from(container.querySelectorAll('label')).filter(function (label) {
    var textToMatch = label.textContent; // The children of a textarea are part of `textContent` as well. We
    // need to remove them from the string so we can match it afterwards.

    Array.from(label.querySelectorAll('textarea')).forEach(function (textarea) {
      textToMatch = textToMatch.replace(textarea.value, '');
    }); // The children of a select are also part of `textContent`, so we
    // need also to remove their text.

    Array.from(label.querySelectorAll('select')).forEach(function (select) {
      textToMatch = textToMatch.replace(select.textContent, '');
    });
    return matcher(textToMatch, label, text, matchNormalizer);
  });
}

function queryAllByLabelText(container, text) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? '*' : _ref2$selector,
      _ref2$exact = _ref2.exact,
      exact = _ref2$exact === void 0 ? true : _ref2$exact,
      collapseWhitespace = _ref2.collapseWhitespace,
      trim = _ref2.trim,
      normalizer = _ref2.normalizer;

  var matchNormalizer = (0, _allUtils.makeNormalizer)({
    collapseWhitespace: collapseWhitespace,
    trim: trim,
    normalizer: normalizer
  });
  var labels = queryAllLabelsByText(container, text, {
    exact: exact,
    normalizer: matchNormalizer
  });
  var labelledElements = labels.reduce(function (matchedElements, label) {
    var elementsForLabel = [];

    if (label.control) {
      elementsForLabel.push(label.control);
    }
    /* istanbul ignore if */


    if (label.getAttribute('for')) {
      // we're using this notation because with the # selector we would have to escape special characters e.g. user.name
      // see https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector#Escaping_special_characters
      // <label for="someId">text</label><input id="someId" />
      // .control support has landed in jsdom (https://github.com/jsdom/jsdom/issues/2175)
      elementsForLabel.push(container.querySelector("[id=\"".concat(label.getAttribute('for'), "\"]")));
    }

    if (label.getAttribute('id')) {
      // <label id="someId">text</label><input aria-labelledby="someId" />
      container.querySelectorAll("[aria-labelledby~=\"".concat(label.getAttribute('id'), "\"]")).forEach(function (element) {
        return elementsForLabel.push(element);
      });
    }

    if (label.childNodes.length) {
      // <label>text: <input /></label>
      label.querySelectorAll('button, input, meter, output, progress, select, textarea').forEach(function (element) {
        return elementsForLabel.push(element);
      });
    }

    return matchedElements.concat(elementsForLabel);
  }, []).filter(function (element) {
    return element !== null;
  }).concat((0, _allUtils.queryAllByAttribute)('aria-label', container, text, {
    exact: exact
  }));
  var possibleAriaLabelElements = (0, _text.queryAllByText)(container, text, {
    exact: exact,
    normalizer: matchNormalizer
  });
  var ariaLabelledElements = possibleAriaLabelElements.reduce(function (allLabelledElements, nextLabelElement) {
    var labelId = nextLabelElement.getAttribute('id');
    if (!labelId) return allLabelledElements; // ARIA labels can label multiple elements

    var labelledNodes = Array.from(container.querySelectorAll("[aria-labelledby~=\"".concat(labelId, "\"]")));
    return allLabelledElements.concat(labelledNodes);
  }, []);
  return Array.from(new Set([].concat(_toConsumableArray(labelledElements), _toConsumableArray(ariaLabelledElements)))).filter(function (element) {
    return element.matches(selector);
  });
} // the getAll* query would normally look like this:
// const getAllByLabelText = makeGetAllQuery(
//   queryAllByLabelText,
//   (c, text) => `Unable to find a label with the text of: ${text}`,
// )
// however, we can give a more helpful error message than the generic one,
// so we're writing this one out by hand.


function getAllByLabelText(container, text) {
  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    rest[_key - 2] = arguments[_key];
  }

  var els = queryAllByLabelText.apply(void 0, [container, text].concat(rest));

  if (!els.length) {
    var labels = queryAllLabelsByText.apply(void 0, [container, text].concat(rest));

    if (labels.length) {
      throw (0, _config.getConfig)().getElementError("Found a label with the text of: ".concat(text, ", however no form control was found associated to that label. Make sure you're using the \"for\" attribute or \"aria-labelledby\" attribute correctly."), container);
    } else {
      throw (0, _config.getConfig)().getElementError("Unable to find a label with the text of: ".concat(text), container);
    }
  }

  return els;
} // the reason mentioned above is the same reason we're not using buildQueries


var getMultipleError = function getMultipleError(c, text) {
  return "Found multiple elements with the text of: ".concat(text);
};

var queryByLabelText = (0, _allUtils.makeSingleQuery)(queryAllByLabelText, getMultipleError);
exports.queryByLabelText = queryByLabelText;
var getByLabelText = (0, _allUtils.makeSingleQuery)(getAllByLabelText, getMultipleError);
exports.getByLabelText = getByLabelText;
var findAllByLabelText = (0, _allUtils.makeFindQuery)(getAllByLabelText);
exports.findAllByLabelText = findAllByLabelText;
var findByLabelText = (0, _allUtils.makeFindQuery)(getByLabelText);
exports.findByLabelText = findByLabelText;