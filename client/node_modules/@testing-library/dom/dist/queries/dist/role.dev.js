"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryAllByRole = queryAllByRole;
exports.findByRole = exports.findAllByRole = exports.getByRole = exports.getAllByRole = exports.queryByRole = void 0;

var _domAccessibilityApi = require("dom-accessibility-api");

var _roleHelpers = require("../role-helpers");

var _allUtils = require("./all-utils");

function queryAllByRole(container, role) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$exact = _ref.exact,
      exact = _ref$exact === void 0 ? true : _ref$exact,
      collapseWhitespace = _ref.collapseWhitespace,
      _ref$hidden = _ref.hidden,
      hidden = _ref$hidden === void 0 ? (0, _allUtils.getConfig)().defaultHidden : _ref$hidden,
      name = _ref.name,
      trim = _ref.trim,
      normalizer = _ref.normalizer,
      _ref$queryFallbacks = _ref.queryFallbacks,
      queryFallbacks = _ref$queryFallbacks === void 0 ? false : _ref$queryFallbacks;

  var matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;
  var matchNormalizer = (0, _allUtils.makeNormalizer)({
    collapseWhitespace: collapseWhitespace,
    trim: trim,
    normalizer: normalizer
  });
  var subtreeIsInaccessibleCache = new WeakMap();

  function cachedIsSubtreeInaccessible(element) {
    if (!subtreeIsInaccessibleCache.has(element)) {
      subtreeIsInaccessibleCache.set(element, (0, _roleHelpers.isSubtreeInaccessible)(element));
    }

    return subtreeIsInaccessibleCache.get(element);
  }

  return Array.from(container.querySelectorAll('*')).filter(function (node) {
    var isRoleSpecifiedExplicitly = node.hasAttribute('role');

    if (isRoleSpecifiedExplicitly) {
      var roleValue = node.getAttribute('role');

      if (queryFallbacks) {
        return roleValue.split(' ').filter(Boolean).some(function (text) {
          return matcher(text, node, role, matchNormalizer);
        });
      } // if a custom normalizer is passed then let normalizer handle the role value


      if (normalizer) {
        return matcher(roleValue, node, role, matchNormalizer);
      } // other wise only send the first word to match


      var _roleValue$split = roleValue.split(' '),
          _roleValue$split2 = _slicedToArray(_roleValue$split, 1),
          firstWord = _roleValue$split2[0];

      return matcher(firstWord, node, role, matchNormalizer);
    }

    var implicitRoles = (0, _roleHelpers.getImplicitAriaRoles)(node);
    return implicitRoles.some(function (implicitRole) {
      return matcher(implicitRole, node, role, matchNormalizer);
    });
  }).filter(function (element) {
    return hidden === false ? (0, _roleHelpers.isInaccessible)(element, {
      isSubtreeInaccessible: cachedIsSubtreeInaccessible
    }) === false : true;
  }).filter(function (element) {
    if (name === undefined) {
      // Don't care
      return true;
    }

    return (0, _allUtils.matches)((0, _domAccessibilityApi.computeAccessibleName)(element), element, name, function (text) {
      return text;
    });
  });
}

var getMultipleError = function getMultipleError(c, role) {
  return "Found multiple elements with the role \"".concat(role, "\"");
};

var getMissingError = function getMissingError(container, role) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$hidden = _ref2.hidden,
      hidden = _ref2$hidden === void 0 ? (0, _allUtils.getConfig)().defaultHidden : _ref2$hidden,
      name = _ref2.name;

  var roles = (0, _roleHelpers.prettyRoles)(container, {
    hidden: hidden,
    includeName: name !== undefined
  });
  var roleMessage;

  if (roles.length === 0) {
    if (hidden === false) {
      roleMessage = 'There are no accessible roles. But there might be some inaccessible roles. ' + 'If you wish to access them, then set the `hidden` option to `true`. ' + 'Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole';
    } else {
      roleMessage = 'There are no available roles.';
    }
  } else {
    roleMessage = "\nHere are the ".concat(hidden === false ? 'accessible' : 'available', " roles:\n\n  ").concat(roles.replace(/\n/g, '\n  ').replace(/\n\s\s\n/g, '\n\n'), "\n").trim();
  }

  var nameHint = '';

  if (name === undefined) {
    nameHint = '';
  } else if (typeof name === 'string') {
    nameHint = " and name \"".concat(name, "\"");
  } else {
    nameHint = " and name `".concat(name, "`");
  }

  return "\nUnable to find an ".concat(hidden === false ? 'accessible ' : '', "element with the role \"").concat(role, "\"").concat(nameHint, "\n\n").concat(roleMessage).trim();
};

var _ref3 = (0, _allUtils.buildQueries)(queryAllByRole, getMultipleError, getMissingError),
    _ref4 = _slicedToArray(_ref3, 5),
    queryByRole = _ref4[0],
    getAllByRole = _ref4[1],
    getByRole = _ref4[2],
    findAllByRole = _ref4[3],
    findByRole = _ref4[4];

exports.findByRole = findByRole;
exports.findAllByRole = findAllByRole;
exports.getByRole = getByRole;
exports.getAllByRole = getAllByRole;
exports.queryByRole = queryByRole;