'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require('fs');

var sysPath = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var isBinaryPath = require('is-binary-path');

var _require2 = require('./constants'),
    isWindows = _require2.isWindows,
    isLinux = _require2.isLinux,
    EMPTY_FN = _require2.EMPTY_FN,
    EMPTY_STR = _require2.EMPTY_STR,
    KEY_LISTENERS = _require2.KEY_LISTENERS,
    KEY_ERR = _require2.KEY_ERR,
    KEY_RAW = _require2.KEY_RAW,
    HANDLER_KEYS = _require2.HANDLER_KEYS,
    EV_CHANGE = _require2.EV_CHANGE,
    EV_ADD = _require2.EV_ADD,
    EV_ADD_DIR = _require2.EV_ADD_DIR,
    EV_ERROR = _require2.EV_ERROR,
    STR_DATA = _require2.STR_DATA,
    STR_END = _require2.STR_END,
    BRACE_START = _require2.BRACE_START,
    STAR = _require2.STAR;

var THROTTLE_MODE_WATCH = 'watch';
var open = promisify(fs.open);
var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var close = promisify(fs.close);
var fsrealpath = promisify(fs.realpath);
var statMethods = {
  lstat: lstat,
  stat: stat
}; // TODO: emit errors properly. Example: EMFILE on Macos.

var foreach = function foreach(val, fn) {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

var addAndConvert = function addAndConvert(main, prop, item) {
  var container = main[prop];

  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }

  container.add(item);
};

var clearItem = function clearItem(cont) {
  return function (key) {
    var set = cont[key];

    if (set instanceof Set) {
      set.clear();
    } else {
      delete cont[key];
    }
  };
};

var delFromSet = function delFromSet(main, prop, item) {
  var container = main[prop];

  if (container instanceof Set) {
    container["delete"](item);
  } else if (container === item) {
    delete main[prop];
  }
};

var isEmptySet = function isEmptySet(val) {
  return val instanceof Set ? val.size === 0 : !val;
};
/**
 * @typedef {String} Path
 */
// fs_watch helpers
// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */


var FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */

function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function handleEvent(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, {
      watchedPath: path
    }); // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)

    if (evPath && path !== evPath) {
      fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
    }
  };

  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */


var fsWatchBroadcast = function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  var cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], function (listener) {
    listener(val1, val2, val3);
  });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */


var setFsWatchListener = function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      errHandler = handlers.errHandler,
      rawEmitter = handlers.rawEmitter;
  var cont = FsWatchInstances.get(fullPath);
  /** @type {fs.FSWatcher=} */

  var watcher;

  if (!options.persistent) {
    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
    return watcher.close.bind(watcher);
  }

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
    if (!watcher) return;
    watcher.on(EV_ERROR, function _callee(error) {
      var broadcastErr, fd;
      return regeneratorRuntime.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
              cont.watcherUnusable = true; // documented since Node 10.4.1
              // Workaround for https://github.com/joyent/node/issues/4337

              if (!(isWindows && error.code === 'EPERM')) {
                _context.next = 16;
                break;
              }

              _context.prev = 3;
              _context.next = 6;
              return regeneratorRuntime.awrap(open(path, 'r'));

            case 6:
              fd = _context.sent;
              _context.next = 9;
              return regeneratorRuntime.awrap(close(fd));

            case 9:
              broadcastErr(error);
              _context.next = 14;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](3);

            case 14:
              _context.next = 17;
              break;

            case 16:
              broadcastErr(error);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, [[3, 12]]);
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher: watcher
    };
    FsWatchInstances.set(fullPath, cont);
  } // const index = cont.listeners.indexOf(listener);
  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left


  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);

    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close(); // }

      FsWatchInstances["delete"](fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
}; // fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)


var FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */

var setFsWatchFileListener = function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      rawEmitter = handlers.rawEmitter;
  var cont = FsWatchFileInstances.get(fullPath);
  /* eslint-disable no-unused-vars, prefer-destructuring */

  var listeners = new Set();
  var rawEmitters = new Set();
  var copts = cont && cont.options;

  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }
  /* eslint-enable no-unused-vars, prefer-destructuring */


  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options: options,
      watcher: fs.watchFile(fullPath, options, function (curr, prev) {
        foreach(cont.rawEmitters, function (rawEmitter) {
          rawEmitter(EV_CHANGE, fullPath, {
            curr: curr,
            prev: prev
          });
        });
        var currmtime = curr.mtimeMs;

        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, function (listener) {
            return listener(path, curr);
          });
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  } // const index = cont.listeners.indexOf(listener);
  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.


  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);

    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances["delete"](fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};
/**
 * @mixin
 */


var NodeFsHandler =
/*#__PURE__*/
function () {
  /**
   * @param {import("../index").FSWatcher} fsW
   */
  function NodeFsHandler(fsW) {
    _classCallCheck(this, NodeFsHandler);

    this.fsw = fsW;

    this._boundHandleError = function (error) {
      return fsW._handleError(error);
    };
  }
  /**
   * Watch file for changes with fs_watchFile or fs_watch.
   * @param {String} path to file or dir
   * @param {Function} listener on fs change
   * @returns {Function} closer for the watcher instance
   */


  _createClass(NodeFsHandler, [{
    key: "_watchWithNodeFs",
    value: function _watchWithNodeFs(path, listener) {
      var opts = this.fsw.options;
      var directory = sysPath.dirname(path);
      var basename = sysPath.basename(path);

      var parent = this.fsw._getWatchedDir(directory);

      parent.add(basename);
      var absolutePath = sysPath.resolve(path);
      var options = {
        persistent: opts.persistent
      };
      if (!listener) listener = EMPTY_FN;
      var closer;

      if (opts.usePolling) {
        options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
        closer = setFsWatchFileListener(path, absolutePath, options, {
          listener: listener,
          rawEmitter: this.fsw._emitRaw
        });
      } else {
        closer = setFsWatchListener(path, absolutePath, options, {
          listener: listener,
          errHandler: this._boundHandleError,
          rawEmitter: this.fsw._emitRaw
        });
      }

      return closer;
    }
    /**
     * Watch a file and emit add event if warranted.
     * @param {Path} file Path
     * @param {fs.Stats} stats result of fs_stat
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @returns {Function} closer for the watcher instance
     */

  }, {
    key: "_handleFile",
    value: function _handleFile(file, stats, initialAdd) {
      var _this = this;

      if (this.fsw.closed) {
        return;
      }

      var dirname = sysPath.dirname(file);
      var basename = sysPath.basename(file);

      var parent = this.fsw._getWatchedDir(dirname); // stats is always present


      var prevStats = stats; // if the file is already being watched, do nothing

      if (parent.has(basename)) return;

      var listener = function listener(path, newStats) {
        var _newStats, at, mt, _at, _mt;

        return regeneratorRuntime.async(function listener$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (_this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (!(!newStats || newStats.mtimeMs === 0)) {
                  _context2.next = 20;
                  break;
                }

                _context2.prev = 3;
                _context2.next = 6;
                return regeneratorRuntime.awrap(stat(file));

              case 6:
                _newStats = _context2.sent;

                if (!_this.fsw.closed) {
                  _context2.next = 9;
                  break;
                }

                return _context2.abrupt("return");

              case 9:
                // Check that change event was not fired because of changed only accessTime.
                at = _newStats.atimeMs;
                mt = _newStats.mtimeMs;

                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                  _this.fsw._emit(EV_CHANGE, file, _newStats);
                }

                if (isLinux && prevStats.ino !== _newStats.ino) {
                  _this.fsw._closeFile(path);

                  prevStats = _newStats;

                  _this.fsw._addPathCloser(path, _this._watchWithNodeFs(file, listener));
                } else {
                  prevStats = _newStats;
                }

                _context2.next = 18;
                break;

              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](3);

                // Fix issues where mtime is null but file is still present
                _this.fsw._remove(dirname, basename);

              case 18:
                _context2.next = 21;
                break;

              case 20:
                if (parent.has(basename)) {
                  // Check that change event was not fired because of changed only accessTime.
                  _at = newStats.atimeMs;
                  _mt = newStats.mtimeMs;

                  if (!_at || _at <= _mt || _mt !== prevStats.mtimeMs) {
                    _this.fsw._emit(EV_CHANGE, file, newStats);
                  }

                  prevStats = newStats;
                }

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, null, null, [[3, 15]]);
      }; // kick off the watcher


      var closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to


      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
        if (!this.fsw._throttle(EV_ADD, file, 0)) return;

        this.fsw._emit(EV_ADD, file, stats);
      }

      return closer;
    }
    /**
     * Handle symlinks encountered while reading a dir.
     * @param {Object} entry returned by readdirp
     * @param {String} directory path of dir being read
     * @param {String} path of this item
     * @param {String} item basename of this item
     * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
     */

  }, {
    key: "_handleSymlink",
    value: function _handleSymlink(entry, directory, path, item) {
      var full, dir, linkPath;
      return regeneratorRuntime.async(function _handleSymlink$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.fsw.closed) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              full = entry.fullPath;
              dir = this.fsw._getWatchedDir(directory);

              if (this.fsw.options.followSymlinks) {
                _context3.next = 14;
                break;
              }

              // watch symlink directly (don't follow) and detect changes
              this.fsw._incrReadyCount();

              _context3.next = 8;
              return regeneratorRuntime.awrap(fsrealpath(path));

            case 8:
              linkPath = _context3.sent;

              if (!this.fsw.closed) {
                _context3.next = 11;
                break;
              }

              return _context3.abrupt("return");

            case 11:
              if (dir.has(item)) {
                if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                  this.fsw._symlinkPaths.set(full, linkPath);

                  this.fsw._emit(EV_CHANGE, path, entry.stats);
                }
              } else {
                dir.add(item);

                this.fsw._symlinkPaths.set(full, linkPath);

                this.fsw._emit(EV_ADD, path, entry.stats);
              }

              this.fsw._emitReady();

              return _context3.abrupt("return", true);

            case 14:
              if (!this.fsw._symlinkPaths.has(full)) {
                _context3.next = 16;
                break;
              }

              return _context3.abrupt("return", true);

            case 16:
              this.fsw._symlinkPaths.set(full, true);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_handleRead",
    value: function _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
      var _this2 = this;

      // Normalize the directory name on Windows
      directory = sysPath.join(directory, EMPTY_STR);

      if (!wh.hasGlob) {
        throttler = this.fsw._throttle('readdir', directory, 1000);
        if (!throttler) return;
      }

      var previous = this.fsw._getWatchedDir(wh.path);

      var current = new Set();

      var stream = this.fsw._readdirp(directory, {
        fileFilter: function fileFilter(entry) {
          return wh.filterPath(entry);
        },
        directoryFilter: function directoryFilter(entry) {
          return wh.filterDir(entry);
        },
        depth: 0
      }).on(STR_DATA, function _callee2(entry) {
        var item, path;
        return regeneratorRuntime.async(function _callee2$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!_this2.fsw.closed) {
                  _context4.next = 3;
                  break;
                }

                stream = undefined;
                return _context4.abrupt("return");

              case 3:
                item = entry.path;
                path = sysPath.join(directory, item);
                current.add(item);
                _context4.t0 = entry.stats.isSymbolicLink();

                if (!_context4.t0) {
                  _context4.next = 11;
                  break;
                }

                _context4.next = 10;
                return regeneratorRuntime.awrap(_this2._handleSymlink(entry, directory, path, item));

              case 10:
                _context4.t0 = _context4.sent;

              case 11:
                if (!_context4.t0) {
                  _context4.next = 13;
                  break;
                }

                return _context4.abrupt("return");

              case 13:
                if (!_this2.fsw.closed) {
                  _context4.next = 16;
                  break;
                }

                stream = undefined;
                return _context4.abrupt("return");

              case 16:
                // Files that present in current directory snapshot
                // but absent in previous are added to watch list and
                // emit `add` event.
                if (item === target || !target && !previous.has(item)) {
                  _this2.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse


                  path = sysPath.join(dir, sysPath.relative(dir, path));

                  _this2._addToNodeFs(path, initialAdd, wh, depth + 1);
                }

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        });
      }).on(EV_ERROR, this._boundHandleError);

      return new Promise(function (resolve) {
        return stream.once(STR_END, function () {
          if (_this2.fsw.closed) {
            stream = undefined;
            return;
          }

          var wasThrottled = throttler ? throttler.clear() : false;
          resolve(); // Files that absent in current directory snapshot
          // but present in previous emit `remove` event
          // and are removed from @watched[directory].

          previous.getChildren().filter(function (item) {
            return item !== directory && !current.has(item) && ( // in case of intersecting globs;
            // a path may have been filtered out of this readdir, but
            // shouldn't be removed because it matches a different glob
            !wh.hasGlob || wh.filterPath({
              fullPath: sysPath.resolve(directory, item)
            }));
          }).forEach(function (item) {
            _this2.fsw._remove(directory, item);
          });
          stream = undefined; // one more time for any missed in case changes came in extremely quickly

          if (wasThrottled) _this2._handleRead(directory, false, wh, target, dir, depth, throttler);
        });
      });
    }
    /**
     * Read directory to add / remove files from `@watched` list and re-read it on change.
     * @param {String} dir fs path
     * @param {fs.Stats} stats
     * @param {Boolean} initialAdd
     * @param {Number} depth relative to user-supplied path
     * @param {String} target child path targeted for watch
     * @param {Object} wh Common watch helpers for this path
     * @param {String} realpath
     * @returns {Promise<Function>} closer for the watcher instance.
     */

  }, {
    key: "_handleDir",
    value: function _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
      var _this3 = this;

      var parentDir, tracked, throttler, closer, oDepth;
      return regeneratorRuntime.async(function _handleDir$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
              tracked = parentDir.has(sysPath.basename(dir));

              if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
                if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
              } // ensure dir is tracked (harmless if redundant)


              parentDir.add(sysPath.basename(dir));

              this.fsw._getWatchedDir(dir);

              oDepth = this.fsw.options.depth;

              if (!((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath))) {
                _context5.next = 13;
                break;
              }

              if (target) {
                _context5.next = 12;
                break;
              }

              _context5.next = 10;
              return regeneratorRuntime.awrap(this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler));

            case 10:
              if (!this.fsw.closed) {
                _context5.next = 12;
                break;
              }

              return _context5.abrupt("return");

            case 12:
              closer = this._watchWithNodeFs(dir, function (dirPath, stats) {
                // if current directory is removed, do nothing
                if (stats && stats.mtimeMs === 0) return;

                _this3._handleRead(dirPath, false, wh, target, dir, depth, throttler);
              });

            case 13:
              return _context5.abrupt("return", closer);

            case 14:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
    /**
     * Handle added file, directory, or glob pattern.
     * Delegates call to _handleFile / _handleDir after checks.
     * @param {String} path to file or ir
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @param {Object} priorWh depth relative to user-supplied path
     * @param {Number} depth Child path actually targeted for watch
     * @param {String=} target Child path actually targeted for watch
     * @returns {Promise}
     */

  }, {
    key: "_addToNodeFs",
    value: function _addToNodeFs(path, initialAdd, priorWh, depth, target) {
      var ready, wh, stats, follow, closer, targetPath, _targetPath, parent;

      return regeneratorRuntime.async(function _addToNodeFs$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              ready = this.fsw._emitReady;

              if (!(this.fsw._isIgnored(path) || this.fsw.closed)) {
                _context6.next = 4;
                break;
              }

              ready();
              return _context6.abrupt("return", false);

            case 4:
              wh = this.fsw._getWatchHelpers(path, depth);

              if (!wh.hasGlob && priorWh) {
                wh.hasGlob = priorWh.hasGlob;
                wh.globFilter = priorWh.globFilter;

                wh.filterPath = function (entry) {
                  return priorWh.filterPath(entry);
                };

                wh.filterDir = function (entry) {
                  return priorWh.filterDir(entry);
                };
              } // evaluate what is at the path we're being asked to watch


              _context6.prev = 6;
              _context6.next = 9;
              return regeneratorRuntime.awrap(statMethods[wh.statMethod](wh.watchPath));

            case 9:
              stats = _context6.sent;

              if (!this.fsw.closed) {
                _context6.next = 12;
                break;
              }

              return _context6.abrupt("return");

            case 12:
              if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                _context6.next = 15;
                break;
              }

              ready();
              return _context6.abrupt("return", false);

            case 15:
              follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);

              if (!stats.isDirectory()) {
                _context6.next = 35;
                break;
              }

              if (!follow) {
                _context6.next = 23;
                break;
              }

              _context6.next = 20;
              return regeneratorRuntime.awrap(fsrealpath(path));

            case 20:
              _context6.t0 = _context6.sent;
              _context6.next = 24;
              break;

            case 23:
              _context6.t0 = path;

            case 24:
              targetPath = _context6.t0;

              if (!this.fsw.closed) {
                _context6.next = 27;
                break;
              }

              return _context6.abrupt("return");

            case 27:
              _context6.next = 29;
              return regeneratorRuntime.awrap(this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath));

            case 29:
              closer = _context6.sent;

              if (!this.fsw.closed) {
                _context6.next = 32;
                break;
              }

              return _context6.abrupt("return");

            case 32:
              // preserve this symlink's target path
              if (path !== targetPath && targetPath !== undefined) {
                this.fsw._symlinkPaths.set(targetPath, true);
              }

              _context6.next = 58;
              break;

            case 35:
              if (!stats.isSymbolicLink()) {
                _context6.next = 57;
                break;
              }

              if (!follow) {
                _context6.next = 42;
                break;
              }

              _context6.next = 39;
              return regeneratorRuntime.awrap(fsrealpath(path));

            case 39:
              _context6.t1 = _context6.sent;
              _context6.next = 43;
              break;

            case 42:
              _context6.t1 = path;

            case 43:
              _targetPath = _context6.t1;

              if (!this.fsw.closed) {
                _context6.next = 46;
                break;
              }

              return _context6.abrupt("return");

            case 46:
              parent = sysPath.dirname(wh.watchPath);

              this.fsw._getWatchedDir(parent).add(wh.watchPath);

              this.fsw._emit(EV_ADD, wh.watchPath, stats);

              _context6.next = 51;
              return regeneratorRuntime.awrap(this._handleDir(parent, stats, initialAdd, depth, path, wh, _targetPath));

            case 51:
              closer = _context6.sent;

              if (!this.fsw.closed) {
                _context6.next = 54;
                break;
              }

              return _context6.abrupt("return");

            case 54:
              // preserve this symlink's target path
              if (_targetPath !== undefined) {
                this.fsw._symlinkPaths.set(sysPath.resolve(path), _targetPath);
              }

              _context6.next = 58;
              break;

            case 57:
              closer = this._handleFile(wh.watchPath, stats, initialAdd);

            case 58:
              ready();

              this.fsw._addPathCloser(path, closer);

              return _context6.abrupt("return", false);

            case 63:
              _context6.prev = 63;
              _context6.t2 = _context6["catch"](6);

              if (!this.fsw._handleError(_context6.t2)) {
                _context6.next = 68;
                break;
              }

              ready();
              return _context6.abrupt("return", path);

            case 68:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this, [[6, 63]]);
    }
  }]);

  return NodeFsHandler;
}();

module.exports = NodeFsHandler;