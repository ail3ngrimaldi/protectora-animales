'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require('fs');

var sysPath = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var fsevents;

try {
  fsevents = require('fsevents');
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  var mtch = process.version.match(/v(\d+)\.(\d+)/);

  if (mtch && mtch[1] && mtch[2]) {
    var maj = Number.parseInt(mtch[1], 10);
    var min = Number.parseInt(mtch[2], 10);

    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

var _require2 = require('./constants'),
    EV_ADD = _require2.EV_ADD,
    EV_CHANGE = _require2.EV_CHANGE,
    EV_ADD_DIR = _require2.EV_ADD_DIR,
    EV_UNLINK = _require2.EV_UNLINK,
    EV_ERROR = _require2.EV_ERROR,
    STR_DATA = _require2.STR_DATA,
    STR_END = _require2.STR_END,
    FSEVENT_CREATED = _require2.FSEVENT_CREATED,
    FSEVENT_MODIFIED = _require2.FSEVENT_MODIFIED,
    FSEVENT_DELETED = _require2.FSEVENT_DELETED,
    FSEVENT_MOVED = _require2.FSEVENT_MOVED,
    FSEVENT_UNKNOWN = _require2.FSEVENT_UNKNOWN,
    FSEVENT_TYPE_FILE = _require2.FSEVENT_TYPE_FILE,
    FSEVENT_TYPE_DIRECTORY = _require2.FSEVENT_TYPE_DIRECTORY,
    FSEVENT_TYPE_SYMLINK = _require2.FSEVENT_TYPE_SYMLINK,
    ROOT_GLOBSTAR = _require2.ROOT_GLOBSTAR,
    DIR_SUFFIX = _require2.DIR_SUFFIX,
    DOT_SLASH = _require2.DOT_SLASH,
    FUNCTION_TYPE = _require2.FUNCTION_TYPE,
    EMPTY_FN = _require2.EMPTY_FN,
    IDENTITY_FN = _require2.IDENTITY_FN;

var Depth = function Depth(value) {
  return isNaN(value) ? {} : {
    depth: value
  };
};

var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var realpath = promisify(fs.realpath);
var statMethods = {
  stat: stat,
  lstat: lstat
};
/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */
// fsevents instance helper functions

/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */

var FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start
// consolidating going forward

var consolidateThreshhold = 10;
var wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);
/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */

var createFSEventsInstance = function createFSEventsInstance(path, callback) {
  var stop = fsevents.watch(path, callback);
  return {
    stop: stop
  };
};
/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */


function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
  var parentPath = sysPath.dirname(watchPath);
  var cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.

  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;

  var filteredListener = function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);
  }; // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match


  var watchedParent = false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = FSEventsWatchers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var watchedPath = _step.value;

      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
        watchPath = watchedPath;
        cont = FSEventsWatchers.get(watchPath);
        watchedParent = true;
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter: rawEmitter,
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        if (!cont.listeners.size) return;
        var info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(function (list) {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  } // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left


  return function () {
    var lst = cont.listeners;
    lst["delete"](filteredListener);

    if (!lst.size) {
      FSEventsWatchers["delete"](watchPath);
      if (cont.watcher) return cont.watcher.stop().then(function () {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
} // Decide whether or not we should start a new higher-level
// parent watcher


var couldConsolidate = function couldConsolidate(path) {
  var count = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = FSEventsWatchers.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var watchPath = _step2.value;

      if (watchPath.indexOf(path) === 0) {
        count++;

        if (count >= consolidateThreshhold) {
          return true;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return false;
}; // returns boolean indicating whether fsevents can be used


var canUse = function canUse() {
  return fsevents && FSEventsWatchers.size < 128;
}; // determines subdirectory traversal levels from root to path


var calcDepth = function calcDepth(path, root) {
  var i = 0;

  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) {
    i++;
  }

  return i;
}; // returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat


var sameTypes = function sameTypes(info, stats) {
  return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
};
/**
 * @mixin
 */


var FsEventsHandler =
/*#__PURE__*/
function () {
  /**
   * @param {import('../index').FSWatcher} fsw
   */
  function FsEventsHandler(fsw) {
    _classCallCheck(this, FsEventsHandler);

    this.fsw = fsw;
  }

  _createClass(FsEventsHandler, [{
    key: "checkIgnored",
    value: function checkIgnored(path, stats) {
      var ipaths = this.fsw._ignoredPaths;

      if (this.fsw._isIgnored(path, stats)) {
        ipaths.add(path);

        if (stats && stats.isDirectory()) {
          ipaths.add(path + ROOT_GLOBSTAR);
        }

        return true;
      }

      ipaths["delete"](path);
      ipaths["delete"](path + ROOT_GLOBSTAR);
    }
  }, {
    key: "addOrChange",
    value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      var event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }, {
    key: "checkExists",
    value: function checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      var stats;
      return regeneratorRuntime.async(function checkExists$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return regeneratorRuntime.awrap(stat(path));

            case 3:
              stats = _context.sent;

              if (!this.fsw.closed) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return");

            case 6:
              if (sameTypes(info, stats)) {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }

              _context.next = 12;
              break;

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](0);

              if (_context.t0.code === 'EACCES') {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[0, 9]]);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      if (this.fsw.closed || this.checkIgnored(path)) return;

      if (event === EV_UNLINK) {
        var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files

        if (isDirectory || watchedDir.has(item)) {
          this.fsw._remove(parent, item, isDirectory);
        }
      } else {
        if (event === EV_ADD) {
          // track new directories
          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
            // push symlinks back to the top of the stack to get handled
            var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
            return this._addToFsEvents(path, false, true, curDepth);
          } // track new paths
          // (other than symlinks being followed, which will be tracked soon)


          this.fsw._getWatchedDir(parent).add(item);
        }
        /**
         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
         */


        var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;

        this.fsw._emit(eventName, path);

        if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
      }
    }
    /**
     * Handle symlinks encountered during directory scan
     * @param {String} watchPath  - file/dir path to be watched with fsevents
     * @param {String} realPath   - real path (in case of symlinks)
     * @param {Function} transform  - path transformer
     * @param {Function} globFilter - path filter in case a glob pattern was provided
     * @returns {Function} closer for the watcher instance
    */

  }, {
    key: "_watchWithFsEvents",
    value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
      var _this = this;

      if (this.fsw.closed) return;
      if (this.fsw._isIgnored(watchPath)) return;
      var opts = this.fsw.options;

      var watchCallback = function watchCallback(fullPath, flags, info) {
        var path, parent, item, watchedDir, stats;
        return regeneratorRuntime.async(function watchCallback$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!_this.fsw.closed) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return");

              case 4:
                path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));

                if (!(globFilter && !globFilter(path))) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return");

              case 7:
                // ensure directories are tracked
                parent = sysPath.dirname(path);
                item = sysPath.basename(path);
                watchedDir = _this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted

                if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {
                  _context2.next = 30;
                  break;
                }

                if (!(_typeof(opts.ignored) === FUNCTION_TYPE)) {
                  _context2.next = 27;
                  break;
                }

                _context2.prev = 12;
                _context2.next = 15;
                return regeneratorRuntime.awrap(stat(path));

              case 15:
                stats = _context2.sent;
                _context2.next = 20;
                break;

              case 18:
                _context2.prev = 18;
                _context2.t0 = _context2["catch"](12);

              case 20:
                if (!_this.fsw.closed) {
                  _context2.next = 22;
                  break;
                }

                return _context2.abrupt("return");

              case 22:
                if (!_this.checkIgnored(path, stats)) {
                  _context2.next = 24;
                  break;
                }

                return _context2.abrupt("return");

              case 24:
                if (sameTypes(info, stats)) {
                  _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

                _context2.next = 28;
                break;

              case 27:
                _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);

              case 28:
                _context2.next = 35;
                break;

              case 30:
                _context2.t1 = info.event;
                _context2.next = _context2.t1 === FSEVENT_CREATED ? 33 : _context2.t1 === FSEVENT_MODIFIED ? 33 : _context2.t1 === FSEVENT_DELETED ? 34 : _context2.t1 === FSEVENT_MOVED ? 34 : 35;
                break;

              case 33:
                return _context2.abrupt("return", _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));

              case 34:
                return _context2.abrupt("return", _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));

              case 35:
              case "end":
                return _context2.stop();
            }
          }
        }, null, null, [[12, 18]]);
      };

      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);

      this.fsw._emitReady();

      return closer;
    }
    /**
     * Handle symlinks encountered during directory scan
     * @param {String} linkPath path to symlink
     * @param {String} fullPath absolute path to the symlink
     * @param {Function} transform pre-existing path transformer
     * @param {Number} curDepth level of subdirectories traversed to where symlink is
     * @returns {Promise<void>}
     */

  }, {
    key: "_handleFsEventsSymlink",
    value: function _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
      var linkTarget;
      return regeneratorRuntime.async(function _handleFsEventsSymlink$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              this.fsw._symlinkPaths.set(fullPath, true);

              this.fsw._incrReadyCount();

              _context3.prev = 4;
              _context3.next = 7;
              return regeneratorRuntime.awrap(realpath(linkPath));

            case 7:
              linkTarget = _context3.sent;

              if (!this.fsw.closed) {
                _context3.next = 10;
                break;
              }

              return _context3.abrupt("return");

            case 10:
              if (!this.fsw._isIgnored(linkTarget)) {
                _context3.next = 12;
                break;
              }

              return _context3.abrupt("return", this.fsw._emitReady());

            case 12:
              this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform
              // that causes emitted paths to incorporate the link's path


              this._addToFsEvents(linkTarget || linkPath, function (path) {
                var aliasedPath = linkPath;

                if (linkTarget && linkTarget !== DOT_SLASH) {
                  aliasedPath = path.replace(linkTarget, linkPath);
                } else if (path !== DOT_SLASH) {
                  aliasedPath = sysPath.join(linkPath, path);
                }

                return transform(aliasedPath);
              }, false, curDepth);

              _context3.next = 20;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t0 = _context3["catch"](4);

              if (!this.fsw._handleError(_context3.t0)) {
                _context3.next = 20;
                break;
              }

              return _context3.abrupt("return", this.fsw._emitReady());

            case 20:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[4, 16]]);
    }
    /**
     *
     * @param {Path} newPath
     * @param {fs.Stats} stats
     */

  }, {
    key: "emitAdd",
    value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();

      var dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));

      var base = sysPath.basename(pp); // ensure empty dirs get tracked

      if (isDir) this.fsw._getWatchedDir(pp);
      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!opts.ignoreInitial || forceAdd === true) {
        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
      }
    }
  }, {
    key: "initWatch",
    value: function initWatch(realPath, path, wh, processPath) {
      if (this.fsw.closed) return;

      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);

      this.fsw._addPathCloser(path, closer);
    }
    /**
     * Handle added path with fsevents
     * @param {String} path file/dir path or glob pattern
     * @param {Function|Boolean=} transform converts working path to what the user expects
     * @param {Boolean=} forceAdd ensure add is emitted
     * @param {Number=} priorDepth Level of subdirectories already traversed.
     * @returns {Promise<void>}
     */

  }, {
    key: "_addToFsEvents",
    value: function _addToFsEvents(path, transform, forceAdd, priorDepth) {
      var _this2 = this;

      var opts, processPath, wh, stats, realPath;
      return regeneratorRuntime.async(function _addToFsEvents$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!this.fsw.closed) {
                _context4.next = 2;
                break;
              }

              return _context4.abrupt("return");

            case 2:
              opts = this.fsw.options;
              processPath = _typeof(transform) === FUNCTION_TYPE ? transform : IDENTITY_FN;
              wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch

              _context4.prev = 5;
              _context4.next = 8;
              return regeneratorRuntime.awrap(statMethods[wh.statMethod](wh.watchPath));

            case 8:
              stats = _context4.sent;

              if (!this.fsw.closed) {
                _context4.next = 11;
                break;
              }

              return _context4.abrupt("return");

            case 11:
              if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                _context4.next = 13;
                break;
              }

              throw null;

            case 13:
              if (!stats.isDirectory()) {
                _context4.next = 20;
                break;
              }

              // emit addDir unless this is a glob parent
              if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting

              if (!(priorDepth && priorDepth > opts.depth)) {
                _context4.next = 17;
                break;
              }

              return _context4.abrupt("return");

            case 17:
              // scan the contents of the dir
              this.fsw._readdirp(wh.watchPath, _objectSpread({
                fileFilter: function fileFilter(entry) {
                  return wh.filterPath(entry);
                },
                directoryFilter: function directoryFilter(entry) {
                  return wh.filterDir(entry);
                }
              }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {
                // need to check filterPath on dirs b/c filterDir is less restrictive
                if (_this2.fsw.closed) {
                  return;
                }

                if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
                var joinedPath = sysPath.join(wh.watchPath, entry.path);
                var fullPath = entry.fullPath;

                if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                  // preserve the current depth here since it can't be derived from
                  // real paths past the symlink
                  var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

                  _this2._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                } else {
                  _this2.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                }
              }).on(EV_ERROR, EMPTY_FN).on(STR_END, function () {
                _this2.fsw._emitReady();
              });

              _context4.next = 22;
              break;

            case 20:
              this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);

              this.fsw._emitReady();

            case 22:
              _context4.next = 27;
              break;

            case 24:
              _context4.prev = 24;
              _context4.t0 = _context4["catch"](5);

              if (!_context4.t0 || this.fsw._handleError(_context4.t0)) {
                // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                this.fsw._emitReady();

                this.fsw._emitReady();
              }

            case 27:
              if (!(opts.persistent && forceAdd !== true)) {
                _context4.next = 41;
                break;
              }

              if (!(_typeof(transform) === FUNCTION_TYPE)) {
                _context4.next = 32;
                break;
              }

              // realpath has already been resolved
              this.initWatch(undefined, path, wh, processPath);
              _context4.next = 41;
              break;

            case 32:
              _context4.prev = 32;
              _context4.next = 35;
              return regeneratorRuntime.awrap(realpath(wh.watchPath));

            case 35:
              realPath = _context4.sent;
              _context4.next = 40;
              break;

            case 38:
              _context4.prev = 38;
              _context4.t1 = _context4["catch"](32);

            case 40:
              this.initWatch(realPath, path, wh, processPath);

            case 41:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[5, 24], [32, 38]]);
    }
  }]);

  return FsEventsHandler;
}();

module.exports = FsEventsHandler;
module.exports.canUse = canUse;