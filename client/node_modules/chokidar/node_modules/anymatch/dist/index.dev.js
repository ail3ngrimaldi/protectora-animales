'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var picomatch = require('picomatch');

var normalizePath = require('normalize-path');
/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */


var BANG = '!';
var DEFAULT_OPTIONS = {
  returnIndex: false
};

var arrify = function arrify(item) {
  return Array.isArray(item) ? item : [item];
};
/**
 * @param {AnymatchPattern} matcher
 * @param {object} options
 * @returns {AnymatchFn}
 */


var createPattern = function createPattern(matcher, options) {
  if (typeof matcher === 'function') {
    return matcher;
  }

  if (typeof matcher === 'string') {
    var glob = picomatch(matcher, options);
    return function (string) {
      return matcher === string || glob(string);
    };
  }

  if (matcher instanceof RegExp) {
    return function (string) {
      return matcher.test(string);
    };
  }

  return function (string) {
    return false;
  };
};
/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */


var matchPatterns = function matchPatterns(patterns, negPatterns, args, returnIndex) {
  var isList = Array.isArray(args);

  var _path = isList ? args[0] : args;

  if (!isList && typeof _path !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));
  }

  var path = normalizePath(_path);

  for (var index = 0; index < negPatterns.length; index++) {
    var nglob = negPatterns[index];

    if (nglob(path)) {
      return returnIndex ? -1 : false;
    }
  }

  var applied = isList && [path].concat(args.slice(1));

  for (var _index = 0; _index < patterns.length; _index++) {
    var pattern = patterns[_index];

    if (isList ? pattern.apply(void 0, _toConsumableArray(applied)) : pattern(path)) {
      return returnIndex ? _index : true;
    }
  }

  return returnIndex ? -1 : false;
};
/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {object} options
 * @returns {boolean|number|Function}
 */


var anymatch = function anymatch(matchers, testString) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }

  var opts = typeof options === 'boolean' ? {
    returnIndex: options
  } : options;
  var returnIndex = opts.returnIndex || false; // Early cache for matchers.

  var mtchers = arrify(matchers);
  var negatedGlobs = mtchers.filter(function (item) {
    return typeof item === 'string' && item.charAt(0) === BANG;
  }).map(function (item) {
    return item.slice(1);
  }).map(function (item) {
    return picomatch(item, opts);
  });
  var patterns = mtchers.map(function (matcher) {
    return createPattern(matcher, opts);
  });

  if (testString == null) {
    return function (testString) {
      var ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
  }

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch["default"] = anymatch;
module.exports = anymatch;