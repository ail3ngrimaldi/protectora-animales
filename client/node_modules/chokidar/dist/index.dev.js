'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('events'),
    EventEmitter = _require.EventEmitter;

var fs = require('fs');

var sysPath = require('path');

var _require2 = require('util'),
    promisify = _require2.promisify;

var readdirp = require('readdirp');

var anymatch = require('anymatch')["default"];

var globParent = require('glob-parent');

var isGlob = require('is-glob');

var braces = require('braces');

var normalizePath = require('normalize-path');

var NodeFsHandler = require('./lib/nodefs-handler');

var FsEventsHandler = require('./lib/fsevents-handler');

var _require3 = require('./lib/constants'),
    EV_ALL = _require3.EV_ALL,
    EV_READY = _require3.EV_READY,
    EV_ADD = _require3.EV_ADD,
    EV_CHANGE = _require3.EV_CHANGE,
    EV_UNLINK = _require3.EV_UNLINK,
    EV_ADD_DIR = _require3.EV_ADD_DIR,
    EV_UNLINK_DIR = _require3.EV_UNLINK_DIR,
    EV_RAW = _require3.EV_RAW,
    EV_ERROR = _require3.EV_ERROR,
    STR_CLOSE = _require3.STR_CLOSE,
    STR_END = _require3.STR_END,
    BACK_SLASH_RE = _require3.BACK_SLASH_RE,
    DOUBLE_SLASH_RE = _require3.DOUBLE_SLASH_RE,
    SLASH_OR_BACK_SLASH_RE = _require3.SLASH_OR_BACK_SLASH_RE,
    DOT_RE = _require3.DOT_RE,
    REPLACER_RE = _require3.REPLACER_RE,
    SLASH = _require3.SLASH,
    SLASH_SLASH = _require3.SLASH_SLASH,
    BRACE_START = _require3.BRACE_START,
    BANG = _require3.BANG,
    ONE_DOT = _require3.ONE_DOT,
    TWO_DOTS = _require3.TWO_DOTS,
    GLOBSTAR = _require3.GLOBSTAR,
    SLASH_GLOBSTAR = _require3.SLASH_GLOBSTAR,
    ANYMATCH_OPTS = _require3.ANYMATCH_OPTS,
    STRING_TYPE = _require3.STRING_TYPE,
    FUNCTION_TYPE = _require3.FUNCTION_TYPE,
    EMPTY_STR = _require3.EMPTY_STR,
    EMPTY_FN = _require3.EMPTY_FN,
    isWindows = _require3.isWindows,
    isMacos = _require3.isMacos;

var stat = promisify(fs.stat);
var readdir = promisify(fs.readdir);
/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

var arrify = function arrify() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return Array.isArray(value) ? value : [value];
};

var flatten = function flatten(list) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  list.forEach(function (item) {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

var unifyPaths = function unifyPaths(paths_) {
  /**
   * @type {Array<String>}
   */
  var paths = flatten(arrify(paths_));

  if (!paths.every(function (p) {
    return _typeof(p) === STRING_TYPE;
  })) {
    throw new TypeError("Non-string provided as watch path: ".concat(paths));
  }

  return paths.map(normalizePathToUnix);
}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path


var toUnix = function toUnix(string) {
  var str = string.replace(BACK_SLASH_RE, SLASH);
  var prepend = false;

  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }

  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }

  if (prepend) {
    str = SLASH + str;
  }

  return str;
}; // Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why


var normalizePathToUnix = function normalizePathToUnix(path) {
  return toUnix(sysPath.normalize(toUnix(path)));
};

var normalizeIgnored = function normalizeIgnored() {
  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;
  return function (path) {
    if (_typeof(path) !== STRING_TYPE) return path;
    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
  };
};

var getAbsolutePath = function getAbsolutePath(path, cwd) {
  if (sysPath.isAbsolute(path)) {
    return path;
  }

  if (path.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path.slice(1));
  }

  return sysPath.join(cwd, path);
};

var undef = function undef(opts, key) {
  return opts[key] === undefined;
};
/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */


var DirEntry =
/*#__PURE__*/
function () {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  function DirEntry(dir, removeWatcher) {
    _classCallCheck(this, DirEntry);

    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */

    this.items = new Set();
  }

  _createClass(DirEntry, [{
    key: "add",
    value: function add(item) {
      var items = this.items;
      if (!items) return;
      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
    }
  }, {
    key: "remove",
    value: function remove(item) {
      var items, dir;
      return regeneratorRuntime.async(function remove$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              items = this.items;

              if (items) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              items["delete"](item);

              if (!(items.size > 0)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return");

            case 6:
              dir = this.path;
              _context.prev = 7;
              _context.next = 10;
              return regeneratorRuntime.awrap(readdir(dir));

            case 10:
              _context.next = 15;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](7);

              if (this._removeWatcher) {
                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
              }

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[7, 12]]);
    }
  }, {
    key: "has",
    value: function has(item) {
      var items = this.items;
      if (!items) return;
      return items.has(item);
    }
    /**
     * @returns {Array<String>}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      var items = this.items;
      if (!items) return;
      return _toConsumableArray(items.values());
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.items.clear();
      delete this.path;
      delete this._removeWatcher;
      delete this.items;
      Object.freeze(this);
    }
  }]);

  return DirEntry;
}();

var STAT_METHOD_F = 'stat';
var STAT_METHOD_L = 'lstat';

var WatchHelper =
/*#__PURE__*/
function () {
  function WatchHelper(path, watchPath, follow, fsw) {
    _classCallCheck(this, WatchHelper);

    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */

    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach(function (parts) {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }

  _createClass(WatchHelper, [{
    key: "checkGlobSymlink",
    value: function checkGlobSymlink(entry) {
      // only need to resolve once
      // first entry should always have entry.parentDir === EMPTY_STR
      if (this.globSymlink === undefined) {
        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {
          realPath: entry.fullParentDir,
          linkPath: this.fullWatchPath
        };
      }

      if (this.globSymlink) {
        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
      }

      return entry.fullPath;
    }
  }, {
    key: "entryPath",
    value: function entryPath(entry) {
      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
    }
  }, {
    key: "filterPath",
    value: function filterPath(entry) {
      var stats = entry.stats;
      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
      var resolvedPath = this.entryPath(entry);
      var matchesGlob = this.hasGlob && _typeof(this.globFilter) === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
  }, {
    key: "getDirParts",
    value: function getDirParts(path) {
      var _this = this;

      if (!this.hasGlob) return [];
      var parts = [];
      var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
      expandedPath.forEach(function (path) {
        parts.push(sysPath.relative(_this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
      });
      return parts;
    }
  }, {
    key: "filterDir",
    value: function filterDir(entry) {
      if (this.hasGlob) {
        var entryParts = this.getDirParts(this.checkGlobSymlink(entry));
        var globstar = false;
        this.unmatchedGlob = !this.dirParts.some(function (parts) {
          return parts.every(function (part, i) {
            if (part === GLOBSTAR) globstar = true;
            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
          });
        });
      }

      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
  }]);

  return WatchHelper;
}();
/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */


var FSWatcher =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(FSWatcher, _EventEmitter);

  // Not indenting methods for history sake; for now.
  function FSWatcher(_opts) {
    var _this2;

    _classCallCheck(this, FSWatcher);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(FSWatcher).call(this));
    var opts = {};
    if (_opts) Object.assign(opts, _opts); // for frozen objects

    /** @type {Map<String, DirEntry>} */

    _this2._watched = new Map();
    /** @type {Map<String, Array>} */

    _this2._closers = new Map();
    /** @type {Set<String>} */

    _this2._ignoredPaths = new Set();
    /** @type {Map<ThrottleType, Map>} */

    _this2._throttled = new Map();
    /** @type {Map<Path, String|Boolean>} */

    _this2._symlinkPaths = new Map();
    _this2._streams = new Set();
    _this2.closed = false; // Set up default options.

    if (undef(opts, 'persistent')) opts.persistent = true;
    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
    if (undef(opts, 'interval')) opts.interval = 100;
    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.

    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.

    var canUseFsEvents = FsEventsHandler.canUse();
    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.
    // Other platforms use non-polling fs_watch.

    if (undef(opts, 'usePolling') && !opts.useFsEvents) {
      opts.usePolling = isMacos;
    } // Global override (useful for end-developers that need to force polling for all
    // instances of chokidar, regardless of usage/dependency depth)


    var envPoll = process.env.CHOKIDAR_USEPOLLING;

    if (envPoll !== undefined) {
      var envLower = envPoll.toLowerCase();

      if (envLower === 'false' || envLower === '0') {
        opts.usePolling = false;
      } else if (envLower === 'true' || envLower === '1') {
        opts.usePolling = true;
      } else {
        opts.usePolling = !!envLower;
      }
    }

    var envInterval = process.env.CHOKIDAR_INTERVAL;

    if (envInterval) {
      opts.interval = Number.parseInt(envInterval, 10);
    } // Editor atomic write normalization enabled by default with fs.watch


    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
    if (opts.atomic) _this2._pendingUnlinks = new Map();
    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;
    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
    var awf = opts.awaitWriteFinish;

    if (awf) {
      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
      if (!awf.pollInterval) awf.pollInterval = 100;
      _this2._pendingWrites = new Map();
    }

    if (opts.ignored) opts.ignored = arrify(opts.ignored);
    var readyCalls = 0;

    _this2._emitReady = function () {
      readyCalls++;

      if (readyCalls >= _this2._readyCount) {
        _this2._emitReady = EMPTY_FN;
        _this2._readyEmitted = true; // use process.nextTick to allow time for listener to be bound

        process.nextTick(function () {
          return _this2.emit(EV_READY);
        });
      }
    };

    _this2._emitRaw = function () {
      var _this3;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_this3 = _this2).emit.apply(_this3, [EV_RAW].concat(args));
    };

    _this2._readyEmitted = false;
    _this2.options = opts; // Initialize with proper watcher.

    if (opts.useFsEvents) {
      _this2._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_this2));
    } else {
      _this2._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_this2));
    } // You’re frozen when your heart’s not open.


    Object.freeze(opts);
    return _this2;
  } // Public methods

  /**
   * Adds paths to be watched on an existing FSWatcher instance
   * @param {Path|Array<Path>} paths_
   * @param {String=} _origAdd private; for handling non-existent paths to be watched
   * @param {Boolean=} _internal private; indicates a non-user add
   * @returns {FSWatcher} for chaining
   */


  _createClass(FSWatcher, [{
    key: "add",
    value: function add(paths_, _origAdd, _internal) {
      var _this4 = this;

      var _this$options = this.options,
          cwd = _this$options.cwd,
          disableGlobbing = _this$options.disableGlobbing;
      this.closed = false;
      var paths = unifyPaths(paths_);

      if (cwd) {
        paths = paths.map(function (path) {
          var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob

          if (disableGlobbing || !isGlob(path)) {
            return absPath;
          }

          return normalizePath(absPath);
        });
      } // set aside negated glob strings


      paths = paths.filter(function (path) {
        if (path.startsWith(BANG)) {
          _this4._ignoredPaths.add(path.slice(1));

          return false;
        } // if a path is being added that was previously ignored, stop ignoring it


        _this4._ignoredPaths["delete"](path);

        _this4._ignoredPaths["delete"](path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective


        _this4._userIgnored = undefined;
        return true;
      });

      if (this.options.useFsEvents && this._fsEventsHandler) {
        if (!this._readyCount) this._readyCount = paths.length;
        if (this.options.persistent) this._readyCount *= 2;
        paths.forEach(function (path) {
          return _this4._fsEventsHandler._addToFsEvents(path);
        });
      } else {
        if (!this._readyCount) this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(function _callee(path) {
          var res;
          return regeneratorRuntime.async(function _callee$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return regeneratorRuntime.awrap(_this4._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd));

                case 2:
                  res = _context2.sent;
                  if (res) _this4._emitReady();
                  return _context2.abrupt("return", res);

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          });
        })).then(function (results) {
          if (_this4.closed) return;
          results.filter(function (item) {
            return item;
          }).forEach(function (item) {
            _this4.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          });
        });
      }

      return this;
    }
    /**
     * Close watchers or start ignoring events from specified paths.
     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
     * @returns {FSWatcher} for chaining
    */

  }, {
    key: "unwatch",
    value: function unwatch(paths_) {
      var _this5 = this;

      if (this.closed) return this;
      var paths = unifyPaths(paths_);
      var cwd = this.options.cwd;
      paths.forEach(function (path) {
        // convert to absolute path unless relative path already matches
        if (!sysPath.isAbsolute(path) && !_this5._closers.has(path)) {
          if (cwd) path = sysPath.join(cwd, path);
          path = sysPath.resolve(path);
        }

        _this5._closePath(path);

        _this5._ignoredPaths.add(path);

        if (_this5._watched.has(path)) {
          _this5._ignoredPaths.add(path + SLASH_GLOBSTAR);
        } // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective


        _this5._userIgnored = undefined;
      });
      return this;
    }
    /**
     * Close watchers and remove all listeners from watched paths.
     * @returns {Promise<void>}.
    */

  }, {
    key: "close",
    value: function close() {
      var _this6 = this;

      if (this.closed) return this._closePromise;
      this.closed = true; // Memory management.

      this.removeAllListeners();
      var closers = [];

      this._closers.forEach(function (closerList) {
        return closerList.forEach(function (closer) {
          var promise = closer();
          if (promise instanceof Promise) closers.push(promise);
        });
      });

      this._streams.forEach(function (stream) {
        return stream.destroy();
      });

      this._userIgnored = undefined;
      this._readyCount = 0;
      this._readyEmitted = false;

      this._watched.forEach(function (dirent) {
        return dirent.dispose();
      });

      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {
        _this6["_".concat(key)].clear();
      });
      this._closePromise = closers.length ? Promise.all(closers).then(function () {
        return undefined;
      }) : Promise.resolve();
      return this._closePromise;
    }
    /**
     * Expose list of watched paths
     * @returns {Object} for chaining
    */

  }, {
    key: "getWatched",
    value: function getWatched() {
      var _this7 = this;

      var watchList = {};

      this._watched.forEach(function (entry, dir) {
        var key = _this7.options.cwd ? sysPath.relative(_this7.options.cwd, dir) : dir;
        watchList[key || ONE_DOT] = entry.getChildren().sort();
      });

      return watchList;
    }
  }, {
    key: "emitWithAll",
    value: function emitWithAll(event, args) {
      this.emit.apply(this, _toConsumableArray(args));
      if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));
    } // Common helpers
    // --------------

    /**
     * Normalize and emit events.
     * Calling _emit DOES NOT MEAN emit() would be called!
     * @param {EventName} event Type of event
     * @param {Path} path File or directory path
     * @param {*=} val1 arguments to be passed with event
     * @param {*=} val2
     * @param {*=} val3
     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */

  }, {
    key: "_emit",
    value: function _emit(event, path, val1, val2, val3) {
      var _this8 = this;

      var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;
      return regeneratorRuntime.async(function _emit$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.closed) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              opts = this.options;
              if (isWindows) path = sysPath.normalize(path);
              if (opts.cwd) path = sysPath.relative(opts.cwd, path);
              /** @type Array<any> */

              args = [event, path];
              if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);
              awf = opts.awaitWriteFinish;

              if (!(awf && (pw = this._pendingWrites.get(path)))) {
                _context3.next = 11;
                break;
              }

              pw.lastChange = new Date();
              return _context3.abrupt("return", this);

            case 11:
              if (!opts.atomic) {
                _context3.next = 17;
                break;
              }

              if (!(event === EV_UNLINK)) {
                _context3.next = 16;
                break;
              }

              this._pendingUnlinks.set(path, args);

              setTimeout(function () {
                _this8._pendingUnlinks.forEach(function (entry, path) {
                  _this8.emit.apply(_this8, _toConsumableArray(entry));

                  _this8.emit.apply(_this8, [EV_ALL].concat(_toConsumableArray(entry)));

                  _this8._pendingUnlinks["delete"](path);
                });
              }, typeof opts.atomic === 'number' ? opts.atomic : 100);
              return _context3.abrupt("return", this);

            case 16:
              if (event === EV_ADD && this._pendingUnlinks.has(path)) {
                event = args[0] = EV_CHANGE;

                this._pendingUnlinks["delete"](path);
              }

            case 17:
              if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {
                _context3.next = 21;
                break;
              }

              awfEmit = function awfEmit(err, stats) {
                if (err) {
                  event = args[0] = EV_ERROR;
                  args[1] = err;

                  _this8.emitWithAll(event, args);
                } else if (stats) {
                  // if stats doesn't exist the file must have been deleted
                  if (args.length > 2) {
                    args[2] = stats;
                  } else {
                    args.push(stats);
                  }

                  _this8.emitWithAll(event, args);
                }
              };

              this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);

              return _context3.abrupt("return", this);

            case 21:
              if (!(event === EV_CHANGE)) {
                _context3.next = 25;
                break;
              }

              isThrottled = !this._throttle(EV_CHANGE, path, 50);

              if (!isThrottled) {
                _context3.next = 25;
                break;
              }

              return _context3.abrupt("return", this);

            case 25:
              if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {
                _context3.next = 38;
                break;
              }

              fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
              _context3.prev = 27;
              _context3.next = 30;
              return regeneratorRuntime.awrap(stat(fullPath));

            case 30:
              stats = _context3.sent;
              _context3.next = 35;
              break;

            case 33:
              _context3.prev = 33;
              _context3.t0 = _context3["catch"](27);

            case 35:
              if (!(!stats || this.closed)) {
                _context3.next = 37;
                break;
              }

              return _context3.abrupt("return");

            case 37:
              args.push(stats);

            case 38:
              this.emitWithAll(event, args);
              return _context3.abrupt("return", this);

            case 40:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[27, 33]]);
    }
    /**
     * Common handler for errors
     * @param {Error} error
     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */

  }, {
    key: "_handleError",
    value: function _handleError(error) {
      var code = error && error.code;

      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {
        this.emit(EV_ERROR, error);
      }

      return error || this.closed;
    }
    /**
     * Helper utility for throttling
     * @param {ThrottleType} actionType type being throttled
     * @param {Path} path being acted upon
     * @param {Number} timeout duration of time to suppress duplicate actions
     * @returns {Object|false} tracking object or false if action should be suppressed
     */

  }, {
    key: "_throttle",
    value: function _throttle(actionType, path, timeout) {
      if (!this._throttled.has(actionType)) {
        this._throttled.set(actionType, new Map());
      }
      /** @type {Map<Path, Object>} */


      var action = this._throttled.get(actionType);
      /** @type {Object} */


      var actionPath = action.get(path);

      if (actionPath) {
        actionPath.count++;
        return false;
      }

      var timeoutObject;

      var clear = function clear() {
        var item = action.get(path);
        var count = item ? item.count : 0;
        action["delete"](path);
        clearTimeout(timeoutObject);
        if (item) clearTimeout(item.timeoutObject);
        return count;
      };

      timeoutObject = setTimeout(clear, timeout);
      var thr = {
        timeoutObject: timeoutObject,
        clear: clear,
        count: 0
      };
      action.set(path, thr);
      return thr;
    }
  }, {
    key: "_incrReadyCount",
    value: function _incrReadyCount() {
      return this._readyCount++;
    }
    /**
     * Awaits write operation to finish.
     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
     * @param {Path} path being acted upon
     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
     * @param {EventName} event
     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
     */

  }, {
    key: "_awaitWriteFinish",
    value: function _awaitWriteFinish(path, threshold, event, awfEmit) {
      var _this9 = this;

      var timeoutHandler;
      var fullPath = path;

      if (this.options.cwd && !sysPath.isAbsolute(path)) {
        fullPath = sysPath.join(this.options.cwd, path);
      }

      var now = new Date();

      var awaitWriteFinish = function awaitWriteFinish(prevStat) {
        fs.stat(fullPath, function (err, curStat) {
          if (err || !_this9._pendingWrites.has(path)) {
            if (err && err.code !== 'ENOENT') awfEmit(err);
            return;
          }

          var now = Number(new Date());

          if (prevStat && curStat.size !== prevStat.size) {
            _this9._pendingWrites.get(path).lastChange = now;
          }

          var pw = _this9._pendingWrites.get(path);

          var df = now - pw.lastChange;

          if (df >= threshold) {
            _this9._pendingWrites["delete"](path);

            awfEmit(undefined, curStat);
          } else {
            timeoutHandler = setTimeout(awaitWriteFinish, _this9.options.awaitWriteFinish.pollInterval, curStat);
          }
        });
      };

      if (!this._pendingWrites.has(path)) {
        this._pendingWrites.set(path, {
          lastChange: now,
          cancelWait: function cancelWait() {
            _this9._pendingWrites["delete"](path);

            clearTimeout(timeoutHandler);
            return event;
          }
        });

        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
      }
    }
  }, {
    key: "_getGlobIgnored",
    value: function _getGlobIgnored() {
      return _toConsumableArray(this._ignoredPaths.values());
    }
    /**
     * Determines whether user has asked to ignore this path.
     * @param {Path} path filepath or dir
     * @param {fs.Stats=} stats result of fs.stat
     * @returns {Boolean}
     */

  }, {
    key: "_isIgnored",
    value: function _isIgnored(path, stats) {
      if (this.options.atomic && DOT_RE.test(path)) return true;

      if (!this._userIgnored) {
        var cwd = this.options.cwd;
        var ign = this.options.ignored;
        var ignored = ign && ign.map(normalizeIgnored(cwd));
        var paths = arrify(ignored).filter(function (path) {
          return _typeof(path) === STRING_TYPE && !isGlob(path);
        }).map(function (path) {
          return path + SLASH_GLOBSTAR;
        });

        var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);

        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
      }

      return this._userIgnored([path, stats]);
    }
  }, {
    key: "_isntIgnored",
    value: function _isntIgnored(path, stat) {
      return !this._isIgnored(path, stat);
    }
    /**
     * Provides a set of common helpers and properties relating to symlink and glob handling.
     * @param {Path} path file, directory, or glob pattern being watched
     * @param {Number=} depth at any depth > 0, this isn't a glob
     * @returns {WatchHelper} object containing helpers for this path
     */

  }, {
    key: "_getWatchHelpers",
    value: function _getWatchHelpers(path, depth) {
      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
      var follow = this.options.followSymlinks;
      return new WatchHelper(path, watchPath, follow, this);
    } // Directory helpers
    // -----------------

    /**
     * Provides directory tracking objects
     * @param {String} directory path of the directory
     * @returns {DirEntry} the directory's tracking object
     */

  }, {
    key: "_getWatchedDir",
    value: function _getWatchedDir(directory) {
      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
      var dir = sysPath.resolve(directory);
      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
      return this._watched.get(dir);
    } // File helpers
    // ------------

    /**
     * Check for read permissions.
     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
     * @param {fs.Stats} stats - object, result of fs_stat
     * @returns {Boolean} indicates whether the file can be read
    */

  }, {
    key: "_hasReadPermissions",
    value: function _hasReadPermissions(stats) {
      if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint

      var md = stats && Number.parseInt(stats.mode, 10);
      var st = md & 511;
      var it = Number.parseInt(st.toString(8)[0], 10);
      return Boolean(4 & it);
    }
    /**
     * Handles emitting unlink events for
     * files and directories, and via recursion, for
     * files and directories within directories that are unlinked
     * @param {String} directory within which the following item is located
     * @param {String} item      base path of item/directory
     * @returns {void}
    */

  }, {
    key: "_remove",
    value: function _remove(directory, item, isDirectory) {
      var _this10 = this;

      // if what is being deleted is a directory, get that directory's paths
      // for recursive deleting and cleaning of watched object
      // if it is not a directory, nestedDirectoryChildren will be empty array
      var path = sysPath.join(directory, item);
      var fullPath = sysPath.resolve(path);
      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously
      // via multiple paths (such as _handleFile and _handleDir)

      if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return

      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
        this.add(directory, item, true);
      } // This will create a new entry in the watched object in either case
      // so we got to do the directory check beforehand


      var wp = this._getWatchedDir(path);

      var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.

      nestedDirectoryChildren.forEach(function (nested) {
        return _this10._remove(path, nested);
      }); // Check if item was on the watched list and remove it

      var parent = this._getWatchedDir(directory);

      var wasTracked = parent.has(item);
      parent.remove(item); // If we wait for this file to be fully written, cancel the wait.

      var relPath = path;
      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);

      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
        var event = this._pendingWrites.get(relPath).cancelWait();

        if (event === EV_ADD) return;
      } // The Entry will either be a directory that just got removed
      // or a bogus entry to a file, in either case we have to remove it


      this._watched["delete"](path);

      this._watched["delete"](fullPath);

      var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name

      if (!this.options.useFsEvents) {
        this._closePath(path);
      }
    }
    /**
     * Closes all watchers for a path
     * @param {Path} path
     */

  }, {
    key: "_closePath",
    value: function _closePath(path) {
      this._closeFile(path);

      var dir = sysPath.dirname(path);

      this._getWatchedDir(dir).remove(sysPath.basename(path));
    }
    /**
     * Closes only file-specific watchers
     * @param {Path} path
     */

  }, {
    key: "_closeFile",
    value: function _closeFile(path) {
      var closers = this._closers.get(path);

      if (!closers) return;
      closers.forEach(function (closer) {
        return closer();
      });

      this._closers["delete"](path);
    }
    /**
     *
     * @param {Path} path
     * @param {Function} closer
     */

  }, {
    key: "_addPathCloser",
    value: function _addPathCloser(path, closer) {
      if (!closer) return;

      var list = this._closers.get(path);

      if (!list) {
        list = [];

        this._closers.set(path, list);
      }

      list.push(closer);
    }
  }, {
    key: "_readdirp",
    value: function _readdirp(root, opts) {
      var _this11 = this;

      if (this.closed) return;

      var options = _objectSpread({
        type: EV_ALL,
        alwaysStat: true,
        lstat: true
      }, opts);

      var stream = readdirp(root, options);

      this._streams.add(stream);

      stream.once(STR_CLOSE, function () {
        stream = undefined;
      });
      stream.once(STR_END, function () {
        if (stream) {
          _this11._streams["delete"](stream);

          stream = undefined;
        }
      });
      return stream;
    }
  }]);

  return FSWatcher;
}(EventEmitter); // Export FSWatcher class


exports.FSWatcher = FSWatcher;
/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */

var watch = function watch(paths, options) {
  var watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
};

exports.watch = watch;