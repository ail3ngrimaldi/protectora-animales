"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var eslint_visitor_keys_1 = require("eslint-visitor-keys");

var scope_manager_1 = require("./scope/scope-manager");

var typescript_estree_1 = require("@typescript-eslint/typescript-estree");
/**
 * Define the override function of `Scope#__define` for global augmentation.
 * @param {Function} define The original Scope#__define method.
 * @returns {Function} The override function.
 */


function overrideDefine(define) {
  return function (node, definition) {
    define.call(this, node, definition); // Set `variable.eslintUsed` to tell ESLint that the variable is exported.

    var variable = 'name' in node && typeof node.name === 'string' && this.set.get(node.name);

    if (variable) {
      variable.eslintUsed = true;
    }
  };
}

var PatternVisitor =
/*#__PURE__*/
function (_experimental_utils_) {
  _inherits(PatternVisitor, _experimental_utils_);

  function PatternVisitor(options, rootPattern, callback) {
    _classCallCheck(this, PatternVisitor);

    return _possibleConstructorReturn(this, _getPrototypeOf(PatternVisitor).call(this, options, rootPattern, callback));
  }

  _createClass(PatternVisitor, [{
    key: "Identifier",
    value: function Identifier(node) {
      _get(_getPrototypeOf(PatternVisitor.prototype), "Identifier", this).call(this, node);

      if (node.decorators) {
        var _this$rightHandNodes;

        (_this$rightHandNodes = this.rightHandNodes).push.apply(_this$rightHandNodes, _toConsumableArray(node.decorators));
      }

      if (node.typeAnnotation) {
        this.rightHandNodes.push(node.typeAnnotation);
      }
    }
  }, {
    key: "ArrayPattern",
    value: function ArrayPattern(node) {
      node.elements.forEach(this.visit, this);

      if (node.decorators) {
        var _this$rightHandNodes2;

        (_this$rightHandNodes2 = this.rightHandNodes).push.apply(_this$rightHandNodes2, _toConsumableArray(node.decorators));
      }

      if (node.typeAnnotation) {
        this.rightHandNodes.push(node.typeAnnotation);
      }
    }
  }, {
    key: "ObjectPattern",
    value: function ObjectPattern(node) {
      node.properties.forEach(this.visit, this);

      if (node.decorators) {
        var _this$rightHandNodes3;

        (_this$rightHandNodes3 = this.rightHandNodes).push.apply(_this$rightHandNodes3, _toConsumableArray(node.decorators));
      }

      if (node.typeAnnotation) {
        this.rightHandNodes.push(node.typeAnnotation);
      }
    }
  }, {
    key: "RestElement",
    value: function RestElement(node) {
      _get(_getPrototypeOf(PatternVisitor.prototype), "RestElement", this).call(this, node);

      if (node.decorators) {
        var _this$rightHandNodes4;

        (_this$rightHandNodes4 = this.rightHandNodes).push.apply(_this$rightHandNodes4, _toConsumableArray(node.decorators));
      }

      if (node.typeAnnotation) {
        this.rightHandNodes.push(node.typeAnnotation);
      }
    }
  }, {
    key: "TSParameterProperty",
    value: function TSParameterProperty(node) {
      this.visit(node.parameter);

      if (node.decorators) {
        var _this$rightHandNodes5;

        (_this$rightHandNodes5 = this.rightHandNodes).push.apply(_this$rightHandNodes5, _toConsumableArray(node.decorators));
      }
    }
  }]);

  return PatternVisitor;
}(experimental_utils_1.TSESLintScope.PatternVisitor);

var Referencer =
/*#__PURE__*/
function (_experimental_utils_2) {
  _inherits(Referencer, _experimental_utils_2);

  function Referencer(options, scopeManager) {
    var _this;

    _classCallCheck(this, Referencer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Referencer).call(this, options, scopeManager));
    _this.typeMode = false;
    return _this;
  }
  /**
   * Override to use PatternVisitor we overrode.
   * @param node The Identifier node to visit.
   * @param [options] The flag to visit right-hand side nodes.
   * @param callback The callback function for left-hand side nodes.
   */


  _createClass(Referencer, [{
    key: "visitPattern",
    value: function visitPattern(node, options, callback) {
      if (!node) {
        return;
      }

      if (typeof options === 'function') {
        callback = options;
        options = {
          processRightHandNodes: false
        };
      }

      var visitor = new PatternVisitor(this.options, node, callback);
      visitor.visit(node);

      if (options.processRightHandNodes) {
        visitor.rightHandNodes.forEach(this.visit, this);
      }
    }
    /**
     * Override.
     * Visit `node.typeParameters` and `node.returnType` additionally to find `typeof` expressions.
     * @param node The function node to visit.
     */

  }, {
    key: "visitFunction",
    value: function visitFunction(node) {
      var _this2 = this;

      var type = node.type,
          id = node.id,
          typeParameters = node.typeParameters,
          params = node.params,
          returnType = node.returnType,
          body = node.body;
      var scopeManager = this.scopeManager;
      var upperScope = this.currentScope(); // Process the name.

      if (type === experimental_utils_1.AST_NODE_TYPES.FunctionDeclaration && id) {
        upperScope.__define(id, new experimental_utils_1.TSESLintScope.Definition('FunctionName', id, node, null, null, null)); // Remove overload definition to avoid confusion of no-redeclare rule.


        var _upperScope$set$get = upperScope.set.get(id.name),
            defs = _upperScope$set$get.defs,
            identifiers = _upperScope$set$get.identifiers;

        for (var i = 0; i < defs.length; ++i) {
          var def = defs[i];

          if (def.type === 'FunctionName' && def.node.type === experimental_utils_1.AST_NODE_TYPES.TSDeclareFunction) {
            defs.splice(i, 1);
            identifiers.splice(i, 1);
            break;
          }
        }
      } else if (type === experimental_utils_1.AST_NODE_TYPES.FunctionExpression && id) {
        scopeManager.__nestFunctionExpressionNameScope(node);
      } // Open the function scope.


      scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

      var innerScope = this.currentScope(); // Process the type parameters

      this.visit(typeParameters); // Process parameter declarations.

      var _loop = function _loop(_i) {
        _this2.visitPattern(params[_i], {
          processRightHandNodes: true
        }, function (pattern, info) {
          if (pattern.type !== experimental_utils_1.AST_NODE_TYPES.Identifier || pattern.name !== 'this') {
            innerScope.__define(pattern, new experimental_utils_1.TSESLintScope.ParameterDefinition(pattern, node, _i, info.rest));

            _this2.referencingDefaultValue(pattern, info.assignments, null, true);
          }
        });
      };

      for (var _i = 0; _i < params.length; ++_i) {
        _loop(_i);
      } // Process the return type.


      this.visit(returnType); // Process the body.

      if (body && body.type === experimental_utils_1.AST_NODE_TYPES.BlockStatement) {
        this.visitChildren(body);
      } else {
        this.visit(body);
      } // Close the function scope.


      this.close(node);
    }
    /**
     * Override.
     * Visit decorators.
     * @param node The class node to visit.
     */

  }, {
    key: "visitClass",
    value: function visitClass(node) {
      this.visitDecorators(node.decorators);
      var upperTypeMode = this.typeMode;
      this.typeMode = true;

      if (node.superTypeParameters) {
        this.visit(node.superTypeParameters);
      }

      if (node["implements"]) {
        node["implements"].forEach(this.visit, this);
      }

      this.typeMode = upperTypeMode;

      _get(_getPrototypeOf(Referencer.prototype), "visitClass", this).call(this, node);
    }
    /**
     * Visit typeParameters.
     * @param node The node to visit.
     */

  }, {
    key: "visitTypeParameters",
    value: function visitTypeParameters(node) {
      if (node.typeParameters) {
        var upperTypeMode = this.typeMode;
        this.typeMode = true;
        this.visit(node.typeParameters);
        this.typeMode = upperTypeMode;
      }
    }
    /**
     * Override.
     */

  }, {
    key: "JSXOpeningElement",
    value: function JSXOpeningElement(node) {
      this.visit(node.name);
      this.visitTypeParameters(node);
      node.attributes.forEach(this.visit, this);
    }
    /**
     * Override.
     * Don't create the reference object in the type mode.
     * @param node The Identifier node to visit.
     */

  }, {
    key: "Identifier",
    value: function Identifier(node) {
      this.visitDecorators(node.decorators);

      if (!this.typeMode) {
        _get(_getPrototypeOf(Referencer.prototype), "Identifier", this).call(this, node);
      }

      this.visit(node.typeAnnotation);
    }
    /**
     * Override.
     * Visit decorators.
     * @param node The MethodDefinition node to visit.
     */

  }, {
    key: "MethodDefinition",
    value: function MethodDefinition(node) {
      this.visitDecorators(node.decorators);

      _get(_getPrototypeOf(Referencer.prototype), "MethodDefinition", this).call(this, node);
    }
    /**
     * Don't create the reference object for the key if not computed.
     * @param node The ClassProperty node to visit.
     */

  }, {
    key: "ClassProperty",
    value: function ClassProperty(node) {
      var upperTypeMode = this.typeMode;
      var computed = node.computed,
          decorators = node.decorators,
          key = node.key,
          typeAnnotation = node.typeAnnotation,
          value = node.value;
      this.typeMode = false;
      this.visitDecorators(decorators);

      if (computed) {
        this.visit(key);
      }

      this.typeMode = true;
      this.visit(typeAnnotation);
      this.typeMode = false;
      this.visit(value);
      this.typeMode = upperTypeMode;
    }
    /**
     * Visit new expression.
     * @param node The NewExpression node to visit.
     */

  }, {
    key: "NewExpression",
    value: function NewExpression(node) {
      this.visitTypeParameters(node);
      this.visit(node.callee);
      node.arguments.forEach(this.visit, this);
    }
    /**
     * Override.
     * Visit call expression.
     * @param node The CallExpression node to visit.
     */

  }, {
    key: "CallExpression",
    value: function CallExpression(node) {
      this.visitTypeParameters(node);
      this.visit(node.callee);
      node.arguments.forEach(this.visit, this);
    }
    /**
     * Visit optional member expression.
     * @param node The OptionalMemberExpression node to visit.
     */

  }, {
    key: "OptionalMemberExpression",
    value: function OptionalMemberExpression(node) {
      this.visit(node.object);

      if (node.computed) {
        this.visit(node.property);
      }
    }
    /**
     * Visit optional call expression.
     * @param node The OptionalMemberExpression node to visit.
     */

  }, {
    key: "OptionalCallExpression",
    value: function OptionalCallExpression(node) {
      this.visitTypeParameters(node);
      this.visit(node.callee);
      node.arguments.forEach(this.visit, this);
    }
    /**
     * Define the variable of this function declaration only once.
     * Because to avoid confusion of `no-redeclare` rule by overloading.
     * @param node The TSDeclareFunction node to visit.
     */

  }, {
    key: "TSDeclareFunction",
    value: function TSDeclareFunction(node) {
      var _this3 = this;

      var scopeManager = this.scopeManager;
      var upperScope = this.currentScope();
      var id = node.id,
          typeParameters = node.typeParameters,
          params = node.params,
          returnType = node.returnType; // Ignore this if other overload have already existed.

      if (id) {
        var variable = upperScope.set.get(id.name);
        var defs = variable === null || variable === void 0 ? void 0 : variable.defs;
        var existed = defs === null || defs === void 0 ? void 0 : defs.some(function (d) {
          return d.type === 'FunctionName';
        });

        if (!existed) {
          upperScope.__define(id, new experimental_utils_1.TSESLintScope.Definition('FunctionName', id, node, null, null, null));
        }
      } // Open the function scope.


      scopeManager.__nestEmptyFunctionScope(node);

      var innerScope = this.currentScope(); // Process the type parameters

      this.visit(typeParameters); // Process parameter declarations.

      var _loop2 = function _loop2(i) {
        _this3.visitPattern(params[i], {
          processRightHandNodes: true
        }, function (pattern, info) {
          innerScope.__define(pattern, new experimental_utils_1.TSESLintScope.ParameterDefinition(pattern, node, i, info.rest)); // Set `variable.eslintUsed` to tell ESLint that the variable is used.


          var variable = innerScope.set.get(pattern.name);

          if (variable) {
            variable.eslintUsed = true;
          }

          _this3.referencingDefaultValue(pattern, info.assignments, null, true);
        });
      };

      for (var i = 0; i < params.length; ++i) {
        _loop2(i);
      } // Process the return type.


      this.visit(returnType); // Close the function scope.

      this.close(node);
    }
    /**
     * Create reference objects for the references in parameters and return type.
     * @param node The TSEmptyBodyFunctionExpression node to visit.
     */

  }, {
    key: "TSEmptyBodyFunctionExpression",
    value: function TSEmptyBodyFunctionExpression(node) {
      var upperTypeMode = this.typeMode;
      var typeParameters = node.typeParameters,
          params = node.params,
          returnType = node.returnType;
      this.typeMode = true;
      this.visit(typeParameters);
      params.forEach(this.visit, this);
      this.visit(returnType);
      this.typeMode = upperTypeMode;
    }
    /**
     * Don't make variable because it declares only types.
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSInterfaceDeclaration node to visit.
     */

  }, {
    key: "TSInterfaceDeclaration",
    value: function TSInterfaceDeclaration(node) {
      this.visitTypeNodes(node);
    }
    /**
     * Don't make variable because it declares only types.
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSClassImplements node to visit.
     */

  }, {
    key: "TSClassImplements",
    value: function TSClassImplements(node) {
      this.visitTypeNodes(node);
    }
    /**
     * Don't make variable because it declares only types.
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSIndexSignature node to visit.
     */

  }, {
    key: "TSIndexSignature",
    value: function TSIndexSignature(node) {
      this.visitTypeNodes(node);
    }
    /**
     * Visit type assertion.
     * @param node The TSTypeAssertion node to visit.
     */

  }, {
    key: "TSTypeAssertion",
    value: function TSTypeAssertion(node) {
      if (this.typeMode) {
        this.visit(node.typeAnnotation);
      } else {
        this.typeMode = true;
        this.visit(node.typeAnnotation);
        this.typeMode = false;
      }

      this.visit(node.expression);
    }
    /**
     * Visit as expression.
     * @param node The TSAsExpression node to visit.
     */

  }, {
    key: "TSAsExpression",
    value: function TSAsExpression(node) {
      this.visit(node.expression);

      if (this.typeMode) {
        this.visit(node.typeAnnotation);
      } else {
        this.typeMode = true;
        this.visit(node.typeAnnotation);
        this.typeMode = false;
      }
    }
    /**
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSTypeAnnotation node to visit.
     */

  }, {
    key: "TSTypeAnnotation",
    value: function TSTypeAnnotation(node) {
      this.visitTypeNodes(node);
    }
    /**
     * Switch to the type mode and visit child nodes to find `typeof x` expression in type declarations.
     * @param node The TSTypeParameterDeclaration node to visit.
     */

  }, {
    key: "TSTypeParameterDeclaration",
    value: function TSTypeParameterDeclaration(node) {
      this.visitTypeNodes(node);
    }
    /**
     * Create reference objects for the references in `typeof` expression.
     * @param node The TSTypeQuery node to visit.
     */

  }, {
    key: "TSTypeQuery",
    value: function TSTypeQuery(node) {
      if (this.typeMode) {
        this.typeMode = false;
        this.visitChildren(node);
        this.typeMode = true;
      } else {
        this.visitChildren(node);
      }
    }
    /**
     * @param node The TSTypeParameter node to visit.
     */

  }, {
    key: "TSTypeParameter",
    value: function TSTypeParameter(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSInferType node to visit.
     */

  }, {
    key: "TSInferType",
    value: function TSInferType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSTypeReference node to visit.
     */

  }, {
    key: "TSTypeReference",
    value: function TSTypeReference(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSTypeLiteral node to visit.
     */

  }, {
    key: "TSTypeLiteral",
    value: function TSTypeLiteral(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSLiteralType node to visit.
     */

  }, {
    key: "TSLiteralType",
    value: function TSLiteralType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSIntersectionType node to visit.
     */

  }, {
    key: "TSIntersectionType",
    value: function TSIntersectionType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSConditionalType node to visit.
     */

  }, {
    key: "TSConditionalType",
    value: function TSConditionalType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSIndexedAccessType node to visit.
     */

  }, {
    key: "TSIndexedAccessType",
    value: function TSIndexedAccessType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSMappedType node to visit.
     */

  }, {
    key: "TSMappedType",
    value: function TSMappedType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSOptionalType node to visit.
     */

  }, {
    key: "TSOptionalType",
    value: function TSOptionalType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSParenthesizedType node to visit.
     */

  }, {
    key: "TSParenthesizedType",
    value: function TSParenthesizedType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSRestType node to visit.
     */

  }, {
    key: "TSRestType",
    value: function TSRestType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * @param node The TSTupleType node to visit.
     */

  }, {
    key: "TSTupleType",
    value: function TSTupleType(node) {
      this.visitTypeNodes(node);
    }
    /**
     * Create reference objects for the object part. (This is `obj.prop`)
     * @param node The TSQualifiedName node to visit.
     */

  }, {
    key: "TSQualifiedName",
    value: function TSQualifiedName(node) {
      this.visit(node.left);
    }
    /**
     * Create reference objects for the references in computed keys.
     * @param node The TSPropertySignature node to visit.
     */

  }, {
    key: "TSPropertySignature",
    value: function TSPropertySignature(node) {
      var upperTypeMode = this.typeMode;
      var computed = node.computed,
          key = node.key,
          typeAnnotation = node.typeAnnotation,
          initializer = node.initializer;

      if (computed) {
        this.typeMode = false;
        this.visit(key);
        this.typeMode = true;
      } else {
        this.typeMode = true;
        this.visit(key);
      }

      this.visit(typeAnnotation);
      this.visit(initializer);
      this.typeMode = upperTypeMode;
    }
    /**
     * Create reference objects for the references in computed keys.
     * @param node The TSMethodSignature node to visit.
     */

  }, {
    key: "TSMethodSignature",
    value: function TSMethodSignature(node) {
      var upperTypeMode = this.typeMode;
      var computed = node.computed,
          key = node.key,
          typeParameters = node.typeParameters,
          params = node.params,
          returnType = node.returnType;

      if (computed) {
        this.typeMode = false;
        this.visit(key);
        this.typeMode = true;
      } else {
        this.typeMode = true;
        this.visit(key);
      }

      this.visit(typeParameters);
      params.forEach(this.visit, this);
      this.visit(returnType);
      this.typeMode = upperTypeMode;
    }
    /**
     * Create variable object for the enum.
     * The enum declaration creates a scope for the enum members.
     *
     * enum E {
     *   A,
     *   B,
     *   C = A + B // A and B are references to the enum member.
     * }
     *
     * const a = 0
     * enum E {
     *   A = a // a is above constant.
     * }
     *
     * @param node The TSEnumDeclaration node to visit.
     */

  }, {
    key: "TSEnumDeclaration",
    value: function TSEnumDeclaration(node) {
      var id = node.id,
          members = node.members;
      var scopeManager = this.scopeManager;
      var scope = this.currentScope();

      if (id) {
        scope.__define(id, new experimental_utils_1.TSESLintScope.Definition('EnumName', id, node));
      }

      scopeManager.__nestEnumScope(node);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = members[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var member = _step.value;
          this.visit(member);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.close(node);
    }
    /**
     * Create variable object for the enum member and create reference object for the initializer.
     * And visit the initializer.
     *
     * @param node The TSEnumMember node to visit.
     */

  }, {
    key: "TSEnumMember",
    value: function TSEnumMember(node) {
      var id = node.id,
          initializer = node.initializer;
      var scope = this.currentScope();

      scope.__define(id, new experimental_utils_1.TSESLintScope.Definition('EnumMemberName', id, node));

      if (initializer) {
        scope.__referencing(id, experimental_utils_1.TSESLintScope.Reference.WRITE, initializer, null, false, true);

        this.visit(initializer);
      }
    }
    /**
     * Create the variable object for the module name, and visit children.
     * @param node The TSModuleDeclaration node to visit.
     */

  }, {
    key: "TSModuleDeclaration",
    value: function TSModuleDeclaration(node) {
      var scope = this.currentScope();
      var id = node.id,
          body = node.body;

      if (node.global) {
        this.visitGlobalAugmentation(node);
        return;
      }

      if (id && id.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
        scope.__define(id, new experimental_utils_1.TSESLintScope.Definition('NamespaceName', id, node, null, null, null));
      }

      this.visit(body);
    }
  }, {
    key: "TSTypeAliasDeclaration",
    value: function TSTypeAliasDeclaration(node) {
      this.typeMode = true;
      this.visitChildren(node);
      this.typeMode = false;
    }
    /**
     * Process the module block.
     * @param node The TSModuleBlock node to visit.
     */

  }, {
    key: "TSModuleBlock",
    value: function TSModuleBlock(node) {
      this.scopeManager.__nestBlockScope(node);

      this.visitChildren(node);
      this.close(node);
    }
  }, {
    key: "TSAbstractClassProperty",
    value: function TSAbstractClassProperty(node) {
      this.ClassProperty(node);
    }
  }, {
    key: "TSAbstractMethodDefinition",
    value: function TSAbstractMethodDefinition(node) {
      this.MethodDefinition(node);
    }
    /**
     * Process import equal declaration
     * @param node The TSImportEqualsDeclaration node to visit.
     */

  }, {
    key: "TSImportEqualsDeclaration",
    value: function TSImportEqualsDeclaration(node) {
      var id = node.id,
          moduleReference = node.moduleReference;

      if (id && id.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
        this.currentScope().__define(id, new experimental_utils_1.TSESLintScope.Definition('ImportBinding', id, node, null, null, null));
      }

      this.visit(moduleReference);
    }
    /**
     * Process the global augmentation.
     * 1. Set the global scope as the current scope.
     * 2. Configure the global scope to set `variable.eslintUsed = true` for all defined variables. This means `no-unused-vars` doesn't warn those.
     * @param node The TSModuleDeclaration node to visit.
     */

  }, {
    key: "visitGlobalAugmentation",
    value: function visitGlobalAugmentation(node) {
      var scopeManager = this.scopeManager;
      var currentScope = this.currentScope();
      var globalScope = scopeManager.globalScope;
      var originalDefine = globalScope.__define;
      globalScope.__define = overrideDefine(originalDefine);
      scopeManager.__currentScope = globalScope; // Skip TSModuleBlock to avoid to create that block scope.

      if (node.body && node.body.type === experimental_utils_1.AST_NODE_TYPES.TSModuleBlock) {
        node.body.body.forEach(this.visit, this);
      }

      scopeManager.__currentScope = currentScope;
      globalScope.__define = originalDefine;
    }
    /**
     * Process decorators.
     * @param decorators The decorator nodes to visit.
     */

  }, {
    key: "visitDecorators",
    value: function visitDecorators(decorators) {
      if (decorators) {
        decorators.forEach(this.visit, this);
      }
    }
    /**
     * Process all child of type nodes
     * @param node node to be processed
     */

  }, {
    key: "visitTypeNodes",
    value: function visitTypeNodes(node) {
      if (this.typeMode) {
        this.visitChildren(node);
      } else {
        this.typeMode = true;
        this.visitChildren(node);
        this.typeMode = false;
      }
    }
  }]);

  return Referencer;
}(experimental_utils_1.TSESLintScope.Referencer);

function analyzeScope(ast, parserOptions) {
  var _a;

  var options = {
    ignoreEval: true,
    optimistic: false,
    directive: false,
    nodejsScope: parserOptions.sourceType === 'script' && (parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) === true,
    impliedStrict: false,
    sourceType: parserOptions.sourceType,
    ecmaVersion: (_a = parserOptions.ecmaVersion) !== null && _a !== void 0 ? _a : 2018,
    childVisitorKeys: typescript_estree_1.visitorKeys,
    fallback: eslint_visitor_keys_1.getKeys
  };
  var scopeManager = new scope_manager_1.ScopeManager(options);
  var referencer = new Referencer(options, scopeManager);
  referencer.visit(ast);
  return scopeManager;
}

exports.analyzeScope = analyzeScope;