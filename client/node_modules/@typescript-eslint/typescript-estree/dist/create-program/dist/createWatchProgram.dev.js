"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var debug_1 = __importDefault(require("debug"));

var fs_1 = __importDefault(require("fs"));

var semver_1 = __importDefault(require("semver"));

var ts = __importStar(require("typescript"));

var shared_1 = require("./shared");

var log = debug_1["default"]('typescript-eslint:typescript-estree:createWatchProgram');
/**
 * Maps tsconfig paths to their corresponding file contents and resulting watches
 */

var knownWatchProgramMap = new Map();
/**
 * Maps file/folder paths to their set of corresponding watch callbacks
 * There may be more than one per file/folder if a file/folder is shared between projects
 */

var fileWatchCallbackTrackingMap = new Map();
var folderWatchCallbackTrackingMap = new Map();
/**
 * Stores the list of known files for each program
 */

var programFileListCache = new Map();
/**
 * Caches the last modified time of the tsconfig files
 */

var tsconfigLastModifiedTimestampCache = new Map();
var parsedFilesSeenHash = new Map();
/**
 * Clear all of the parser caches.
 * This should only be used in testing to ensure the parser is clean between tests.
 */

function clearCaches() {
  knownWatchProgramMap.clear();
  fileWatchCallbackTrackingMap.clear();
  folderWatchCallbackTrackingMap.clear();
  parsedFilesSeenHash.clear();
  programFileListCache.clear();
  tsconfigLastModifiedTimestampCache.clear();
}

exports.clearCaches = clearCaches;

function saveWatchCallback(trackingMap) {
  return function (fileName, callback) {
    var normalizedFileName = shared_1.getCanonicalFileName(fileName);

    var watchers = function () {
      var watchers = trackingMap.get(normalizedFileName);

      if (!watchers) {
        watchers = new Set();
        trackingMap.set(normalizedFileName, watchers);
      }

      return watchers;
    }();

    watchers.add(callback);
    return {
      close: function close() {
        watchers["delete"](callback);
      }
    };
  };
}
/**
 * Holds information about the file currently being linted
 */


var currentLintOperationState = {
  code: '',
  filePath: ''
};
/**
 * Appropriately report issues found when reading a config file
 * @param diagnostic The diagnostic raised when creating a program
 */

function diagnosticReporter(diagnostic) {
  throw new Error(ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine));
}
/**
 * Hash content for compare content.
 * @param content hashed contend
 * @returns hashed result
 */


function createHash(content) {
  // No ts.sys in browser environments.
  if (ts.sys && ts.sys.createHash) {
    return ts.sys.createHash(content);
  }

  return content;
}
/**
 * Calculate project environments using options provided by consumer and paths from config
 * @param code The code being linted
 * @param filePathIn The path of the file being parsed
 * @param extra.tsconfigRootDir The root directory for relative tsconfig paths
 * @param extra.projects Provided tsconfig paths
 * @returns The programs corresponding to the supplied tsconfig paths
 */


function getProgramsForProjects(code, filePathIn, extra) {
  var filePath = shared_1.getCanonicalFileName(filePathIn);
  var results = []; // preserve reference to code and file being linted

  currentLintOperationState.code = code;
  currentLintOperationState.filePath = filePath; // Update file version if necessary

  var fileWatchCallbacks = fileWatchCallbackTrackingMap.get(filePath);
  var codeHash = createHash(code);

  if (parsedFilesSeenHash.get(filePath) !== codeHash && fileWatchCallbacks && fileWatchCallbacks.size > 0) {
    fileWatchCallbacks.forEach(function (cb) {
      return cb(filePath, ts.FileWatcherEventKind.Changed);
    });
  }
  /*
   * before we go into the process of attempting to find and update every program
   * see if we know of a program that contains this file
   */


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = extra.projects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var rawTsconfigPath = _step.value;
      var tsconfigPath = shared_1.getTsconfigPath(rawTsconfigPath, extra);
      var existingWatch = knownWatchProgramMap.get(tsconfigPath);

      if (!existingWatch) {
        continue;
      }

      var fileList = programFileListCache.get(tsconfigPath);
      var updatedProgram = null;

      if (!fileList) {
        updatedProgram = existingWatch.getProgram().getProgram();
        fileList = new Set(updatedProgram.getRootFileNames().map(function (f) {
          return shared_1.getCanonicalFileName(f);
        }));
        programFileListCache.set(tsconfigPath, fileList);
      }

      if (fileList.has(filePath)) {
        log('Found existing program for file. %s', filePath);
        updatedProgram = updatedProgram !== null && updatedProgram !== void 0 ? updatedProgram : existingWatch.getProgram().getProgram(); // sets parent pointers in source files

        updatedProgram.getTypeChecker();
        return [updatedProgram];
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  log('File did not belong to any existing programs, moving to create/update. %s', filePath);
  /*
   * We don't know of a program that contains the file, this means that either:
   * - the required program hasn't been created yet, or
   * - the file is new/renamed, and the program hasn't been updated.
   */

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = extra.projects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _rawTsconfigPath = _step2.value;

      var _tsconfigPath = shared_1.getTsconfigPath(_rawTsconfigPath, extra);

      var _existingWatch = knownWatchProgramMap.get(_tsconfigPath);

      if (_existingWatch) {
        var _updatedProgram = maybeInvalidateProgram(_existingWatch, filePath, _tsconfigPath);

        if (!_updatedProgram) {
          continue;
        } // sets parent pointers in source files


        _updatedProgram.getTypeChecker();

        results.push(_updatedProgram);
        continue;
      }

      var programWatch = createWatchProgram(_tsconfigPath, extra);
      var program = programWatch.getProgram().getProgram(); // cache watch program and return current program

      knownWatchProgramMap.set(_tsconfigPath, programWatch); // sets parent pointers in source files

      program.getTypeChecker();
      results.push(program);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return results;
}

exports.getProgramsForProjects = getProgramsForProjects;
var isRunningNoTimeoutFix = semver_1["default"].satisfies(ts.version, '>=3.9.0-beta', {
  includePrerelease: true
});

function createWatchProgram(tsconfigPath, extra) {
  log('Creating watch program for %s.', tsconfigPath); // create compiler host

  var watchCompilerHost = ts.createWatchCompilerHost(tsconfigPath, shared_1.createDefaultCompilerOptionsFromExtra(extra), ts.sys, ts.createAbstractBuilder, diagnosticReporter,
  /*reportWatchStatus*/
  function () {}); // ensure readFile reads the code being linted instead of the copy on disk

  var oldReadFile = watchCompilerHost.readFile;

  watchCompilerHost.readFile = function (filePathIn, encoding) {
    var filePath = shared_1.getCanonicalFileName(filePathIn);
    var fileContent = filePath === currentLintOperationState.filePath ? currentLintOperationState.code : oldReadFile(filePath, encoding);

    if (fileContent !== undefined) {
      parsedFilesSeenHash.set(filePath, createHash(fileContent));
    }

    return fileContent;
  }; // ensure process reports error on failure instead of exiting process immediately


  watchCompilerHost.onUnRecoverableConfigFileDiagnostic = diagnosticReporter; // ensure process doesn't emit programs

  watchCompilerHost.afterProgramCreate = function (program) {
    // report error if there are any errors in the config file
    var configFileDiagnostics = program.getConfigFileParsingDiagnostics().filter(function (diag) {
      return diag.category === ts.DiagnosticCategory.Error && diag.code !== 18003;
    });

    if (configFileDiagnostics.length > 0) {
      diagnosticReporter(configFileDiagnostics[0]);
    }
  };
  /*
   * From the CLI, the file watchers won't matter, as the files will be parsed once and then forgotten.
   * When running from an IDE, these watchers will let us tell typescript about changes.
   *
   * ESLint IDE plugins will send us unfinished file content as the user types (before it's saved to disk).
   * We use the file watchers to tell typescript about this latest file content.
   *
   * When files are created (or renamed), we won't know about them because we have no filesystem watchers attached.
   * We use the folder watchers to tell typescript it needs to go and find new files in the project folders.
   */


  watchCompilerHost.watchFile = saveWatchCallback(fileWatchCallbackTrackingMap);
  watchCompilerHost.watchDirectory = saveWatchCallback(folderWatchCallbackTrackingMap); // allow files with custom extensions to be included in program (uses internal ts api)

  var oldOnDirectoryStructureHostCreate = watchCompilerHost.onCachedDirectoryStructureHostCreate;

  watchCompilerHost.onCachedDirectoryStructureHostCreate = function (host) {
    var oldReadDirectory = host.readDirectory;

    host.readDirectory = function (path, extensions, exclude, include, depth) {
      return oldReadDirectory(path, !extensions ? undefined : extensions.concat(extra.extraFileExtensions), exclude, include, depth);
    };

    oldOnDirectoryStructureHostCreate(host);
  }; // This works only on 3.9


  watchCompilerHost.extraFileExtensions = extra.extraFileExtensions.map(function (extension) {
    return {
      extension: extension,
      isMixedContent: true,
      scriptKind: ts.ScriptKind.Deferred
    };
  });
  watchCompilerHost.trace = log; // Since we don't want to asynchronously update program we want to disable timeout methods
  // So any changes in the program will be delayed and updated when getProgram is called on watch

  var callback;

  if (isRunningNoTimeoutFix) {
    watchCompilerHost.setTimeout = undefined;
    watchCompilerHost.clearTimeout = undefined;
  } else {
    log('Running without timeout fix'); // But because of https://github.com/microsoft/TypeScript/pull/37308 we cannot just set it to undefined
    // instead save it and call before getProgram is called

    watchCompilerHost.setTimeout = function (cb, _ms) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      callback = cb.bind.apply(cb, [
      /*this*/
      undefined].concat(args));
      return callback;
    };

    watchCompilerHost.clearTimeout = function () {
      callback = undefined;
    };
  }

  var watch = ts.createWatchProgram(watchCompilerHost);

  if (!isRunningNoTimeoutFix) {
    var originalGetProgram = watch.getProgram;

    watch.getProgram = function () {
      if (callback) {
        callback();
      }

      callback = undefined;
      return originalGetProgram.call(watch);
    };
  }

  return watch;
}

exports.createWatchProgram = createWatchProgram;

function hasTSConfigChanged(tsconfigPath) {
  var stat = fs_1["default"].statSync(tsconfigPath);
  var lastModifiedAt = stat.mtimeMs;
  var cachedLastModifiedAt = tsconfigLastModifiedTimestampCache.get(tsconfigPath);
  tsconfigLastModifiedTimestampCache.set(tsconfigPath, lastModifiedAt);

  if (cachedLastModifiedAt === undefined) {
    return false;
  }

  return Math.abs(cachedLastModifiedAt - lastModifiedAt) > Number.EPSILON;
}

function maybeInvalidateProgram(existingWatch, filePath, tsconfigPath) {
  /*
   * By calling watchProgram.getProgram(), it will trigger a resync of the program based on
   * whatever new file content we've given it from our input.
   */
  var updatedProgram = existingWatch.getProgram().getProgram(); // In case this change causes problems in larger real world codebases
  // Provide an escape hatch so people don't _have_ to revert to an older version

  if (process.env.TSESTREE_NO_INVALIDATION === 'true') {
    return updatedProgram;
  }

  if (hasTSConfigChanged(tsconfigPath)) {
    /*
     * If the stat of the tsconfig has changed, that could mean the include/exclude/files lists has changed
     * We need to make sure typescript knows this so it can update appropriately
     */
    log('tsconfig has changed - triggering program update. %s', tsconfigPath);
    fileWatchCallbackTrackingMap.get(tsconfigPath).forEach(function (cb) {
      return cb(tsconfigPath, ts.FileWatcherEventKind.Changed);
    }); // tsconfig change means that the file list more than likely changed, so clear the cache

    programFileListCache["delete"](tsconfigPath);
  }

  var sourceFile = updatedProgram.getSourceFile(filePath);

  if (sourceFile) {
    return updatedProgram;
  }
  /*
   * Missing source file means our program's folder structure might be out of date.
   * So we need to tell typescript it needs to update the correct folder.
   */


  log('File was not found in program - triggering folder update. %s', filePath); // Find the correct directory callback by climbing the folder tree

  var currentDir = shared_1.canonicalDirname(filePath);
  var current = null;
  var next = currentDir;
  var hasCallback = false;

  while (current !== next) {
    current = next;
    var folderWatchCallbacks = folderWatchCallbackTrackingMap.get(current);

    if (folderWatchCallbacks) {
      folderWatchCallbacks.forEach(function (cb) {
        if (currentDir !== current) {
          cb(currentDir, ts.FileWatcherEventKind.Changed);
        }

        cb(current, ts.FileWatcherEventKind.Changed);
      });
      hasCallback = true;
    }

    next = shared_1.canonicalDirname(current);
  }

  if (!hasCallback) {
    /*
     * No callback means the paths don't matchup - so no point returning any program
     * this will signal to the caller to skip this program
     */
    log('No callback found for file, not part of this program. %s', filePath);
    return null;
  } // directory update means that the file list more than likely changed, so clear the cache


  programFileListCache["delete"](tsconfigPath); // force the immediate resync

  updatedProgram = existingWatch.getProgram().getProgram();
  sourceFile = updatedProgram.getSourceFile(filePath);

  if (sourceFile) {
    return updatedProgram;
  }
  /*
   * At this point we're in one of two states:
   * - The file isn't supposed to be in this program due to exclusions
   * - The file is new, and was renamed from an old, included filename
   *
   * For the latter case, we need to tell typescript that the old filename is now deleted
   */


  log('File was still not found in program after directory update - checking file deletions. %s', filePath);
  var rootFilenames = updatedProgram.getRootFileNames(); // use find because we only need to "delete" one file to cause typescript to do a full resync

  var deletedFile = rootFilenames.find(function (file) {
    return !fs_1["default"].existsSync(file);
  });

  if (!deletedFile) {
    // There are no deleted files, so it must be the former case of the file not belonging to this program
    return null;
  }

  var fileWatchCallbacks = fileWatchCallbackTrackingMap.get(shared_1.getCanonicalFileName(deletedFile));

  if (!fileWatchCallbacks) {
    // shouldn't happen, but just in case
    log('Could not find watch callbacks for root file. %s', deletedFile);
    return updatedProgram;
  }

  log('Marking file as deleted. %s', deletedFile);
  fileWatchCallbacks.forEach(function (cb) {
    return cb(deletedFile, ts.FileWatcherEventKind.Deleted);
  }); // deleted files means that the file list _has_ changed, so clear the cache

  programFileListCache["delete"](tsconfigPath);
  updatedProgram = existingWatch.getProgram().getProgram();
  sourceFile = updatedProgram.getSourceFile(filePath);

  if (sourceFile) {
    return updatedProgram;
  }

  log('File was still not found in program after deletion check, assuming it is not part of this program. %s', filePath);
  return null;
}