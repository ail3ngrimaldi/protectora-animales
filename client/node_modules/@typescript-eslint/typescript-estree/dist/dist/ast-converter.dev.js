"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var convert_1 = require("./convert");

var convert_comments_1 = require("./convert-comments");

var node_utils_1 = require("./node-utils");

var simple_traverse_1 = require("./simple-traverse");

function astConverter(ast, extra, shouldPreserveNodeMaps) {
  /**
   * The TypeScript compiler produced fundamental parse errors when parsing the
   * source.
   */
  // internal typescript api...
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var parseDiagnostics = ast.parseDiagnostics;

  if (parseDiagnostics.length) {
    throw convert_1.convertError(parseDiagnostics[0]);
  }
  /**
   * Recursively convert the TypeScript AST into an ESTree-compatible AST
   */


  var instance = new convert_1.Converter(ast, {
    errorOnUnknownASTType: extra.errorOnUnknownASTType || false,
    useJSXTextNode: extra.useJSXTextNode || false,
    shouldPreserveNodeMaps: shouldPreserveNodeMaps
  });
  var estree = instance.convertProgram();
  /**
   * Optionally remove range and loc if specified
   */

  if (!extra.range || !extra.loc) {
    simple_traverse_1.simpleTraverse(estree, {
      enter: function enter(node) {
        if (!extra.range) {
          delete node.range;
        }

        if (!extra.loc) {
          delete node.loc;
        }
      }
    });
  }
  /**
   * Optionally convert and include all tokens in the AST
   */


  if (extra.tokens) {
    estree.tokens = node_utils_1.convertTokens(ast);
  }
  /**
   * Optionally convert and include all comments in the AST
   */


  if (extra.comment) {
    estree.comments = convert_comments_1.convertComments(ast, extra.code);
  }

  var astMaps = shouldPreserveNodeMaps ? instance.getASTMaps() : undefined;
  return {
    estree: estree,
    astMaps: astMaps
  };
}

exports.astConverter = astConverter;