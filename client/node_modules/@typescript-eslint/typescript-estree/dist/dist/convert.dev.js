"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); // There's lots of funny stuff due to the typing of ts.Node

/* eslint-disable @typescript-eslint/no-explicit-any */

var ts = __importStar(require("typescript"));

var node_utils_1 = require("./node-utils");

var ts_estree_1 = require("./ts-estree");

var SyntaxKind = ts.SyntaxKind;
/**
 * Extends and formats a given error object
 * @param error the error object
 * @returns converted error object
 */

function convertError(error) {
  return node_utils_1.createError(error.file, error.start, error.message || error.messageText);
}

exports.convertError = convertError;

var Converter =
/*#__PURE__*/
function () {
  /**
   * Converts a TypeScript node into an ESTree node
   * @param ast the full TypeScript AST
   * @param options additional options for the conversion
   * @returns the converted ESTreeNode
   */
  function Converter(ast, options) {
    _classCallCheck(this, Converter);

    this.esTreeNodeToTSNodeMap = new WeakMap();
    this.tsNodeToESTreeNodeMap = new WeakMap();
    this.allowPattern = false;
    this.inTypeMode = false;
    this.ast = ast;
    this.options = Object.assign({}, options);
  }

  _createClass(Converter, [{
    key: "getASTMaps",
    value: function getASTMaps() {
      return {
        esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,
        tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap
      };
    }
  }, {
    key: "convertProgram",
    value: function convertProgram() {
      return this.converter(this.ast);
    }
    /**
     * Converts a TypeScript node into an ESTree node.
     * @param node the child ts.Node
     * @param parent parentNode
     * @param inTypeMode flag to determine if we are in typeMode
     * @param allowPattern flag to determine if patterns are allowed
     * @returns the converted ESTree node
     */

  }, {
    key: "converter",
    value: function converter(node, parent, inTypeMode, allowPattern) {
      /**
       * Exit early for null and undefined
       */
      if (!node) {
        return null;
      }

      var typeMode = this.inTypeMode;
      var pattern = this.allowPattern;

      if (inTypeMode !== undefined) {
        this.inTypeMode = inTypeMode;
      }

      if (allowPattern !== undefined) {
        this.allowPattern = allowPattern;
      }

      var result = this.convertNode(node, parent !== null && parent !== void 0 ? parent : node.parent);
      this.registerTSNodeInNodeMap(node, result);
      this.inTypeMode = typeMode;
      this.allowPattern = pattern;
      return result;
    }
    /**
     * Fixes the exports of the given ts.Node
     * @param node the ts.Node
     * @param result result
     * @returns the ESTreeNode with fixed exports
     */

  }, {
    key: "fixExports",
    value: function fixExports(node, result) {
      // check for exports
      if (node.modifiers && node.modifiers[0].kind === SyntaxKind.ExportKeyword) {
        /**
         * Make sure that original node is registered instead of export
         */
        this.registerTSNodeInNodeMap(node, result);
        var exportKeyword = node.modifiers[0];
        var nextModifier = node.modifiers[1];
        var declarationIsDefault = nextModifier && nextModifier.kind === SyntaxKind.DefaultKeyword;
        var varToken = declarationIsDefault ? node_utils_1.findNextToken(nextModifier, this.ast, this.ast) : node_utils_1.findNextToken(exportKeyword, this.ast, this.ast);
        result.range[0] = varToken.getStart(this.ast);
        result.loc = node_utils_1.getLocFor(result.range[0], result.range[1], this.ast);

        if (declarationIsDefault) {
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,
            declaration: result,
            range: [exportKeyword.getStart(this.ast), result.range[1]],
            exportKind: 'value'
          });
        } else {
          var isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration || result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;
          var isDeclare = result.declare === true;
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,
            declaration: result,
            specifiers: [],
            source: null,
            exportKind: isType || isDeclare ? 'type' : 'value',
            range: [exportKeyword.getStart(this.ast), result.range[1]]
          });
        }
      }

      return result;
    }
    /**
     * Register specific TypeScript node into map with first ESTree node provided
     */

  }, {
    key: "registerTSNodeInNodeMap",
    value: function registerTSNodeInNodeMap(node, result) {
      if (result && this.options.shouldPreserveNodeMaps) {
        if (!this.tsNodeToESTreeNodeMap.has(node)) {
          this.tsNodeToESTreeNodeMap.set(node, result);
        }
      }
    }
    /**
     * Converts a TypeScript node into an ESTree node.
     * @param child the child ts.Node
     * @param parent parentNode
     * @returns the converted ESTree node
     */

  }, {
    key: "convertPattern",
    value: function convertPattern(child, parent) {
      return this.converter(child, parent, this.inTypeMode, true);
    }
    /**
     * Converts a TypeScript node into an ESTree node.
     * @param child the child ts.Node
     * @param parent parentNode
     * @returns the converted ESTree node
     */

  }, {
    key: "convertChild",
    value: function convertChild(child, parent) {
      return this.converter(child, parent, this.inTypeMode, false);
    }
    /**
     * Converts a TypeScript node into an ESTree node.
     * @param child the child ts.Node
     * @param parent parentNode
     * @returns the converted ESTree node
     */

  }, {
    key: "convertType",
    value: function convertType(child, parent) {
      return this.converter(child, parent, true, false);
    }
  }, {
    key: "createNode",
    value: function createNode(node, data) {
      var result = data;

      if (!result.range) {
        result.range = node_utils_1.getRange(node, this.ast);
      }

      if (!result.loc) {
        result.loc = node_utils_1.getLocFor(result.range[0], result.range[1], this.ast);
      }

      if (result && this.options.shouldPreserveNodeMaps) {
        this.esTreeNodeToTSNodeMap.set(result, node);
      }

      return result;
    }
    /**
     * Converts a child into a type annotation. This creates an intermediary
     * TypeAnnotation node to match what Flow does.
     * @param child The TypeScript AST node to convert.
     * @param parent parentNode
     * @returns The type annotation node.
     */

  }, {
    key: "convertTypeAnnotation",
    value: function convertTypeAnnotation(child, parent) {
      // in FunctionType and ConstructorType typeAnnotation has 2 characters `=>` and in other places is just colon
      var offset = parent.kind === SyntaxKind.FunctionType || parent.kind === SyntaxKind.ConstructorType ? 2 : 1;
      var annotationStartCol = child.getFullStart() - offset;
      var loc = node_utils_1.getLocFor(annotationStartCol, child.end, this.ast);
      return {
        type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,
        loc: loc,
        range: [annotationStartCol, child.end],
        typeAnnotation: this.convertType(child)
      };
    }
    /**
     * Coverts body Nodes and add a directive field to StringLiterals
     * @param nodes of ts.Node
     * @param parent parentNode
     * @returns Array of body statements
     */

  }, {
    key: "convertBodyExpressions",
    value: function convertBodyExpressions(nodes, parent) {
      var _this = this;

      var allowDirectives = node_utils_1.canContainDirective(parent);
      return nodes.map(function (statement) {
        var child = _this.convertChild(statement);

        if (allowDirectives) {
          if ((child === null || child === void 0 ? void 0 : child.expression) && ts.isExpressionStatement(statement) && ts.isStringLiteral(statement.expression)) {
            var raw = child.expression.raw;
            child.directive = raw.slice(1, -1);
            return child; // child can be null, but it's filtered below
          } else {
            allowDirectives = false;
          }
        }

        return child; // child can be null, but it's filtered below
      }) // filter out unknown nodes for now
      .filter(function (statement) {
        return statement;
      });
    }
    /**
     * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node
     * @param typeArguments ts.NodeArray typeArguments
     * @param node parent used to create this node
     * @returns TypeParameterInstantiation node
     */

  }, {
    key: "convertTypeArgumentsToTypeParameters",
    value: function convertTypeArgumentsToTypeParameters(typeArguments, node) {
      var _this2 = this;

      var greaterThanToken = node_utils_1.findNextToken(typeArguments, this.ast, this.ast);
      return this.createNode(node, {
        type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,
        range: [typeArguments.pos - 1, greaterThanToken.end],
        params: typeArguments.map(function (typeArgument) {
          return _this2.convertType(typeArgument);
        })
      });
    }
    /**
     * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node
     * @param typeParameters ts.Node typeParameters
     * @returns TypeParameterDeclaration node
     */

  }, {
    key: "convertTSTypeParametersToTypeParametersDeclaration",
    value: function convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {
      var _this3 = this;

      var greaterThanToken = node_utils_1.findNextToken(typeParameters, this.ast, this.ast);
      return {
        type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,
        range: [typeParameters.pos - 1, greaterThanToken.end],
        loc: node_utils_1.getLocFor(typeParameters.pos - 1, greaterThanToken.end, this.ast),
        params: typeParameters.map(function (typeParameter) {
          return _this3.convertType(typeParameter);
        })
      };
    }
    /**
     * Converts an array of ts.Node parameters into an array of ESTreeNode params
     * @param parameters An array of ts.Node params to be converted
     * @returns an array of converted ESTreeNode params
     */

  }, {
    key: "convertParameters",
    value: function convertParameters(parameters) {
      var _this4 = this;

      if (!parameters || !parameters.length) {
        return [];
      }

      return parameters.map(function (param) {
        var convertedParam = _this4.convertChild(param);

        if (param.decorators && param.decorators.length) {
          convertedParam.decorators = param.decorators.map(function (el) {
            return _this4.convertChild(el);
          });
        }

        return convertedParam;
      });
    }
    /**
     * For nodes that are copied directly from the TypeScript AST into
     * ESTree mostly as-is. The only difference is the addition of a type
     * property instead of a kind property. Recursively copies all children.
     */

  }, {
    key: "deeplyCopy",
    value: function deeplyCopy(node) {
      var _this5 = this;

      if (node.kind === ts.SyntaxKind.JSDocFunctionType) {
        throw node_utils_1.createError(this.ast, node.pos, 'JSDoc types can only be used inside documentation comments.');
      }

      var customType = "TS".concat(SyntaxKind[node.kind]);
      /**
       * If the "errorOnUnknownASTType" option is set to true, throw an error,
       * otherwise fallback to just including the unknown type as-is.
       */

      if (this.options.errorOnUnknownASTType && !ts_estree_1.AST_NODE_TYPES[customType]) {
        throw new Error("Unknown AST_NODE_TYPE: \"".concat(customType, "\""));
      }

      var result = this.createNode(node, {
        type: customType
      });

      if ('type' in node) {
        result.typeAnnotation = node.type && 'kind' in node.type && ts.isTypeNode(node.type) ? this.convertTypeAnnotation(node.type, node) : null;
      }

      if ('typeArguments' in node) {
        result.typeParameters = node.typeArguments && 'pos' in node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null;
      }

      if ('typeParameters' in node) {
        result.typeParameters = node.typeParameters && 'pos' in node.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters) : null;
      }

      if ('decorators' in node && node.decorators && node.decorators.length) {
        result.decorators = node.decorators.map(function (el) {
          return _this5.convertChild(el);
        });
      }

      Object.entries(node).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            key = _ref2[0];

        return !/^(?:_children|kind|parent|pos|end|flags|modifierFlagsCache|jsDoc|type|typeArguments|typeParameters|decorators)$/.test(key);
      }).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        if (Array.isArray(value)) {
          result[key] = value.map(function (el) {
            return _this5.convertChild(el);
          });
        } else if (value && _typeof(value) === 'object' && value.kind) {
          // need to check node[key].kind to ensure we don't try to convert a symbol
          result[key] = _this5.convertChild(value);
        } else {
          result[key] = value;
        }
      });
      return result;
    }
    /**
     * Converts a TypeScript JSX node.tagName into an ESTree node.name
     * @param node the tagName object from a JSX ts.Node
     * @param parent
     * @returns the converted ESTree name object
     */

  }, {
    key: "convertJSXTagName",
    value: function convertJSXTagName(node, parent) {
      var result;

      switch (node.kind) {
        case SyntaxKind.PropertyAccessExpression:
          if (node.name.kind === SyntaxKind.PrivateIdentifier) {
            // This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.
            // So we shouldn't ever get into this state to begin with.
            throw new Error('Non-private identifier expected.');
          }

          result = this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,
            object: this.convertJSXTagName(node.expression, parent),
            property: this.convertJSXTagName(node.name, parent)
          });
          break;

        case SyntaxKind.ThisKeyword:
          result = this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
            name: 'this'
          });
          break;

        case SyntaxKind.Identifier:
        default:
          result = this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
            name: node.text
          });
          break;
      }

      this.registerTSNodeInNodeMap(node, result);
      return result;
    }
    /**
     * Applies the given TS modifiers to the given result object.
     * @param result
     * @param modifiers original ts.Nodes from the node.modifiers array
     * @returns the current result object will be mutated
     * @deprecated This method adds not standardized `modifiers` property in nodes
     */

  }, {
    key: "applyModifiersToResult",
    value: function applyModifiersToResult(result, modifiers) {
      var _this6 = this;

      if (!modifiers || !modifiers.length) {
        return;
      }
      /**
       * Some modifiers are explicitly handled by applying them as
       * boolean values on the result node. As well as adding them
       * to the result, we remove them from the array, so that they
       * are not handled twice.
       */


      var handledModifierIndices = {};

      for (var i = 0; i < modifiers.length; i++) {
        var modifier = modifiers[i];

        switch (modifier.kind) {
          /**
           * Ignore ExportKeyword and DefaultKeyword, they are handled
           * via the fixExports utility function
           */
          case SyntaxKind.ExportKeyword:
          case SyntaxKind.DefaultKeyword:
            handledModifierIndices[i] = true;
            break;

          case SyntaxKind.ConstKeyword:
            result["const"] = true;
            handledModifierIndices[i] = true;
            break;

          case SyntaxKind.DeclareKeyword:
            result.declare = true;
            handledModifierIndices[i] = true;
            break;

          default:
        }
      }
      /**
       * If there are still valid modifiers available which have
       * not been explicitly handled above, we just convert and
       * add the modifiers array to the result node.
       */


      var remainingModifiers = modifiers.filter(function (_, i) {
        return !handledModifierIndices[i];
      });

      if (!remainingModifiers || !remainingModifiers.length) {
        return;
      }

      result.modifiers = remainingModifiers.map(function (el) {
        return _this6.convertChild(el);
      });
    }
    /**
     * Uses the provided range location to adjust the location data of the given Node
     * @param result The node that will have its location data mutated
     * @param childRange The child node range used to expand location
     */

  }, {
    key: "fixParentLocation",
    value: function fixParentLocation(result, childRange) {
      if (childRange[0] < result.range[0]) {
        result.range[0] = childRange[0];
        result.loc.start = node_utils_1.getLineAndCharacterFor(result.range[0], this.ast);
      }

      if (childRange[1] > result.range[1]) {
        result.range[1] = childRange[1];
        result.loc.end = node_utils_1.getLineAndCharacterFor(result.range[1], this.ast);
      }
    }
    /**
     * Converts a TypeScript node into an ESTree node.
     * The core of the conversion logic:
     * Identify and convert each relevant TypeScript SyntaxKind
     * @param node the child ts.Node
     * @param parent parentNode
     * @returns the converted ESTree node
     */

  }, {
    key: "convertNode",
    value: function convertNode(node, parent) {
      var _this7 = this;

      var _a, _b, _c, _d, _e, _f, _g, _h;

      switch (node.kind) {
        case SyntaxKind.SourceFile:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Program,
              body: this.convertBodyExpressions(node.statements, node),
              sourceType: node.externalModuleIndicator ? 'module' : 'script',
              range: [node.getStart(this.ast), node.endOfFileToken.end]
            });
          }

        case SyntaxKind.Block:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.BlockStatement,
              body: this.convertBodyExpressions(node.statements, node)
            });
          }

        case SyntaxKind.Identifier:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Identifier,
              name: node.text
            });
          }

        case SyntaxKind.WithStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.WithStatement,
            object: this.convertChild(node.expression),
            body: this.convertChild(node.statement)
          });
        // Control Flow

        case SyntaxKind.ReturnStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.LabeledStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,
            label: this.convertChild(node.label),
            body: this.convertChild(node.statement)
          });

        case SyntaxKind.ContinueStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,
            label: this.convertChild(node.label)
          });

        case SyntaxKind.BreakStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.BreakStatement,
            label: this.convertChild(node.label)
          });
        // Choice

        case SyntaxKind.IfStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.IfStatement,
            test: this.convertChild(node.expression),
            consequent: this.convertChild(node.thenStatement),
            alternate: this.convertChild(node.elseStatement)
          });

        case SyntaxKind.SwitchStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,
            discriminant: this.convertChild(node.expression),
            cases: node.caseBlock.clauses.map(function (el) {
              return _this7.convertChild(el);
            })
          });

        case SyntaxKind.CaseClause:
        case SyntaxKind.DefaultClause:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.SwitchCase,
            // expression is present in case only
            test: node.kind === SyntaxKind.CaseClause ? this.convertChild(node.expression) : null,
            consequent: node.statements.map(function (el) {
              return _this7.convertChild(el);
            })
          });
        // Exceptions

        case SyntaxKind.ThrowStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.TryStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TryStatement,
            block: this.convertChild(node.tryBlock),
            handler: this.convertChild(node.catchClause),
            finalizer: this.convertChild(node.finallyBlock)
          });

        case SyntaxKind.CatchClause:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.CatchClause,
            param: node.variableDeclaration ? this.convertChild(node.variableDeclaration.name) : null,
            body: this.convertChild(node.block)
          });
        // Loops

        case SyntaxKind.WhileStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.WhileStatement,
            test: this.convertChild(node.expression),
            body: this.convertChild(node.statement)
          });

        /**
         * Unlike other parsers, TypeScript calls a "DoWhileStatement"
         * a "DoStatement"
         */

        case SyntaxKind.DoStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,
            test: this.convertChild(node.expression),
            body: this.convertChild(node.statement)
          });

        case SyntaxKind.ForStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ForStatement,
            init: this.convertChild(node.initializer),
            test: this.convertChild(node.condition),
            update: this.convertChild(node.incrementor),
            body: this.convertChild(node.statement)
          });

        case SyntaxKind.ForInStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ForInStatement,
            left: this.convertPattern(node.initializer),
            right: this.convertChild(node.expression),
            body: this.convertChild(node.statement)
          });

        case SyntaxKind.ForOfStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,
            left: this.convertPattern(node.initializer),
            right: this.convertChild(node.expression),
            body: this.convertChild(node.statement),
            "await": Boolean(node.awaitModifier && node.awaitModifier.kind === SyntaxKind.AwaitKeyword)
          });
        // Declarations

        case SyntaxKind.FunctionDeclaration:
          {
            var isDeclare = node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node);
            var result = this.createNode(node, {
              type: isDeclare || !node.body ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,
              id: this.convertChild(node.name),
              generator: !!node.asteriskToken,
              expression: false,
              async: node_utils_1.hasModifier(SyntaxKind.AsyncKeyword, node),
              params: this.convertParameters(node.parameters),
              body: this.convertChild(node.body) || undefined
            }); // Process returnType

            if (node.type) {
              result.returnType = this.convertTypeAnnotation(node.type, node);
            }

            if (isDeclare) {
              result.declare = true;
            } // Process typeParameters


            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            /**
             * Semantically, decorators are not allowed on function declarations,
             * but the TypeScript compiler will parse them and produce a valid AST,
             * so we handle them here too.
             */


            if (node.decorators) {
              result.decorators = node.decorators.map(function (el) {
                return _this7.convertChild(el);
              });
            } // check for exports


            return this.fixExports(node, result);
          }

        case SyntaxKind.VariableDeclaration:
          {
            var _result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,
              id: this.convertPattern(node.name),
              init: this.convertChild(node.initializer)
            });

            if (node.exclamationToken) {
              _result.definite = true;
            }

            if (node.type) {
              _result.id.typeAnnotation = this.convertTypeAnnotation(node.type, node);
              this.fixParentLocation(_result.id, _result.id.typeAnnotation.range);
            }

            return _result;
          }

        case SyntaxKind.VariableStatement:
          {
            var _result2 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,
              declarations: node.declarationList.declarations.map(function (el) {
                return _this7.convertChild(el);
              }),
              kind: node_utils_1.getDeclarationKind(node.declarationList)
            });
            /**
             * Semantically, decorators are not allowed on variable declarations,
             * but the TypeScript compiler will parse them and produce a valid AST,
             * so we handle them here too.
             */


            if (node.decorators) {
              _result2.decorators = node.decorators.map(function (el) {
                return _this7.convertChild(el);
              });
            }

            if (node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)) {
              _result2.declare = true;
            } // check for exports


            return this.fixExports(node, _result2);
          }
        // mostly for for-of, for-in

        case SyntaxKind.VariableDeclarationList:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,
            declarations: node.declarations.map(function (el) {
              return _this7.convertChild(el);
            }),
            kind: node_utils_1.getDeclarationKind(node)
          });
        // Expressions

        case SyntaxKind.ExpressionStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,
            expression: this.convertChild(node.expression)
          });

        case SyntaxKind.ThisKeyword:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ThisExpression
          });

        case SyntaxKind.ArrayLiteralExpression:
          {
            // TypeScript uses ArrayLiteralExpression in destructuring assignment, too
            if (this.allowPattern) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,
                elements: node.elements.map(function (el) {
                  return _this7.convertPattern(el);
                })
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,
                elements: node.elements.map(function (el) {
                  return _this7.convertChild(el);
                })
              });
            }
          }

        case SyntaxKind.ObjectLiteralExpression:
          {
            // TypeScript uses ObjectLiteralExpression in destructuring assignment, too
            if (this.allowPattern) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,
                properties: node.properties.map(function (el) {
                  return _this7.convertPattern(el);
                })
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,
                properties: node.properties.map(function (el) {
                  return _this7.convertChild(el);
                })
              });
            }
          }

        case SyntaxKind.PropertyAssignment:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.Property,
            key: this.convertChild(node.name),
            value: this.converter(node.initializer, node, this.inTypeMode, this.allowPattern),
            computed: node_utils_1.isComputedProperty(node.name),
            method: false,
            shorthand: false,
            kind: 'init'
          });

        case SyntaxKind.ShorthandPropertyAssignment:
          {
            if (node.objectAssignmentInitializer) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Property,
                key: this.convertChild(node.name),
                value: this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: this.convertPattern(node.name),
                  right: this.convertChild(node.objectAssignmentInitializer)
                }),
                computed: false,
                method: false,
                shorthand: true,
                kind: 'init'
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Property,
                key: this.convertChild(node.name),
                value: this.convertChild(node.name),
                computed: false,
                method: false,
                shorthand: true,
                kind: 'init'
              });
            }
          }

        case SyntaxKind.ComputedPropertyName:
          return this.convertChild(node.expression);

        case SyntaxKind.PropertyDeclaration:
          {
            var isAbstract = node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node);

            var _result3 = this.createNode(node, {
              type: isAbstract ? ts_estree_1.AST_NODE_TYPES.TSAbstractClassProperty : ts_estree_1.AST_NODE_TYPES.ClassProperty,
              key: this.convertChild(node.name),
              value: this.convertChild(node.initializer),
              computed: node_utils_1.isComputedProperty(node.name),
              "static": node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node),
              readonly: node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node) || undefined,
              declare: node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)
            });

            if (node.type) {
              _result3.typeAnnotation = this.convertTypeAnnotation(node.type, node);
            }

            if (node.decorators) {
              _result3.decorators = node.decorators.map(function (el) {
                return _this7.convertChild(el);
              });
            }

            var accessibility = node_utils_1.getTSNodeAccessibility(node);

            if (accessibility) {
              _result3.accessibility = accessibility;
            }

            if ((node.name.kind === SyntaxKind.Identifier || node.name.kind === SyntaxKind.ComputedPropertyName) && node.questionToken) {
              _result3.optional = true;
            }

            if (node.exclamationToken) {
              _result3.definite = true;
            }

            if (_result3.key.type === ts_estree_1.AST_NODE_TYPES.Literal && node.questionToken) {
              _result3.optional = true;
            }

            return _result3;
          }

        case SyntaxKind.GetAccessor:
        case SyntaxKind.SetAccessor:
        case SyntaxKind.MethodDeclaration:
          {
            var method = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
              id: null,
              generator: !!node.asteriskToken,
              expression: false,
              async: node_utils_1.hasModifier(SyntaxKind.AsyncKeyword, node),
              body: this.convertChild(node.body),
              range: [node.parameters.pos - 1, node.end],
              params: []
            });

            if (node.type) {
              method.returnType = this.convertTypeAnnotation(node.type, node);
            } // Process typeParameters


            if (node.typeParameters) {
              method.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
              this.fixParentLocation(method, method.typeParameters.range);
            }

            var _result4;

            if (parent.kind === SyntaxKind.ObjectLiteralExpression) {
              method.params = node.parameters.map(function (el) {
                return _this7.convertChild(el);
              });
              _result4 = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Property,
                key: this.convertChild(node.name),
                value: method,
                computed: node_utils_1.isComputedProperty(node.name),
                method: node.kind === SyntaxKind.MethodDeclaration,
                shorthand: false,
                kind: 'init'
              });
            } else {
              // class

              /**
               * Unlike in object literal methods, class method params can have decorators
               */
              method.params = this.convertParameters(node.parameters);
              /**
               * TypeScript class methods can be defined as "abstract"
               */

              var methodDefinitionType = node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition;
              _result4 = this.createNode(node, {
                type: methodDefinitionType,
                key: this.convertChild(node.name),
                value: method,
                computed: node_utils_1.isComputedProperty(node.name),
                "static": node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node),
                kind: 'method'
              });

              if (node.decorators) {
                _result4.decorators = node.decorators.map(function (el) {
                  return _this7.convertChild(el);
                });
              }

              var _accessibility = node_utils_1.getTSNodeAccessibility(node);

              if (_accessibility) {
                _result4.accessibility = _accessibility;
              }
            }

            if (_result4.key.type === ts_estree_1.AST_NODE_TYPES.Identifier && node.questionToken) {
              _result4.key.optional = true;
            }

            if (node.kind === SyntaxKind.GetAccessor) {
              _result4.kind = 'get';
            } else if (node.kind === SyntaxKind.SetAccessor) {
              _result4.kind = 'set';
            } else if (!_result4["static"] && node.name.kind === SyntaxKind.StringLiteral && node.name.text === 'constructor' && _result4.type !== ts_estree_1.AST_NODE_TYPES.Property) {
              _result4.kind = 'constructor';
            }

            return _result4;
          }
        // TypeScript uses this even for static methods named "constructor"

        case SyntaxKind.Constructor:
          {
            var lastModifier = node_utils_1.getLastModifier(node);
            var constructorToken = lastModifier && node_utils_1.findNextToken(lastModifier, node, this.ast) || node.getFirstToken();

            var _constructor = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
              id: null,
              params: this.convertParameters(node.parameters),
              generator: false,
              expression: false,
              async: false,
              body: this.convertChild(node.body),
              range: [node.parameters.pos - 1, node.end]
            }); // Process typeParameters


            if (node.typeParameters) {
              _constructor.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
              this.fixParentLocation(_constructor, _constructor.typeParameters.range);
            } // Process returnType


            if (node.type) {
              _constructor.returnType = this.convertTypeAnnotation(node.type, node);
            }

            var constructorKey = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Identifier,
              name: 'constructor',
              range: [constructorToken.getStart(this.ast), constructorToken.end]
            });
            var isStatic = node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node);

            var _result5 = this.createNode(node, {
              type: node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition,
              key: constructorKey,
              value: _constructor,
              computed: false,
              "static": isStatic,
              kind: isStatic ? 'method' : 'constructor'
            });

            var _accessibility2 = node_utils_1.getTSNodeAccessibility(node);

            if (_accessibility2) {
              _result5.accessibility = _accessibility2;
            }

            return _result5;
          }

        case SyntaxKind.FunctionExpression:
          {
            var _result6 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
              id: this.convertChild(node.name),
              generator: !!node.asteriskToken,
              params: this.convertParameters(node.parameters),
              body: this.convertChild(node.body),
              async: node_utils_1.hasModifier(SyntaxKind.AsyncKeyword, node),
              expression: false
            }); // Process returnType


            if (node.type) {
              _result6.returnType = this.convertTypeAnnotation(node.type, node);
            } // Process typeParameters


            if (node.typeParameters) {
              _result6.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }

            return _result6;
          }

        case SyntaxKind.SuperKeyword:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.Super
          });

        case SyntaxKind.ArrayBindingPattern:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,
            elements: node.elements.map(function (el) {
              return _this7.convertPattern(el);
            })
          });
        // occurs with missing array elements like [,]

        case SyntaxKind.OmittedExpression:
          return null;

        case SyntaxKind.ObjectBindingPattern:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,
            properties: node.elements.map(function (el) {
              return _this7.convertPattern(el);
            })
          });

        case SyntaxKind.BindingElement:
          {
            if (parent.kind === SyntaxKind.ArrayBindingPattern) {
              var arrayItem = this.convertChild(node.name, parent);

              if (node.initializer) {
                return this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: arrayItem,
                  right: this.convertChild(node.initializer)
                });
              } else if (node.dotDotDotToken) {
                return this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.RestElement,
                  argument: arrayItem
                });
              } else {
                return arrayItem;
              }
            } else {
              var _result7;

              if (node.dotDotDotToken) {
                _result7 = this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.RestElement,
                  argument: this.convertChild((_a = node.propertyName) !== null && _a !== void 0 ? _a : node.name)
                });
              } else {
                _result7 = this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.Property,
                  key: this.convertChild((_b = node.propertyName) !== null && _b !== void 0 ? _b : node.name),
                  value: this.convertChild(node.name),
                  computed: Boolean(node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName),
                  method: false,
                  shorthand: !node.propertyName,
                  kind: 'init'
                });
              }

              if (node.initializer) {
                _result7.value = this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: this.convertChild(node.name),
                  right: this.convertChild(node.initializer),
                  range: [node.name.getStart(this.ast), node.initializer.end]
                });
              }

              return _result7;
            }
          }

        case SyntaxKind.ArrowFunction:
          {
            var _result8 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,
              generator: false,
              id: null,
              params: this.convertParameters(node.parameters),
              body: this.convertChild(node.body),
              async: node_utils_1.hasModifier(SyntaxKind.AsyncKeyword, node),
              expression: node.body.kind !== SyntaxKind.Block
            }); // Process returnType


            if (node.type) {
              _result8.returnType = this.convertTypeAnnotation(node.type, node);
            } // Process typeParameters


            if (node.typeParameters) {
              _result8.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }

            return _result8;
          }

        case SyntaxKind.YieldExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.YieldExpression,
            delegate: !!node.asteriskToken,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.AwaitExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,
            argument: this.convertChild(node.expression)
          });
        // Template Literals

        case SyntaxKind.NoSubstitutionTemplateLiteral:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,
            quasis: [this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TemplateElement,
              value: {
                raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - 1),
                cooked: node.text
              },
              tail: true
            })],
            expressions: []
          });

        case SyntaxKind.TemplateExpression:
          {
            var _result9 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,
              quasis: [this.convertChild(node.head)],
              expressions: []
            });

            node.templateSpans.forEach(function (templateSpan) {
              _result9.expressions.push(_this7.convertChild(templateSpan.expression));

              _result9.quasis.push(_this7.convertChild(templateSpan.literal));
            });
            return _result9;
          }

        case SyntaxKind.TaggedTemplateExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,
            typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,
            tag: this.convertChild(node.tag),
            quasi: this.convertChild(node.template)
          });

        case SyntaxKind.TemplateHead:
        case SyntaxKind.TemplateMiddle:
        case SyntaxKind.TemplateTail:
          {
            var tail = node.kind === SyntaxKind.TemplateTail;
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TemplateElement,
              value: {
                raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - (tail ? 1 : 2)),
                cooked: node.text
              },
              tail: tail
            });
          }
        // Patterns

        case SyntaxKind.SpreadAssignment:
        case SyntaxKind.SpreadElement:
          {
            if (this.allowPattern) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.RestElement,
                argument: this.convertPattern(node.expression)
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.SpreadElement,
                argument: this.convertChild(node.expression)
              });
            }
          }

        case SyntaxKind.Parameter:
          {
            var parameter;

            var _result10;

            if (node.dotDotDotToken) {
              parameter = _result10 = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.RestElement,
                argument: this.convertChild(node.name)
              });
            } else if (node.initializer) {
              parameter = this.convertChild(node.name);
              _result10 = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                left: parameter,
                right: this.convertChild(node.initializer)
              });

              if (node.modifiers) {
                // AssignmentPattern should not contain modifiers in range
                _result10.range[0] = parameter.range[0];
                _result10.loc = node_utils_1.getLocFor(_result10.range[0], _result10.range[1], this.ast);
              }
            } else {
              parameter = _result10 = this.convertChild(node.name, parent);
            }

            if (node.type) {
              parameter.typeAnnotation = this.convertTypeAnnotation(node.type, node);
              this.fixParentLocation(parameter, parameter.typeAnnotation.range);
            }

            if (node.questionToken) {
              if (node.questionToken.end > parameter.range[1]) {
                parameter.range[1] = node.questionToken.end;
                parameter.loc.end = node_utils_1.getLineAndCharacterFor(parameter.range[1], this.ast);
              }

              parameter.optional = true;
            }

            if (node.modifiers) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,
                accessibility: (_c = node_utils_1.getTSNodeAccessibility(node)) !== null && _c !== void 0 ? _c : undefined,
                readonly: node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node) || undefined,
                "static": node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node) || undefined,
                "export": node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node) || undefined,
                parameter: _result10
              });
            }

            return _result10;
          }
        // Classes

        case SyntaxKind.ClassDeclaration:
        case SyntaxKind.ClassExpression:
          {
            var heritageClauses = (_d = node.heritageClauses) !== null && _d !== void 0 ? _d : [];
            var classNodeType = node.kind === SyntaxKind.ClassDeclaration ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration : ts_estree_1.AST_NODE_TYPES.ClassExpression;
            var superClass = heritageClauses.find(function (clause) {
              return clause.token === SyntaxKind.ExtendsKeyword;
            });
            var implementsClause = heritageClauses.find(function (clause) {
              return clause.token === SyntaxKind.ImplementsKeyword;
            });

            var _result11 = this.createNode(node, {
              type: classNodeType,
              id: this.convertChild(node.name),
              body: this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ClassBody,
                body: [],
                range: [node.members.pos - 1, node.end]
              }),
              superClass: (superClass === null || superClass === void 0 ? void 0 : superClass.types[0]) ? this.convertChild(superClass.types[0].expression) : null
            });

            if (superClass) {
              if (superClass.types.length > 1) {
                throw node_utils_1.createError(this.ast, superClass.types[1].pos, 'Classes can only extend a single class.');
              }

              if (superClass.types[0] && superClass.types[0].typeArguments) {
                _result11.superTypeParameters = this.convertTypeArgumentsToTypeParameters(superClass.types[0].typeArguments, superClass.types[0]);
              }
            }

            if (node.typeParameters) {
              _result11.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }

            if (implementsClause) {
              _result11["implements"] = implementsClause.types.map(function (el) {
                return _this7.convertChild(el);
              });
            }
            /**
             * TypeScript class declarations can be defined as "abstract"
             */


            if (node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node)) {
              _result11["abstract"] = true;
            }

            if (node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)) {
              _result11.declare = true;
            }

            if (node.decorators) {
              _result11.decorators = node.decorators.map(function (el) {
                return _this7.convertChild(el);
              });
            }

            var filteredMembers = node.members.filter(node_utils_1.isESTreeClassMember);

            if (filteredMembers.length) {
              _result11.body.body = filteredMembers.map(function (el) {
                return _this7.convertChild(el);
              });
            } // check for exports


            return this.fixExports(node, _result11);
          }
        // Modules

        case SyntaxKind.ModuleBlock:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,
            body: this.convertBodyExpressions(node.statements, node)
          });

        case SyntaxKind.ImportDeclaration:
          {
            var _result12 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,
              source: this.convertChild(node.moduleSpecifier),
              specifiers: [],
              importKind: 'value'
            });

            if (node.importClause) {
              if (node.importClause.isTypeOnly) {
                _result12.importKind = 'type';
              }

              if (node.importClause.name) {
                _result12.specifiers.push(this.convertChild(node.importClause));
              }

              if (node.importClause.namedBindings) {
                switch (node.importClause.namedBindings.kind) {
                  case SyntaxKind.NamespaceImport:
                    _result12.specifiers.push(this.convertChild(node.importClause.namedBindings));

                    break;

                  case SyntaxKind.NamedImports:
                    _result12.specifiers = _result12.specifiers.concat(node.importClause.namedBindings.elements.map(function (el) {
                      return _this7.convertChild(el);
                    }));
                    break;
                }
              }
            }

            return _result12;
          }

        case SyntaxKind.NamespaceImport:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,
            local: this.convertChild(node.name)
          });

        case SyntaxKind.ImportSpecifier:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,
            local: this.convertChild(node.name),
            imported: this.convertChild((_e = node.propertyName) !== null && _e !== void 0 ? _e : node.name)
          });

        case SyntaxKind.ImportClause:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,
            local: this.convertChild(node.name),
            range: [node.getStart(this.ast), node.name.end]
          });

        case SyntaxKind.ExportDeclaration:
          if (((_f = node.exportClause) === null || _f === void 0 ? void 0 : _f.kind) === SyntaxKind.NamedExports) {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,
              source: this.convertChild(node.moduleSpecifier),
              specifiers: node.exportClause.elements.map(function (el) {
                return _this7.convertChild(el);
              }),
              exportKind: node.isTypeOnly ? 'type' : 'value',
              declaration: null
            });
          } else {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,
              source: this.convertChild(node.moduleSpecifier),
              exportKind: node.isTypeOnly ? 'type' : 'value',
              exported: // note - for compat with 3.7.x, where node.exportClause is always undefined and
              //        SyntaxKind.NamespaceExport does not exist yet (i.e. is undefined), this
              //        cannot be shortened to an optional chain, or else you end up with
              //        undefined === undefined, and the true path will hard error at runtime
              node.exportClause && node.exportClause.kind === SyntaxKind.NamespaceExport ? this.convertChild(node.exportClause.name) : null
            });
          }

        case SyntaxKind.ExportSpecifier:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,
            local: this.convertChild((_g = node.propertyName) !== null && _g !== void 0 ? _g : node.name),
            exported: this.convertChild(node.name)
          });

        case SyntaxKind.ExportAssignment:
          if (node.isExportEquals) {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,
              expression: this.convertChild(node.expression)
            });
          } else {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,
              declaration: this.convertChild(node.expression),
              exportKind: 'value'
            });
          }

        // Unary Operations

        case SyntaxKind.PrefixUnaryExpression:
        case SyntaxKind.PostfixUnaryExpression:
          {
            var operator = node_utils_1.getTextForTokenKind(node.operator);
            /**
             * ESTree uses UpdateExpression for ++/--
             */

            if (operator === '++' || operator === '--') {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,
                operator: operator,
                prefix: node.kind === SyntaxKind.PrefixUnaryExpression,
                argument: this.convertChild(node.operand)
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
                operator: operator,
                prefix: node.kind === SyntaxKind.PrefixUnaryExpression,
                argument: this.convertChild(node.operand)
              });
            }
          }

        case SyntaxKind.DeleteExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
            operator: 'delete',
            prefix: true,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.VoidExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
            operator: 'void',
            prefix: true,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.TypeOfExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
            operator: 'typeof',
            prefix: true,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.TypeOperator:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,
            operator: node_utils_1.getTextForTokenKind(node.operator),
            typeAnnotation: this.convertChild(node.type)
          });
        // Binary Operations

        case SyntaxKind.BinaryExpression:
          {
            // TypeScript uses BinaryExpression for sequences as well
            if (node_utils_1.isComma(node.operatorToken)) {
              var _result13 = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,
                expressions: []
              });

              var left = this.convertChild(node.left);

              if (left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression && node.left.kind !== SyntaxKind.ParenthesizedExpression) {
                _result13.expressions = _result13.expressions.concat(left.expressions);
              } else {
                _result13.expressions.push(left);
              }

              _result13.expressions.push(this.convertChild(node.right));

              return _result13;
            } else {
              var type = node_utils_1.getBinaryExpressionType(node.operatorToken);

              if (this.allowPattern && type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {
                return this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: this.convertPattern(node.left, node),
                  right: this.convertChild(node.right)
                });
              }

              return this.createNode(node, {
                type: type,
                operator: node_utils_1.getTextForTokenKind(node.operatorToken.kind),
                left: this.converter(node.left, node, this.inTypeMode, type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),
                right: this.convertChild(node.right)
              });
            }
          }

        case SyntaxKind.PropertyAccessExpression:
          {
            var object = this.convertChild(node.expression);
            var property = this.convertChild(node.name);
            var computed = false;
            var isLocallyOptional = node.questionDotToken !== undefined; // the optional expression should propagate up the member expression tree

            var isChildOptional = (object.type === ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression || object.type === ts_estree_1.AST_NODE_TYPES.OptionalCallExpression) && // (x?.y).z is semantically different, and as such .z is no longer optional
            node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression;

            if (isLocallyOptional || isChildOptional) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression,
                object: object,
                property: property,
                computed: computed,
                optional: isLocallyOptional
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.MemberExpression,
                object: object,
                property: property,
                computed: computed,
                optional: false
              });
            }
          }

        case SyntaxKind.ElementAccessExpression:
          {
            var _object = this.convertChild(node.expression);

            var _property = this.convertChild(node.argumentExpression);

            var _computed = true;

            var _isLocallyOptional = node.questionDotToken !== undefined; // the optional expression should propagate up the member expression tree


            var _isChildOptional = (_object.type === ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression || _object.type === ts_estree_1.AST_NODE_TYPES.OptionalCallExpression) && // (x?.y).z is semantically different, and as such .z is no longer optional
            node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression;

            if (_isLocallyOptional || _isChildOptional) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression,
                object: _object,
                property: _property,
                computed: _computed,
                optional: _isLocallyOptional
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.MemberExpression,
                object: _object,
                property: _property,
                computed: _computed,
                optional: false
              });
            }
          }

        case SyntaxKind.CallExpression:
          {
            var callee = this.convertChild(node.expression);
            var args = node.arguments.map(function (el) {
              return _this7.convertChild(el);
            });

            var _result14;

            var _isLocallyOptional2 = node.questionDotToken !== undefined; // the optional expression should propagate up the member expression tree


            var _isChildOptional2 = (callee.type === ts_estree_1.AST_NODE_TYPES.OptionalMemberExpression || callee.type === ts_estree_1.AST_NODE_TYPES.OptionalCallExpression) && // (x?.y).z() is semantically different, and as such .z() is no longer optional
            node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression;

            if (_isLocallyOptional2 || _isChildOptional2) {
              _result14 = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.OptionalCallExpression,
                callee: callee,
                arguments: args,
                optional: _isLocallyOptional2
              });
            } else {
              _result14 = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.CallExpression,
                callee: callee,
                arguments: args,
                optional: false
              });
            }

            if (node.typeArguments) {
              _result14.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);
            }

            return _result14;
          }

        case SyntaxKind.NewExpression:
          {
            // NOTE - NewExpression cannot have an optional chain in it
            var _result15 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.NewExpression,
              callee: this.convertChild(node.expression),
              arguments: node.arguments ? node.arguments.map(function (el) {
                return _this7.convertChild(el);
              }) : []
            });

            if (node.typeArguments) {
              _result15.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);
            }

            return _result15;
          }

        case SyntaxKind.ConditionalExpression:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,
            test: this.convertChild(node.condition),
            consequent: this.convertChild(node.whenTrue),
            alternate: this.convertChild(node.whenFalse)
          });

        case SyntaxKind.MetaProperty:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.MetaProperty,
              meta: this.createNode( // TODO: do we really want to convert it to Token?
              node.getFirstToken(), {
                type: ts_estree_1.AST_NODE_TYPES.Identifier,
                name: node_utils_1.getTextForTokenKind(node.keywordToken)
              }),
              property: this.convertChild(node.name)
            });
          }

        case SyntaxKind.Decorator:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Decorator,
              expression: this.convertChild(node.expression)
            });
          }
        // Literals

        case SyntaxKind.StringLiteral:
          {
            var _result16 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              raw: '',
              value: ''
            });

            _result16.raw = this.ast.text.slice(_result16.range[0], _result16.range[1]);

            if ('name' in parent && parent.name === node) {
              _result16.value = node.text;
            } else {
              _result16.value = node_utils_1.unescapeStringLiteralText(node.text);
            }

            return _result16;
          }

        case SyntaxKind.NumericLiteral:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: Number(node.text),
              raw: node.getText()
            });
          }

        case SyntaxKind.BigIntLiteral:
          {
            var _result17 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.BigIntLiteral,
              raw: '',
              value: ''
            });

            _result17.raw = this.ast.text.slice(_result17.range[0], _result17.range[1]);
            _result17.value = _result17.raw.slice(0, -1); // remove suffix `n`

            return _result17;
          }

        case SyntaxKind.RegularExpressionLiteral:
          {
            var pattern = node.text.slice(1, node.text.lastIndexOf('/'));
            var flags = node.text.slice(node.text.lastIndexOf('/') + 1);
            var regex = null;

            try {
              regex = new RegExp(pattern, flags);
            } catch (exception) {
              regex = null;
            }

            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: regex,
              raw: node.text,
              regex: {
                pattern: pattern,
                flags: flags
              }
            });
          }

        case SyntaxKind.TrueKeyword:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.Literal,
            value: true,
            raw: 'true'
          });

        case SyntaxKind.FalseKeyword:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.Literal,
            value: false,
            raw: 'false'
          });

        case SyntaxKind.NullKeyword:
          {
            if (this.inTypeMode) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Literal,
                value: null,
                raw: 'null'
              });
            }
          }

        case SyntaxKind.ImportKeyword:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.Import
          });

        case SyntaxKind.EmptyStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.EmptyStatement
          });

        case SyntaxKind.DebuggerStatement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement
          });
        // JSX

        case SyntaxKind.JsxElement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXElement,
            openingElement: this.convertChild(node.openingElement),
            closingElement: this.convertChild(node.closingElement),
            children: node.children.map(function (el) {
              return _this7.convertChild(el);
            })
          });

        case SyntaxKind.JsxFragment:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXFragment,
            openingFragment: this.convertChild(node.openingFragment),
            closingFragment: this.convertChild(node.closingFragment),
            children: node.children.map(function (el) {
              return _this7.convertChild(el);
            })
          });

        case SyntaxKind.JsxSelfClosingElement:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXElement,

              /**
               * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,
               * TypeScript does not seem to have the idea of openingElement when tag is self-closing
               */
              openingElement: this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,
                typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,
                selfClosing: true,
                name: this.convertJSXTagName(node.tagName, node),
                attributes: node.attributes.properties.map(function (el) {
                  return _this7.convertChild(el);
                }),
                range: node_utils_1.getRange(node, this.ast)
              }),
              closingElement: null,
              children: []
            });
          }

        case SyntaxKind.JsxOpeningElement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,
            typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined,
            selfClosing: false,
            name: this.convertJSXTagName(node.tagName, node),
            attributes: node.attributes.properties.map(function (el) {
              return _this7.convertChild(el);
            })
          });

        case SyntaxKind.JsxClosingElement:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,
            name: this.convertJSXTagName(node.tagName, node)
          });

        case SyntaxKind.JsxOpeningFragment:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment
          });

        case SyntaxKind.JsxClosingFragment:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment
          });

        case SyntaxKind.JsxExpression:
          {
            var expression = node.expression ? this.convertChild(node.expression) : this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,
              range: [node.getStart(this.ast) + 1, node.getEnd() - 1]
            });

            if (node.dotDotDotToken) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,
                expression: expression
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,
                expression: expression
              });
            }
          }

        case SyntaxKind.JsxAttribute:
          {
            var attributeName = this.convertChild(node.name);
            attributeName.type = ts_estree_1.AST_NODE_TYPES.JSXIdentifier;
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,
              name: attributeName,
              value: this.convertChild(node.initializer)
            });
          }

        /**
         * The JSX AST changed the node type for string literals
         * inside a JSX Element from `Literal` to `JSXText`. We
         * provide a flag to support both types until `Literal`
         * node type is deprecated in ESLint v5.
         */

        case SyntaxKind.JsxText:
          {
            var start = node.getFullStart();
            var end = node.getEnd();

            if (this.options.useJSXTextNode) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXText,
                value: this.ast.text.slice(start, end),
                raw: this.ast.text.slice(start, end),
                range: [start, end]
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Literal,
                value: this.ast.text.slice(start, end),
                raw: this.ast.text.slice(start, end),
                range: [start, end]
              });
            }
          }

        case SyntaxKind.JsxSpreadAttribute:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,
            argument: this.convertChild(node.expression)
          });

        case SyntaxKind.QualifiedName:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,
              left: this.convertChild(node.left),
              right: this.convertChild(node.right)
            });
          }
        // TypeScript specific

        case SyntaxKind.TypeReference:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,
              typeName: this.convertType(node.typeName),
              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : undefined
            });
          }

        case SyntaxKind.TypeParameter:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,
              name: this.convertType(node.name),
              constraint: node.constraint ? this.convertType(node.constraint) : undefined,
              "default": node["default"] ? this.convertType(node["default"]) : undefined
            });
          }

        case SyntaxKind.ThisType:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TSThisType
          });

        case SyntaxKind.AnyKeyword:
        case SyntaxKind.BigIntKeyword:
        case SyntaxKind.BooleanKeyword:
        case SyntaxKind.NeverKeyword:
        case SyntaxKind.NumberKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.SymbolKeyword:
        case SyntaxKind.UnknownKeyword:
        case SyntaxKind.VoidKeyword:
        case SyntaxKind.UndefinedKeyword:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES["TS".concat(SyntaxKind[node.kind])]
            });
          }

        case SyntaxKind.NonNullExpression:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,
              expression: this.convertChild(node.expression)
            });
          }

        case SyntaxKind.TypeLiteral:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,
              members: node.members.map(function (el) {
                return _this7.convertChild(el);
              })
            });
          }

        case SyntaxKind.ArrayType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSArrayType,
              elementType: this.convertType(node.elementType)
            });
          }

        case SyntaxKind.IndexedAccessType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,
              objectType: this.convertType(node.objectType),
              indexType: this.convertType(node.indexType)
            });
          }

        case SyntaxKind.ConditionalType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,
              checkType: this.convertType(node.checkType),
              extendsType: this.convertType(node.extendsType),
              trueType: this.convertType(node.trueType),
              falseType: this.convertType(node.falseType)
            });
          }

        case SyntaxKind.TypeQuery:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,
              exprName: this.convertType(node.exprName)
            });
          }

        case SyntaxKind.MappedType:
          {
            var _result18 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSMappedType,
              typeParameter: this.convertType(node.typeParameter)
            });

            if (node.readonlyToken) {
              if (node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {
                _result18.readonly = true;
              } else {
                _result18.readonly = node_utils_1.getTextForTokenKind(node.readonlyToken.kind);
              }
            }

            if (node.questionToken) {
              if (node.questionToken.kind === SyntaxKind.QuestionToken) {
                _result18.optional = true;
              } else {
                _result18.optional = node_utils_1.getTextForTokenKind(node.questionToken.kind);
              }
            }

            if (node.type) {
              _result18.typeAnnotation = this.convertType(node.type);
            }

            return _result18;
          }

        case SyntaxKind.ParenthesizedExpression:
          return this.convertChild(node.expression, parent);

        case SyntaxKind.TypeAliasDeclaration:
          {
            var _result19 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
              id: this.convertChild(node.name),
              typeAnnotation: this.convertType(node.type)
            });

            if (node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)) {
              _result19.declare = true;
            } // Process typeParameters


            if (node.typeParameters) {
              _result19.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            } // check for exports


            return this.fixExports(node, _result19);
          }

        case SyntaxKind.MethodSignature:
          {
            var _result20 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,
              computed: node_utils_1.isComputedProperty(node.name),
              key: this.convertChild(node.name),
              params: this.convertParameters(node.parameters)
            });

            if (node_utils_1.isOptional(node)) {
              _result20.optional = true;
            }

            if (node.type) {
              _result20.returnType = this.convertTypeAnnotation(node.type, node);
            }

            if (node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node)) {
              _result20.readonly = true;
            }

            if (node.typeParameters) {
              _result20.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }

            var _accessibility3 = node_utils_1.getTSNodeAccessibility(node);

            if (_accessibility3) {
              _result20.accessibility = _accessibility3;
            }

            if (node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node)) {
              _result20["export"] = true;
            }

            if (node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node)) {
              _result20["static"] = true;
            }

            return _result20;
          }

        case SyntaxKind.PropertySignature:
          {
            var _result21 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,
              optional: node_utils_1.isOptional(node) || undefined,
              computed: node_utils_1.isComputedProperty(node.name),
              key: this.convertChild(node.name),
              typeAnnotation: node.type ? this.convertTypeAnnotation(node.type, node) : undefined,
              initializer: this.convertChild(node.initializer) || undefined,
              readonly: node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node) || undefined,
              "static": node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node) || undefined,
              "export": node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node) || undefined
            });

            var _accessibility4 = node_utils_1.getTSNodeAccessibility(node);

            if (_accessibility4) {
              _result21.accessibility = _accessibility4;
            }

            return _result21;
          }

        case SyntaxKind.IndexSignature:
          {
            var _result22 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,
              parameters: node.parameters.map(function (el) {
                return _this7.convertChild(el);
              })
            });

            if (node.type) {
              _result22.typeAnnotation = this.convertTypeAnnotation(node.type, node);
            }

            if (node_utils_1.hasModifier(SyntaxKind.ReadonlyKeyword, node)) {
              _result22.readonly = true;
            }

            var _accessibility5 = node_utils_1.getTSNodeAccessibility(node);

            if (_accessibility5) {
              _result22.accessibility = _accessibility5;
            }

            if (node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node)) {
              _result22["export"] = true;
            }

            if (node_utils_1.hasModifier(SyntaxKind.StaticKeyword, node)) {
              _result22["static"] = true;
            }

            return _result22;
          }

        case SyntaxKind.ConstructorType:
        case SyntaxKind.FunctionType:
        case SyntaxKind.ConstructSignature:
        case SyntaxKind.CallSignature:
          {
            var _type;

            switch (node.kind) {
              case SyntaxKind.ConstructSignature:
                _type = ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration;
                break;

              case SyntaxKind.CallSignature:
                _type = ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration;
                break;

              case SyntaxKind.FunctionType:
                _type = ts_estree_1.AST_NODE_TYPES.TSFunctionType;
                break;

              case SyntaxKind.ConstructorType:
              default:
                _type = ts_estree_1.AST_NODE_TYPES.TSConstructorType;
                break;
            }

            var _result23 = this.createNode(node, {
              type: _type,
              params: this.convertParameters(node.parameters)
            });

            if (node.type) {
              _result23.returnType = this.convertTypeAnnotation(node.type, node);
            }

            if (node.typeParameters) {
              _result23.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }

            return _result23;
          }

        case SyntaxKind.ExpressionWithTypeArguments:
          {
            var _result24 = this.createNode(node, {
              type: parent && parent.kind === SyntaxKind.InterfaceDeclaration ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage : ts_estree_1.AST_NODE_TYPES.TSClassImplements,
              expression: this.convertChild(node.expression)
            });

            if (node.typeArguments) {
              _result24.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);
            }

            return _result24;
          }

        case SyntaxKind.InterfaceDeclaration:
          {
            var interfaceHeritageClauses = (_h = node.heritageClauses) !== null && _h !== void 0 ? _h : [];

            var _result25 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,
              body: this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,
                body: node.members.map(function (member) {
                  return _this7.convertChild(member);
                }),
                range: [node.members.pos - 1, node.end]
              }),
              id: this.convertChild(node.name)
            });

            if (node.typeParameters) {
              _result25.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }

            if (interfaceHeritageClauses.length > 0) {
              var interfaceExtends = [];
              var interfaceImplements = [];
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = interfaceHeritageClauses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var heritageClause = _step.value;

                  if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                      for (var _iterator2 = heritageClause.types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var n = _step2.value;
                        interfaceExtends.push(this.convertChild(n, node));
                      }
                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }
                  } else {
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                      for (var _iterator3 = heritageClause.types[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var _n2 = _step3.value;
                        interfaceImplements.push(this.convertChild(_n2, node));
                      }
                    } catch (err) {
                      _didIteratorError3 = true;
                      _iteratorError3 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                          _iterator3["return"]();
                        }
                      } finally {
                        if (_didIteratorError3) {
                          throw _iteratorError3;
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              if (interfaceExtends.length) {
                _result25["extends"] = interfaceExtends;
              }

              if (interfaceImplements.length) {
                _result25["implements"] = interfaceImplements;
              }
            }
            /**
             * Semantically, decorators are not allowed on interface declarations,
             * but the TypeScript compiler will parse them and produce a valid AST,
             * so we handle them here too.
             */


            if (node.decorators) {
              _result25.decorators = node.decorators.map(function (el) {
                return _this7.convertChild(el);
              });
            }

            if (node_utils_1.hasModifier(SyntaxKind.AbstractKeyword, node)) {
              _result25["abstract"] = true;
            }

            if (node_utils_1.hasModifier(SyntaxKind.DeclareKeyword, node)) {
              _result25.declare = true;
            } // check for exports


            return this.fixExports(node, _result25);
          }

        case SyntaxKind.TypePredicate:
          {
            var _result26 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,
              asserts: node.assertsModifier !== undefined,
              parameterName: this.convertChild(node.parameterName),
              typeAnnotation: null
            });
            /**
             * Specific fix for type-guard location data
             */


            if (node.type) {
              _result26.typeAnnotation = this.convertTypeAnnotation(node.type, node);
              _result26.typeAnnotation.loc = _result26.typeAnnotation.typeAnnotation.loc;
              _result26.typeAnnotation.range = _result26.typeAnnotation.typeAnnotation.range;
            }

            return _result26;
          }

        case SyntaxKind.ImportType:
          return this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.TSImportType,
            isTypeOf: !!node.isTypeOf,
            parameter: this.convertChild(node.argument),
            qualifier: this.convertChild(node.qualifier),
            typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null
          });

        case SyntaxKind.EnumDeclaration:
          {
            var _result27 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,
              id: this.convertChild(node.name),
              members: node.members.map(function (el) {
                return _this7.convertChild(el);
              })
            }); // apply modifiers first...


            this.applyModifiersToResult(_result27, node.modifiers);
            /**
             * Semantically, decorators are not allowed on enum declarations,
             * but the TypeScript compiler will parse them and produce a valid AST,
             * so we handle them here too.
             */

            if (node.decorators) {
              _result27.decorators = node.decorators.map(function (el) {
                return _this7.convertChild(el);
              });
            } // ...then check for exports


            return this.fixExports(node, _result27);
          }

        case SyntaxKind.EnumMember:
          {
            var _result28 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,
              id: this.convertChild(node.name)
            });

            if (node.initializer) {
              _result28.initializer = this.convertChild(node.initializer);
            }

            if (node.name.kind === ts.SyntaxKind.ComputedPropertyName) {
              _result28.computed = true;
            }

            return _result28;
          }

        case SyntaxKind.ModuleDeclaration:
          {
            var _result29 = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration,
              id: this.convertChild(node.name)
            });

            if (node.body) {
              _result29.body = this.convertChild(node.body);
            } // apply modifiers first...


            this.applyModifiersToResult(_result29, node.modifiers);

            if (node.flags & ts.NodeFlags.GlobalAugmentation) {
              _result29.global = true;
            } // ...then check for exports


            return this.fixExports(node, _result29);
          }
        // TypeScript specific types

        case SyntaxKind.OptionalType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,
              typeAnnotation: this.convertType(node.type)
            });
          }

        case SyntaxKind.ParenthesizedType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSParenthesizedType,
              typeAnnotation: this.convertType(node.type)
            });
          }

        case SyntaxKind.TupleType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTupleType,
              elementTypes: node.elementTypes.map(function (el) {
                return _this7.convertType(el);
              })
            });
          }

        case SyntaxKind.UnionType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSUnionType,
              types: node.types.map(function (el) {
                return _this7.convertType(el);
              })
            });
          }

        case SyntaxKind.IntersectionType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,
              types: node.types.map(function (el) {
                return _this7.convertType(el);
              })
            });
          }

        case SyntaxKind.RestType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSRestType,
              typeAnnotation: this.convertType(node.type)
            });
          }

        case SyntaxKind.AsExpression:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,
              expression: this.convertChild(node.expression),
              typeAnnotation: this.convertType(node.type)
            });
          }

        case SyntaxKind.InferType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSInferType,
              typeParameter: this.convertType(node.typeParameter)
            });
          }

        case SyntaxKind.LiteralType:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,
              literal: this.convertType(node.literal)
            });
          }

        case SyntaxKind.TypeAssertionExpression:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,
              typeAnnotation: this.convertType(node.type),
              expression: this.convertChild(node.expression)
            });
          }

        case SyntaxKind.ImportEqualsDeclaration:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,
              id: this.convertChild(node.name),
              moduleReference: this.convertChild(node.moduleReference),
              isExport: node_utils_1.hasModifier(SyntaxKind.ExportKeyword, node)
            });
          }

        case SyntaxKind.ExternalModuleReference:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,
              expression: this.convertChild(node.expression)
            });
          }

        case SyntaxKind.NamespaceExportDeclaration:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,
              id: this.convertChild(node.name)
            });
          }

        case SyntaxKind.AbstractKeyword:
          {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword
            });
          }

        default:
          return this.deeplyCopy(node);
      }
    }
  }]);

  return Converter;
}();

exports.Converter = Converter;