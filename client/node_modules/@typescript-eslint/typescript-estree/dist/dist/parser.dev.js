"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var debug_1 = __importDefault(require("debug"));

var glob_1 = require("glob");

var is_glob_1 = __importDefault(require("is-glob"));

var semver_1 = __importDefault(require("semver"));

var ts = __importStar(require("typescript"));

var ast_converter_1 = require("./ast-converter");

var convert_1 = require("./convert");

var createDefaultProgram_1 = require("./create-program/createDefaultProgram");

var createIsolatedProgram_1 = require("./create-program/createIsolatedProgram");

var createProjectProgram_1 = require("./create-program/createProjectProgram");

var createSourceFile_1 = require("./create-program/createSourceFile");

var semantic_or_syntactic_errors_1 = require("./semantic-or-syntactic-errors");

var shared_1 = require("./create-program/shared");

var log = debug_1["default"]('typescript-eslint:typescript-estree:parser');
/**
 * This needs to be kept in sync with the top-level README.md in the
 * typescript-eslint monorepo
 */

var SUPPORTED_TYPESCRIPT_VERSIONS = '>=3.2.1 <3.8.0';
/*
 * The semver package will ignore prerelease ranges, and we don't want to explicitly document every one
 * List them all separately here, so we can automatically create the full string
 */

var SUPPORTED_PRERELEASE_RANGES = ['>3.7.0-dev.0', '3.7.1-rc'];
var ACTIVE_TYPESCRIPT_VERSION = ts.version;
var isRunningSupportedTypeScriptVersion = semver_1["default"].satisfies(ACTIVE_TYPESCRIPT_VERSION, [SUPPORTED_TYPESCRIPT_VERSIONS].concat(SUPPORTED_PRERELEASE_RANGES).join(' || '));
var extra;
var warnedAboutTSVersion = false;

function enforceString(code) {
  /**
   * Ensure the source code is a string
   */
  if (typeof code !== 'string') {
    return String(code);
  }

  return code;
}
/**
 * @param code The code of the file being linted
 * @param shouldProvideParserServices True if the program should be attempted to be calculated from provided tsconfig files
 * @param shouldCreateDefaultProgram True if the program should be created from compiler host
 * @returns Returns a source file and program corresponding to the linted code
 */


function getProgramAndAST(code, shouldProvideParserServices, shouldCreateDefaultProgram) {
  return shouldProvideParserServices && createProjectProgram_1.createProjectProgram(code, shouldCreateDefaultProgram, extra) || shouldProvideParserServices && shouldCreateDefaultProgram && createDefaultProgram_1.createDefaultProgram(code, extra) || createIsolatedProgram_1.createIsolatedProgram(code, extra);
}
/**
 * Compute the filename based on the parser options.
 *
 * Even if jsx option is set in typescript compiler, filename still has to
 * contain .tsx file extension.
 *
 * @param options Parser options
 */


function getFileName() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      jsx = _ref.jsx;

  return jsx ? 'estree.tsx' : 'estree.ts';
}
/**
 * Resets the extra config object
 */


function resetExtra() {
  extra = {
    code: '',
    comment: false,
    comments: [],
    createDefaultProgram: false,
    debugLevel: new Set(),
    errorOnTypeScriptSyntacticAndSemanticIssues: false,
    errorOnUnknownASTType: false,
    extraFileExtensions: [],
    filePath: getFileName(),
    jsx: false,
    loc: false,
    log: console.log,
    preserveNodeMaps: undefined,
    projects: [],
    range: false,
    strict: false,
    tokens: null,
    tsconfigRootDir: process.cwd(),
    useJSXTextNode: false
  };
}
/**
 * Normalizes, sanitizes, resolves and filters the provided
 */


function prepareAndTransformProjects(projectsInput, ignoreListInput) {
  var projects = []; // Normalize and sanitize the project paths

  if (typeof projectsInput === 'string') {
    projects.push(projectsInput);
  } else if (Array.isArray(projectsInput)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = projectsInput[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var project = _step.value;

        if (typeof project === 'string') {
          projects.push(project);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (projects.length === 0) {
    return projects;
  } // Transform glob patterns into paths


  projects = projects.reduce(function (projects, project) {
    return projects.concat(is_glob_1["default"](project) ? glob_1.sync(project, {
      cwd: extra.tsconfigRootDir
    }) : project);
  }, []); // Normalize and sanitize the ignore regex list

  var ignoreRegexes = [];

  if (Array.isArray(ignoreListInput)) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = ignoreListInput[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var ignore = _step2.value;

        if (ignore instanceof RegExp) {
          ignoreRegexes.push(ignore);
        } else if (typeof ignore === 'string') {
          ignoreRegexes.push(new RegExp(ignore));
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } else {
    ignoreRegexes.push(/\/node_modules\//);
  } // Remove any paths that match the ignore list


  var filtered = projects.filter(function (project) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = ignoreRegexes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _ignore = _step3.value;

        if (_ignore.test(project)) {
          return false;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return true;
  });
  log('parserOptions.project matched projects: %s', projects);
  log('ignore list applied to parserOptions.project: %s', filtered);
  return filtered;
}

function applyParserOptionsToExtra(options) {
  /**
   * Configure Debug logging
   */
  if (options.debugLevel === true) {
    extra.debugLevel = new Set(['typescript-eslint']);
  } else if (Array.isArray(options.debugLevel)) {
    extra.debugLevel = new Set(options.debugLevel);
  }

  if (extra.debugLevel.size > 0) {
    // debug doesn't support multiple `enable` calls, so have to do it all at once
    var namespaces = [];

    if (extra.debugLevel.has('typescript-eslint')) {
      namespaces.push('typescript-eslint:*');
    }

    if (extra.debugLevel.has('eslint') || // make sure we don't turn off the eslint debug if it was enabled via --debug
    debug_1["default"].enabled('eslint:*')) {
      // https://github.com/eslint/eslint/blob/9dfc8501fb1956c90dc11e6377b4cb38a6bea65d/bin/eslint.js#L25
      namespaces.push('eslint:*,-eslint:code-path');
    }

    debug_1["default"].enable(namespaces.join(','));
  }
  /**
   * Track range information in the AST
   */


  extra.range = typeof options.range === 'boolean' && options.range;
  extra.loc = typeof options.loc === 'boolean' && options.loc;
  /**
   * Track tokens in the AST
   */

  if (typeof options.tokens === 'boolean' && options.tokens) {
    extra.tokens = [];
  }
  /**
   * Track comments in the AST
   */


  if (typeof options.comment === 'boolean' && options.comment) {
    extra.comment = true;
    extra.comments = [];
  }
  /**
   * Enable JSX - note the applicable file extension is still required
   */


  if (typeof options.jsx === 'boolean' && options.jsx) {
    extra.jsx = true;
  }
  /**
   * Get the file extension
   */


  if (typeof options.filePath === 'string' && options.filePath !== '<input>') {
    extra.filePath = options.filePath;
  } else {
    extra.filePath = getFileName(extra);
  }
  /**
   * The JSX AST changed the node type for string literals
   * inside a JSX Element from `Literal` to `JSXText`.
   *
   * When value is `true`, these nodes will be parsed as type `JSXText`.
   * When value is `false`, these nodes will be parsed as type `Literal`.
   */


  if (typeof options.useJSXTextNode === 'boolean' && options.useJSXTextNode) {
    extra.useJSXTextNode = true;
  }
  /**
   * Allow the user to cause the parser to error if it encounters an unknown AST Node Type
   * (used in testing)
   */


  if (typeof options.errorOnUnknownASTType === 'boolean' && options.errorOnUnknownASTType) {
    extra.errorOnUnknownASTType = true;
  }
  /**
   * Allow the user to override the function used for logging
   */


  if (typeof options.loggerFn === 'function') {
    extra.log = options.loggerFn;
  } else if (options.loggerFn === false) {
    extra.log = Function.prototype;
  }

  if (typeof options.tsconfigRootDir === 'string') {
    extra.tsconfigRootDir = options.tsconfigRootDir;
  } // NOTE - ensureAbsolutePath relies upon having the correct tsconfigRootDir in extra


  extra.filePath = shared_1.ensureAbsolutePath(extra.filePath, extra); // NOTE - prepareAndTransformProjects relies upon having the correct tsconfigRootDir in extra

  extra.projects = prepareAndTransformProjects(options.project, options.projectFolderIgnoreList);

  if (Array.isArray(options.extraFileExtensions) && options.extraFileExtensions.every(function (ext) {
    return typeof ext === 'string';
  })) {
    extra.extraFileExtensions = options.extraFileExtensions;
  }
  /**
   * Allow the user to enable or disable the preservation of the AST node maps
   * during the conversion process.
   *
   * NOTE: For backwards compatibility we also preserve node maps in the case where `project` is set,
   * and `preserveNodeMaps` is not explicitly set to anything.
   */


  extra.preserveNodeMaps = typeof options.preserveNodeMaps === 'boolean' && options.preserveNodeMaps;

  if (options.preserveNodeMaps === undefined && extra.projects.length > 0) {
    extra.preserveNodeMaps = true;
  }

  extra.createDefaultProgram = typeof options.createDefaultProgram === 'boolean' && options.createDefaultProgram;
}

function warnAboutTSVersion() {
  var _a;

  if (!isRunningSupportedTypeScriptVersion && !warnedAboutTSVersion) {
    var isTTY = (typeof process === "undefined" ? "undefined" : _typeof(process)) === undefined ? false : (_a = process.stdout) === null || _a === void 0 ? void 0 : _a.isTTY;

    if (isTTY) {
      var border = '=============';
      var versionWarning = [border, 'WARNING: You are currently running a version of TypeScript which is not officially supported by @typescript-eslint/typescript-estree.', 'You may find that it works just fine, or you may not.', "SUPPORTED TYPESCRIPT VERSIONS: ".concat(SUPPORTED_TYPESCRIPT_VERSIONS), "YOUR TYPESCRIPT VERSION: ".concat(ACTIVE_TYPESCRIPT_VERSION), 'Please only submit bug reports when using the officially supported version.', border];
      extra.log(versionWarning.join('\n\n'));
    }

    warnedAboutTSVersion = true;
  }
} //------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------


var version = require('../package.json').version;

exports.version = version;

function parse(code, options) {
  /**
   * Reset the parse configuration
   */
  resetExtra();
  /**
   * Ensure users do not attempt to use parse() when they need parseAndGenerateServices()
   */

  if (options === null || options === void 0 ? void 0 : options.errorOnTypeScriptSyntacticAndSemanticIssues) {
    throw new Error("\"errorOnTypeScriptSyntacticAndSemanticIssues\" is only supported for parseAndGenerateServices()");
  }
  /**
   * Ensure the source code is a string, and store a reference to it
   */


  code = enforceString(code);
  extra.code = code;
  /**
   * Apply the given parser options
   */

  if (typeof options !== 'undefined') {
    applyParserOptionsToExtra(options);
  }
  /**
   * Warn if the user is using an unsupported version of TypeScript
   */


  warnAboutTSVersion();
  /**
   * Create a ts.SourceFile directly, no ts.Program is needed for a simple
   * parse
   */

  var ast = createSourceFile_1.createSourceFile(code, extra);
  /**
   * Convert the TypeScript AST to an ESTree-compatible one
   */

  var _ast_converter_1$astC = ast_converter_1.astConverter(ast, extra, false),
      estree = _ast_converter_1$astC.estree;

  return estree;
}

exports.parse = parse;

function parseAndGenerateServices(code, options) {
  /**
   * Reset the parse configuration
   */
  resetExtra();
  /**
   * Ensure the source code is a string, and store a reference to it
   */

  code = enforceString(code);
  extra.code = code;
  /**
   * Apply the given parser options
   */

  if (typeof options !== 'undefined') {
    applyParserOptionsToExtra(options);

    if (typeof options.errorOnTypeScriptSyntacticAndSemanticIssues === 'boolean' && options.errorOnTypeScriptSyntacticAndSemanticIssues) {
      extra.errorOnTypeScriptSyntacticAndSemanticIssues = true;
    }
  }
  /**
   * Warn if the user is using an unsupported version of TypeScript
   */


  warnAboutTSVersion();
  /**
   * Generate a full ts.Program in order to be able to provide parser
   * services, such as type-checking
   */

  var shouldProvideParserServices = extra.projects && extra.projects.length > 0;

  var _getProgramAndAST = getProgramAndAST(code, shouldProvideParserServices, extra.createDefaultProgram),
      ast = _getProgramAndAST.ast,
      program = _getProgramAndAST.program;
  /**
   * Determine if two-way maps of converted AST nodes should be preserved
   * during the conversion process
   */


  var shouldPreserveNodeMaps = extra.preserveNodeMaps !== undefined ? extra.preserveNodeMaps : shouldProvideParserServices;
  /**
   * Convert the TypeScript AST to an ESTree-compatible one, and optionally preserve
   * mappings between converted and original AST nodes
   */

  var _ast_converter_1$astC2 = ast_converter_1.astConverter(ast, extra, shouldPreserveNodeMaps),
      estree = _ast_converter_1$astC2.estree,
      astMaps = _ast_converter_1$astC2.astMaps;
  /**
   * Even if TypeScript parsed the source code ok, and we had no problems converting the AST,
   * there may be other syntactic or semantic issues in the code that we can optionally report on.
   */


  if (program && extra.errorOnTypeScriptSyntacticAndSemanticIssues) {
    var error = semantic_or_syntactic_errors_1.getFirstSemanticOrSyntacticError(program, ast);

    if (error) {
      throw convert_1.convertError(error);
    }
  }
  /**
   * Return the converted AST and additional parser services
   */


  return {
    ast: estree,
    services: {
      program: shouldProvideParserServices ? program : undefined,
      esTreeNodeToTSNodeMap: shouldPreserveNodeMaps && astMaps ? astMaps.esTreeNodeToTSNodeMap : undefined,
      tsNodeToESTreeNodeMap: shouldPreserveNodeMaps && astMaps ? astMaps.tsNodeToESTreeNodeMap : undefined
    }
  };
}

exports.parseAndGenerateServices = parseAndGenerateServices;

var simple_traverse_1 = require("./simple-traverse");

exports.simpleTraverse = simple_traverse_1.simpleTraverse;

var visitor_keys_1 = require("./visitor-keys");

exports.visitorKeys = visitor_keys_1.visitorKeys;

__export(require("./ts-estree"));

var createWatchProgram_1 = require("./create-program/createWatchProgram");

exports.clearCaches = createWatchProgram_1.clearCaches;