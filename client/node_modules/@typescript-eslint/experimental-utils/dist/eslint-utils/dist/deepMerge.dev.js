"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Check if the variable contains an object strictly rejecting arrays
 * @param obj an object
 * @returns `true` if obj is an object
 */

function isObjectNotArray(obj) {
  return _typeof(obj) === 'object' && !Array.isArray(obj);
}

exports.isObjectNotArray = isObjectNotArray;
/**
 * Pure function - doesn't mutate either parameter!
 * Merges two objects together deeply, overwriting the properties in first with the properties in second
 * @param first The first object
 * @param second The second object
 * @returns a new object
 */

function deepMerge() {
  var first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // get the unique set of keys across both objects
  var keys = new Set(Object.keys(first).concat(Object.keys(second)));
  return Array.from(keys).reduce(function (acc, key) {
    var firstHasKey = key in first;
    var secondHasKey = key in second;
    var firstValue = first[key];
    var secondValue = second[key];

    if (firstHasKey && secondHasKey) {
      if (isObjectNotArray(firstValue) && isObjectNotArray(secondValue)) {
        // object type
        acc[key] = deepMerge(firstValue, secondValue);
      } else {
        // value type
        acc[key] = secondValue;
      }
    } else if (firstHasKey) {
      acc[key] = firstValue;
    } else {
      acc[key] = secondValue;
    }

    return acc;
  }, {});
}

exports.deepMerge = deepMerge;