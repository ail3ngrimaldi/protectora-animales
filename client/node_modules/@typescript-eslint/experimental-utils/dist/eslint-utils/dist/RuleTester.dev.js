"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var TSESLint = __importStar(require("../ts-eslint"));

var path = __importStar(require("path"));

var parser = '@typescript-eslint/parser';

var RuleTester =
/*#__PURE__*/
function (_TSESLint$RuleTester) {
  _inherits(RuleTester, _TSESLint$RuleTester);

  // as of eslint 6 you have to provide an absolute path to the parser
  // but that's not as clean to type, this saves us trying to manually enforce
  // that contributors require.resolve everything
  function RuleTester(options) {
    var _this;

    _classCallCheck(this, RuleTester);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RuleTester).call(this, Object.assign(Object.assign({}, options), {
      parser: require.resolve(options.parser)
    })));
    _this.options = options; // make sure that the parser doesn't hold onto file handles between tests
    // on linux (i.e. our CI env), there can be very a limited number of watch handles available

    afterAll(function () {
      try {
        // instead of creating a hard dependency, just use a soft require
        // a bit weird, but if they're using this tooling, it'll be installed
        require(parser).clearCaches();
      } catch (_a) {// ignored
      }
    });
    return _this;
  }

  _createClass(RuleTester, [{
    key: "getFilename",
    value: function getFilename(options) {
      if (options) {
        var filename = "file.ts".concat(options.ecmaFeatures && options.ecmaFeatures.jsx ? 'x' : '');

        if (options.project) {
          return path.join(options.tsconfigRootDir != null ? options.tsconfigRootDir : process.cwd(), filename);
        }

        return filename;
      } else if (this.options.parserOptions) {
        return this.getFilename(this.options.parserOptions);
      }

      return 'file.ts';
    } // as of eslint 6 you have to provide an absolute path to the parser
    // If you don't do that at the test level, the test will fail somewhat cryptically...
    // This is a lot more explicit

  }, {
    key: "run",
    value: function run(name, rule, tests) {
      var _this2 = this;

      var errorMessage = "Do not set the parser at the test level unless you want to use a parser other than ".concat(parser); // standardize the valid tests as objects

      tests.valid = tests.valid.map(function (test) {
        if (typeof test === 'string') {
          return {
            code: test
          };
        }

        return test;
      });
      tests.valid.forEach(function (test) {
        if (typeof test !== 'string') {
          if (test.parser === parser) {
            throw new Error(errorMessage);
          }

          if (!test.filename) {
            test.filename = _this2.getFilename(test.parserOptions);
          }
        }
      });
      tests.invalid.forEach(function (test) {
        if (test.parser === parser) {
          throw new Error(errorMessage);
        }

        if (!test.filename) {
          test.filename = _this2.getFilename(test.parserOptions);
        }
      });

      _get(_getPrototypeOf(RuleTester.prototype), "run", this).call(this, name, rule, tests);
    }
  }]);

  return RuleTester;
}(TSESLint.RuleTester);

exports.RuleTester = RuleTester;
/**
 * Simple no-op tag to mark code samples as "should not format with prettier"
 *   for the internal/plugin-test-formatting lint rule
 */

function noFormat(strings) {
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  var lastIndex = strings.length - 1;
  return strings.slice(0, lastIndex).reduce(function (p, s, i) {
    return p + s + keys[i];
  }, '') + strings[lastIndex];
}

exports.noFormat = noFormat;