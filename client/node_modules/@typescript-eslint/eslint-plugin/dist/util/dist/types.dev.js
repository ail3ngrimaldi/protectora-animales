"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tsutils_1 = require("tsutils");

var ts = __importStar(require("typescript"));
/**
 * Checks if the given type is either an array type,
 * or a union made up solely of array types.
 */


function isTypeArrayTypeOrUnionOfArrayTypes(type, checker) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tsutils_1.unionTypeParts(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var t = _step.value;

      if (!checker.isArrayType(t)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return true;
}

exports.isTypeArrayTypeOrUnionOfArrayTypes = isTypeArrayTypeOrUnionOfArrayTypes;
/**
 * @param type Type being checked by name.
 * @param allowedNames Symbol names checking on the type.
 * @returns Whether the type is, extends, or contains all of the allowed names.
 */

function containsAllTypesByName(type, allowAny, allowedNames) {
  if (isTypeFlagSet(type, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
    return !allowAny;
  }

  if (tsutils_1.isTypeReference(type)) {
    type = type.target;
  }

  var symbol = type.getSymbol();

  if (symbol && allowedNames.has(symbol.name)) {
    return true;
  }

  if (tsutils_1.isUnionOrIntersectionType(type)) {
    return type.types.every(function (t) {
      return containsAllTypesByName(t, allowAny, allowedNames);
    });
  }

  var bases = type.getBaseTypes();
  return typeof bases !== 'undefined' && bases.length > 0 && bases.every(function (t) {
    return containsAllTypesByName(t, allowAny, allowedNames);
  });
}

exports.containsAllTypesByName = containsAllTypesByName;
/**
 * Get the type name of a given type.
 * @param typeChecker The context sensitive TypeScript TypeChecker.
 * @param type The type to get the name of.
 */

function getTypeName(typeChecker, type) {
  // It handles `string` and string literal types as string.
  if ((type.flags & ts.TypeFlags.StringLike) !== 0) {
    return 'string';
  } // If the type is a type parameter which extends primitive string types,
  // but it was not recognized as a string like. So check the constraint
  // type of the type parameter.


  if ((type.flags & ts.TypeFlags.TypeParameter) !== 0) {
    // `type.getConstraint()` method doesn't return the constraint type of
    // the type parameter for some reason. So this gets the constraint type
    // via AST.
    var symbol = type.getSymbol();
    var decls = symbol === null || symbol === void 0 ? void 0 : symbol.getDeclarations();
    var typeParamDecl = decls === null || decls === void 0 ? void 0 : decls[0];

    if (ts.isTypeParameterDeclaration(typeParamDecl) && typeParamDecl.constraint != null) {
      return getTypeName(typeChecker, typeChecker.getTypeFromTypeNode(typeParamDecl.constraint));
    }
  } // If the type is a union and all types in the union are string like,
  // return `string`. For example:
  // - `"a" | "b"` is string.
  // - `string | string[]` is not string.


  if (type.isUnion() && type.types.map(function (value) {
    return getTypeName(typeChecker, value);
  }).every(function (t) {
    return t === 'string';
  })) {
    return 'string';
  } // If the type is an intersection and a type in the intersection is string
  // like, return `string`. For example: `string & {__htmlEscaped: void}`


  if (type.isIntersection() && type.types.map(function (value) {
    return getTypeName(typeChecker, value);
  }).some(function (t) {
    return t === 'string';
  })) {
    return 'string';
  }

  return typeChecker.typeToString(type);
}

exports.getTypeName = getTypeName;
/**
 * Resolves the given node's type. Will resolve to the type's generic constraint, if it has one.
 */

function getConstrainedTypeAtLocation(checker, node) {
  var nodeType = checker.getTypeAtLocation(node);
  var constrained = checker.getBaseConstraintOfType(nodeType);
  return constrained !== null && constrained !== void 0 ? constrained : nodeType;
}

exports.getConstrainedTypeAtLocation = getConstrainedTypeAtLocation;
/**
 * Checks if the given type is (or accepts) nullable
 * @param isReceiver true if the type is a receiving type (i.e. the type of a called function's parameter)
 */

function isNullableType(type) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$isReceiver = _ref.isReceiver,
      isReceiver = _ref$isReceiver === void 0 ? false : _ref$isReceiver,
      _ref$allowUndefined = _ref.allowUndefined,
      allowUndefined = _ref$allowUndefined === void 0 ? true : _ref$allowUndefined;

  var flags = getTypeFlags(type);

  if (isReceiver && flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
    return true;
  }

  if (allowUndefined) {
    return (flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) !== 0;
  } else {
    return (flags & ts.TypeFlags.Null) !== 0;
  }
}

exports.isNullableType = isNullableType;
/**
 * Gets the declaration for the given variable
 */

function getDeclaration(checker, node) {
  var _a;

  var symbol = checker.getSymbolAtLocation(node);

  if (!symbol) {
    return null;
  }

  var declarations = symbol.getDeclarations();
  return (_a = declarations === null || declarations === void 0 ? void 0 : declarations[0]) !== null && _a !== void 0 ? _a : null;
}

exports.getDeclaration = getDeclaration;
/**
 * Gets all of the type flags in a type, iterating through unions automatically
 */

function getTypeFlags(type) {
  var flags = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = tsutils_1.unionTypeParts(type)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var t = _step2.value;
      flags |= t.flags;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return flags;
}

exports.getTypeFlags = getTypeFlags;
/**
 * Checks if the given type is (or accepts) the given flags
 * @param isReceiver true if the type is a receiving type (i.e. the type of a called function's parameter)
 */

function isTypeFlagSet(type, flagsToCheck, isReceiver) {
  var flags = getTypeFlags(type);

  if (isReceiver && flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {
    return true;
  }

  return (flags & flagsToCheck) !== 0;
}

exports.isTypeFlagSet = isTypeFlagSet;
/**
 * @returns Whether a type is an instance of the parent type, including for the parent's base types.
 */

function typeIsOrHasBaseType(type, parentType) {
  var parentSymbol = parentType.getSymbol();

  if (!type.getSymbol() || !parentSymbol) {
    return false;
  }

  var typeAndBaseTypes = [type];
  var ancestorTypes = type.getBaseTypes();

  if (ancestorTypes) {
    typeAndBaseTypes.push.apply(typeAndBaseTypes, _toConsumableArray(ancestorTypes));
  }

  for (var _i = 0, _typeAndBaseTypes = typeAndBaseTypes; _i < _typeAndBaseTypes.length; _i++) {
    var baseType = _typeAndBaseTypes[_i];
    var baseSymbol = baseType.getSymbol();

    if (baseSymbol && baseSymbol.name === parentSymbol.name) {
      return true;
    }
  }

  return false;
}

exports.typeIsOrHasBaseType = typeIsOrHasBaseType;
/**
 * Gets the source file for a given node
 */

function getSourceFileOfNode(node) {
  while (node && node.kind !== ts.SyntaxKind.SourceFile) {
    node = node.parent;
  }

  return node;
}

exports.getSourceFileOfNode = getSourceFileOfNode;

function getTokenAtPosition(sourceFile, position) {
  var queue = [sourceFile];
  var current;

  while (queue.length > 0) {
    current = queue.shift(); // find the child that contains 'position'

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = current.getChildren(sourceFile)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var child = _step3.value;
        var start = child.getFullStart();

        if (start > position) {
          // If this child begins after position, then all subsequent children will as well.
          return current;
        }

        var end = child.getEnd();

        if (position < end || position === end && child.kind === ts.SyntaxKind.EndOfFileToken) {
          queue.push(child);
          break;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  return current;
}

exports.getTokenAtPosition = getTokenAtPosition;

function getEqualsKind(operator) {
  switch (operator) {
    case '==':
      return {
        isPositive: true,
        isStrict: false
      };

    case '===':
      return {
        isPositive: true,
        isStrict: true
      };

    case '!=':
      return {
        isPositive: false,
        isStrict: false
      };

    case '!==':
      return {
        isPositive: true,
        isStrict: true
      };

    default:
      return undefined;
  }
}

exports.getEqualsKind = getEqualsKind;

function getTypeArguments(type, checker) {
  var _a; // getTypeArguments was only added in TS3.7


  if (checker.getTypeArguments) {
    return checker.getTypeArguments(type);
  }

  return (_a = type.typeArguments) !== null && _a !== void 0 ? _a : [];
}

exports.getTypeArguments = getTypeArguments;
/**
 * @returns true if the type is `any`
 */

function isTypeAnyType(type) {
  return isTypeFlagSet(type, ts.TypeFlags.Any);
}

exports.isTypeAnyType = isTypeAnyType;
/**
 * @returns true if the type is `any[]`
 */

function isTypeAnyArrayType(type, checker) {
  return checker.isArrayType(type) && isTypeAnyType( // getTypeArguments was only added in TS3.7
  getTypeArguments(type, checker)[0]);
}

exports.isTypeAnyArrayType = isTypeAnyArrayType;
/**
 * @returns `AnyType.Any` if the type is `any`, `AnyType.AnyArray` if the type is `any[]` or `readonly any[]`,
 *          otherwise it returns `AnyType.Safe`.
 */

function isAnyOrAnyArrayTypeDiscriminated(node, checker) {
  var type = checker.getTypeAtLocation(node);

  if (isTypeAnyType(type)) {
    return 0
    /* Any */
    ;
  }

  if (isTypeAnyArrayType(type, checker)) {
    return 1
    /* AnyArray */
    ;
  }

  return 2
  /* Safe */
  ;
}

exports.isAnyOrAnyArrayTypeDiscriminated = isAnyOrAnyArrayTypeDiscriminated;
/**
 * Does a simple check to see if there is an any being assigned to a non-any type.
 *
 * This also checks generic positions to ensure there's no unsafe sub-assignments.
 * Note: in the case of generic positions, it makes the assumption that the two types are the same.
 *
 * @example See tests for examples
 *
 * @returns false if it's safe, or an object with the two types if it's unsafe
 */

function isUnsafeAssignment(type, receiver, checker) {
  var _a, _b;

  if (isTypeAnyType(type) && !isTypeAnyType(receiver)) {
    return {
      sender: type,
      receiver: receiver
    };
  }

  if (tsutils_1.isTypeReference(type) && tsutils_1.isTypeReference(receiver)) {
    // TODO - figure out how to handle cases like this,
    // where the types are assignable, but not the same type

    /*
    function foo(): ReadonlySet<number> { return new Set<any>(); }
         // and
         type Test<T> = { prop: T }
    type Test2 = { prop: string }
    declare const a: Test<any>;
    const b: Test2 = a;
    */
    if (type.target !== receiver.target) {
      // if the type references are different, assume safe, as we won't know how to compare the two types
      // the generic positions might not be equivalent for both types
      return false;
    }

    var typeArguments = (_a = type.typeArguments) !== null && _a !== void 0 ? _a : [];
    var receiverTypeArguments = (_b = receiver.typeArguments) !== null && _b !== void 0 ? _b : [];

    for (var i = 0; i < typeArguments.length; i += 1) {
      var arg = typeArguments[i];
      var receiverArg = receiverTypeArguments[i];
      var unsafe = isUnsafeAssignment(arg, receiverArg, checker);

      if (unsafe) {
        return {
          sender: type,
          receiver: receiver
        };
      }
    }

    return false;
  }

  return false;
}

exports.isUnsafeAssignment = isUnsafeAssignment;
/**
 * Returns the contextual type of a given node.
 * Contextual type is the type of the target the node is going into.
 * i.e. the type of a called function's parameter, or the defined type of a variable declaration
 */

function getContextualType(checker, node) {
  var parent = node.parent;

  if (!parent) {
    return;
  }

  if (tsutils_1.isCallExpression(parent) || tsutils_1.isNewExpression(parent)) {
    if (node === parent.expression) {
      // is the callee, so has no contextual type
      return;
    }
  } else if (tsutils_1.isVariableDeclaration(parent) || tsutils_1.isPropertyDeclaration(parent) || tsutils_1.isParameterDeclaration(parent)) {
    return parent.type ? checker.getTypeFromTypeNode(parent.type) : undefined;
  } else if (tsutils_1.isJsxExpression(parent)) {
    return checker.getContextualType(parent);
  } else if (tsutils_1.isPropertyAssignment(parent) && tsutils_1.isIdentifier(node)) {
    return checker.getContextualType(node);
  } else if (![ts.SyntaxKind.TemplateSpan, ts.SyntaxKind.JsxExpression].includes(parent.kind)) {
    // parent is not something we know we can get the contextual type of
    return;
  } // TODO - support return statement checking


  return checker.getContextualType(node);
}

exports.getContextualType = getContextualType;