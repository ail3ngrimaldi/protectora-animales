"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tsutils_1 = require("tsutils");

var ts = __importStar(require("typescript"));

var _1 = require(".");

function isTypeReadonlyArrayOrTuple(checker, type, seenTypes) {
  function checkTypeArguments(arrayType) {
    var typeArguments = checker.getTypeArguments(arrayType); // this shouldn't happen in reality as:
    // - tuples require at least 1 type argument
    // - ReadonlyArray requires at least 1 type argument

    /* istanbul ignore if */

    if (typeArguments.length === 0) {
      return 3
      /* Readonly */
      ;
    } // validate the element types are also readonly


    if (typeArguments.some(function (typeArg) {
      return isTypeReadonlyRecurser(checker, typeArg, seenTypes) === 2;
    }
    /* Mutable */
    )) {
      return 2
      /* Mutable */
      ;
    }

    return 3
    /* Readonly */
    ;
  }

  if (checker.isArrayType(type)) {
    var symbol = _1.nullThrows(type.getSymbol(), _1.NullThrowsReasons.MissingToken('symbol', 'array type'));

    var escapedName = symbol.getEscapedName();

    if (escapedName === 'Array') {
      return 2
      /* Mutable */
      ;
    }

    return checkTypeArguments(type);
  }

  if (checker.isTupleType(type)) {
    if (!type.target.readonly) {
      return 2
      /* Mutable */
      ;
    }

    return checkTypeArguments(type);
  }

  return 1
  /* UnknownType */
  ;
}

function isTypeReadonlyObject(checker, type, seenTypes) {
  function checkIndexSignature(kind) {
    var indexInfo = checker.getIndexInfoOfType(type, kind);

    if (indexInfo) {
      return indexInfo.isReadonly ? 3
      /* Readonly */
      : 2
      /* Mutable */
      ;
    }

    return 1
    /* UnknownType */
    ;
  }

  var properties = type.getProperties();

  if (properties.length) {
    // ensure the properties are marked as readonly
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var property = _step.value;

        if (!tsutils_1.isPropertyReadonlyInType(type, property.getEscapedName(), checker)) {
          return 2
          /* Mutable */
          ;
        }
      } // all properties were readonly
      // now ensure that all of the values are readonly also.
      // do this after checking property readonly-ness as a perf optimization,
      // as we might be able to bail out early due to a mutable property before
      // doing this deep, potentially expensive check.

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _property = _step2.value;

        var propertyType = _1.nullThrows(checker.getTypeOfPropertyOfType(type, _property.getName()), _1.NullThrowsReasons.MissingToken("property \"".concat(_property.name, "\""), 'type')); // handle recursive types.
        // we only need this simple check, because a mutable recursive type will break via the above prop readonly check


        if (seenTypes.has(propertyType)) {
          continue;
        }

        if (isTypeReadonlyRecurser(checker, propertyType, seenTypes) === 2
        /* Mutable */
        ) {
            return 2
            /* Mutable */
            ;
          }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var isStringIndexSigReadonly = checkIndexSignature(ts.IndexKind.String);

  if (isStringIndexSigReadonly === 2
  /* Mutable */
  ) {
      return isStringIndexSigReadonly;
    }

  var isNumberIndexSigReadonly = checkIndexSignature(ts.IndexKind.Number);

  if (isNumberIndexSigReadonly === 2
  /* Mutable */
  ) {
      return isNumberIndexSigReadonly;
    }

  return 3
  /* Readonly */
  ;
} // a helper function to ensure the seenTypes map is always passed down, except by the external caller


function isTypeReadonlyRecurser(checker, type, seenTypes) {
  seenTypes.add(type);

  if (tsutils_1.isUnionType(type)) {
    // all types in the union must be readonly
    var result = tsutils_1.unionTypeParts(type).every(function (t) {
      return isTypeReadonlyRecurser(checker, t, seenTypes);
    });
    var readonlyness = result ? 3
    /* Readonly */
    : 2
    /* Mutable */
    ;
    return readonlyness;
  } // all non-object, non-intersection types are readonly.
  // this should only be primitive types


  if (!tsutils_1.isObjectType(type) && !tsutils_1.isUnionOrIntersectionType(type)) {
    return 3
    /* Readonly */
    ;
  } // pure function types are readonly


  if (type.getCallSignatures().length > 0 && type.getProperties().length === 0) {
    return 3
    /* Readonly */
    ;
  }

  var isReadonlyArray = isTypeReadonlyArrayOrTuple(checker, type, seenTypes);

  if (isReadonlyArray !== 1
  /* UnknownType */
  ) {
      return isReadonlyArray;
    }

  var isReadonlyObject = isTypeReadonlyObject(checker, type, seenTypes);
  /* istanbul ignore else */

  if (isReadonlyObject !== 1
  /* UnknownType */
  ) {
      return isReadonlyObject;
    }

  throw new Error('Unhandled type');
}
/**
 * Checks if the given type is readonly
 */


function isTypeReadonly(checker, type) {
  return isTypeReadonlyRecurser(checker, type, new Set()) === 3
  /* Readonly */
  ;
}

exports.isTypeReadonly = isTypeReadonly;