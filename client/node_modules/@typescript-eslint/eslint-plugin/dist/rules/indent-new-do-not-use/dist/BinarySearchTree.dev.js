"use strict"; // The following code is adapted from the the code in eslint.
// License: https://github.com/eslint/eslint/blob/48700fc8408f394887cdedd071b22b757700fdcb/LICENSE

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var functional_red_black_tree_1 = __importDefault(require("functional-red-black-tree"));
/**
 * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.
 * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation
 * can easily be swapped out.
 */


var BinarySearchTree =
/*#__PURE__*/
function () {
  function BinarySearchTree() {
    _classCallCheck(this, BinarySearchTree);

    this.rbTree = functional_red_black_tree_1["default"]();
  }
  /**
   * Inserts an entry into the tree.
   */


  _createClass(BinarySearchTree, [{
    key: "insert",
    value: function insert(key, value) {
      var iterator = this.rbTree.find(key);

      if (iterator.valid) {
        this.rbTree = iterator.update(value);
      } else {
        this.rbTree = this.rbTree.insert(key, value);
      }
    }
    /**
     * Finds the entry with the largest key less than or equal to the provided key
     * @returns The found entry, or null if no such entry exists.
     */

  }, {
    key: "findLe",
    value: function findLe(key) {
      var iterator = this.rbTree.le(key);
      return {
        key: iterator.key,
        value: iterator.value
      };
    }
    /**
     * Deletes all of the keys in the interval [start, end)
     */

  }, {
    key: "deleteRange",
    value: function deleteRange(start, end) {
      // Exit without traversing the tree if the range has zero size.
      if (start === end) {
        return;
      }

      var iterator = this.rbTree.ge(start);

      while (iterator.valid && iterator.key < end) {
        this.rbTree = this.rbTree.remove(iterator.key);
        iterator.next();
      }
    }
  }]);

  return BinarySearchTree;
}();

exports.BinarySearchTree = BinarySearchTree;