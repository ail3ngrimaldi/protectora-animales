"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var ts = __importStar(require("typescript"));

var util = __importStar(require("../util"));

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

exports["default"] = util.createRule({
  name: 'no-throw-literal',
  meta: {
    type: 'problem',
    docs: {
      description: 'Disallow throwing literals as exceptions',
      category: 'Best Practices',
      recommended: false,
      requiresTypeChecking: true
    },
    schema: [],
    messages: {
      object: 'Expected an error object to be thrown.',
      undef: 'Do not throw undefined.'
    }
  },
  defaultOptions: [],
  create: function create(context) {
    var parserServices = util.getParserServices(context);
    var program = parserServices.program;
    var checker = program.getTypeChecker();

    function isErrorLike(type) {
      var _a;

      var symbol = type.getSymbol();

      if (!symbol) {
        return false;
      }

      if (symbol.getName() === 'Error') {
        var declarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var declaration = _step.value;
            var sourceFile = declaration.getSourceFile();

            if (program.isSourceFileDefaultLibrary(sourceFile)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (symbol.flags & (ts.SymbolFlags.Class | ts.SymbolFlags.Interface)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = checker.getBaseTypes(type)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var baseType = _step2.value;

            if (isErrorLike(baseType)) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return false;
    }

    function tryGetThrowArgumentType(node) {
      switch (node.type) {
        case experimental_utils_1.AST_NODE_TYPES.Identifier:
        case experimental_utils_1.AST_NODE_TYPES.CallExpression:
        case experimental_utils_1.AST_NODE_TYPES.NewExpression:
        case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
          {
            var tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
            return checker.getTypeAtLocation(tsNode);
          }

        case experimental_utils_1.AST_NODE_TYPES.AssignmentExpression:
          return tryGetThrowArgumentType(node.right);

        case experimental_utils_1.AST_NODE_TYPES.SequenceExpression:
          return tryGetThrowArgumentType(node.expressions[node.expressions.length - 1]);

        case experimental_utils_1.AST_NODE_TYPES.LogicalExpression:
          {
            var left = tryGetThrowArgumentType(node.left);
            return left !== null && left !== void 0 ? left : tryGetThrowArgumentType(node.right);
          }

        case experimental_utils_1.AST_NODE_TYPES.ConditionalExpression:
          {
            var consequent = tryGetThrowArgumentType(node.consequent);
            return consequent !== null && consequent !== void 0 ? consequent : tryGetThrowArgumentType(node.alternate);
          }

        default:
          return null;
      }
    }

    function checkThrowArgument(node) {
      if (node.type === experimental_utils_1.AST_NODE_TYPES.AwaitExpression || node.type === experimental_utils_1.AST_NODE_TYPES.YieldExpression) {
        return;
      }

      var type = tryGetThrowArgumentType(node);

      if (type) {
        if (type.flags & ts.TypeFlags.Undefined) {
          context.report({
            node: node,
            messageId: 'undef'
          });
          return;
        }

        if (type.flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown) || isErrorLike(type)) {
          return;
        }
      }

      context.report({
        node: node,
        messageId: 'object'
      });
    }

    return {
      ThrowStatement: function ThrowStatement(node) {
        if (node.argument) {
          checkThrowArgument(node.argument);
        }
      }
    };
  }
});