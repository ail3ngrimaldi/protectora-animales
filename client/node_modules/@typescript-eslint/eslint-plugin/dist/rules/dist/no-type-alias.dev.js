"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

var enumValues = ['always', 'never', 'in-unions', 'in-intersections', 'in-unions-and-intersections'];
exports["default"] = util.createRule({
  name: 'no-type-alias',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Disallow the use of type aliases',
      category: 'Stylistic Issues',
      // too opinionated to be recommended
      recommended: false
    },
    messages: {
      noTypeAlias: 'Type {{alias}} are not allowed.',
      noCompositionAlias: '{{typeName}} in {{compositionType}} types are not allowed.'
    },
    schema: [{
      type: 'object',
      properties: {
        allowAliases: {
          "enum": enumValues
        },
        allowCallbacks: {
          "enum": ['always', 'never']
        },
        allowConditionalTypes: {
          "enum": ['always', 'never']
        },
        allowConstructors: {
          "enum": ['always', 'never']
        },
        allowLiterals: {
          "enum": enumValues
        },
        allowMappedTypes: {
          "enum": enumValues
        },
        allowTupleTypes: {
          "enum": enumValues
        }
      },
      additionalProperties: false
    }]
  },
  defaultOptions: [{
    allowAliases: 'never',
    allowCallbacks: 'never',
    allowConditionalTypes: 'never',
    allowConstructors: 'never',
    allowLiterals: 'never',
    allowMappedTypes: 'never',
    allowTupleTypes: 'never'
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        _ref2$ = _ref2[0],
        allowAliases = _ref2$.allowAliases,
        allowCallbacks = _ref2$.allowCallbacks,
        allowConditionalTypes = _ref2$.allowConditionalTypes,
        allowConstructors = _ref2$.allowConstructors,
        allowLiterals = _ref2$.allowLiterals,
        allowMappedTypes = _ref2$.allowMappedTypes,
        allowTupleTypes = _ref2$.allowTupleTypes;

    var unions = ['always', 'in-unions', 'in-unions-and-intersections'];
    var intersections = ['always', 'in-intersections', 'in-unions-and-intersections'];
    var compositions = ['in-unions', 'in-intersections', 'in-unions-and-intersections'];
    var aliasTypes = new Set([experimental_utils_1.AST_NODE_TYPES.TSArrayType, experimental_utils_1.AST_NODE_TYPES.TSTypeReference, experimental_utils_1.AST_NODE_TYPES.TSLiteralType, experimental_utils_1.AST_NODE_TYPES.TSTypeQuery, experimental_utils_1.AST_NODE_TYPES.TSIndexedAccessType]);
    /**
     * Determines if the composition type is supported by the allowed flags.
     * @param isTopLevel a flag indicating this is the top level node.
     * @param compositionType the composition type (either TSUnionType or TSIntersectionType)
     * @param allowed the currently allowed flags.
     */

    function isSupportedComposition(isTopLevel, compositionType, allowed) {
      return !compositions.includes(allowed) || !isTopLevel && (compositionType === experimental_utils_1.AST_NODE_TYPES.TSUnionType && unions.includes(allowed) || compositionType === experimental_utils_1.AST_NODE_TYPES.TSIntersectionType && intersections.includes(allowed));
    }
    /**
     * Gets the message to be displayed based on the node type and whether the node is a top level declaration.
     * @param node the location
     * @param compositionType the type of composition this alias is part of (undefined if not
     *                                  part of a composition)
     * @param isRoot a flag indicating we are dealing with the top level declaration.
     * @param type the kind of type alias being validated.
     */


    function reportError(node, compositionType, isRoot, type) {
      if (isRoot) {
        return context.report({
          node: node,
          messageId: 'noTypeAlias',
          data: {
            alias: type.toLowerCase()
          }
        });
      }

      return context.report({
        node: node,
        messageId: 'noCompositionAlias',
        data: {
          compositionType: compositionType === experimental_utils_1.AST_NODE_TYPES.TSUnionType ? 'union' : 'intersection',
          typeName: type
        }
      });
    }

    var isValidTupleType = function isValidTupleType(type) {
      if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSTupleType) {
        return true;
      }

      if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSTypeOperator) {
        if (['keyof', 'readonly'].includes(type.node.operator) && type.node.typeAnnotation && type.node.typeAnnotation.type === experimental_utils_1.AST_NODE_TYPES.TSTupleType) {
          return true;
        }
      }

      return false;
    };

    var checkAndReport = function checkAndReport(optionValue, isTopLevel, type, label) {
      if (optionValue === 'never' || !isSupportedComposition(isTopLevel, type.compositionType, optionValue)) {
        reportError(type.node, type.compositionType, isTopLevel, label);
      }
    };
    /**
     * Validates the node looking for aliases, callbacks and literals.
     * @param type the type of composition this alias is part of (null if not
     *                                  part of a composition)
     * @param isTopLevel a flag indicating this is the top level node.
     */


    function validateTypeAliases(type) {
      var isTopLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSFunctionType) {
        // callback
        if (allowCallbacks === 'never') {
          reportError(type.node, type.compositionType, isTopLevel, 'Callbacks');
        }
      } else if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSConditionalType) {
        // conditional type
        if (allowConditionalTypes === 'never') {
          reportError(type.node, type.compositionType, isTopLevel, 'Conditional types');
        }
      } else if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSConstructorType) {
        if (allowConstructors === 'never') {
          reportError(type.node, type.compositionType, isTopLevel, 'Constructors');
        }
      } else if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSTypeLiteral) {
        // literal object type
        checkAndReport(allowLiterals, isTopLevel, type, 'Literals');
      } else if (type.node.type === experimental_utils_1.AST_NODE_TYPES.TSMappedType) {
        // mapped type
        checkAndReport(allowMappedTypes, isTopLevel, type, 'Mapped types');
      } else if (isValidTupleType(type)) {
        // tuple types
        checkAndReport(allowTupleTypes, isTopLevel, type, 'Tuple Types');
      } else if ( // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
      type.node.type.endsWith('Keyword') || aliasTypes.has(type.node.type) || type.node.type === experimental_utils_1.AST_NODE_TYPES.TSTypeOperator && type.node.operator === 'readonly' && type.node.typeAnnotation && aliasTypes.has(type.node.typeAnnotation.type)) {
        // alias / keyword
        checkAndReport(allowAliases, isTopLevel, type, 'Aliases');
      } else {
        // unhandled type - shouldn't happen
        reportError(type.node, type.compositionType, isTopLevel, 'Unhandled');
      }
    }
    /**
     * Flatten the given type into an array of its dependencies
     */


    function getTypes(node) {
      var compositionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (node.type === experimental_utils_1.AST_NODE_TYPES.TSUnionType || node.type === experimental_utils_1.AST_NODE_TYPES.TSIntersectionType) {
        return node.types.reduce(function (acc, type) {
          acc.push.apply(acc, _toConsumableArray(getTypes(type, node.type)));
          return acc;
        }, []);
      }

      if (node.type === experimental_utils_1.AST_NODE_TYPES.TSParenthesizedType) {
        return getTypes(node.typeAnnotation, compositionType);
      }

      return [{
        node: node,
        compositionType: compositionType
      }];
    }

    return {
      TSTypeAliasDeclaration: function TSTypeAliasDeclaration(node) {
        var types = getTypes(node.typeAnnotation);

        if (types.length === 1) {
          // is a top level type annotation
          validateTypeAliases(types[0], true);
        } else {
          // is a composition type
          types.forEach(function (type) {
            validateTypeAliases(type);
          });
        }
      }
    };
  }
});