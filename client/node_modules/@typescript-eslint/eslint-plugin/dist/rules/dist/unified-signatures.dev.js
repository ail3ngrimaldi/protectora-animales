"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'unified-signatures',
  meta: {
    docs: {
      description: 'Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter',
      category: 'Variables',
      // too opinionated to be recommended
      recommended: false
    },
    type: 'suggestion',
    messages: {
      omittingRestParameter: '{{failureStringStart}} with a rest parameter.',
      omittingSingleParameter: '{{failureStringStart}} with an optional parameter.',
      singleParameterDifference: '{{failureStringStart}} taking `{{type1}} | {{type2}}`.'
    },
    schema: []
  },
  defaultOptions: [],
  create: function create(context) {
    var sourceCode = context.getSourceCode(); //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    function failureStringStart(otherLine) {
      // For only 2 overloads we don't need to specify which is the other one.
      var overloads = otherLine === undefined ? 'These overloads' : "This overload and the one on line ".concat(otherLine);
      return "".concat(overloads, " can be combined into one signature");
    }

    function addFailures(failures) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = failures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var failure = _step.value;
          var unify = failure.unify,
              only2 = failure.only2;

          switch (unify.kind) {
            case 'single-parameter-difference':
              {
                var p0 = unify.p0,
                    p1 = unify.p1;
                var lineOfOtherOverload = only2 ? undefined : p0.loc.start.line;
                var typeAnnotation0 = isTSParameterProperty(p0) ? p0.parameter.typeAnnotation : p0.typeAnnotation;
                var typeAnnotation1 = isTSParameterProperty(p1) ? p1.parameter.typeAnnotation : p1.typeAnnotation;
                context.report({
                  loc: p1.loc,
                  messageId: 'singleParameterDifference',
                  data: {
                    failureStringStart: failureStringStart(lineOfOtherOverload),
                    type1: sourceCode.getText(typeAnnotation0 === null || typeAnnotation0 === void 0 ? void 0 : typeAnnotation0.typeAnnotation),
                    type2: sourceCode.getText(typeAnnotation1 === null || typeAnnotation1 === void 0 ? void 0 : typeAnnotation1.typeAnnotation)
                  },
                  node: p1
                });
                break;
              }

            case 'extra-parameter':
              {
                var extraParameter = unify.extraParameter,
                    otherSignature = unify.otherSignature;

                var _lineOfOtherOverload = only2 ? undefined : otherSignature.loc.start.line;

                context.report({
                  loc: extraParameter.loc,
                  messageId: extraParameter.type === experimental_utils_1.AST_NODE_TYPES.RestElement ? 'omittingRestParameter' : 'omittingSingleParameter',
                  data: {
                    failureStringStart: failureStringStart(_lineOfOtherOverload)
                  },
                  node: extraParameter
                });
              }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    function checkOverloads(signatures, typeParameters) {
      var result = [];
      var isTypeParameter = getIsTypeParameter(typeParameters);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = signatures[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var overloads = _step2.value;

          if (overloads.length === 2) {
            var signature0 = overloads[0].value || overloads[0];
            var signature1 = overloads[1].value || overloads[1];
            var unify = compareSignatures(signature0, signature1, isTypeParameter);

            if (unify !== undefined) {
              result.push({
                unify: unify,
                only2: true
              });
            }
          } else {
            forEachPair(overloads, function (a, b) {
              var signature0 = a.value || a;
              var signature1 = b.value || b;
              var unify = compareSignatures(signature0, signature1, isTypeParameter);

              if (unify !== undefined) {
                result.push({
                  unify: unify,
                  only2: false
                });
              }
            });
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return result;
    }

    function compareSignatures(a, b, isTypeParameter) {
      if (!signaturesCanBeUnified(a, b, isTypeParameter)) {
        return undefined;
      }

      return a.params.length === b.params.length ? signaturesDifferBySingleParameter(a.params, b.params) : signaturesDifferByOptionalOrRestParameter(a, b);
    }

    function signaturesCanBeUnified(a, b, isTypeParameter) {
      // Must return the same type.
      var aTypeParams = a.typeParameters !== undefined ? a.typeParameters.params : undefined;
      var bTypeParams = b.typeParameters !== undefined ? b.typeParameters.params : undefined;
      return typesAreEqual(a.returnType, b.returnType) && // Must take the same type parameters.
      // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.
      util.arraysAreEqual(aTypeParams, bTypeParams, typeParametersAreEqual) && signatureUsesTypeParameter(a, isTypeParameter) === signatureUsesTypeParameter(b, isTypeParameter);
    }
    /** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */


    function signaturesDifferBySingleParameter(types1, types2) {
      var index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);

      if (index === undefined) {
        return undefined;
      } // If remaining arrays are equal, the signatures differ by just one parameter type


      if (!util.arraysAreEqual(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {
        return undefined;
      }

      var a = types1[index];
      var b = types2[index]; // Can unify `a?: string` and `b?: number`. Can't unify `...args: string[]` and `...args: number[]`.
      // See https://github.com/Microsoft/TypeScript/issues/5077

      return parametersHaveEqualSigils(a, b) && a.type !== experimental_utils_1.AST_NODE_TYPES.RestElement ? {
        kind: 'single-parameter-difference',
        p0: a,
        p1: b
      } : undefined;
    }
    /**
     * Detect `a(): void` and `a(x: number): void`.
     * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.
     */


    function signaturesDifferByOptionalOrRestParameter(a, b) {
      var sig1 = a.params;
      var sig2 = b.params;
      var minLength = Math.min(sig1.length, sig2.length);
      var longer = sig1.length < sig2.length ? sig2 : sig1;
      var shorter = sig1.length < sig2.length ? sig1 : sig2;
      var shorterSig = sig1.length < sig2.length ? a : b; // If one is has 2+ parameters more than the other, they must all be optional/rest.
      // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)
      // Not allowed: f() and f(x, y)

      for (var i = minLength + 1; i < longer.length; i++) {
        if (!parameterMayBeMissing(longer[i])) {
          return undefined;
        }
      }

      for (var _i = 0; _i < minLength; _i++) {
        var sig1i = sig1[_i];
        var sig2i = sig2[_i];
        var typeAnnotation1 = isTSParameterProperty(sig1i) ? sig1i.parameter.typeAnnotation : sig1i.typeAnnotation;
        var typeAnnotation2 = isTSParameterProperty(sig2i) ? sig2i.parameter.typeAnnotation : sig2i.typeAnnotation;

        if (!typesAreEqual(typeAnnotation1, typeAnnotation2)) {
          return undefined;
        }
      }

      if (minLength > 0 && shorter[minLength - 1].type === experimental_utils_1.AST_NODE_TYPES.RestElement) {
        return undefined;
      }

      return {
        extraParameter: longer[longer.length - 1],
        kind: 'extra-parameter',
        otherSignature: shorterSig
      };
    }
    /** Given type parameters, returns a function to test whether a type is one of those parameters. */


    function getIsTypeParameter(typeParameters) {
      if (typeParameters === undefined) {
        return function () {
          return false;
        };
      }

      var set = new Set();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = typeParameters.params[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var t = _step3.value;
          set.add(t.name.name);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return function (typeName) {
        return set.has(typeName);
      };
    }
    /** True if any of the outer type parameters are used in a signature. */


    function signatureUsesTypeParameter(sig, isTypeParameter) {
      return sig.params.some(function (p) {
        return typeContainsTypeParameter(isTSParameterProperty(p) ? p.parameter.typeAnnotation : p.typeAnnotation);
      });

      function typeContainsTypeParameter(type) {
        if (!type) {
          return false;
        }

        if (type.type === experimental_utils_1.AST_NODE_TYPES.TSTypeReference) {
          var typeName = type.typeName;

          if (isIdentifier(typeName) && isTypeParameter(typeName.name)) {
            return true;
          }
        }

        return typeContainsTypeParameter(type.typeAnnotation || type.elementType);
      }
    }

    function isTSParameterProperty(node) {
      return node.type === experimental_utils_1.AST_NODE_TYPES.TSParameterProperty;
    }

    function parametersAreEqual(a, b) {
      var typeAnnotationA = isTSParameterProperty(a) ? a.parameter.typeAnnotation : a.typeAnnotation;
      var typeAnnotationB = isTSParameterProperty(b) ? b.parameter.typeAnnotation : b.typeAnnotation;
      return parametersHaveEqualSigils(a, b) && typesAreEqual(typeAnnotationA, typeAnnotationB);
    }
    /** True for optional/rest parameters. */


    function parameterMayBeMissing(p) {
      var optional = isTSParameterProperty(p) ? p.parameter.optional : p.optional;
      return p.type === experimental_utils_1.AST_NODE_TYPES.RestElement || optional;
    }
    /** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */


    function parametersHaveEqualSigils(a, b) {
      var optionalA = isTSParameterProperty(a) ? a.parameter.optional : a.optional;
      var optionalB = isTSParameterProperty(b) ? b.parameter.optional : b.optional;
      return a.type === experimental_utils_1.AST_NODE_TYPES.RestElement === (b.type === experimental_utils_1.AST_NODE_TYPES.RestElement) && optionalA !== undefined === (optionalB !== undefined);
    }

    function typeParametersAreEqual(a, b) {
      return a.name.name === b.name.name && constraintsAreEqual(a.constraint, b.constraint);
    }

    function typesAreEqual(a, b) {
      return a === b || a !== undefined && b !== undefined && sourceCode.getText(a.typeAnnotation) === sourceCode.getText(b.typeAnnotation);
    }

    function constraintsAreEqual(a, b) {
      return a === b || a !== undefined && b !== undefined && a.type === b.type;
    }
    /* Returns the first index where `a` and `b` differ. */


    function getIndexOfFirstDifference(a, b, equal) {
      for (var i = 0; i < a.length && i < b.length; i++) {
        if (!equal(a[i], b[i])) {
          return i;
        }
      }

      return undefined;
    }
    /** Calls `action` for every pair of values in `values`. */


    function forEachPair(values, action) {
      for (var i = 0; i < values.length; i++) {
        for (var j = i + 1; j < values.length; j++) {
          action(values[i], values[j]);
        }
      }
    }

    var scopes = [];
    var currentScope = {
      overloads: new Map()
    };

    function createScope(parent, typeParameters) {
      currentScope && scopes.push(currentScope);
      currentScope = {
        overloads: new Map(),
        parent: parent,
        typeParameters: typeParameters
      };
    }

    function checkScope() {
      var failures = checkOverloads(Array.from(currentScope.overloads.values()), currentScope.typeParameters);
      addFailures(failures);
      currentScope = scopes.pop();
    }

    function addOverload(signature, key, containingNode) {
      key = key !== null && key !== void 0 ? key : getOverloadKey(signature);

      if (currentScope && (containingNode || signature).parent === currentScope.parent) {
        var overloads = currentScope.overloads.get(key);

        if (overloads !== undefined) {
          overloads.push(signature);
        } else {
          currentScope.overloads.set(key, [signature]);
        }
      }
    } //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------


    return {
      Program: createScope,
      TSModuleBlock: createScope,
      TSInterfaceDeclaration: function TSInterfaceDeclaration(node) {
        createScope(node.body, node.typeParameters);
      },
      ClassDeclaration: function ClassDeclaration(node) {
        createScope(node.body, node.typeParameters);
      },
      TSTypeLiteral: createScope,
      // collect overloads
      TSDeclareFunction: function TSDeclareFunction(node) {
        var _a, _b;

        var exportingNode = getExportingNode(node);
        addOverload(node, (_b = (_a = node.id) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : exportingNode === null || exportingNode === void 0 ? void 0 : exportingNode.type, exportingNode);
      },
      TSCallSignatureDeclaration: addOverload,
      TSConstructSignatureDeclaration: addOverload,
      TSMethodSignature: addOverload,
      TSAbstractMethodDefinition: function TSAbstractMethodDefinition(node) {
        if (!node.value.body) {
          addOverload(node);
        }
      },
      MethodDefinition: function MethodDefinition(node) {
        if (!node.value.body) {
          addOverload(node);
        }
      },
      // validate scopes
      'Program:exit': checkScope,
      'TSModuleBlock:exit': checkScope,
      'TSInterfaceDeclaration:exit': checkScope,
      'ClassDeclaration:exit': checkScope,
      'TSTypeLiteral:exit': checkScope
    };
  }
});

function getExportingNode(node) {
  return node.parent && (node.parent.type === experimental_utils_1.AST_NODE_TYPES.ExportNamedDeclaration || node.parent.type === experimental_utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) ? node.parent : undefined;
}

function getOverloadKey(node) {
  var info = getOverloadInfo(node);
  return (node.computed ? '0' : '1') + (node["static"] ? '0' : '1') + info;
}

function getOverloadInfo(node) {
  switch (node.type) {
    case experimental_utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:
      return 'constructor';

    case experimental_utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:
      return '()';

    default:
      {
        var key = node.key;
        return isIdentifier(key) ? key.name : key.raw;
      }
  }
}

function isIdentifier(node) {
  return node.type === experimental_utils_1.AST_NODE_TYPES.Identifier;
}