"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'no-inferrable-types',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean',
      category: 'Best Practices',
      recommended: 'error'
    },
    fixable: 'code',
    messages: {
      noInferrableType: 'Type {{type}} trivially inferred from a {{type}} literal, remove type annotation.'
    },
    schema: [{
      type: 'object',
      properties: {
        ignoreParameters: {
          type: 'boolean'
        },
        ignoreProperties: {
          type: 'boolean'
        }
      },
      additionalProperties: false
    }]
  },
  defaultOptions: [{
    ignoreParameters: false,
    ignoreProperties: false
  }],
  create: function create(context, _ref) {
    var _keywordMap;

    var _ref2 = _slicedToArray(_ref, 1),
        _ref2$ = _ref2[0],
        ignoreParameters = _ref2$.ignoreParameters,
        ignoreProperties = _ref2$.ignoreProperties;

    function isFunctionCall(init, callName) {
      return (init.type === experimental_utils_1.AST_NODE_TYPES.CallExpression || init.type === experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression) && init.callee.type === experimental_utils_1.AST_NODE_TYPES.Identifier && init.callee.name === callName;
    }

    function isLiteral(init, typeName) {
      return init.type === experimental_utils_1.AST_NODE_TYPES.Literal && _typeof(init.value) === typeName;
    }

    function isIdentifier(init) {
      for (var _len = arguments.length, names = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        names[_key - 1] = arguments[_key];
      }

      return init.type === experimental_utils_1.AST_NODE_TYPES.Identifier && names.includes(init.name);
    }

    function hasUnaryPrefix(init) {
      for (var _len2 = arguments.length, operators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        operators[_key2 - 1] = arguments[_key2];
      }

      return init.type === experimental_utils_1.AST_NODE_TYPES.UnaryExpression && operators.includes(init.operator);
    }

    var keywordMap = (_keywordMap = {}, _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSBigIntKeyword, 'bigint'), _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSBooleanKeyword, 'boolean'), _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSNumberKeyword, 'number'), _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSNullKeyword, 'null'), _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSStringKeyword, 'string'), _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSSymbolKeyword, 'symbol'), _defineProperty(_keywordMap, experimental_utils_1.AST_NODE_TYPES.TSUndefinedKeyword, 'undefined'), _keywordMap);
    /**
     * Returns whether a node has an inferrable value or not
     */

    function isInferrable(annotation, init) {
      switch (annotation.type) {
        case experimental_utils_1.AST_NODE_TYPES.TSBigIntKeyword:
          {
            // note that bigint cannot have + prefixed to it
            var unwrappedInit = hasUnaryPrefix(init, '-') ? init.argument : init;
            return isFunctionCall(unwrappedInit, 'BigInt') || unwrappedInit.type === experimental_utils_1.AST_NODE_TYPES.BigIntLiteral;
          }

        case experimental_utils_1.AST_NODE_TYPES.TSBooleanKeyword:
          return hasUnaryPrefix(init, '!') || // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
          isFunctionCall(init, 'Boolean') || isLiteral(init, 'boolean');

        case experimental_utils_1.AST_NODE_TYPES.TSNumberKeyword:
          {
            var _unwrappedInit = hasUnaryPrefix(init, '+', '-') ? init.argument : init;

            return isIdentifier(_unwrappedInit, 'Infinity', 'NaN') || isFunctionCall(_unwrappedInit, 'Number') || isLiteral(_unwrappedInit, 'number');
          }

        case experimental_utils_1.AST_NODE_TYPES.TSNullKeyword:
          return init.type === experimental_utils_1.AST_NODE_TYPES.Literal && init.value === null;

        case experimental_utils_1.AST_NODE_TYPES.TSStringKeyword:
          return (// eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum
            isFunctionCall(init, 'String') || isLiteral(init, 'string') || init.type === experimental_utils_1.AST_NODE_TYPES.TemplateLiteral
          );

        case experimental_utils_1.AST_NODE_TYPES.TSSymbolKeyword:
          return isFunctionCall(init, 'Symbol');

        case experimental_utils_1.AST_NODE_TYPES.TSTypeReference:
          {
            if (annotation.typeName.type === experimental_utils_1.AST_NODE_TYPES.Identifier && annotation.typeName.name === 'RegExp') {
              var isRegExpLiteral = init.type === experimental_utils_1.AST_NODE_TYPES.Literal && init.value instanceof RegExp;
              var isRegExpNewCall = init.type === experimental_utils_1.AST_NODE_TYPES.NewExpression && init.callee.type === experimental_utils_1.AST_NODE_TYPES.Identifier && init.callee.name === 'RegExp';
              var isRegExpCall = isFunctionCall(init, 'RegExp');
              return isRegExpLiteral || isRegExpCall || isRegExpNewCall;
            }

            return false;
          }

        case experimental_utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
          return hasUnaryPrefix(init, 'void') || isIdentifier(init, 'undefined');
      }

      return false;
    }
    /**
     * Reports an inferrable type declaration, if any
     */


    function reportInferrableType(node, typeNode, initNode) {
      if (!typeNode || !initNode || !typeNode.typeAnnotation) {
        return;
      }

      if (!isInferrable(typeNode.typeAnnotation, initNode)) {
        return;
      }

      var type = typeNode.typeAnnotation.type === experimental_utils_1.AST_NODE_TYPES.TSTypeReference ? // TODO - if we add more references
      'RegExp' : keywordMap[typeNode.typeAnnotation.type];
      context.report({
        node: node,
        messageId: 'noInferrableType',
        data: {
          type: type
        },
        fix: function fix(fixer) {
          return fixer.remove(typeNode);
        }
      });
    }

    function inferrableVariableVisitor(node) {
      if (!node.id) {
        return;
      }

      reportInferrableType(node, node.id.typeAnnotation, node.init);
    }

    function inferrableParameterVisitor(node) {
      if (ignoreParameters || !node.params) {
        return;
      }

      node.params.filter(function (param) {
        return param.type === experimental_utils_1.AST_NODE_TYPES.AssignmentPattern && param.left && param.right;
      }).forEach(function (param) {
        reportInferrableType(param, param.left.typeAnnotation, param.right);
      });
    }

    function inferrablePropertyVisitor(node) {
      // We ignore `readonly` because of Microsoft/TypeScript#14416
      // Essentially a readonly property without a type
      // will result in its value being the type, leading to
      // compile errors if the type is stripped.
      if (ignoreProperties || node.readonly || node.optional) {
        return;
      }

      reportInferrableType(node, node.typeAnnotation, node.value);
    }

    return {
      VariableDeclarator: inferrableVariableVisitor,
      FunctionExpression: inferrableParameterVisitor,
      FunctionDeclaration: inferrableParameterVisitor,
      ArrowFunctionExpression: inferrableParameterVisitor,
      ClassProperty: inferrablePropertyVisitor
    };
  }
});