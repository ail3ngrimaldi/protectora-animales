"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var brace_style_1 = __importDefault(require("eslint/lib/rules/brace-style"));

var util_1 = require("../util");

exports["default"] = util_1.createRule({
  name: 'brace-style',
  meta: {
    type: 'layout',
    docs: {
      description: 'Enforce consistent brace style for blocks',
      category: 'Stylistic Issues',
      recommended: false,
      extendsBaseRule: true
    },
    messages: brace_style_1["default"].meta.messages,
    fixable: brace_style_1["default"].meta.fixable,
    schema: brace_style_1["default"].meta.schema
  },
  defaultOptions: ['1tbs'],
  create: function create(context) {
    var _context$options = _slicedToArray(context.options, 2),
        style = _context$options[0],
        _context$options$ = _context$options[1];

    _context$options$ = _context$options$ === void 0 ? {
      allowSingleLine: false
    } : _context$options$;
    var allowSingleLine = _context$options$.allowSingleLine;
    var isAllmanStyle = style === 'allman';
    var sourceCode = context.getSourceCode();
    var rules = brace_style_1["default"].create(context);
    /**
     * Checks a pair of curly brackets based on the user's config
     */

    function validateCurlyPair(openingCurlyToken, closingCurlyToken) {
      if (allowSingleLine && util_1.isTokenOnSameLine(openingCurlyToken, closingCurlyToken)) {
        return;
      }

      var tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurlyToken);
      var tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurlyToken);
      var tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurlyToken);

      if (!isAllmanStyle && !util_1.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurlyToken)) {
        context.report({
          node: openingCurlyToken,
          messageId: 'nextLineOpen',
          fix: function fix(fixer) {
            var textRange = [tokenBeforeOpeningCurly.range[1], openingCurlyToken.range[0]];
            var textBetween = sourceCode.text.slice(textRange[0], textRange[1]);

            if (textBetween.trim()) {
              return null;
            }

            return fixer.replaceTextRange(textRange, ' ');
          }
        });
      }

      if (isAllmanStyle && util_1.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurlyToken)) {
        context.report({
          node: openingCurlyToken,
          messageId: 'sameLineOpen',
          fix: function fix(fixer) {
            return fixer.insertTextBefore(openingCurlyToken, '\n');
          }
        });
      }

      if (util_1.isTokenOnSameLine(openingCurlyToken, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurlyToken) {
        context.report({
          node: openingCurlyToken,
          messageId: 'blockSameLine',
          fix: function fix(fixer) {
            return fixer.insertTextAfter(openingCurlyToken, '\n');
          }
        });
      }

      if (util_1.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurlyToken) && tokenBeforeClosingCurly !== openingCurlyToken) {
        context.report({
          node: closingCurlyToken,
          messageId: 'singleLineClose',
          fix: function fix(fixer) {
            return fixer.insertTextBefore(closingCurlyToken, '\n');
          }
        });
      }
    }

    return Object.assign(Object.assign({}, rules), {
      'TSInterfaceBody, TSModuleBlock': function TSInterfaceBodyTSModuleBlock(node) {
        var openingCurly = sourceCode.getFirstToken(node);
        var closingCurly = sourceCode.getLastToken(node);
        validateCurlyPair(openingCurly, closingCurly);
      },
      TSEnumDeclaration: function TSEnumDeclaration(node) {
        var closingCurly = sourceCode.getLastToken(node);
        var openingCurly = sourceCode.getTokenBefore(node.members.length ? node.members[0] : closingCurly);
        validateCurlyPair(openingCurly, closingCurly);
      }
    });
  }
});