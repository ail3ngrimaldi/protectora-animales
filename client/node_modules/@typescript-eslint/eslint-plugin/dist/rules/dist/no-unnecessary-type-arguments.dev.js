"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tsutils = __importStar(require("tsutils"));

var ts = __importStar(require("typescript"));

var util = __importStar(require("../util"));

var util_1 = require("../util");

exports["default"] = util.createRule({
  name: 'no-unnecessary-type-arguments',
  meta: {
    docs: {
      description: 'Enforces that type arguments will not be used if not required',
      category: 'Best Practices',
      recommended: false,
      requiresTypeChecking: true
    },
    fixable: 'code',
    messages: {
      unnecessaryTypeParameter: 'This is the default value for this type parameter, so it can be omitted.'
    },
    schema: [],
    type: 'suggestion'
  },
  defaultOptions: [],
  create: function create(context) {
    var parserServices = util.getParserServices(context);
    var checker = parserServices.program.getTypeChecker();
    var sourceCode = context.getSourceCode();

    function checkTSArgsAndParameters(esParameters, typeParameters) {
      // Just check the last one. Must specify previous type parameters if the last one is specified.
      var i = esParameters.params.length - 1;
      var arg = esParameters.params[i];
      var param = typeParameters[i]; // TODO: would like checker.areTypesEquivalent. https://github.com/Microsoft/TypeScript/issues/13502

      if (!(param === null || param === void 0 ? void 0 : param["default"]) || param["default"].getText() !== sourceCode.getText(arg)) {
        return;
      }

      context.report({
        node: arg,
        messageId: 'unnecessaryTypeParameter',
        fix: function fix(fixer) {
          return fixer.removeRange(i === 0 ? esParameters.range : [esParameters.params[i - 1].range[1], arg.range[1]]);
        }
      });
    }

    return {
      TSTypeParameterInstantiation: function TSTypeParameterInstantiation(node) {
        var expression = parserServices.esTreeNodeToTSNodeMap.get(node);
        var typeParameters = getTypeParametersFromNode(expression, checker);

        if (typeParameters) {
          checkTSArgsAndParameters(node, typeParameters);
        }
      }
    };
  }
});

function getTypeParametersFromNode(node, checker) {
  if (ts.isExpressionWithTypeArguments(node)) {
    return getTypeParametersFromType(node.expression, checker);
  }

  if (ts.isTypeReferenceNode(node)) {
    return getTypeParametersFromType(node.typeName, checker);
  }

  if (ts.isCallExpression(node) || ts.isNewExpression(node)) {
    return getTypeParametersFromCall(node, checker);
  }

  return undefined;
}

function getTypeParametersFromType(type, checker) {
  var symAtLocation = checker.getSymbolAtLocation(type);

  if (!symAtLocation) {
    return undefined;
  }

  var sym = getAliasedSymbol(symAtLocation, checker);
  var declarations = sym.getDeclarations();

  if (!declarations) {
    return undefined;
  }

  return util_1.findFirstResult(declarations, function (decl) {
    return tsutils.isClassLikeDeclaration(decl) || ts.isTypeAliasDeclaration(decl) || ts.isInterfaceDeclaration(decl) ? decl.typeParameters : undefined;
  });
}

function getTypeParametersFromCall(node, checker) {
  var sig = checker.getResolvedSignature(node);
  var sigDecl = sig === null || sig === void 0 ? void 0 : sig.getDeclaration();

  if (!sigDecl) {
    return ts.isNewExpression(node) ? getTypeParametersFromType(node.expression, checker) : undefined;
  }

  return sigDecl.typeParameters;
}

function getAliasedSymbol(symbol, checker) {
  return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : symbol;
}