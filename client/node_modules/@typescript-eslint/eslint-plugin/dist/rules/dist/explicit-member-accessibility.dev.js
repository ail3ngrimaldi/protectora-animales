"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

var accessibilityLevel = {
  "enum": ['explicit', 'no-public', 'off']
};
exports["default"] = util.createRule({
  name: 'explicit-member-accessibility',
  meta: {
    type: 'problem',
    docs: {
      description: 'Require explicit accessibility modifiers on class properties and methods',
      category: 'Stylistic Issues',
      // too opinionated to be recommended
      recommended: false
    },
    fixable: 'code',
    messages: {
      missingAccessibility: 'Missing accessibility modifier on {{type}} {{name}}.',
      unwantedPublicAccessibility: 'Public accessibility modifier on {{type}} {{name}}.'
    },
    schema: [{
      type: 'object',
      properties: {
        accessibility: accessibilityLevel,
        overrides: {
          type: 'object',
          properties: {
            accessors: accessibilityLevel,
            constructors: accessibilityLevel,
            methods: accessibilityLevel,
            properties: accessibilityLevel,
            parameterProperties: accessibilityLevel
          },
          additionalProperties: false
        },
        ignoredMethodNames: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      },
      additionalProperties: false
    }]
  },
  defaultOptions: [{
    accessibility: 'explicit'
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        option = _ref2[0];

    var _a, _b, _c, _d, _e, _f, _g, _h;

    var sourceCode = context.getSourceCode();
    var baseCheck = (_a = option.accessibility) !== null && _a !== void 0 ? _a : 'explicit';
    var overrides = (_b = option.overrides) !== null && _b !== void 0 ? _b : {};
    var ctorCheck = (_c = overrides.constructors) !== null && _c !== void 0 ? _c : baseCheck;
    var accessorCheck = (_d = overrides.accessors) !== null && _d !== void 0 ? _d : baseCheck;
    var methodCheck = (_e = overrides.methods) !== null && _e !== void 0 ? _e : baseCheck;
    var propCheck = (_f = overrides.properties) !== null && _f !== void 0 ? _f : baseCheck;
    var paramPropCheck = (_g = overrides.parameterProperties) !== null && _g !== void 0 ? _g : baseCheck;
    var ignoredMethodNames = new Set((_h = option.ignoredMethodNames) !== null && _h !== void 0 ? _h : []);
    /**
     * Generates the report for rule violations
     */

    function reportIssue(messageId, nodeType, node, nodeName) {
      var fix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      context.report({
        node: node,
        messageId: messageId,
        data: {
          type: nodeType,
          name: nodeName
        },
        fix: fix
      });
    }
    /**
     * Checks if a method declaration has an accessibility modifier.
     * @param methodDefinition The node representing a MethodDefinition.
     */


    function checkMethodAccessibilityModifier(methodDefinition) {
      var nodeType = 'method definition';
      var check = baseCheck;

      switch (methodDefinition.kind) {
        case 'method':
          check = methodCheck;
          break;

        case 'constructor':
          check = ctorCheck;
          break;

        case 'get':
        case 'set':
          check = accessorCheck;
          nodeType = "".concat(methodDefinition.kind, " property accessor");
          break;
      }

      var methodName = util.getNameFromMember(methodDefinition, sourceCode);

      if (check === 'off' || ignoredMethodNames.has(methodName)) {
        return;
      }

      if (check === 'no-public' && methodDefinition.accessibility === 'public') {
        reportIssue('unwantedPublicAccessibility', nodeType, methodDefinition, methodName, getUnwantedPublicAccessibilityFixer(methodDefinition));
      } else if (check === 'explicit' && !methodDefinition.accessibility) {
        reportIssue('missingAccessibility', nodeType, methodDefinition, methodName);
      }
    }
    /**
     * Creates a fixer that removes a "public" keyword with following spaces
     */


    function getUnwantedPublicAccessibilityFixer(node) {
      return function (fixer) {
        var tokens = sourceCode.getTokens(node);
        var rangeToRemove;

        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];

          if (token.type === experimental_utils_1.AST_TOKEN_TYPES.Keyword && token.value === 'public') {
            var commensAfterPublicKeyword = sourceCode.getCommentsAfter(token);

            if (commensAfterPublicKeyword.length) {
              // public /* Hi there! */ static foo()
              // ^^^^^^^
              rangeToRemove = [token.range[0], commensAfterPublicKeyword[0].range[0]];
              break;
            } else {
              // public static foo()
              // ^^^^^^^
              rangeToRemove = [token.range[0], tokens[i + 1].range[0]];
              break;
            }
          }
        }

        return fixer.removeRange(rangeToRemove);
      };
    }
    /**
     * Checks if property has an accessibility modifier.
     * @param classProperty The node representing a ClassProperty.
     */


    function checkPropertyAccessibilityModifier(classProperty) {
      var nodeType = 'class property';
      var propertyName = util.getNameFromMember(classProperty, sourceCode);

      if (propCheck === 'no-public' && classProperty.accessibility === 'public') {
        reportIssue('unwantedPublicAccessibility', nodeType, classProperty, propertyName, getUnwantedPublicAccessibilityFixer(classProperty));
      } else if (propCheck === 'explicit' && !classProperty.accessibility) {
        reportIssue('missingAccessibility', nodeType, classProperty, propertyName);
      }
    }
    /**
     * Checks that the parameter property has the desired accessibility modifiers set.
     * @param node The node representing a Parameter Property
     */


    function checkParameterPropertyAccessibilityModifier(node) {
      var nodeType = 'parameter property'; // HAS to be an identifier or assignment or TSC will throw

      if (node.parameter.type !== experimental_utils_1.AST_NODE_TYPES.Identifier && node.parameter.type !== experimental_utils_1.AST_NODE_TYPES.AssignmentPattern) {
        return;
      }

      var nodeName = node.parameter.type === experimental_utils_1.AST_NODE_TYPES.Identifier ? node.parameter.name : // has to be an Identifier or TSC will throw an error
      node.parameter.left.name;

      switch (paramPropCheck) {
        case 'explicit':
          {
            if (!node.accessibility) {
              reportIssue('missingAccessibility', nodeType, node, nodeName);
            }

            break;
          }

        case 'no-public':
          {
            if (node.accessibility === 'public' && node.readonly) {
              reportIssue('unwantedPublicAccessibility', nodeType, node, nodeName, getUnwantedPublicAccessibilityFixer(node));
            }

            break;
          }
      }
    }

    return {
      TSParameterProperty: checkParameterPropertyAccessibilityModifier,
      ClassProperty: checkPropertyAccessibilityModifier,
      MethodDefinition: checkMethodAccessibilityModifier
    };
  }
});