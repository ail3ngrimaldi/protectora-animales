"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var ts = __importStar(require("typescript"));

var tsutils = __importStar(require("tsutils"));

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'no-unnecessary-qualifier',
  meta: {
    docs: {
      category: 'Best Practices',
      description: 'Warns when a namespace qualifier is unnecessary',
      recommended: false,
      requiresTypeChecking: true
    },
    fixable: 'code',
    messages: {
      unnecessaryQualifier: "Qualifier is unnecessary since '{{ name }}' is in scope."
    },
    schema: [],
    type: 'suggestion'
  },
  defaultOptions: [],
  create: function create(context) {
    var namespacesInScope = [];
    var currentFailedNamespaceExpression = null;
    var parserServices = util.getParserServices(context);
    var esTreeNodeToTSNodeMap = parserServices.esTreeNodeToTSNodeMap;
    var program = parserServices.program;
    var checker = program.getTypeChecker();
    var sourceCode = context.getSourceCode();

    function tryGetAliasedSymbol(symbol, checker) {
      return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : null;
    }

    function symbolIsNamespaceInScope(symbol) {
      var _a;

      var symbolDeclarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];

      if (symbolDeclarations.some(function (decl) {
        return namespacesInScope.some(function (ns) {
          return ns === decl;
        });
      })) {
        return true;
      }

      var alias = tryGetAliasedSymbol(symbol, checker);
      return alias !== null && symbolIsNamespaceInScope(alias);
    }

    function getSymbolInScope(node, flags, name) {
      // TODO:PERF `getSymbolsInScope` gets a long list. Is there a better way?
      var scope = checker.getSymbolsInScope(node, flags);
      return scope.find(function (scopeSymbol) {
        return scopeSymbol.name === name;
      });
    }

    function symbolsAreEqual(accessed, inScope) {
      return accessed === checker.getExportSymbolOfSymbol(inScope);
    }

    function qualifierIsUnnecessary(qualifier, name) {
      var tsQualifier = esTreeNodeToTSNodeMap.get(qualifier);
      var tsName = esTreeNodeToTSNodeMap.get(name);
      var namespaceSymbol = checker.getSymbolAtLocation(tsQualifier);

      if (typeof namespaceSymbol === 'undefined' || !symbolIsNamespaceInScope(namespaceSymbol)) {
        return false;
      }

      var accessedSymbol = checker.getSymbolAtLocation(tsName);

      if (typeof accessedSymbol === 'undefined') {
        return false;
      } // If the symbol in scope is different, the qualifier is necessary.


      var fromScope = getSymbolInScope(tsQualifier, accessedSymbol.flags, sourceCode.getText(name));
      return typeof fromScope === 'undefined' || symbolsAreEqual(accessedSymbol, fromScope);
    }

    function visitNamespaceAccess(node, qualifier, name) {
      // Only look for nested qualifier errors if we didn't already fail on the outer qualifier.
      if (!currentFailedNamespaceExpression && qualifierIsUnnecessary(qualifier, name)) {
        currentFailedNamespaceExpression = node;
        context.report({
          node: qualifier,
          messageId: 'unnecessaryQualifier',
          data: {
            name: sourceCode.getText(name)
          },
          fix: function fix(fixer) {
            return fixer.removeRange([qualifier.range[0], name.range[0]]);
          }
        });
      }
    }

    function enterDeclaration(node) {
      namespacesInScope.push(esTreeNodeToTSNodeMap.get(node));
    }

    function exitDeclaration() {
      namespacesInScope.pop();
    }

    function resetCurrentNamespaceExpression(node) {
      if (node === currentFailedNamespaceExpression) {
        currentFailedNamespaceExpression = null;
      }
    }

    function isPropertyAccessExpression(node) {
      return node.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression && !node.computed;
    }

    function isEntityNameExpression(node) {
      return node.type === experimental_utils_1.AST_NODE_TYPES.Identifier || isPropertyAccessExpression(node) && isEntityNameExpression(node.object);
    }

    return {
      TSModuleDeclaration: enterDeclaration,
      TSEnumDeclaration: enterDeclaration,
      'ExportNamedDeclaration[declaration.type="TSModuleDeclaration"]': enterDeclaration,
      'ExportNamedDeclaration[declaration.type="TSEnumDeclaration"]': enterDeclaration,
      'TSModuleDeclaration:exit': exitDeclaration,
      'TSEnumDeclaration:exit': exitDeclaration,
      'ExportNamedDeclaration[declaration.type="TSModuleDeclaration"]:exit': exitDeclaration,
      'ExportNamedDeclaration[declaration.type="TSEnumDeclaration"]:exit': exitDeclaration,
      TSQualifiedName: function TSQualifiedName(node) {
        visitNamespaceAccess(node, node.left, node.right);
      },
      'MemberExpression[computed=false]': function MemberExpressionComputedFalse(node) {
        var property = node.property;

        if (isEntityNameExpression(node.object)) {
          visitNamespaceAccess(node, node.object, property);
        }
      },
      'TSQualifiedName:exit': resetCurrentNamespaceExpression,
      'MemberExpression:exit': resetCurrentNamespaceExpression
    };
  }
});