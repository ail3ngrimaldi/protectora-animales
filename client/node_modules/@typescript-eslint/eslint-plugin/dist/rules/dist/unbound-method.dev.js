"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var tsutils = __importStar(require("tsutils"));

var ts = __importStar(require("typescript"));

var util = __importStar(require("../util"));
/**
 * The following is a list of exceptions to the rule
 * Generated via the following script.
 * This is statically defined to save making purposely invalid calls every lint run
 * ```
SUPPORTED_GLOBALS.flatMap(namespace => {
  const object = window[namespace];
    return Object.getOwnPropertyNames(object)
      .filter(
        name =>
          !name.startsWith('_') &&
          typeof object[name] === 'function',
      )
      .map(name => {
        try {
          const x = object[name];
          x();
        } catch (e) {
          if (e.message.includes("called on non-object")) {
            return `${namespace}.${name}`;
          }
        }
      });
}).filter(Boolean);
   * ```
 */


var nativelyNotBoundMembers = new Set(['Promise.all', 'Promise.race', 'Promise.resolve', 'Promise.reject', 'Promise.allSettled', 'Object.defineProperties', 'Object.defineProperty', 'Reflect.defineProperty', 'Reflect.deleteProperty', 'Reflect.get', 'Reflect.getOwnPropertyDescriptor', 'Reflect.getPrototypeOf', 'Reflect.has', 'Reflect.isExtensible', 'Reflect.ownKeys', 'Reflect.preventExtensions', 'Reflect.set', 'Reflect.setPrototypeOf']);
var SUPPORTED_GLOBALS = ['Number', 'Object', 'String', 'RegExp', 'Symbol', 'Array', 'Proxy', 'Date', 'Infinity', 'Atomics', 'Reflect', 'console', 'Math', 'JSON', 'Intl'];
var nativelyBoundMembers = SUPPORTED_GLOBALS.map(function (namespace) {
  var object = global[namespace];
  return Object.getOwnPropertyNames(object).filter(function (name) {
    return !name.startsWith('_') && typeof object[name] === 'function';
  }).map(function (name) {
    return "".concat(namespace, ".").concat(name);
  });
}).reduce(function (arr, names) {
  return arr.concat(names);
}, []).filter(function (name) {
  return !nativelyNotBoundMembers.has(name);
});

var isMemberNotImported = function isMemberNotImported(symbol, currentSourceFile) {
  var valueDeclaration = symbol.valueDeclaration;

  if (!valueDeclaration) {
    // working around https://github.com/microsoft/TypeScript/issues/31294
    return false;
  }

  return !!currentSourceFile && currentSourceFile !== valueDeclaration.getSourceFile();
};

var getNodeName = function getNodeName(node) {
  return node.type === experimental_utils_1.AST_NODE_TYPES.Identifier ? node.name : null;
};

var getMemberFullName = function getMemberFullName(node) {
  return "".concat(getNodeName(node.object), ".").concat(getNodeName(node.property));
};

exports["default"] = util.createRule({
  name: 'unbound-method',
  meta: {
    docs: {
      category: 'Best Practices',
      description: 'Enforces unbound methods are called with their expected scope',
      recommended: 'error',
      requiresTypeChecking: true
    },
    messages: {
      unbound: 'Avoid referencing unbound methods which may cause unintentional scoping of `this`.'
    },
    schema: [{
      type: 'object',
      properties: {
        ignoreStatic: {
          type: 'boolean'
        }
      },
      additionalProperties: false
    }],
    type: 'problem'
  },
  defaultOptions: [{
    ignoreStatic: false
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        ignoreStatic = _ref2[0].ignoreStatic;

    var parserServices = util.getParserServices(context);
    var checker = parserServices.program.getTypeChecker();
    var currentSourceFile = parserServices.program.getSourceFile(context.getFilename());
    return {
      'MemberExpression, OptionalMemberExpression': function MemberExpressionOptionalMemberExpression(node) {
        if (isSafeUse(node)) {
          return;
        }

        var objectSymbol = checker.getSymbolAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.object));

        if (objectSymbol && nativelyBoundMembers.includes(getMemberFullName(node)) && isMemberNotImported(objectSymbol, currentSourceFile)) {
          return;
        }

        var originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);
        var symbol = checker.getSymbolAtLocation(originalNode);

        if (symbol && isDangerousMethod(symbol, ignoreStatic)) {
          context.report({
            messageId: 'unbound',
            node: node
          });
        }
      }
    };
  }
});

function isDangerousMethod(symbol, ignoreStatic) {
  var _a;

  var valueDeclaration = symbol.valueDeclaration;

  if (!valueDeclaration) {
    // working around https://github.com/microsoft/TypeScript/issues/31294
    return false;
  }

  switch (valueDeclaration.kind) {
    case ts.SyntaxKind.PropertyDeclaration:
      return ((_a = valueDeclaration.initializer) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.FunctionExpression;

    case ts.SyntaxKind.MethodDeclaration:
    case ts.SyntaxKind.MethodSignature:
      return !(ignoreStatic && tsutils.hasModifier(valueDeclaration.modifiers, ts.SyntaxKind.StaticKeyword));
  }

  return false;
}

function isSafeUse(node) {
  var parent = node.parent;

  switch (parent === null || parent === void 0 ? void 0 : parent.type) {
    case experimental_utils_1.AST_NODE_TYPES.IfStatement:
    case experimental_utils_1.AST_NODE_TYPES.ForStatement:
    case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
    case experimental_utils_1.AST_NODE_TYPES.OptionalMemberExpression:
    case experimental_utils_1.AST_NODE_TYPES.SwitchStatement:
    case experimental_utils_1.AST_NODE_TYPES.UpdateExpression:
    case experimental_utils_1.AST_NODE_TYPES.WhileStatement:
      return true;

    case experimental_utils_1.AST_NODE_TYPES.CallExpression:
    case experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression:
      return parent.callee === node;

    case experimental_utils_1.AST_NODE_TYPES.ConditionalExpression:
      return parent.test === node;

    case experimental_utils_1.AST_NODE_TYPES.TaggedTemplateExpression:
      return parent.tag === node;

    case experimental_utils_1.AST_NODE_TYPES.UnaryExpression:
      // the first case is safe for obvious
      // reasons. The second one is also fine
      // since we're returning something falsy
      return ['typeof', '!', 'void', 'delete'].includes(parent.operator);

    case experimental_utils_1.AST_NODE_TYPES.BinaryExpression:
      return ['instanceof', '==', '!=', '===', '!=='].includes(parent.operator);

    case experimental_utils_1.AST_NODE_TYPES.AssignmentExpression:
      return parent.operator === '=' && node === parent.left;

    case experimental_utils_1.AST_NODE_TYPES.TSNonNullExpression:
    case experimental_utils_1.AST_NODE_TYPES.TSAsExpression:
    case experimental_utils_1.AST_NODE_TYPES.TSTypeAssertion:
      return isSafeUse(parent);

    case experimental_utils_1.AST_NODE_TYPES.LogicalExpression:
      if (parent.operator === '&&' && parent.left === node) {
        // this is safe, as && will return the left if and only if it's falsy
        return true;
      } // in all other cases, it's likely the logical expression will return the method ref
      // so make sure the parent is a safe usage


      return isSafeUse(parent);
  }

  return false;
}