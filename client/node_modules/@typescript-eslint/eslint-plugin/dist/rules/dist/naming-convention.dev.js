"use strict";

var _PredefinedFormatToCh;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util")); // #region Options Type Config


var PredefinedFormats;

(function (PredefinedFormats) {
  PredefinedFormats[PredefinedFormats["camelCase"] = 1] = "camelCase";
  PredefinedFormats[PredefinedFormats["strictCamelCase"] = 2] = "strictCamelCase";
  PredefinedFormats[PredefinedFormats["PascalCase"] = 4] = "PascalCase";
  PredefinedFormats[PredefinedFormats["StrictPascalCase"] = 8] = "StrictPascalCase"; // eslint-disable-next-line @typescript-eslint/camelcase

  PredefinedFormats[PredefinedFormats["snake_case"] = 16] = "snake_case";
  PredefinedFormats[PredefinedFormats["UPPER_CASE"] = 32] = "UPPER_CASE";
})(PredefinedFormats || (PredefinedFormats = {}));

var UnderscoreOptions;

(function (UnderscoreOptions) {
  UnderscoreOptions[UnderscoreOptions["forbid"] = 1] = "forbid";
  UnderscoreOptions[UnderscoreOptions["allow"] = 2] = "allow";
  UnderscoreOptions[UnderscoreOptions["require"] = 4] = "require";
})(UnderscoreOptions || (UnderscoreOptions = {}));

var Selectors;

(function (Selectors) {
  // variableLike
  Selectors[Selectors["variable"] = 1] = "variable";
  Selectors[Selectors["function"] = 2] = "function";
  Selectors[Selectors["parameter"] = 4] = "parameter"; // memberLike

  Selectors[Selectors["property"] = 8] = "property";
  Selectors[Selectors["parameterProperty"] = 16] = "parameterProperty";
  Selectors[Selectors["method"] = 32] = "method";
  Selectors[Selectors["accessor"] = 64] = "accessor";
  Selectors[Selectors["enumMember"] = 128] = "enumMember"; // typeLike

  Selectors[Selectors["class"] = 256] = "class";
  Selectors[Selectors["interface"] = 512] = "interface";
  Selectors[Selectors["typeAlias"] = 1024] = "typeAlias";
  Selectors[Selectors["enum"] = 2048] = "enum";
  Selectors[Selectors["typeParameter"] = 4096] = "typeParameter";
})(Selectors || (Selectors = {}));

var SELECTOR_COUNT = util.getEnumNames(Selectors).length;
var MetaSelectors;

(function (MetaSelectors) {
  MetaSelectors[MetaSelectors["default"] = -1] = "default";
  MetaSelectors[MetaSelectors["variableLike"] = 7] = "variableLike";
  MetaSelectors[MetaSelectors["memberLike"] = 248] = "memberLike";
  MetaSelectors[MetaSelectors["typeLike"] = 7936] = "typeLike";
})(MetaSelectors || (MetaSelectors = {}));

var Modifiers;

(function (Modifiers) {
  Modifiers[Modifiers["readonly"] = 1] = "readonly";
  Modifiers[Modifiers["static"] = 2] = "static";
  Modifiers[Modifiers["public"] = 4] = "public";
  Modifiers[Modifiers["protected"] = 8] = "protected";
  Modifiers[Modifiers["private"] = 16] = "private";
  Modifiers[Modifiers["abstract"] = 32] = "abstract";
})(Modifiers || (Modifiers = {}));

var TypeModifiers;

(function (TypeModifiers) {
  TypeModifiers[TypeModifiers["boolean"] = 1024] = "boolean";
  TypeModifiers[TypeModifiers["string"] = 2048] = "string";
  TypeModifiers[TypeModifiers["number"] = 4096] = "number";
  TypeModifiers[TypeModifiers["function"] = 8192] = "function";
  TypeModifiers[TypeModifiers["array"] = 16384] = "array";
})(TypeModifiers || (TypeModifiers = {})); // #endregion Options Type Config
// #region Schema Config


var UNDERSCORE_SCHEMA = {
  type: 'string',
  "enum": util.getEnumNames(UnderscoreOptions)
};
var PREFIX_SUFFIX_SCHEMA = {
  type: 'array',
  items: {
    type: 'string',
    minLength: 1
  },
  additionalItems: false
};
var MATCH_REGEX_SCHEMA = {
  type: 'object',
  properties: {
    match: {
      type: 'boolean'
    },
    regex: {
      type: 'string'
    }
  },
  required: ['match', 'regex']
};
var FORMAT_OPTIONS_PROPERTIES = {
  format: {
    oneOf: [{
      type: 'array',
      items: {
        type: 'string',
        "enum": util.getEnumNames(PredefinedFormats)
      },
      additionalItems: false
    }, {
      type: 'null'
    }]
  },
  custom: MATCH_REGEX_SCHEMA,
  leadingUnderscore: UNDERSCORE_SCHEMA,
  trailingUnderscore: UNDERSCORE_SCHEMA,
  prefix: PREFIX_SUFFIX_SCHEMA,
  suffix: PREFIX_SUFFIX_SCHEMA
};

function selectorSchema(selectorString, allowType, modifiers) {
  var selector = {
    filter: {
      oneOf: [{
        type: 'string',
        minLength: 1
      }, MATCH_REGEX_SCHEMA]
    },
    selector: {
      type: 'string',
      "enum": [selectorString]
    }
  };

  if (modifiers && modifiers.length > 0) {
    selector.modifiers = {
      type: 'array',
      items: {
        type: 'string',
        "enum": modifiers
      },
      additionalItems: false
    };
  }

  if (allowType) {
    selector.types = {
      type: 'array',
      items: {
        type: 'string',
        "enum": util.getEnumNames(TypeModifiers)
      },
      additionalItems: false
    };
  }

  return [{
    type: 'object',
    properties: Object.assign(Object.assign({}, FORMAT_OPTIONS_PROPERTIES), selector),
    required: ['selector', 'format'],
    additionalProperties: false
  }];
}

var SCHEMA = {
  type: 'array',
  items: {
    oneOf: [].concat(_toConsumableArray(selectorSchema('default', false, util.getEnumNames(Modifiers))), _toConsumableArray(selectorSchema('variableLike', false)), _toConsumableArray(selectorSchema('variable', true)), _toConsumableArray(selectorSchema('function', false)), _toConsumableArray(selectorSchema('parameter', true)), _toConsumableArray(selectorSchema('memberLike', false, ['private', 'protected', 'public', 'static', 'readonly', 'abstract'])), _toConsumableArray(selectorSchema('property', true, ['private', 'protected', 'public', 'static', 'readonly', 'abstract'])), _toConsumableArray(selectorSchema('parameterProperty', true, ['private', 'protected', 'public', 'readonly'])), _toConsumableArray(selectorSchema('method', false, ['private', 'protected', 'public', 'static', 'abstract'])), _toConsumableArray(selectorSchema('accessor', true, ['private', 'protected', 'public', 'static', 'abstract'])), _toConsumableArray(selectorSchema('enumMember', false)), _toConsumableArray(selectorSchema('typeLike', false, ['abstract'])), _toConsumableArray(selectorSchema('class', false, ['abstract'])), _toConsumableArray(selectorSchema('interface', false)), _toConsumableArray(selectorSchema('typeAlias', false)), _toConsumableArray(selectorSchema('enum', false)), _toConsumableArray(selectorSchema('typeParameter', false)))
  },
  additionalItems: false
}; // #endregion Schema Config
// This essentially mirrors ESLint's `camelcase` rule
// note that that rule ignores leading and trailing underscores and only checks those in the middle of a variable name

var defaultCamelCaseAllTheThingsConfig = [{
  selector: 'default',
  format: ['camelCase'],
  leadingUnderscore: 'allow',
  trailingUnderscore: 'allow'
}, {
  selector: 'variable',
  format: ['camelCase', 'UPPER_CASE'],
  leadingUnderscore: 'allow',
  trailingUnderscore: 'allow'
}, {
  selector: 'typeLike',
  format: ['PascalCase']
}];
exports["default"] = util.createRule({
  name: 'naming-convention',
  meta: {
    docs: {
      category: 'Variables',
      description: 'Enforces naming conventions for everything across a codebase',
      recommended: false,
      // technically only requires type checking if the user uses "type" modifiers
      requiresTypeChecking: true
    },
    type: 'suggestion',
    messages: {
      unexpectedUnderscore: '{{type}} name {{name}} must not have a {{position}} underscore.',
      missingUnderscore: '{{type}} name {{name}} must have a {{position}} underscore.',
      missingAffix: '{{type}} name {{name}} must have one of the following {{position}}es: {{affixes}}',
      satisfyCustom: '{{type}} name {{name}} must {{regexMatch}} the RegExp: {{regex}}',
      doesNotMatchFormat: '{{type}} name {{name}} must match one of the following formats: {{formats}}'
    },
    schema: SCHEMA
  },
  defaultOptions: defaultCamelCaseAllTheThingsConfig,
  create: function create(contextWithoutDefaults) {
    var _ref;

    var context = contextWithoutDefaults.options ? contextWithoutDefaults : // only apply the defaults when the user provides no config
    Object.setPrototypeOf({
      options: defaultCamelCaseAllTheThingsConfig
    }, contextWithoutDefaults);
    var validators = parseOptions(context);

    function handleMember(validator, node, modifiers) {
      if (!validator) {
        return;
      }

      var key = node.key;
      validator(key, modifiers);
    }

    function getMemberModifiers(node) {
      var modifiers = new Set();

      if (node.accessibility) {
        modifiers.add(Modifiers[node.accessibility]);
      } else {
        modifiers.add(Modifiers["public"]);
      }

      if (node["static"]) {
        modifiers.add(Modifiers["static"]);
      }

      if ('readonly' in node && node.readonly) {
        modifiers.add(Modifiers.readonly);
      }

      if (node.type === experimental_utils_1.AST_NODE_TYPES.TSAbstractClassProperty || node.type === experimental_utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition) {
        modifiers.add(Modifiers["abstract"]);
      }

      return modifiers;
    }

    return _ref = {
      // #region variable
      VariableDeclarator: function VariableDeclarator(node) {
        var validator = validators.variable;

        if (!validator) {
          return;
        }

        var identifiers = [];
        getIdentifiersFromPattern(node.id, identifiers);
        identifiers.forEach(function (i) {
          validator(i);
        });
      },
      // #endregion
      // #region function
      'FunctionDeclaration, TSDeclareFunction, FunctionExpression': function FunctionDeclarationTSDeclareFunctionFunctionExpression(node) {
        var validator = validators["function"];

        if (!validator || node.id === null) {
          return;
        }

        validator(node.id);
      },
      // #endregion function
      // #region parameter
      'FunctionDeclaration, TSDeclareFunction, FunctionExpression, ArrowFunctionExpression': function FunctionDeclarationTSDeclareFunctionFunctionExpressionArrowFunctionExpression(node) {
        var validator = validators.parameter;

        if (!validator) {
          return;
        }

        node.params.forEach(function (param) {
          if (param.type === experimental_utils_1.AST_NODE_TYPES.TSParameterProperty) {
            return;
          }

          var identifiers = [];
          getIdentifiersFromPattern(param, identifiers);
          identifiers.forEach(function (i) {
            validator(i);
          });
        });
      },
      // #endregion parameter
      // #region parameterProperty
      TSParameterProperty: function TSParameterProperty(node) {
        var validator = validators.parameterProperty;

        if (!validator) {
          return;
        }

        var modifiers = getMemberModifiers(node);
        var identifiers = [];
        getIdentifiersFromPattern(node.parameter, identifiers);
        identifiers.forEach(function (i) {
          validator(i, modifiers);
        });
      },
      // #endregion parameterProperty
      // #region property
      'Property[computed = false][kind = "init"][value.type != "ArrowFunctionExpression"][value.type != "FunctionExpression"][value.type != "TSEmptyBodyFunctionExpression"]': function PropertyComputedFalseKindInitValueTypeArrowFunctionExpressionValueTypeFunctionExpressionValueTypeTSEmptyBodyFunctionExpression(node) {
        var modifiers = new Set([Modifiers["public"]]);
        handleMember(validators.property, node, modifiers);
      },
      ':matches(ClassProperty, TSAbstractClassProperty)[computed = false][value.type != "ArrowFunctionExpression"][value.type != "FunctionExpression"][value.type != "TSEmptyBodyFunctionExpression"]': function matchesClassPropertyTSAbstractClassPropertyComputedFalseValueTypeArrowFunctionExpressionValueTypeFunctionExpressionValueTypeTSEmptyBodyFunctionExpression(node) {
        var modifiers = getMemberModifiers(node);
        handleMember(validators.property, node, modifiers);
      },
      'TSPropertySignature[computed = false]': function TSPropertySignatureComputedFalse(node) {
        var modifiers = new Set([Modifiers["public"]]);

        if (node.readonly) {
          modifiers.add(Modifiers.readonly);
        }

        handleMember(validators.property, node, modifiers);
      }
    }, _defineProperty(_ref, ['Property[computed = false][kind = "init"][value.type = "ArrowFunctionExpression"]', 'Property[computed = false][kind = "init"][value.type = "FunctionExpression"]', 'Property[computed = false][kind = "init"][value.type = "TSEmptyBodyFunctionExpression"]', 'TSMethodSignature[computed = false]'].join(', '), function (node) {
      var modifiers = new Set([Modifiers["public"]]);
      handleMember(validators.method, node, modifiers);
    }), _defineProperty(_ref, [':matches(ClassProperty, TSAbstractClassProperty)[computed = false][value.type = "ArrowFunctionExpression"]', ':matches(ClassProperty, TSAbstractClassProperty)[computed = false][value.type = "FunctionExpression"]', ':matches(ClassProperty, TSAbstractClassProperty)[computed = false][value.type = "TSEmptyBodyFunctionExpression"]', ':matches(MethodDefinition, TSAbstractMethodDefinition)[computed = false][kind = "method"]'].join(', '), function (node) {
      var modifiers = getMemberModifiers(node);
      handleMember(validators.method, node, modifiers);
    }), _defineProperty(_ref, 'Property[computed = false]:matches([kind = "get"], [kind = "set"])', function PropertyComputedFalseMatchesKindGetKindSet(node) {
      var modifiers = new Set([Modifiers["public"]]);
      handleMember(validators.accessor, node, modifiers);
    }), _defineProperty(_ref, 'MethodDefinition[computed = false]:matches([kind = "get"], [kind = "set"])', function MethodDefinitionComputedFalseMatchesKindGetKindSet(node) {
      var modifiers = getMemberModifiers(node);
      handleMember(validators.accessor, node, modifiers);
    }), _defineProperty(_ref, 'TSEnumMember[computed != true]', function TSEnumMemberComputedTrue(node) {
      var validator = validators.enumMember;

      if (!validator) {
        return;
      }

      var id = node.id;
      validator(id);
    }), _defineProperty(_ref, 'ClassDeclaration, ClassExpression', function ClassDeclarationClassExpression(node) {
      var validator = validators["class"];

      if (!validator) {
        return;
      }

      var id = node.id;

      if (id === null) {
        return;
      }

      var modifiers = new Set();

      if (node["abstract"]) {
        modifiers.add(Modifiers["abstract"]);
      }

      validator(id, modifiers);
    }), _defineProperty(_ref, "TSInterfaceDeclaration", function TSInterfaceDeclaration(node) {
      var validator = validators["interface"];

      if (!validator) {
        return;
      }

      validator(node.id);
    }), _defineProperty(_ref, "TSTypeAliasDeclaration", function TSTypeAliasDeclaration(node) {
      var validator = validators.typeAlias;

      if (!validator) {
        return;
      }

      validator(node.id);
    }), _defineProperty(_ref, "TSEnumDeclaration", function TSEnumDeclaration(node) {
      var validator = validators["enum"];

      if (!validator) {
        return;
      }

      validator(node.id);
    }), _defineProperty(_ref, 'TSTypeParameterDeclaration > TSTypeParameter', function TSTypeParameterDeclarationTSTypeParameter(node) {
      var validator = validators.typeParameter;

      if (!validator) {
        return;
      }

      validator(node.name);
    }), _ref;
  }
});

function getIdentifiersFromPattern(pattern, identifiers) {
  switch (pattern.type) {
    case experimental_utils_1.AST_NODE_TYPES.Identifier:
      identifiers.push(pattern);
      break;

    case experimental_utils_1.AST_NODE_TYPES.ArrayPattern:
      pattern.elements.forEach(function (element) {
        if (element !== null) {
          getIdentifiersFromPattern(element, identifiers);
        }
      });
      break;

    case experimental_utils_1.AST_NODE_TYPES.ObjectPattern:
      pattern.properties.forEach(function (property) {
        if (property.type === experimental_utils_1.AST_NODE_TYPES.RestElement) {
          getIdentifiersFromPattern(property, identifiers);
        } else {
          // this is a bit weird, but it's because ESTree doesn't have a new node type
          // for object destructuring properties - it just reuses Property...
          // https://github.com/estree/estree/blob/9ae284b71130d53226e7153b42f01bf819e6e657/es2015.md#L206-L211
          // However, the parser guarantees this is safe (and there is error handling)
          getIdentifiersFromPattern(property.value, identifiers);
        }
      });
      break;

    case experimental_utils_1.AST_NODE_TYPES.RestElement:
      getIdentifiersFromPattern(pattern.argument, identifiers);
      break;

    case experimental_utils_1.AST_NODE_TYPES.AssignmentPattern:
      getIdentifiersFromPattern(pattern.left, identifiers);
      break;

    case experimental_utils_1.AST_NODE_TYPES.MemberExpression:
      // ignore member expressions, as the everything must already be defined
      break;

    default:
      // https://github.com/typescript-eslint/typescript-eslint/issues/1282
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      throw new Error("Unexpected pattern type ".concat(pattern.type));
  }
}

function parseOptions(context) {
  var normalizedOptions = context.options.map(function (opt) {
    return normalizeOption(opt);
  });
  var parsedOptions = util.getEnumNames(Selectors).reduce(function (acc, k) {
    acc[k] = createValidator(k, context, normalizedOptions);
    return acc;
  }, {});
  return parsedOptions;
}

function createValidator(type, context, allConfigs) {
  // make sure the "highest priority" configs are checked first
  var selectorType = Selectors[type];
  var configs = allConfigs // gather all of the applicable selectors
  .filter(function (c) {
    return (c.selector & selectorType) !== 0 || c.selector === MetaSelectors["default"];
  }).sort(function (a, b) {
    if (a.selector === b.selector) {
      // in the event of the same selector, order by modifier weight
      // sort descending - the type modifiers are "more important"
      return b.modifierWeight - a.modifierWeight;
    }
    /*
    meta selectors will always be larger numbers than the normal selectors they contain, as they are the sum of all
    of the selectors that they contain.
    to give normal selectors a higher priority, shift them all SELECTOR_COUNT bits to the left before comparison, so
    they are instead always guaranteed to be larger than the meta selectors.
    */


    var aSelector = isMetaSelector(a.selector) ? a.selector : a.selector << SELECTOR_COUNT;
    var bSelector = isMetaSelector(b.selector) ? b.selector : b.selector << SELECTOR_COUNT; // sort descending - the meta selectors are "least important"

    return bSelector - aSelector;
  });
  return function (node) {
    var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

    var _a, _b, _c;

    var originalName = node.type === experimental_utils_1.AST_NODE_TYPES.Identifier ? node.name : "".concat(node.value); // return will break the loop and stop checking configs
    // it is only used when the name is known to have failed or succeeded a config.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = configs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var config = _step.value;

        if (((_a = config.filter) === null || _a === void 0 ? void 0 : _a.regex.test(originalName)) !== ((_b = config.filter) === null || _b === void 0 ? void 0 : _b.match)) {
          // name does not match the filter
          continue;
        }

        if ((_c = config.modifiers) === null || _c === void 0 ? void 0 : _c.some(function (modifier) {
          return !modifiers.has(modifier);
        })) {
          // does not have the required modifiers
          continue;
        }

        if (!isCorrectType(node, config, context)) {
          // is not the correct type
          continue;
        }

        var name = originalName;
        name = validateUnderscore('leading', config, name, node, originalName);

        if (name === null) {
          // fail
          return;
        }

        name = validateUnderscore('trailing', config, name, node, originalName);

        if (name === null) {
          // fail
          return;
        }

        name = validateAffix('prefix', config, name, node, originalName);

        if (name === null) {
          // fail
          return;
        }

        name = validateAffix('suffix', config, name, node, originalName);

        if (name === null) {
          // fail
          return;
        }

        if (!validateCustom(config, name, node, originalName)) {
          // fail
          return;
        }

        if (!validatePredefinedFormat(config, name, node, originalName)) {
          // fail
          return;
        } // it's valid for this config, so we don't need to check any more configs


        return;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }; // centralizes the logic for formatting the report data

  function formatReportData(_ref2) {
    var affixes = _ref2.affixes,
        formats = _ref2.formats,
        originalName = _ref2.originalName,
        position = _ref2.position,
        custom = _ref2.custom;

    var _a;

    return {
      type: selectorTypeToMessageString(type),
      name: originalName,
      position: position,
      affixes: affixes === null || affixes === void 0 ? void 0 : affixes.join(', '),
      formats: formats === null || formats === void 0 ? void 0 : formats.map(function (f) {
        return PredefinedFormats[f];
      }).join(', '),
      regex: (_a = custom === null || custom === void 0 ? void 0 : custom.regex) === null || _a === void 0 ? void 0 : _a.toString(),
      regexMatch: (custom === null || custom === void 0 ? void 0 : custom.match) === true ? 'match' : (custom === null || custom === void 0 ? void 0 : custom.match) === false ? 'not match' : null
    };
  }
  /**
   * @returns the name with the underscore removed, if it is valid according to the specified underscore option, null otherwise
   */


  function validateUnderscore(position, config, name, node, originalName) {
    var option = position === 'leading' ? config.leadingUnderscore : config.trailingUnderscore;

    if (!option) {
      return name;
    }

    var hasUnderscore = position === 'leading' ? name.startsWith('_') : name.endsWith('_');
    var trimUnderscore = position === 'leading' ? function () {
      return name.slice(1);
    } : function () {
      return name.slice(0, -1);
    };

    switch (option) {
      case UnderscoreOptions.allow:
        // no check - the user doesn't care if it's there or not
        break;

      case UnderscoreOptions.forbid:
        if (hasUnderscore) {
          context.report({
            node: node,
            messageId: 'unexpectedUnderscore',
            data: formatReportData({
              originalName: originalName,
              position: position
            })
          });
          return null;
        }

        break;

      case UnderscoreOptions.require:
        if (!hasUnderscore) {
          context.report({
            node: node,
            messageId: 'missingUnderscore',
            data: formatReportData({
              originalName: originalName,
              position: position
            })
          });
          return null;
        }

    }

    return hasUnderscore ? trimUnderscore() : name;
  }
  /**
   * @returns the name with the affix removed, if it is valid according to the specified affix option, null otherwise
   */


  function validateAffix(position, config, name, node, originalName) {
    var affixes = config[position];

    if (!affixes || affixes.length === 0) {
      return name;
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      var _loop = function _loop() {
        var affix = _step2.value;
        var hasAffix = position === 'prefix' ? name.startsWith(affix) : name.endsWith(affix);
        var trimAffix = position === 'prefix' ? function () {
          return name.slice(affix.length);
        } : function () {
          return name.slice(0, -affix.length);
        };

        if (hasAffix) {
          // matches, so trim it and return
          return {
            v: trimAffix()
          };
        }
      };

      for (var _iterator2 = affixes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _ret = _loop();

        if (_typeof(_ret) === "object") return _ret.v;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    context.report({
      node: node,
      messageId: 'missingAffix',
      data: formatReportData({
        originalName: originalName,
        position: position,
        affixes: affixes
      })
    });
    return null;
  }
  /**
   * @returns true if the name is valid according to the `regex` option, false otherwise
   */


  function validateCustom(config, name, node, originalName) {
    var custom = config.custom;

    if (!custom) {
      return true;
    }

    var result = custom.regex.test(name);

    if (custom.match && result) {
      return true;
    }

    if (!custom.match && !result) {
      return true;
    }

    context.report({
      node: node,
      messageId: 'satisfyCustom',
      data: formatReportData({
        originalName: originalName,
        custom: custom
      })
    });
    return false;
  }
  /**
   * @returns true if the name is valid according to the `format` option, false otherwise
   */


  function validatePredefinedFormat(config, name, node, originalName) {
    var formats = config.format;

    if (formats === null || formats.length === 0) {
      return true;
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = formats[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var format = _step3.value;
        var checker = PredefinedFormatToCheckFunction[format];

        if (checker(name)) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    context.report({
      node: node,
      messageId: 'doesNotMatchFormat',
      data: formatReportData({
        originalName: originalName,
        formats: formats
      })
    });
    return false;
  }
} // #region Predefined Format Functions

/*
These format functions are taken from `tslint-consistent-codestyle/naming-convention`:
https://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/rules/namingConventionRule.ts#L603-L645

The licence for the code can be viewed here:
https://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/LICENSE
*/

/*
Why not regex here? Because it's actually really, really difficult to create a regex to handle
all of the unicode cases, and we have many non-english users that use non-english characters.
https://gist.github.com/mathiasbynens/6334847
*/


function isPascalCase(name) {
  return name.length === 0 || // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
  name[0] === name[0].toUpperCase() && !name.includes('_');
}

function isStrictPascalCase(name) {
  return name.length === 0 || // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
  name[0] === name[0].toUpperCase() && hasStrictCamelHumps(name, true);
}

function isCamelCase(name) {
  return name.length === 0 || // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
  name[0] === name[0].toLowerCase() && !name.includes('_');
}

function isStrictCamelCase(name) {
  return name.length === 0 || // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
  name[0] === name[0].toLowerCase() && hasStrictCamelHumps(name, false);
}

function hasStrictCamelHumps(name, isUpper) {
  function isUppercaseChar(_char) {
    return _char === _char.toUpperCase() && _char !== _char.toLowerCase();
  }

  if (name.startsWith('_')) {
    return false;
  }

  for (var i = 1; i < name.length; ++i) {
    if (name[i] === '_') {
      return false;
    }

    if (isUpper === isUppercaseChar(name[i])) {
      if (isUpper) {
        return false;
      }
    } else {
      isUpper = !isUpper;
    }
  }

  return true;
}

function isSnakeCase(name) {
  return name.length === 0 || name === name.toLowerCase() && validateUnderscores(name);
}

function isUpperCase(name) {
  return name.length === 0 || name === name.toUpperCase() && validateUnderscores(name);
}
/** Check for leading trailing and adjacent underscores */


function validateUnderscores(name) {
  if (name.startsWith('_')) {
    return false;
  }

  var wasUnderscore = false;

  for (var i = 1; i < name.length; ++i) {
    if (name[i] === '_') {
      if (wasUnderscore) {
        return false;
      }

      wasUnderscore = true;
    } else {
      wasUnderscore = false;
    }
  }

  return !wasUnderscore;
}

var PredefinedFormatToCheckFunction = (_PredefinedFormatToCh = {}, _defineProperty(_PredefinedFormatToCh, PredefinedFormats.PascalCase, isPascalCase), _defineProperty(_PredefinedFormatToCh, PredefinedFormats.StrictPascalCase, isStrictPascalCase), _defineProperty(_PredefinedFormatToCh, PredefinedFormats.camelCase, isCamelCase), _defineProperty(_PredefinedFormatToCh, PredefinedFormats.strictCamelCase, isStrictCamelCase), _defineProperty(_PredefinedFormatToCh, PredefinedFormats.UPPER_CASE, isUpperCase), _defineProperty(_PredefinedFormatToCh, PredefinedFormats.snake_case, isSnakeCase), _PredefinedFormatToCh); // #endregion Predefined Format Functions

function selectorTypeToMessageString(selectorType) {
  var notCamelCase = selectorType.replace(/([A-Z])/g, ' $1');
  return notCamelCase.charAt(0).toUpperCase() + notCamelCase.slice(1);
}

exports.selectorTypeToMessageString = selectorTypeToMessageString;

function isMetaSelector(selector) {
  return selector in MetaSelectors;
}

function normalizeOption(option) {
  var _a, _b, _c, _d, _e, _f;

  var weight = 0;
  (_a = option.modifiers) === null || _a === void 0 ? void 0 : _a.forEach(function (mod) {
    weight |= Modifiers[mod];
  });
  (_b = option.types) === null || _b === void 0 ? void 0 : _b.forEach(function (mod) {
    weight |= TypeModifiers[mod];
  }); // give selectors with a filter the _highest_ priority

  if (option.filter) {
    weight |= 1 << 30;
  }

  return {
    // format options
    format: option.format ? option.format.map(function (f) {
      return PredefinedFormats[f];
    }) : null,
    custom: option.custom ? {
      regex: new RegExp(option.custom.regex),
      match: option.custom.match
    } : null,
    leadingUnderscore: option.leadingUnderscore !== undefined ? UnderscoreOptions[option.leadingUnderscore] : null,
    trailingUnderscore: option.trailingUnderscore !== undefined ? UnderscoreOptions[option.trailingUnderscore] : null,
    prefix: option.prefix && option.prefix.length > 0 ? option.prefix : null,
    suffix: option.suffix && option.suffix.length > 0 ? option.suffix : null,
    // selector options
    selector: isMetaSelector(option.selector) ? MetaSelectors[option.selector] : Selectors[option.selector],
    modifiers: (_d = (_c = option.modifiers) === null || _c === void 0 ? void 0 : _c.map(function (m) {
      return Modifiers[m];
    })) !== null && _d !== void 0 ? _d : null,
    types: (_f = (_e = option.types) === null || _e === void 0 ? void 0 : _e.map(function (m) {
      return TypeModifiers[m];
    })) !== null && _f !== void 0 ? _f : null,
    filter: option.filter !== undefined ? typeof option.filter === 'string' ? {
      regex: new RegExp(option.filter),
      match: true
    } : {
      regex: new RegExp(option.filter.regex),
      match: option.filter.match
    } : null,
    // calculated ordering weight based on modifiers
    modifierWeight: weight
  };
}

function isCorrectType(node, config, context) {
  if (config.types === null) {
    return true;
  }

  var _util$getParserServic = util.getParserServices(context),
      esTreeNodeToTSNodeMap = _util$getParserServic.esTreeNodeToTSNodeMap,
      program = _util$getParserServic.program;

  var checker = program.getTypeChecker();
  var tsNode = esTreeNodeToTSNodeMap.get(node);
  var type = checker.getTypeAtLocation(tsNode) // remove null and undefined from the type, as we don't care about it here
  .getNonNullableType();
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = config.types[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var allowedType = _step4.value;

      switch (allowedType) {
        case TypeModifiers.array:
          if (isAllTypesMatch(type, function (t) {
            return checker.isArrayType(t) || checker.isTupleType(t);
          })) {
            return true;
          }

          break;

        case TypeModifiers["function"]:
          if (isAllTypesMatch(type, function (t) {
            return t.getCallSignatures().length > 0;
          })) {
            return true;
          }

          break;

        case TypeModifiers["boolean"]:
        case TypeModifiers.number:
        case TypeModifiers.string:
          {
            var typeString = checker.typeToString( // this will resolve things like true => boolean, 'a' => string and 1 => number
            checker.getWidenedType(checker.getBaseTypeOfLiteralType(type)));
            var allowedTypeString = TypeModifiers[allowedType];

            if (typeString === allowedTypeString) {
              return true;
            }

            break;
          }
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return false;
}
/**
 * @returns `true` if the type (or all union types) in the given type return true for the callback
 */


function isAllTypesMatch(type, cb) {
  if (type.isUnion()) {
    return type.types.every(function (t) {
      return cb(t);
    });
  }

  return cb(type);
}