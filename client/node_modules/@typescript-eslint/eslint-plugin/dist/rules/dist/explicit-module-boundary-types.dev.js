"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

var explicitReturnTypeUtils_1 = require("../util/explicitReturnTypeUtils");

exports["default"] = util.createRule({
  name: 'explicit-module-boundary-types',
  meta: {
    type: 'problem',
    docs: {
      description: "Require explicit return and argument types on exported functions' and classes' public class methods",
      category: 'Stylistic Issues',
      recommended: false
    },
    messages: {
      missingReturnType: 'Missing return type on function.',
      missingArgType: "Argument '{{name}}' should be typed."
    },
    schema: [{
      type: 'object',
      properties: {
        allowTypedFunctionExpressions: {
          type: 'boolean'
        },
        allowHigherOrderFunctions: {
          type: 'boolean'
        },
        allowDirectConstAssertionInArrowFunctions: {
          type: 'boolean'
        },
        allowedNames: {
          type: 'array',
          items: {
            type: 'string'
          }
        },
        shouldTrackReferences: {
          type: 'boolean'
        }
      },
      additionalProperties: false
    }]
  },
  defaultOptions: [{
    allowTypedFunctionExpressions: true,
    allowHigherOrderFunctions: true,
    allowDirectConstAssertionInArrowFunctions: true,
    allowedNames: [],
    shouldTrackReferences: true
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        options = _ref2[0];

    var sourceCode = context.getSourceCode();

    function isUnexported(node) {
      var isReturnedValue = false;

      while (node) {
        if (node.type === experimental_utils_1.AST_NODE_TYPES.ExportDefaultDeclaration || node.type === experimental_utils_1.AST_NODE_TYPES.ExportNamedDeclaration || node.type === experimental_utils_1.AST_NODE_TYPES.ExportSpecifier) {
          return false;
        }

        if (node.type === experimental_utils_1.AST_NODE_TYPES.JSXExpressionContainer) {
          return true;
        }

        if (node.type === experimental_utils_1.AST_NODE_TYPES.ReturnStatement) {
          isReturnedValue = true;
        }

        if (node.type === experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression || node.type === experimental_utils_1.AST_NODE_TYPES.FunctionDeclaration || node.type === experimental_utils_1.AST_NODE_TYPES.FunctionExpression) {
          isReturnedValue = false;
        }

        if (node.type === experimental_utils_1.AST_NODE_TYPES.BlockStatement && !isReturnedValue) {
          return true;
        }

        node = node.parent;
      }

      return true;
    }

    function isArgumentUntyped(node) {
      return !node.typeAnnotation || node.typeAnnotation.typeAnnotation.type === experimental_utils_1.AST_NODE_TYPES.TSAnyKeyword;
    }
    /**
     * Checks if a function declaration/expression has a return type.
     */


    function checkArguments(node) {
      var paramIdentifiers = node.params.filter(util.isIdentifier);
      var untypedArgs = paramIdentifiers.filter(isArgumentUntyped);
      untypedArgs.forEach(function (untypedArg) {
        return context.report({
          node: node,
          messageId: 'missingArgType',
          data: {
            name: untypedArg.name
          }
        });
      });
    }
    /**
     * Checks if a function name is allowed and should not be checked.
     */


    function isAllowedName(node) {
      if (!node || !options.allowedNames || !options.allowedNames.length) {
        return false;
      }

      if (node.type === experimental_utils_1.AST_NODE_TYPES.VariableDeclarator) {
        return node.id.type === experimental_utils_1.AST_NODE_TYPES.Identifier && options.allowedNames.includes(node.id.name);
      } else if (node.type === experimental_utils_1.AST_NODE_TYPES.MethodDefinition || node.type === experimental_utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition) {
        if (node.key.type === experimental_utils_1.AST_NODE_TYPES.Literal && typeof node.key.value === 'string') {
          return options.allowedNames.includes(node.key.value);
        }

        if (node.key.type === experimental_utils_1.AST_NODE_TYPES.TemplateLiteral && node.key.expressions.length === 0) {
          return options.allowedNames.includes(node.key.quasis[0].value.raw);
        }

        if (!node.computed && node.key.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
          return options.allowedNames.includes(node.key.name);
        }
      }

      return false;
    }
    /**
     * Finds an array of a function expression node referred by a variable passed from parameters
     */


    function findFunctionExpressionsInScope(variable) {
      var writeExprs = variable.references.map(function (ref) {
        return ref.writeExpr;
      }).filter(function (expr) {
        return (expr === null || expr === void 0 ? void 0 : expr.type) === experimental_utils_1.AST_NODE_TYPES.FunctionExpression || (expr === null || expr === void 0 ? void 0 : expr.type) === experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression;
      });
      return writeExprs;
    }
    /**
     * Finds a function node referred by a variable passed from parameters
     */


    function findFunctionInScope(variable) {
      if (variable.defs[0].type !== 'FunctionName') {
        return;
      }

      var functionNode = variable.defs[0].node;

      if ((functionNode === null || functionNode === void 0 ? void 0 : functionNode.type) !== experimental_utils_1.AST_NODE_TYPES.FunctionDeclaration) {
        return;
      }

      return functionNode;
    }
    /**
     * Checks if a function referred by the identifier passed from parameters follow the rule
     */


    function checkWithTrackingReferences(node) {
      var _a, _b;

      var scope = context.getScope();
      var variable = scope.set.get(node.name);

      if (!variable) {
        return;
      }

      if (variable.defs[0].type === 'ClassName') {
        var classNode = variable.defs[0].node;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = classNode.body.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var classElement = _step.value;

            if (classElement.type === experimental_utils_1.AST_NODE_TYPES.MethodDefinition && classElement.value.type === experimental_utils_1.AST_NODE_TYPES.FunctionExpression) {
              checkFunctionExpression(classElement.value);
            }

            if (classElement.type === experimental_utils_1.AST_NODE_TYPES.ClassProperty && (((_a = classElement.value) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.FunctionExpression || ((_b = classElement.value) === null || _b === void 0 ? void 0 : _b.type) === experimental_utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {
              checkFunctionExpression(classElement.value);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      var functionNode = findFunctionInScope(variable);

      if (functionNode) {
        checkFunction(functionNode);
      }

      var functionExpressions = findFunctionExpressionsInScope(variable);

      if (functionExpressions && functionExpressions.length > 0) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = functionExpressions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var functionExpression = _step2.value;
            checkFunctionExpression(functionExpression);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
    /**
     * Checks if a function expression follow the rule
     */


    function checkFunctionExpression(node) {
      var _a;

      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.MethodDefinition && node.parent.accessibility === 'private') {
        // don't check private methods as they aren't part of the public signature
        return;
      }

      if (isAllowedName(node.parent) || explicitReturnTypeUtils_1.isTypedFunctionExpression(node, options)) {
        return;
      }

      explicitReturnTypeUtils_1.checkFunctionExpressionReturnType(node, options, sourceCode, function (loc) {
        return context.report({
          node: node,
          loc: loc,
          messageId: 'missingReturnType'
        });
      });
      checkArguments(node);
    }
    /**
     * Checks if a function follow the rule
     */


    function checkFunction(node) {
      if (isAllowedName(node.parent)) {
        return;
      }

      explicitReturnTypeUtils_1.checkFunctionReturnType(node, options, sourceCode, function (loc) {
        return context.report({
          node: node,
          loc: loc,
          messageId: 'missingReturnType'
        });
      });
      checkArguments(node);
    }

    return {
      'ArrowFunctionExpression, FunctionExpression': function ArrowFunctionExpressionFunctionExpression(node) {
        if (isUnexported(node)) {
          return;
        }

        checkFunctionExpression(node);
      },
      FunctionDeclaration: function FunctionDeclaration(node) {
        if (isUnexported(node)) {
          return;
        }

        checkFunction(node);
      },
      'ExportDefaultDeclaration, TSExportAssignment': function ExportDefaultDeclarationTSExportAssignment(node) {
        if (!options.shouldTrackReferences) {
          return;
        }

        var exported;

        if (node.type === experimental_utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {
          exported = node.declaration;
        } else {
          exported = node.expression;
        }

        switch (exported.type) {
          case experimental_utils_1.AST_NODE_TYPES.Identifier:
            {
              checkWithTrackingReferences(exported);
              break;
            }

          case experimental_utils_1.AST_NODE_TYPES.ArrayExpression:
            {
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = exported.elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var element = _step3.value;

                  if (element.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
                    checkWithTrackingReferences(element);
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              break;
            }

          case experimental_utils_1.AST_NODE_TYPES.ObjectExpression:
            {
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = exported.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var property = _step4.value;

                  if (property.type === experimental_utils_1.AST_NODE_TYPES.Property && property.value.type === experimental_utils_1.AST_NODE_TYPES.Identifier) {
                    checkWithTrackingReferences(property.value);
                  }
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                    _iterator4["return"]();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              break;
            }
        }
      }
    };
  }
});