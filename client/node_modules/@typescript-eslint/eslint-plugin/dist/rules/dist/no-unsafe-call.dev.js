"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'no-unsafe-call',
  meta: {
    type: 'problem',
    docs: {
      description: 'Disallows calling an any type value',
      category: 'Possible Errors',
      recommended: false,
      requiresTypeChecking: true
    },
    messages: {
      unsafeCall: 'Unsafe call of an any typed value.',
      unsafeNew: 'Unsafe construction of an any type value.',
      unsafeTemplateTag: 'Unsafe any typed template tag.'
    },
    schema: []
  },
  defaultOptions: [],
  create: function create(context) {
    var _util$getParserServic = util.getParserServices(context),
        program = _util$getParserServic.program,
        esTreeNodeToTSNodeMap = _util$getParserServic.esTreeNodeToTSNodeMap;

    var checker = program.getTypeChecker();

    function checkCall(node, reportingNode, messageId) {
      var tsNode = esTreeNodeToTSNodeMap.get(node);
      var type = util.getConstrainedTypeAtLocation(checker, tsNode);

      if (util.isTypeAnyType(type)) {
        context.report({
          node: reportingNode,
          messageId: messageId
        });
      }
    }

    return {
      ':matches(CallExpression, OptionalCallExpression) > :not(Import).callee': function matchesCallExpressionOptionalCallExpressionNotImportCallee(node) {
        checkCall(node, node, 'unsafeCall');
      },
      NewExpression: function NewExpression(node) {
        checkCall(node.callee, node, 'unsafeNew');
      },
      'TaggedTemplateExpression > *.tag': function TaggedTemplateExpressionTag(node) {
        checkCall(node, node, 'unsafeTemplateTag');
      }
    };
  }
});