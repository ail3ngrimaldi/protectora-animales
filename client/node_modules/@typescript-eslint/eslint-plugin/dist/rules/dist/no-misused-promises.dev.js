"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tsutils = __importStar(require("tsutils"));

var ts = __importStar(require("typescript"));

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'no-misused-promises',
  meta: {
    docs: {
      description: 'Avoid using promises in places not designed to handle them',
      category: 'Best Practices',
      recommended: 'error',
      requiresTypeChecking: true
    },
    messages: {
      voidReturn: 'Promise returned in function argument where a void return was expected.',
      conditional: 'Expected non-Promise value in a boolean conditional.'
    },
    schema: [{
      type: 'object',
      properties: {
        checksConditionals: {
          type: 'boolean'
        },
        checksVoidReturn: {
          type: 'boolean'
        }
      }
    }],
    type: 'problem'
  },
  defaultOptions: [{
    checksConditionals: true,
    checksVoidReturn: true
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        _ref2$ = _ref2[0],
        checksConditionals = _ref2$.checksConditionals,
        checksVoidReturn = _ref2$.checksVoidReturn;

    var parserServices = util.getParserServices(context);
    var checker = parserServices.program.getTypeChecker();
    var conditionalChecks = {
      ConditionalExpression: checkTestConditional,
      DoWhileStatement: checkTestConditional,
      ForStatement: checkTestConditional,
      IfStatement: checkTestConditional,
      LogicalExpression: function LogicalExpression(node) {
        // We only check the lhs of a logical expression because the rhs might
        // be the return value of a short circuit expression.
        checkConditional(node.left);
      },
      UnaryExpression: function UnaryExpression(node) {
        if (node.operator === '!') {
          checkConditional(node.argument);
        }
      },
      WhileStatement: checkTestConditional
    };
    var voidReturnChecks = {
      CallExpression: checkArguments,
      OptionalCallExpression: checkArguments,
      NewExpression: checkArguments
    };

    function checkTestConditional(node) {
      if (node.test) {
        checkConditional(node.test);
      }
    }

    function checkConditional(node) {
      var tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);

      if (isAlwaysThenable(checker, tsNode)) {
        context.report({
          messageId: 'conditional',
          node: node
        });
      }
    }

    function checkArguments(node) {
      var tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);
      var voidParams = voidFunctionParams(checker, tsNode);

      if (voidParams.size === 0) {
        return;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = node.arguments.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              index = _step$value[0],
              argument = _step$value[1];

          if (!voidParams.has(index)) {
            continue;
          }

          var _tsNode = parserServices.esTreeNodeToTSNodeMap.get(argument);

          if (returnsThenable(checker, _tsNode)) {
            context.report({
              messageId: 'voidReturn',
              node: argument
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    return Object.assign(Object.assign({}, checksConditionals ? conditionalChecks : {}), checksVoidReturn ? voidReturnChecks : {});
  }
}); // Variation on the thenable check which requires all forms of the type (read:
// alternates in a union) to be thenable. Otherwise, you might be trying to
// check if something is defined or undefined and get caught because one of the
// branches is thenable.

function isAlwaysThenable(checker, node) {
  var type = checker.getTypeAtLocation(node);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = tsutils.unionTypeParts(checker.getApparentType(type))[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var subType = _step2.value;
      var thenProp = subType.getProperty('then'); // If one of the alternates has no then property, it is not thenable in all
      // cases.

      if (thenProp === undefined) {
        return false;
      } // We walk through each variation of the then property. Since we know it
      // exists at this point, we just need at least one of the alternates to
      // be of the right form to consider it thenable.


      var thenType = checker.getTypeOfSymbolAtLocation(thenProp, node);
      var hasThenableSignature = false;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = tsutils.unionTypeParts(thenType)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _subType = _step3.value;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = _subType.getCallSignatures()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var signature = _step4.value;

              if (signature.parameters.length !== 0 && isFunctionParam(checker, signature.parameters[0], node)) {
                hasThenableSignature = true;
                break;
              }
            } // We only need to find one variant of the then property that has a
            // function signature for it to be thenable.

          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          if (hasThenableSignature) {
            break;
          }
        } // If no flavors of the then property are thenable, we don't consider the
        // overall type to be thenable

      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (!hasThenableSignature) {
        return false;
      }
    } // If all variants are considered thenable (i.e. haven't returned false), we
    // consider the overall type thenable

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return true;
}

function isFunctionParam(checker, param, node) {
  var type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = tsutils.unionTypeParts(type)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var subType = _step5.value;

      if (subType.getCallSignatures().length !== 0) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return false;
} // Get the positions of parameters which are void functions (and not also
// thenable functions). These are the candidates for the void-return check at
// the current call site.


function voidFunctionParams(checker, node) {
  var voidReturnIndices = new Set();
  var thenableReturnIndices = new Set();
  var type = checker.getTypeAtLocation(node.expression);
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = tsutils.unionTypeParts(type)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var subType = _step6.value;
      // Standard function calls and `new` have two different types of signatures
      var signatures = ts.isCallExpression(node) ? subType.getCallSignatures() : subType.getConstructSignatures();
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = signatures[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var signature = _step8.value;
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = signature.parameters.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var _step9$value = _slicedToArray(_step9.value, 2),
                  index = _step9$value[0],
                  parameter = _step9$value[1];

              var _type = checker.getTypeOfSymbolAtLocation(parameter, node.expression);

              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = tsutils.unionTypeParts(_type)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var _subType2 = _step10.value;
                  var _iteratorNormalCompletion11 = true;
                  var _didIteratorError11 = false;
                  var _iteratorError11 = undefined;

                  try {
                    for (var _iterator11 = _subType2.getCallSignatures()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                      var _signature = _step11.value;

                      var returnType = _signature.getReturnType();

                      if (tsutils.isTypeFlagSet(returnType, ts.TypeFlags.Void)) {
                        voidReturnIndices.add(index);
                      } else if (tsutils.isThenableType(checker, node.expression, returnType)) {
                        thenableReturnIndices.add(index);
                      }
                    }
                  } catch (err) {
                    _didIteratorError11 = true;
                    _iteratorError11 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                        _iterator11["return"]();
                      }
                    } finally {
                      if (_didIteratorError11) {
                        throw _iteratorError11;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                    _iterator10["return"]();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                _iterator9["return"]();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    } // If a certain positional argument accepts both thenable and void returns,
    // a promise-returning function is valid

  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = thenableReturnIndices[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var thenable = _step7.value;
      voidReturnIndices["delete"](thenable);
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  return voidReturnIndices;
} // Returns true if the expression is a function that returns a thenable


function returnsThenable(checker, node) {
  var type = checker.getApparentType(checker.getTypeAtLocation(node));
  var _iteratorNormalCompletion12 = true;
  var _didIteratorError12 = false;
  var _iteratorError12 = undefined;

  try {
    for (var _iterator12 = tsutils.unionTypeParts(type)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
      var subType = _step12.value;
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = subType.getCallSignatures()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var signature = _step13.value;
          var returnType = signature.getReturnType();

          if (tsutils.isThenableType(checker, node, returnType)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError12 = true;
    _iteratorError12 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
        _iterator12["return"]();
      }
    } finally {
      if (_didIteratorError12) {
        throw _iteratorError12;
      }
    }
  }

  return false;
}