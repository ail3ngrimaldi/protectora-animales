"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

var printNodeModifiers = function printNodeModifiers(node, _final) {
  var _a;

  return "".concat((_a = node.accessibility) !== null && _a !== void 0 ? _a : '').concat(node["static"] ? ' static' : '', " ").concat(_final, " ").trimLeft();
};

var isSupportedLiteral = function isSupportedLiteral(node) {
  if (node.type === experimental_utils_1.AST_NODE_TYPES.Literal || node.type === experimental_utils_1.AST_NODE_TYPES.BigIntLiteral) {
    return true;
  }

  if (node.type === experimental_utils_1.AST_NODE_TYPES.TaggedTemplateExpression || node.type === experimental_utils_1.AST_NODE_TYPES.TemplateLiteral) {
    return ('quasi' in node ? node.quasi.quasis : node.quasis).length === 1;
  }

  return false;
};

exports["default"] = util.createRule({
  name: 'class-literal-property-style',
  meta: {
    type: 'problem',
    docs: {
      description: 'Ensures that literals on classes are exposed in a consistent style',
      category: 'Best Practices',
      recommended: false
    },
    fixable: 'code',
    messages: {
      preferFieldStyle: 'Literals should be exposed using readonly fields.',
      preferGetterStyle: 'Literals should be exposed using getters.'
    },
    schema: [{
      "enum": ['fields', 'getters']
    }]
  },
  defaultOptions: ['fields'],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        style = _ref2[0];

    if (style === 'fields') {
      return {
        MethodDefinition: function MethodDefinition(node) {
          if (node.kind !== 'get' || !node.value.body || !node.value.body.body.length) {
            return;
          }

          var _node$value$body$body = _slicedToArray(node.value.body.body, 1),
              statement = _node$value$body$body[0];

          if (statement.type !== experimental_utils_1.AST_NODE_TYPES.ReturnStatement) {
            return;
          }

          var argument = statement.argument;

          if (!argument || !isSupportedLiteral(argument)) {
            return;
          }

          context.report({
            node: node.key,
            messageId: 'preferFieldStyle',
            fix: function fix(fixer) {
              var sourceCode = context.getSourceCode();
              var name = sourceCode.getText(node.key);
              var text = '';
              text += printNodeModifiers(node, 'readonly');
              text += node.computed ? "[".concat(name, "]") : name;
              text += " = ".concat(sourceCode.getText(argument), ";");
              return fixer.replaceText(node, text);
            }
          });
        }
      };
    }

    return {
      ClassProperty: function ClassProperty(node) {
        if (!node.readonly || node.declare) {
          return;
        }

        var value = node.value;

        if (!value || !isSupportedLiteral(value)) {
          return;
        }

        context.report({
          node: node.key,
          messageId: 'preferGetterStyle',
          fix: function fix(fixer) {
            var sourceCode = context.getSourceCode();
            var name = sourceCode.getText(node.key);
            var text = '';
            text += printNodeModifiers(node, 'get');
            text += node.computed ? "[".concat(name, "]") : name;
            text += "() { return ".concat(sourceCode.getText(value), "; }");
            return fixer.replaceText(node, text);
          }
        });
      }
    };
  }
});