"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

var definition = {
  type: 'object',
  properties: {
    multiline: {
      type: 'object',
      properties: {
        delimiter: {
          "enum": ['none', 'semi', 'comma']
        },
        requireLast: {
          type: 'boolean'
        }
      },
      additionalProperties: false
    },
    singleline: {
      type: 'object',
      properties: {
        // note can't have "none" for single line delimiter as it's invalid syntax
        delimiter: {
          "enum": ['semi', 'comma']
        },
        requireLast: {
          type: 'boolean'
        }
      },
      additionalProperties: false
    }
  },
  additionalProperties: false
};
exports["default"] = util.createRule({
  name: 'member-delimiter-style',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Require a specific member delimiter style for interfaces and type literals',
      category: 'Stylistic Issues',
      recommended: 'error'
    },
    fixable: 'code',
    messages: {
      unexpectedComma: 'Unexpected separator (,).',
      unexpectedSemi: 'Unexpected separator (;).',
      expectedComma: 'Expected a comma.',
      expectedSemi: 'Expected a semicolon.'
    },
    schema: [{
      type: 'object',
      properties: Object.assign({}, definition.properties, {
        overrides: {
          type: 'object',
          properties: {
            "interface": definition,
            typeLiteral: definition
          },
          additionalProperties: false
        }
      }),
      additionalProperties: false
    }]
  },
  defaultOptions: [{
    multiline: {
      delimiter: 'semi',
      requireLast: true
    },
    singleline: {
      delimiter: 'semi',
      requireLast: false
    }
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        options = _ref2[0];

    var _a;

    var sourceCode = context.getSourceCode(); // use the base options as the defaults for the cases

    var baseOptions = options;
    var overrides = (_a = baseOptions.overrides) !== null && _a !== void 0 ? _a : {};
    var interfaceOptions = util.deepMerge(baseOptions, overrides["interface"]);
    var typeLiteralOptions = util.deepMerge(baseOptions, overrides.typeLiteral);
    /**
     * Check the last token in the given member.
     * @param member the member to be evaluated.
     * @param opts the options to be validated.
     * @param isLast a flag indicating `member` is the last in the interface or type literal.
     */

    function checkLastToken(member, opts, isLast) {
      /**
       * Resolves the boolean value for the given setting enum value
       * @param type the option name
       */
      function getOption(type) {
        if (isLast && !opts.requireLast) {
          // only turn the option on if its expecting no delimiter for the last member
          return type === 'none';
        }

        return opts.delimiter === type;
      }

      var messageId = null;
      var missingDelimiter = false;
      var lastToken = sourceCode.getLastToken(member, {
        includeComments: false
      });

      if (!lastToken) {
        return;
      }

      var optsSemi = getOption('semi');
      var optsComma = getOption('comma');
      var optsNone = getOption('none');

      if (lastToken.value === ';') {
        if (optsComma) {
          messageId = 'expectedComma';
        } else if (optsNone) {
          missingDelimiter = true;
          messageId = 'unexpectedSemi';
        }
      } else if (lastToken.value === ',') {
        if (optsSemi) {
          messageId = 'expectedSemi';
        } else if (optsNone) {
          missingDelimiter = true;
          messageId = 'unexpectedComma';
        }
      } else {
        if (optsSemi) {
          missingDelimiter = true;
          messageId = 'expectedSemi';
        } else if (optsComma) {
          missingDelimiter = true;
          messageId = 'expectedComma';
        }
      }

      if (messageId) {
        context.report({
          node: lastToken,
          loc: {
            start: {
              line: lastToken.loc.end.line,
              column: lastToken.loc.end.column
            },
            end: {
              line: lastToken.loc.end.line,
              column: lastToken.loc.end.column
            }
          },
          messageId: messageId,
          fix: function fix(fixer) {
            if (optsNone) {
              // remove the unneeded token
              return fixer.remove(lastToken);
            }

            var token = optsSemi ? ';' : ',';

            if (missingDelimiter) {
              // add the missing delimiter
              return fixer.insertTextAfter(lastToken, token);
            } // correct the current delimiter


            return fixer.replaceText(lastToken, token);
          }
        });
      }
    }
    /**
     * Check the member separator being used matches the delimiter.
     * @param {ASTNode} node the node to be evaluated.
     */


    function checkMemberSeparatorStyle(node) {
      var isSingleLine = node.loc.start.line === node.loc.end.line;
      var members = node.type === experimental_utils_1.AST_NODE_TYPES.TSInterfaceBody ? node.body : node.members;
      var typeOpts = node.type === experimental_utils_1.AST_NODE_TYPES.TSInterfaceBody ? interfaceOptions : typeLiteralOptions;
      var opts = isSingleLine ? typeOpts.singleline : typeOpts.multiline;
      members.forEach(function (member, index) {
        checkLastToken(member, opts !== null && opts !== void 0 ? opts : {}, index === members.length - 1);
      });
    }

    return {
      TSInterfaceBody: checkMemberSeparatorStyle,
      TSTypeLiteral: checkMemberSeparatorStyle
    };
  }
});