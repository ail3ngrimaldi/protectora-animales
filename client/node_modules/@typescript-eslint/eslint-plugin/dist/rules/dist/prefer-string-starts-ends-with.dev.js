"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var regexpp_1 = require("regexpp");

var util_1 = require("../util");

var EQ_OPERATORS = /^[=!]=/;
var regexpp = new regexpp_1.RegExpParser();
exports["default"] = util_1.createRule({
  name: 'prefer-string-starts-ends-with',
  defaultOptions: [],
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforce the use of `String#startsWith` and `String#endsWith` instead of other equivalent methods of checking substrings',
      category: 'Best Practices',
      recommended: 'error',
      requiresTypeChecking: true
    },
    messages: {
      preferStartsWith: "Use 'String#startsWith' method instead.",
      preferEndsWith: "Use the 'String#endsWith' method instead."
    },
    schema: [],
    fixable: 'code'
  },
  create: function create(context) {
    var _ref;

    var _marked =
    /*#__PURE__*/
    regeneratorRuntime.mark(fixWithRightOperand),
        _marked2 =
    /*#__PURE__*/
    regeneratorRuntime.mark(fixWithArgument);

    var globalScope = context.getScope();
    var sourceCode = context.getSourceCode();
    var service = util_1.getParserServices(context);
    var typeChecker = service.program.getTypeChecker();
    /**
     * Check if a given node is a string.
     * @param node The node to check.
     */

    function isStringType(node) {
      var objectType = typeChecker.getTypeAtLocation(service.esTreeNodeToTSNodeMap.get(node));
      return util_1.getTypeName(typeChecker, objectType) === 'string';
    }
    /**
     * Check if a given node is a `Literal` node that is null.
     * @param node The node to check.
     */


    function isNull(node) {
      var evaluated = util_1.getStaticValue(node, globalScope);
      return evaluated != null && evaluated.value === null;
    }
    /**
     * Check if a given node is a `Literal` node that is a given value.
     * @param node The node to check.
     * @param value The expected value of the `Literal` node.
     */


    function isNumber(node, value) {
      var evaluated = util_1.getStaticValue(node, globalScope);
      return evaluated != null && evaluated.value === value;
    }
    /**
     * Check if a given node is a `Literal` node that is a character.
     * @param node The node to check.
     * @param kind The method name to get a character.
     */


    function isCharacter(node) {
      var evaluated = util_1.getStaticValue(node, globalScope);
      return evaluated != null && typeof evaluated.value === 'string' && // checks if the string is a character long
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      evaluated.value[0] === evaluated.value;
    }
    /**
     * Check if a given node is `==`, `===`, `!=`, or `!==`.
     * @param node The node to check.
     */


    function isEqualityComparison(node) {
      return node.type === experimental_utils_1.AST_NODE_TYPES.BinaryExpression && EQ_OPERATORS.test(node.operator);
    }
    /**
     * Check if two given nodes are the same meaning.
     * @param node1 A node to compare.
     * @param node2 Another node to compare.
     */


    function isSameTokens(node1, node2) {
      var tokens1 = sourceCode.getTokens(node1);
      var tokens2 = sourceCode.getTokens(node2);

      if (tokens1.length !== tokens2.length) {
        return false;
      }

      for (var i = 0; i < tokens1.length; ++i) {
        var token1 = tokens1[i];
        var token2 = tokens2[i];

        if (token1.type !== token2.type || token1.value !== token2.value) {
          return false;
        }
      }

      return true;
    }
    /**
     * Check if a given node is the expression of the length of a string.
     *
     * - If `length` property access of `expectedObjectNode`, it's `true`.
     *   E.g., `foo` → `foo.length` / `"foo"` → `"foo".length`
     * - If `expectedObjectNode` is a string literal, `node` can be a number.
     *   E.g., `"foo"` → `3`
     *
     * @param node The node to check.
     * @param expectedObjectNode The node which is expected as the receiver of `length` property.
     */


    function isLengthExpression(node, expectedObjectNode) {
      if (node.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression || node.type === experimental_utils_1.AST_NODE_TYPES.OptionalMemberExpression) {
        return util_1.getPropertyName(node, globalScope) === 'length' && isSameTokens(node.object, expectedObjectNode);
      }

      var evaluatedLength = util_1.getStaticValue(node, globalScope);
      var evaluatedString = util_1.getStaticValue(expectedObjectNode, globalScope);
      return evaluatedLength != null && evaluatedString != null && typeof evaluatedLength.value === 'number' && typeof evaluatedString.value === 'string' && evaluatedLength.value === evaluatedString.value.length;
    }
    /**
     * Check if a given node is a negative index expression
     *
     * E.g. `s.slice(- <expr>)`, `s.substring(s.length - <expr>)`
     *
     * @param node The node to check.
     * @param expectedIndexedNode The node which is expected as the receiver of index expression.
     */


    function isNegativeIndexExpression(node, expectedIndexedNode) {
      return node.type === experimental_utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '-' || node.type === experimental_utils_1.AST_NODE_TYPES.BinaryExpression && node.operator === '-' && isLengthExpression(node.left, expectedIndexedNode);
    }
    /**
     * Check if a given node is the expression of the last index.
     *
     * E.g. `foo.length - 1`
     *
     * @param node The node to check.
     * @param expectedObjectNode The node which is expected as the receiver of `length` property.
     */


    function isLastIndexExpression(node, expectedObjectNode) {
      return node.type === experimental_utils_1.AST_NODE_TYPES.BinaryExpression && node.operator === '-' && isLengthExpression(node.left, expectedObjectNode) && isNumber(node.right, 1);
    }
    /**
     * Get the range of the property of a given `MemberExpression` node.
     *
     * - `obj[foo]` → the range of `[foo]`
     * - `obf.foo` → the range of `.foo`
     * - `(obj).foo` → the range of `.foo`
     *
     * @param node The member expression node to get.
     */


    function getPropertyRange(node) {
      var dotOrOpenBracket = sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken);
      return [dotOrOpenBracket.range[0], node.range[1]];
    }
    /**
     * Parse a given `RegExp` pattern to that string if it's a static string.
     * @param pattern The RegExp pattern text to parse.
     * @param uFlag The Unicode flag of the RegExp.
     */


    function parseRegExpText(pattern, uFlag) {
      // Parse it.
      var ast = regexpp.parsePattern(pattern, undefined, undefined, uFlag);

      if (ast.alternatives.length !== 1) {
        return null;
      } // Drop `^`/`$` assertion.


      var chars = ast.alternatives[0].elements;
      var first = chars[0];

      if (first.type === 'Assertion' && first.kind === 'start') {
        chars.shift();
      } else {
        chars.pop();
      } // Check if it can determine a unique string.


      if (!chars.every(function (c) {
        return c.type === 'Character';
      })) {
        return null;
      } // To string.


      return String.fromCodePoint.apply(String, _toConsumableArray(chars.map(function (c) {
        return c.value;
      })));
    }
    /**
     * Parse a given node if it's a `RegExp` instance.
     * @param node The node to parse.
     */


    function parseRegExp(node) {
      var evaluated = util_1.getStaticValue(node, globalScope);

      if (evaluated == null || !(evaluated.value instanceof RegExp)) {
        return null;
      }

      var _evaluated$value = evaluated.value,
          source = _evaluated$value.source,
          flags = _evaluated$value.flags;
      var isStartsWith = source.startsWith('^');
      var isEndsWith = source.endsWith('$');

      if (isStartsWith === isEndsWith || flags.includes('i') || flags.includes('m')) {
        return null;
      }

      var text = parseRegExpText(source, flags.includes('u'));

      if (text == null) {
        return null;
      }

      return {
        isEndsWith: isEndsWith,
        isStartsWith: isStartsWith,
        text: text
      };
    }
    /**
     * Fix code with using the right operand as the search string.
     * For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')`
     * @param fixer The rule fixer.
     * @param node The node which was reported.
     * @param kind The kind of the report.
     * @param isNegative The flag to fix to negative condition.
     */


    function fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {
      var leftNode, propertyRange;
      return regeneratorRuntime.wrap(function fixWithRightOperand$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // left is CallExpression or MemberExpression.
              leftNode = node.left.type === experimental_utils_1.AST_NODE_TYPES.CallExpression || node.left.type === experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression ? node.left.callee : node.left;
              propertyRange = getPropertyRange(leftNode);

              if (!isNegative) {
                _context.next = 5;
                break;
              }

              _context.next = 5;
              return fixer.insertTextBefore(node, '!');

            case 5:
              _context.next = 7;
              return fixer.replaceTextRange([propertyRange[0], node.right.range[0]], "".concat(isOptional ? '?.' : '.').concat(kind, "sWith("));

            case 7:
              _context.next = 9;
              return fixer.replaceTextRange([node.right.range[1], node.range[1]], ')');

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _marked);
    }
    /**
     * Fix code with using the first argument as the search string.
     * For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')`
     * @param fixer The rule fixer.
     * @param node The node which was reported.
     * @param kind The kind of the report.
     * @param negative The flag to fix to negative condition.
     */


    function fixWithArgument(fixer, node, kind, negative, isOptional) {
      var callNode, calleeNode;
      return regeneratorRuntime.wrap(function fixWithArgument$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              callNode = node.left;
              calleeNode = callNode.callee;

              if (!negative) {
                _context2.next = 5;
                break;
              }

              _context2.next = 5;
              return fixer.insertTextBefore(node, '!');

            case 5:
              _context2.next = 7;
              return fixer.replaceTextRange(getPropertyRange(calleeNode), "".concat(isOptional ? '?.' : '.').concat(kind, "sWith"));

            case 7:
              _context2.next = 9;
              return fixer.removeRange([callNode.range[1], node.range[1]]);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _marked2);
    }

    return _ref = {}, _defineProperty(_ref, ['BinaryExpression > :matches(MemberExpression, OptionalMemberExpression).left[computed=true]', 'BinaryExpression > :matches(CallExpression, OptionalCallExpression).left > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="charAt"][computed=false]'].join(', '), function (node) {
      var parentNode = node.parent;
      var indexNode = null;

      if (parentNode.type === experimental_utils_1.AST_NODE_TYPES.CallExpression || parentNode.type === experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression) {
        if (parentNode.arguments.length === 1) {
          indexNode = parentNode.arguments[0];
        }

        parentNode = parentNode.parent;
      } else {
        indexNode = node.property;
      }

      if (indexNode == null || !isEqualityComparison(parentNode) || !isStringType(node.object)) {
        return;
      }

      var isEndsWith = isLastIndexExpression(indexNode, node.object);
      var isStartsWith = !isEndsWith && isNumber(indexNode, 0);

      if (!isStartsWith && !isEndsWith) {
        return;
      }

      var eqNode = parentNode;
      context.report({
        node: parentNode,
        messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',
        fix: function fix(fixer) {
          // Don't fix if it can change the behavior.
          if (!isCharacter(eqNode.right)) {
            return null;
          }

          return fixWithRightOperand(fixer, eqNode, isStartsWith ? 'start' : 'end', eqNode.operator.startsWith('!'), node.optional);
        }
      });
    }), _defineProperty(_ref, 'BinaryExpression > :matches(CallExpression, OptionalCallExpression).left > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="indexOf"][computed=false]', function BinaryExpressionMatchesCallExpressionOptionalCallExpressionLeftMatchesMemberExpressionOptionalMemberExpressionCalleePropertyNameIndexOfComputedFalse(node) {
      var callNode = node.parent;
      var parentNode = callNode.parent;

      if (callNode.arguments.length !== 1 || !isEqualityComparison(parentNode) || parentNode.left !== callNode || !isNumber(parentNode.right, 0) || !isStringType(node.object)) {
        return;
      }

      context.report({
        node: parentNode,
        messageId: 'preferStartsWith',
        fix: function fix(fixer) {
          return fixWithArgument(fixer, parentNode, 'start', parentNode.operator.startsWith('!'), node.optional);
        }
      });
    }), _defineProperty(_ref, 'BinaryExpression > :matches(CallExpression, OptionalCallExpression).left > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="lastIndexOf"][computed=false]', function BinaryExpressionMatchesCallExpressionOptionalCallExpressionLeftMatchesMemberExpressionOptionalMemberExpressionCalleePropertyNameLastIndexOfComputedFalse(node) {
      var callNode = node.parent;
      var parentNode = callNode.parent;

      if (callNode.arguments.length !== 1 || !isEqualityComparison(parentNode) || parentNode.left !== callNode || parentNode.right.type !== experimental_utils_1.AST_NODE_TYPES.BinaryExpression || parentNode.right.operator !== '-' || !isLengthExpression(parentNode.right.left, node.object) || !isLengthExpression(parentNode.right.right, callNode.arguments[0]) || !isStringType(node.object)) {
        return;
      }

      context.report({
        node: parentNode,
        messageId: 'preferEndsWith',
        fix: function fix(fixer) {
          return fixWithArgument(fixer, parentNode, 'end', parentNode.operator.startsWith('!'), node.optional);
        }
      });
    }), _defineProperty(_ref, 'BinaryExpression > :matches(CallExpression, OptionalCallExpression).left > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="match"][computed=false]', function BinaryExpressionMatchesCallExpressionOptionalCallExpressionLeftMatchesMemberExpressionOptionalMemberExpressionCalleePropertyNameMatchComputedFalse(node) {
      var callNode = node.parent;
      var parentNode = callNode.parent;

      if (!isEqualityComparison(parentNode) || !isNull(parentNode.right) || !isStringType(node.object)) {
        return;
      }

      var parsed = callNode.arguments.length === 1 ? parseRegExp(callNode.arguments[0]) : null;

      if (parsed == null) {
        return;
      }

      var isStartsWith = parsed.isStartsWith,
          text = parsed.text;
      context.report({
        node: callNode,
        messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',
        fix:
        /*#__PURE__*/
        regeneratorRuntime.mark(function fix(fixer) {
          return regeneratorRuntime.wrap(function fix$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (parentNode.operator.startsWith('!')) {
                    _context3.next = 3;
                    break;
                  }

                  _context3.next = 3;
                  return fixer.insertTextBefore(parentNode, '!');

                case 3:
                  _context3.next = 5;
                  return fixer.replaceTextRange(getPropertyRange(node), "".concat(node.optional ? '?.' : '.').concat(isStartsWith ? 'start' : 'end', "sWith"));

                case 5:
                  _context3.next = 7;
                  return fixer.replaceText(callNode.arguments[0], JSON.stringify(text));

                case 7:
                  _context3.next = 9;
                  return fixer.removeRange([callNode.range[1], parentNode.range[1]]);

                case 9:
                case "end":
                  return _context3.stop();
              }
            }
          }, fix);
        })
      });
    }), _defineProperty(_ref, [':matches(CallExpression, OptionalCallExpression) > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="slice"][computed=false]', ':matches(CallExpression, OptionalCallExpression) > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="substring"][computed=false]'].join(', '), function (node) {
      var callNode = node.parent;
      var parentNode = callNode.parent;

      if (!isEqualityComparison(parentNode) || parentNode.left !== callNode || !isStringType(node.object)) {
        return;
      }

      var isEndsWith = (callNode.arguments.length === 1 || callNode.arguments.length === 2 && isLengthExpression(callNode.arguments[1], node.object)) && isNegativeIndexExpression(callNode.arguments[0], node.object);
      var isStartsWith = !isEndsWith && callNode.arguments.length === 2 && isNumber(callNode.arguments[0], 0);

      if (!isStartsWith && !isEndsWith) {
        return;
      }

      var eqNode = parentNode;
      var negativeIndexSupported = node.property.name === 'slice';
      context.report({
        node: parentNode,
        messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',
        fix: function fix(fixer) {
          // Don't fix if it can change the behavior.
          if (eqNode.operator.length === 2 && (eqNode.right.type !== experimental_utils_1.AST_NODE_TYPES.Literal || typeof eqNode.right.value !== 'string')) {
            return null;
          } // code being checked is likely mistake:
          // unequal length of strings being checked for equality
          // or reliant on behavior of substring (negative indices interpreted as 0)


          if (isStartsWith) {
            if (!isLengthExpression(callNode.arguments[1], eqNode.right)) {
              return null;
            }
          } else {
            var posNode = callNode.arguments[0];
            var posNodeIsAbsolutelyValid = posNode.type === experimental_utils_1.AST_NODE_TYPES.BinaryExpression && posNode.operator === '-' && isLengthExpression(posNode.left, node.object) && isLengthExpression(posNode.right, eqNode.right) || negativeIndexSupported && posNode.type === experimental_utils_1.AST_NODE_TYPES.UnaryExpression && posNode.operator === '-' && isLengthExpression(posNode.argument, eqNode.right);

            if (!posNodeIsAbsolutelyValid) {
              return null;
            }
          }

          return fixWithRightOperand(fixer, parentNode, isStartsWith ? 'start' : 'end', parentNode.operator.startsWith('!'), node.optional);
        }
      });
    }), _defineProperty(_ref, ':matches(CallExpression, OptionalCallExpression) > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="test"][computed=false]', function matchesCallExpressionOptionalCallExpressionMatchesMemberExpressionOptionalMemberExpressionCalleePropertyNameTestComputedFalse(node) {
      var callNode = node.parent;
      var parsed = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;

      if (parsed == null) {
        return;
      }

      var isStartsWith = parsed.isStartsWith,
          text = parsed.text;
      var messageId = isStartsWith ? 'preferStartsWith' : 'preferEndsWith';
      var methodName = isStartsWith ? 'startsWith' : 'endsWith';
      context.report({
        node: callNode,
        messageId: messageId,
        fix:
        /*#__PURE__*/
        regeneratorRuntime.mark(function fix(fixer) {
          var argNode, needsParen;
          return regeneratorRuntime.wrap(function fix$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  argNode = callNode.arguments[0];
                  needsParen = argNode.type !== experimental_utils_1.AST_NODE_TYPES.Literal && argNode.type !== experimental_utils_1.AST_NODE_TYPES.TemplateLiteral && argNode.type !== experimental_utils_1.AST_NODE_TYPES.Identifier && argNode.type !== experimental_utils_1.AST_NODE_TYPES.MemberExpression && argNode.type !== experimental_utils_1.AST_NODE_TYPES.OptionalMemberExpression && argNode.type !== experimental_utils_1.AST_NODE_TYPES.CallExpression && argNode.type !== experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression;
                  _context4.next = 4;
                  return fixer.removeRange([callNode.range[0], argNode.range[0]]);

                case 4:
                  if (!needsParen) {
                    _context4.next = 9;
                    break;
                  }

                  _context4.next = 7;
                  return fixer.insertTextBefore(argNode, '(');

                case 7:
                  _context4.next = 9;
                  return fixer.insertTextAfter(argNode, ')');

                case 9:
                  _context4.next = 11;
                  return fixer.insertTextAfter(argNode, "".concat(callNode.type === experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression ? '?.' : '.').concat(methodName, "(").concat(JSON.stringify(text)));

                case 11:
                case "end":
                  return _context4.stop();
              }
            }
          }, fix);
        })
      });
    }), _ref;
  }
});