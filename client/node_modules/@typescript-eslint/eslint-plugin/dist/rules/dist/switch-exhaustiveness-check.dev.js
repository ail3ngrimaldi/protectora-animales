"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var ts = __importStar(require("typescript"));

var util_1 = require("../util");

var tsutils_1 = require("tsutils");

exports["default"] = util_1.createRule({
  name: 'switch-exhaustiveness-check',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Exhaustiveness checking in switch with union type',
      category: 'Best Practices',
      recommended: false,
      suggestion: true,
      requiresTypeChecking: true
    },
    schema: [],
    messages: {
      switchIsNotExhaustive: 'Switch is not exhaustive. Cases not matched: {{missingBranches}}',
      addMissingCases: 'Add branches for missing cases.'
    }
  },
  defaultOptions: [],
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    var service = util_1.getParserServices(context);
    var checker = service.program.getTypeChecker();

    function getNodeType(node) {
      var tsNode = service.esTreeNodeToTSNodeMap.get(node);
      return util_1.getConstrainedTypeAtLocation(checker, tsNode);
    }

    function fixSwitch(fixer, node, missingBranchTypes) {
      var lastCase = node.cases.length > 0 ? node.cases[node.cases.length - 1] : null;
      var caseIndent = lastCase ? ' '.repeat(lastCase.loc.start.column) : // if there are no cases, use indentation of the switch statement
      // and leave it to user to format it correctly
      ' '.repeat(node.loc.start.column);
      var missingCases = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = missingBranchTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var missingBranchType = _step.value;

          // While running this rule on checker.ts of TypeScript project
          // the fix introduced a compiler error due to:
          //
          // type __String = (string & {
          //         __escapedIdentifier: void;
          //     }) | (void & {
          //         __escapedIdentifier: void;
          //     }) | InternalSymbolName;
          //
          // The following check fixes it.
          if (missingBranchType.isIntersection()) {
            continue;
          }

          var caseTest = checker.typeToString(missingBranchType);
          var errorMessage = "Not implemented yet: ".concat(caseTest, " case");
          missingCases.push("case ".concat(caseTest, ": { throw new Error('").concat(errorMessage, "') }"));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var fixString = missingCases.map(function (code) {
        return "".concat(caseIndent).concat(code);
      }).join('\n');

      if (lastCase) {
        return fixer.insertTextAfter(lastCase, "\n".concat(fixString));
      } // there were no existing cases


      var openingBrace = sourceCode.getTokenAfter(node.discriminant, util_1.isOpeningBraceToken);
      var closingBrace = sourceCode.getTokenAfter(node.discriminant, util_1.isClosingBraceToken);
      return fixer.replaceTextRange([openingBrace.range[0], closingBrace.range[1]], ['{', fixString, "".concat(caseIndent, "}")].join('\n'));
    }

    function checkSwitchExhaustive(node) {
      var discriminantType = getNodeType(node.discriminant);

      if (discriminantType.isUnion()) {
        var unionTypes = tsutils_1.unionTypeParts(discriminantType);
        var caseTypes = new Set();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = node.cases[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var switchCase = _step2.value;

            if (switchCase.test === null) {
              // Switch has 'default' branch - do nothing.
              return;
            }

            caseTypes.add(getNodeType(switchCase.test));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var missingBranchTypes = unionTypes.filter(function (unionType) {
          return !caseTypes.has(unionType);
        });

        if (missingBranchTypes.length === 0) {
          // All cases matched - do nothing.
          return;
        }

        context.report({
          node: node.discriminant,
          messageId: 'switchIsNotExhaustive',
          data: {
            missingBranches: missingBranchTypes.map(function (missingType) {
              var _a;

              return tsutils_1.isTypeFlagSet(missingType, ts.TypeFlags.ESSymbolLike) ? "typeof ".concat((_a = missingType.getSymbol()) === null || _a === void 0 ? void 0 : _a.escapedName) : checker.typeToString(missingType);
            }).join(' | ')
          },
          suggest: [{
            messageId: 'addMissingCases',
            fix: function fix(fixer) {
              return fixSwitch(fixer, node, missingBranchTypes);
            }
          }]
        });
      }
    }

    return {
      SwitchStatement: checkSwitchExhaustive
    };
  }
});