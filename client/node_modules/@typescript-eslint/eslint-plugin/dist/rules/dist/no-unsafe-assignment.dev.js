"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'no-unsafe-assignment',
  meta: {
    type: 'problem',
    docs: {
      description: 'Disallows assigning any to variables and properties',
      category: 'Possible Errors',
      recommended: false,
      requiresTypeChecking: true
    },
    messages: {
      anyAssignment: 'Unsafe assignment of an any value.',
      unsafeArrayPattern: 'Unsafe array destructuring of an any array value.',
      unsafeArrayPatternFromTuple: 'Unsafe array destructuring of a tuple element with an any value.',
      unsafeAssignment: 'Unsafe asignment of type {{sender}} to a variable of type {{receiver}}.',
      unsafeArraySpread: 'Unsafe spread of an any value in an array.'
    },
    schema: []
  },
  defaultOptions: [],
  create: function create(context) {
    var _util$getParserServic = util.getParserServices(context),
        program = _util$getParserServic.program,
        esTreeNodeToTSNodeMap = _util$getParserServic.esTreeNodeToTSNodeMap;

    var checker = program.getTypeChecker(); // returns true if the assignment reported

    function checkArrayDestructureHelper(receiverNode, senderNode) {
      if (receiverNode.type !== experimental_utils_1.AST_NODE_TYPES.ArrayPattern) {
        return false;
      }

      var senderTsNode = esTreeNodeToTSNodeMap.get(senderNode);
      var senderType = checker.getTypeAtLocation(senderTsNode);
      return checkArrayDestructure(receiverNode, senderType, senderTsNode);
    } // returns true if the assignment reported


    function checkArrayDestructure(receiverNode, senderType, senderNode) {
      // any array
      // const [x] = ([] as any[]);
      if (util.isTypeAnyArrayType(senderType, checker)) {
        context.report({
          node: receiverNode,
          messageId: 'unsafeArrayPattern'
        });
        return false;
      }

      if (!checker.isTupleType(senderType)) {
        return true;
      }

      var tupleElements = util.getTypeArguments(senderType, checker); // tuple with any
      // const [x] = [1 as any];

      var didReport = false;

      for (var receiverIndex = 0; receiverIndex < receiverNode.elements.length; receiverIndex += 1) {
        var receiverElement = receiverNode.elements[receiverIndex];

        if (!receiverElement) {
          continue;
        }

        if (receiverElement.type === experimental_utils_1.AST_NODE_TYPES.RestElement) {
          // don't handle rests as they're not a 1:1 assignment
          continue;
        }

        var _senderType = tupleElements[receiverIndex];

        if (!_senderType) {
          continue;
        } // check for the any type first so we can handle [[[x]]] = [any]


        if (util.isTypeAnyType(_senderType)) {
          context.report({
            node: receiverElement,
            messageId: 'unsafeArrayPatternFromTuple'
          }); // we want to report on every invalid element in the tuple

          didReport = true;
        } else if (receiverElement.type === experimental_utils_1.AST_NODE_TYPES.ArrayPattern) {
          didReport = checkArrayDestructure(receiverElement, _senderType, senderNode);
        } else if (receiverElement.type === experimental_utils_1.AST_NODE_TYPES.ObjectPattern) {
          didReport = checkObjectDestructure(receiverElement, _senderType, senderNode);
        }
      }

      return didReport;
    } // returns true if the assignment reported


    function checkObjectDestructureHelper(receiverNode, senderNode) {
      if (receiverNode.type !== experimental_utils_1.AST_NODE_TYPES.ObjectPattern) {
        return false;
      }

      var senderTsNode = esTreeNodeToTSNodeMap.get(senderNode);
      var senderType = checker.getTypeAtLocation(senderTsNode);
      return checkObjectDestructure(receiverNode, senderType, senderTsNode);
    } // returns true if the assignment reported


    function checkObjectDestructure(receiverNode, senderType, senderNode) {
      var properties = new Map(senderType.getProperties().map(function (property) {
        return [property.getName(), checker.getTypeOfSymbolAtLocation(property, senderNode)];
      }));
      var didReport = false;

      for (var receiverIndex = 0; receiverIndex < receiverNode.properties.length; receiverIndex += 1) {
        var receiverProperty = receiverNode.properties[receiverIndex];

        if (receiverProperty.type === experimental_utils_1.AST_NODE_TYPES.RestElement) {
          // don't bother checking rest
          continue;
        }

        var key = void 0;

        if (receiverProperty.computed === false) {
          key = receiverProperty.key.type === experimental_utils_1.AST_NODE_TYPES.Identifier ? receiverProperty.key.name : String(receiverProperty.key.value);
        } else if (receiverProperty.key.type === experimental_utils_1.AST_NODE_TYPES.Literal) {
          key = String(receiverProperty.key.value);
        } else if (receiverProperty.key.type === experimental_utils_1.AST_NODE_TYPES.TemplateLiteral && receiverProperty.key.quasis.length === 1) {
          key = String(receiverProperty.key.quasis[0].value.cooked);
        } else {
          // can't figure out the name, so skip it
          continue;
        }

        var _senderType2 = properties.get(key);

        if (!_senderType2) {
          continue;
        } // check for the any type first so we can handle {x: {y: z}} = {x: any}


        if (util.isTypeAnyType(_senderType2)) {
          context.report({
            node: receiverProperty.value,
            messageId: 'unsafeArrayPatternFromTuple'
          });
          didReport = true;
        } else if (receiverProperty.value.type === experimental_utils_1.AST_NODE_TYPES.ArrayPattern) {
          didReport = checkArrayDestructure(receiverProperty.value, _senderType2, senderNode);
        } else if (receiverProperty.value.type === experimental_utils_1.AST_NODE_TYPES.ObjectPattern) {
          didReport = checkObjectDestructure(receiverProperty.value, _senderType2, senderNode);
        }
      }

      return didReport;
    } // returns true if the assignment reported


    function checkAssignment(receiverNode, senderNode, reportingNode, comparisonType) {
      var _a;

      var receiverTsNode = esTreeNodeToTSNodeMap.get(receiverNode);
      var receiverType = comparisonType === 2
      /* Contextual */
      ? (_a = util.getContextualType(checker, receiverTsNode)) !== null && _a !== void 0 ? _a : checker.getTypeAtLocation(receiverTsNode) : checker.getTypeAtLocation(receiverTsNode);
      var senderType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(senderNode));

      if (util.isTypeAnyType(senderType)) {
        context.report({
          node: reportingNode,
          messageId: 'anyAssignment'
        });
        return true;
      }

      if (comparisonType === 0
      /* None */
      ) {
          return false;
        }

      var result = util.isUnsafeAssignment(senderType, receiverType, checker);

      if (!result) {
        return false;
      }

      var sender = result.sender,
          receiver = result.receiver;
      context.report({
        node: reportingNode,
        messageId: 'unsafeAssignment',
        data: {
          sender: checker.typeToString(sender),
          receiver: checker.typeToString(receiver)
        }
      });
      return true;
    }

    function getComparisonType(typeAnnotation) {
      return typeAnnotation ? // if there's a type annotation, we can do a comparison
      1
      /* Basic */
      : // no type annotation means the variable's type will just be inferred, thus equal
      0
      /* None */
      ;
    }

    return {
      'VariableDeclarator[init != null]': function VariableDeclaratorInitNull(node) {
        var init = util.nullThrows(node.init, util.NullThrowsReasons.MissingToken(node.type, 'init'));
        var didReport = checkAssignment(node.id, init, node, getComparisonType(node.id.typeAnnotation));

        if (!didReport) {
          didReport = checkArrayDestructureHelper(node.id, init);
        }

        if (!didReport) {
          checkObjectDestructureHelper(node.id, init);
        }
      },
      'ClassProperty[value != null]': function ClassPropertyValueNull(node) {
        checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));
      },
      'AssignmentExpression[operator = "="], AssignmentPattern': function AssignmentExpressionOperatorAssignmentPattern(node) {
        var didReport = checkAssignment(node.left, node.right, node, 1
        /* Basic */
        );

        if (!didReport) {
          didReport = checkArrayDestructureHelper(node.left, node.right);
        }

        if (!didReport) {
          checkObjectDestructureHelper(node.left, node.right);
        }
      },
      // object pattern props are checked via assignments
      ':not(ObjectPattern) > Property': function notObjectPatternProperty(node) {
        if (node.value.type === experimental_utils_1.AST_NODE_TYPES.AssignmentPattern) {
          // handled by other selector
          return;
        }

        checkAssignment(node.key, node.value, node, 2
        /* Contextual */
        );
      },
      'ArrayExpression > SpreadElement': function ArrayExpressionSpreadElement(node) {
        var resetNode = esTreeNodeToTSNodeMap.get(node.argument);
        var restType = checker.getTypeAtLocation(resetNode);

        if (util.isTypeAnyType(restType) || util.isTypeAnyArrayType(restType, checker)) {
          context.report({
            node: node,
            messageId: 'unsafeArraySpread'
          });
        }
      },
      'JSXAttribute[value != null]': function JSXAttributeValueNull(node) {
        var value = util.nullThrows(node.value, util.NullThrowsReasons.MissingToken(node.type, 'value'));

        if (value.type !== experimental_utils_1.AST_NODE_TYPES.JSXExpressionContainer || value.expression.type === experimental_utils_1.AST_NODE_TYPES.JSXEmptyExpression) {
          return;
        }

        checkAssignment(node.name, value.expression, value.expression, 2
        /* Contextual */
        );
      }
    };
  }
});