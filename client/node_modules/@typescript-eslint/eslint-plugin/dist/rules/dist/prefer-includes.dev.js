"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var regexpp_1 = require("regexpp");

var ts = __importStar(require("typescript"));

var util_1 = require("../util");

exports["default"] = util_1.createRule({
  name: 'prefer-includes',
  defaultOptions: [],
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforce `includes` method over `indexOf` method',
      category: 'Best Practices',
      recommended: 'error',
      requiresTypeChecking: true
    },
    fixable: 'code',
    messages: {
      preferIncludes: "Use 'includes()' method instead.",
      preferStringIncludes: 'Use `String#includes()` method with a string instead.'
    },
    schema: []
  },
  create: function create(context) {
    var globalScope = context.getScope();
    var services = util_1.getParserServices(context);
    var types = services.program.getTypeChecker();

    function isNumber(node, value) {
      var evaluated = util_1.getStaticValue(node, globalScope);
      return evaluated !== null && evaluated.value === value;
    }

    function isPositiveCheck(node) {
      switch (node.operator) {
        case '!==':
        case '!=':
        case '>':
          return isNumber(node.right, -1);

        case '>=':
          return isNumber(node.right, 0);

        default:
          return false;
      }
    }

    function isNegativeCheck(node) {
      switch (node.operator) {
        case '===':
        case '==':
        case '<=':
          return isNumber(node.right, -1);

        case '<':
          return isNumber(node.right, 0);

        default:
          return false;
      }
    }

    function hasSameParameters(nodeA, nodeB) {
      if (!ts.isFunctionLike(nodeA) || !ts.isFunctionLike(nodeB)) {
        return false;
      }

      var paramsA = nodeA.parameters;
      var paramsB = nodeB.parameters;

      if (paramsA.length !== paramsB.length) {
        return false;
      }

      for (var i = 0; i < paramsA.length; ++i) {
        var paramA = paramsA[i];
        var paramB = paramsB[i]; // Check name, type, and question token once.

        if (paramA.getText() !== paramB.getText()) {
          return false;
        }
      }

      return true;
    }
    /**
     * Parse a given node if it's a `RegExp` instance.
     * @param node The node to parse.
     */


    function parseRegExp(node) {
      var evaluated = util_1.getStaticValue(node, globalScope);

      if (evaluated == null || !(evaluated.value instanceof RegExp)) {
        return null;
      }

      var _regexpp_1$parseRegEx = regexpp_1.parseRegExpLiteral(evaluated.value),
          pattern = _regexpp_1$parseRegEx.pattern,
          flags = _regexpp_1$parseRegEx.flags;

      if (pattern.alternatives.length !== 1 || flags.ignoreCase || flags.global) {
        return null;
      } // Check if it can determine a unique string.


      var chars = pattern.alternatives[0].elements;

      if (!chars.every(function (c) {
        return c.type === 'Character';
      })) {
        return null;
      } // To string.


      return String.fromCodePoint.apply(String, _toConsumableArray(chars.map(function (c) {
        return c.value;
      })));
    }

    return {
      "BinaryExpression > :matches(CallExpression, OptionalCallExpression).left > :matches(MemberExpression, OptionalMemberExpression).callee[property.name='indexOf'][computed=false]": function BinaryExpressionMatchesCallExpressionOptionalCallExpressionLeftMatchesMemberExpressionOptionalMemberExpressionCalleePropertyNameIndexOfComputedFalse(node) {
        var _a, _b; // Check if the comparison is equivalent to `includes()`.


        var callNode = node.parent;
        var compareNode = callNode.parent;
        var negative = isNegativeCheck(compareNode);

        if (!negative && !isPositiveCheck(compareNode)) {
          return;
        } // Get the symbol of `indexOf` method.


        var tsNode = services.esTreeNodeToTSNodeMap.get(node.property);
        var indexofMethodDeclarations = (_a = types.getSymbolAtLocation(tsNode)) === null || _a === void 0 ? void 0 : _a.getDeclarations();

        if (indexofMethodDeclarations == null || indexofMethodDeclarations.length === 0) {
          return;
        } // Check if every declaration of `indexOf` method has `includes` method
        // and the two methods have the same parameters.


        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          var _loop = function _loop() {
            var instanceofMethodDecl = _step.value;
            var typeDecl = instanceofMethodDecl.parent;
            var type = types.getTypeAtLocation(typeDecl);
            var includesMethodDecl = (_b = type.getProperty('includes')) === null || _b === void 0 ? void 0 : _b.getDeclarations();

            if (includesMethodDecl == null || !includesMethodDecl.some(function (includesMethodDecl) {
              return hasSameParameters(includesMethodDecl, instanceofMethodDecl);
            })) {
              return {
                v: void 0
              };
            }
          };

          for (var _iterator = indexofMethodDeclarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _ret = _loop();

            if (_typeof(_ret) === "object") return _ret.v;
          } // Report it.

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        context.report({
          node: compareNode,
          messageId: 'preferIncludes',
          fix:
          /*#__PURE__*/
          regeneratorRuntime.mark(function fix(fixer) {
            return regeneratorRuntime.wrap(function fix$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!negative) {
                      _context.next = 3;
                      break;
                    }

                    _context.next = 3;
                    return fixer.insertTextBefore(callNode, '!');

                  case 3:
                    _context.next = 5;
                    return fixer.replaceText(node.property, 'includes');

                  case 5:
                    _context.next = 7;
                    return fixer.removeRange([callNode.range[1], compareNode.range[1]]);

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, fix);
          })
        });
      },
      // /bar/.test(foo)
      ':matches(CallExpression, OptionalCallExpression) > :matches(MemberExpression, OptionalMemberExpression).callee[property.name="test"][computed=false]': function matchesCallExpressionOptionalCallExpressionMatchesMemberExpressionOptionalMemberExpressionCalleePropertyNameTestComputedFalse(node) {
        var callNode = node.parent;
        var text = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;

        if (text == null) {
          return;
        }

        context.report({
          node: callNode,
          messageId: 'preferStringIncludes',
          fix:
          /*#__PURE__*/
          regeneratorRuntime.mark(function fix(fixer) {
            var argNode, needsParen;
            return regeneratorRuntime.wrap(function fix$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    argNode = callNode.arguments[0];
                    needsParen = argNode.type !== experimental_utils_1.AST_NODE_TYPES.Literal && argNode.type !== experimental_utils_1.AST_NODE_TYPES.TemplateLiteral && argNode.type !== experimental_utils_1.AST_NODE_TYPES.Identifier && argNode.type !== experimental_utils_1.AST_NODE_TYPES.MemberExpression && argNode.type !== experimental_utils_1.AST_NODE_TYPES.OptionalMemberExpression && argNode.type !== experimental_utils_1.AST_NODE_TYPES.CallExpression && argNode.type !== experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression;
                    _context2.next = 4;
                    return fixer.removeRange([callNode.range[0], argNode.range[0]]);

                  case 4:
                    if (!needsParen) {
                      _context2.next = 9;
                      break;
                    }

                    _context2.next = 7;
                    return fixer.insertTextBefore(argNode, '(');

                  case 7:
                    _context2.next = 9;
                    return fixer.insertTextAfter(argNode, ')');

                  case 9:
                    _context2.next = 11;
                    return fixer.insertTextAfter(argNode, "".concat(callNode.type === experimental_utils_1.AST_NODE_TYPES.OptionalCallExpression ? '?.' : '.', "includes(").concat(JSON.stringify(text)));

                  case 11:
                  case "end":
                    return _context2.stop();
                }
              }
            }, fix);
          })
        });
      }
    };
  }
});