"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));

exports["default"] = util.createRule({
  name: 'method-signature-style',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforces using a particular method signature syntax.',
      category: 'Best Practices',
      recommended: false
    },
    fixable: 'code',
    messages: {
      errorMethod: 'Shorthand method signature is forbidden. Use a function property instead.',
      errorProperty: 'Function property signature is forbidden. Use a method shorthand instead.'
    },
    schema: [{
      "enum": ['property', 'method']
    }]
  },
  defaultOptions: ['property'],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        mode = _ref2[0];

    var sourceCode = context.getSourceCode();

    function getMethodKey(node) {
      var key = sourceCode.getText(node.key);

      if (node.computed) {
        key = "[".concat(key, "]");
      }

      if (node.optional) {
        key = "".concat(key, "?");
      }

      if (node.readonly) {
        key = "readonly ".concat(key);
      }

      return key;
    }

    function getMethodParams(node) {
      var params = '()';

      if (node.params.length > 0) {
        var openingParen = util.nullThrows(sourceCode.getTokenBefore(node.params[0], util.isOpeningParenToken), 'Missing opening paren before first parameter');
        var closingParen = util.nullThrows(sourceCode.getTokenAfter(node.params[node.params.length - 1], util.isClosingParenToken), 'Missing closing paren after last parameter');
        params = sourceCode.text.substring(openingParen.range[0], closingParen.range[1]);
      }

      if (node.typeParameters != null) {
        var typeParams = sourceCode.getText(node.typeParameters);
        params = "".concat(typeParams).concat(params);
      }

      return params;
    }

    function getMethodReturnType(node) {
      return sourceCode.getText(node.returnType.typeAnnotation);
    }

    function getDelimiter(node) {
      var lastToken = sourceCode.getLastToken(node);

      if (lastToken && (util.isSemicolonToken(lastToken) || util.isCommaToken(lastToken))) {
        return lastToken.value;
      }

      return '';
    }

    return {
      TSMethodSignature: function TSMethodSignature(methodNode) {
        var _a;

        if (mode === 'method') {
          return;
        }

        var duplicatedKeyMethodNodes = ((_a = methodNode.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.TSInterfaceBody ? methodNode.parent.body.filter(function (element) {
          return element.type === experimental_utils_1.AST_NODE_TYPES.TSMethodSignature && element !== methodNode && getMethodKey(element) === getMethodKey(methodNode);
        }) : [];

        if (duplicatedKeyMethodNodes.length > 0) {
          context.report({
            node: methodNode,
            messageId: 'errorMethod',
            fix:
            /*#__PURE__*/
            regeneratorRuntime.mark(function fix(fixer) {
              var methodNodes, typeString, key, delimiter, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, node, lastToken, nextToken;

              return regeneratorRuntime.wrap(function fix$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      methodNodes = [methodNode].concat(_toConsumableArray(duplicatedKeyMethodNodes)).sort(function (a, b) {
                        return a.range[0] < b.range[0] ? -1 : 1;
                      });
                      typeString = methodNodes.reduce(function (str, node, idx, nodes) {
                        var params = getMethodParams(node);
                        var returnType = getMethodReturnType(node);
                        return "".concat(str, "(").concat(params, " => ").concat(returnType, ")").concat(idx !== nodes.length - 1 ? ' & ' : '');
                      }, '');
                      key = getMethodKey(methodNode);
                      delimiter = getDelimiter(methodNode);
                      _context.next = 6;
                      return fixer.replaceText(methodNode, "".concat(key, ": ").concat(typeString).concat(delimiter));

                    case 6:
                      _iteratorNormalCompletion = true;
                      _didIteratorError = false;
                      _iteratorError = undefined;
                      _context.prev = 9;
                      _iterator = duplicatedKeyMethodNodes[Symbol.iterator]();

                    case 11:
                      if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                        _context.next = 24;
                        break;
                      }

                      node = _step.value;
                      lastToken = sourceCode.getLastToken(node);

                      if (!lastToken) {
                        _context.next = 21;
                        break;
                      }

                      nextToken = sourceCode.getTokenAfter(lastToken);

                      if (!nextToken) {
                        _context.next = 21;
                        break;
                      }

                      _context.next = 19;
                      return fixer.remove(node);

                    case 19:
                      _context.next = 21;
                      return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], '');

                    case 21:
                      _iteratorNormalCompletion = true;
                      _context.next = 11;
                      break;

                    case 24:
                      _context.next = 30;
                      break;

                    case 26:
                      _context.prev = 26;
                      _context.t0 = _context["catch"](9);
                      _didIteratorError = true;
                      _iteratorError = _context.t0;

                    case 30:
                      _context.prev = 30;
                      _context.prev = 31;

                      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                        _iterator["return"]();
                      }

                    case 33:
                      _context.prev = 33;

                      if (!_didIteratorError) {
                        _context.next = 36;
                        break;
                      }

                      throw _iteratorError;

                    case 36:
                      return _context.finish(33);

                    case 37:
                      return _context.finish(30);

                    case 38:
                    case "end":
                      return _context.stop();
                  }
                }
              }, fix, null, [[9, 26, 30, 38], [31,, 33, 37]]);
            })
          });
          return;
        }

        context.report({
          node: methodNode,
          messageId: 'errorMethod',
          fix: function fix(fixer) {
            var key = getMethodKey(methodNode);
            var params = getMethodParams(methodNode);
            var returnType = getMethodReturnType(methodNode);
            var delimiter = getDelimiter(methodNode);
            return fixer.replaceText(methodNode, "".concat(key, ": ").concat(params, " => ").concat(returnType).concat(delimiter));
          }
        });
      },
      TSPropertySignature: function TSPropertySignature(propertyNode) {
        var _a;

        var typeNode = (_a = propertyNode.typeAnnotation) === null || _a === void 0 ? void 0 : _a.typeAnnotation;

        if ((typeNode === null || typeNode === void 0 ? void 0 : typeNode.type) !== experimental_utils_1.AST_NODE_TYPES.TSFunctionType) {
          return;
        }

        if (mode === 'property') {
          return;
        }

        context.report({
          node: propertyNode,
          messageId: 'errorProperty',
          fix: function fix(fixer) {
            var key = getMethodKey(propertyNode);
            var params = getMethodParams(typeNode);
            var returnType = getMethodReturnType(typeNode);
            var delimiter = getDelimiter(propertyNode);
            return fixer.replaceText(propertyNode, "".concat(key).concat(params, ": ").concat(returnType).concat(delimiter));
          }
        });
      }
    };
  }
});