"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util = __importStar(require("../util"));
/**
 * Check whatever node can be considered as simple
 * @param node the node to be evaluated.
 */


function isSimpleType(node) {
  switch (node.type) {
    case experimental_utils_1.AST_NODE_TYPES.Identifier:
    case experimental_utils_1.AST_NODE_TYPES.TSAnyKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSBooleanKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSNeverKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSNumberKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSObjectKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSStringKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSSymbolKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSUnknownKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSVoidKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSNullKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSArrayType:
    case experimental_utils_1.AST_NODE_TYPES.TSUndefinedKeyword:
    case experimental_utils_1.AST_NODE_TYPES.TSThisType:
    case experimental_utils_1.AST_NODE_TYPES.TSQualifiedName:
      return true;

    case experimental_utils_1.AST_NODE_TYPES.TSTypeReference:
      if (node.typeName && node.typeName.type === experimental_utils_1.AST_NODE_TYPES.Identifier && node.typeName.name === 'Array') {
        if (!node.typeParameters) {
          return true;
        }

        if (node.typeParameters.params.length === 1) {
          return isSimpleType(node.typeParameters.params[0]);
        }
      } else {
        if (node.typeParameters) {
          return false;
        }

        return isSimpleType(node.typeName);
      }

      return false;

    default:
      return false;
  }
}
/**
 * Check if node needs parentheses
 * @param node the node to be evaluated.
 */


function typeNeedsParentheses(node) {
  switch (node.type) {
    case experimental_utils_1.AST_NODE_TYPES.TSTypeReference:
      return typeNeedsParentheses(node.typeName);

    case experimental_utils_1.AST_NODE_TYPES.TSUnionType:
    case experimental_utils_1.AST_NODE_TYPES.TSFunctionType:
    case experimental_utils_1.AST_NODE_TYPES.TSIntersectionType:
    case experimental_utils_1.AST_NODE_TYPES.TSTypeOperator:
    case experimental_utils_1.AST_NODE_TYPES.TSInferType:
      return true;

    case experimental_utils_1.AST_NODE_TYPES.Identifier:
      return node.name === 'ReadonlyArray';

    default:
      return false;
  }
}

var arrayOption = {
  "enum": ['array', 'generic', 'array-simple']
};
exports["default"] = util.createRule({
  name: 'array-type',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Requires using either `T[]` or `Array<T>` for arrays',
      category: 'Stylistic Issues',
      // too opinionated to be recommended
      recommended: false
    },
    fixable: 'code',
    messages: {
      errorStringGeneric: "Array type using '{{type}}[]' is forbidden. Use 'Array<{{type}}>' instead.",
      errorStringGenericSimple: "Array type using '{{type}}[]' is forbidden for non-simple types. Use 'Array<{{type}}>' instead.",
      errorStringArray: "Array type using 'Array<{{type}}>' is forbidden. Use '{{type}}[]' instead.",
      errorStringArraySimple: "Array type using 'Array<{{type}}>' is forbidden for simple types. Use '{{type}}[]' instead."
    },
    schema: [{
      type: 'object',
      properties: {
        "default": arrayOption,
        readonly: arrayOption
      }
    }]
  },
  defaultOptions: [{
    "default": 'array'
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        options = _ref2[0];

    var _a;

    var sourceCode = context.getSourceCode();
    var defaultOption = options["default"];
    var readonlyOption = (_a = options.readonly) !== null && _a !== void 0 ? _a : defaultOption;
    var isArraySimpleOption = defaultOption === 'array-simple' && readonlyOption === 'array-simple';
    var isArrayOption = defaultOption === 'array' && readonlyOption === 'array';
    var isGenericOption = defaultOption === 'generic' && readonlyOption === 'generic';
    /**
     * Check if whitespace is needed before this node
     * @param node the node to be evaluated.
     */

    function requireWhitespaceBefore(node) {
      var prevToken = sourceCode.getTokenBefore(node);

      if (!prevToken) {
        return false;
      }

      var nextToken = sourceCode.getTokenAfter(prevToken);

      if (nextToken && sourceCode.isSpaceBetweenTokens(prevToken, nextToken)) {
        return false;
      }

      return prevToken.type === experimental_utils_1.AST_TOKEN_TYPES.Identifier;
    }
    /**
     * @param node the node to be evaluated.
     */


    function getMessageType(node) {
      if (node) {
        if (node.type === experimental_utils_1.AST_NODE_TYPES.TSParenthesizedType) {
          return getMessageType(node.typeAnnotation);
        }

        if (isSimpleType(node)) {
          return sourceCode.getText(node);
        }
      }

      return 'T';
    }
    /**
     * @param node the node to be evaluated
     */


    function getTypeOpNodeRange(node) {
      if (!node) {
        return undefined;
      }

      var firstToken = sourceCode.getFirstToken(node);
      var nextToken = sourceCode.getTokenAfter(firstToken);
      return [firstToken.range[0], nextToken.range[0]];
    }

    return {
      TSArrayType: function TSArrayType(node) {
        if (isArrayOption || isArraySimpleOption && isSimpleType(node.elementType)) {
          return;
        }

        var isReadonly = node.parent && node.parent.type === experimental_utils_1.AST_NODE_TYPES.TSTypeOperator && node.parent.operator === 'readonly';
        var isReadonlyGeneric = readonlyOption === 'generic' && defaultOption !== 'generic';
        var isReadonlyArray = readonlyOption !== 'generic' && defaultOption === 'generic';

        if (isReadonlyGeneric && !isReadonly || isReadonlyArray && isReadonly) {
          return;
        }

        var messageId = defaultOption === 'generic' ? 'errorStringGeneric' : 'errorStringGenericSimple';
        var typeOpNode = isReadonly ? node.parent : null;
        context.report({
          node: isReadonly ? node.parent : node,
          messageId: messageId,
          data: {
            type: getMessageType(node.elementType)
          },
          fix: function fix(fixer) {
            var toFix = [fixer.replaceTextRange([node.range[1] - 2, node.range[1]], '>')];
            var startText = requireWhitespaceBefore(node);
            var typeOpNodeRange = getTypeOpNodeRange(typeOpNode);

            if (typeOpNodeRange) {
              toFix.unshift(fixer.removeRange(typeOpNodeRange));
            } else {
              toFix.push(fixer.insertTextBefore(node, "".concat(startText ? ' ' : '')));
            }

            toFix.push(fixer.insertTextBefore(node, "".concat(isReadonly ? 'Readonly' : '', "Array<")));

            if (node.elementType.type === experimental_utils_1.AST_NODE_TYPES.TSParenthesizedType) {
              var first = sourceCode.getFirstToken(node.elementType);
              var last = sourceCode.getLastToken(node.elementType);

              if (!first || !last) {
                return null;
              }

              toFix.push(fixer.remove(first));
              toFix.push(fixer.remove(last));
            }

            return toFix;
          }
        });
      },
      TSTypeReference: function TSTypeReference(node) {
        if (isGenericOption || node.typeName.type !== experimental_utils_1.AST_NODE_TYPES.Identifier) {
          return;
        }

        var isReadonlyArrayType = node.typeName.name === 'ReadonlyArray';
        var isArrayType = node.typeName.name === 'Array';

        if (!(isArrayType || isReadonlyArrayType) || readonlyOption === 'generic' && isReadonlyArrayType || defaultOption === 'generic' && !isReadonlyArrayType) {
          return;
        }

        var readonlyPrefix = isReadonlyArrayType ? 'readonly ' : '';
        var typeParams = node.typeParameters && node.typeParameters.params;
        var messageId = defaultOption === 'array' ? 'errorStringArray' : 'errorStringArraySimple';

        if (!typeParams || typeParams.length === 0) {
          // Create an 'any' array
          context.report({
            node: node,
            messageId: messageId,
            data: {
              type: 'any'
            },
            fix: function fix(fixer) {
              return fixer.replaceText(node, "".concat(readonlyPrefix, "any[]"));
            }
          });
          return;
        }

        if (typeParams.length !== 1 || defaultOption === 'array-simple' && !isSimpleType(typeParams[0])) {
          return;
        }

        var type = typeParams[0];
        var parens = typeNeedsParentheses(type);
        context.report({
          node: node,
          messageId: messageId,
          data: {
            type: getMessageType(type)
          },
          fix: function fix(fixer) {
            return [fixer.replaceTextRange([node.range[0], type.range[0]], "".concat(readonlyPrefix).concat(parens ? '(' : '')), fixer.replaceTextRange([type.range[1], node.range[1]], parens ? ')[]' : '[]')];
          }
        });
      }
    };
  }
});