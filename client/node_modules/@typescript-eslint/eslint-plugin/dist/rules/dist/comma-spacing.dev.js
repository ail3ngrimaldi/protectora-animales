"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var experimental_utils_1 = require("@typescript-eslint/experimental-utils");

var util_1 = require("../util");

exports["default"] = util_1.createRule({
  name: 'comma-spacing',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforces consistent spacing before and after commas',
      category: 'Stylistic Issues',
      recommended: false,
      extendsBaseRule: true
    },
    fixable: 'whitespace',
    schema: [{
      type: 'object',
      properties: {
        before: {
          type: 'boolean',
          "default": false
        },
        after: {
          type: 'boolean',
          "default": true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "There should be no space {{loc}} ','.",
      missing: "A space is required {{loc}} ','."
    }
  },
  defaultOptions: [{
    before: false,
    after: true
  }],
  create: function create(context, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        _ref2$ = _ref2[0],
        spaceBefore = _ref2$.before,
        spaceAfter = _ref2$.after;

    var sourceCode = context.getSourceCode();
    var tokensAndComments = sourceCode.tokensAndComments;
    var ignoredTokens = new Set();
    /**
     * Adds null elements of the ArrayExpression or ArrayPattern node to the ignore list
     * @param node node to evaluate
     */

    function addNullElementsToIgnoreList(node) {
      var previousToken = sourceCode.getFirstToken(node);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = node.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var element = _step.value;
          var token = void 0;

          if (element === null) {
            token = sourceCode.getTokenAfter(previousToken);

            if (token && util_1.isCommaToken(token)) {
              ignoredTokens.add(token);
            }
          } else {
            token = sourceCode.getTokenAfter(element);
          }

          previousToken = token;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * Adds type parameters trailing comma token to the ignore list
     * @param node node to evaluate
     */


    function addTypeParametersTrailingCommaToIgnoreList(node) {
      var param = node.params[node.params.length - 1];
      var afterToken = sourceCode.getTokenAfter(param);

      if (afterToken && util_1.isCommaToken(afterToken)) {
        ignoredTokens.add(afterToken);
      }
    }
    /**
     * Validates the spacing around a comma token.
     * @param commaToken The token representing the comma
     * @param prevToken The last token before the comma
     * @param nextToken The first token after the comma
     */


    function validateCommaSpacing(commaToken, prevToken, nextToken) {
      if (prevToken && util_1.isTokenOnSameLine(prevToken, commaToken) && spaceBefore !== sourceCode.isSpaceBetween(prevToken, commaToken)) {
        context.report({
          node: commaToken,
          data: {
            loc: 'before'
          },
          messageId: spaceBefore ? 'missing' : 'unexpected',
          fix: function fix(fixer) {
            return spaceBefore ? fixer.insertTextBefore(commaToken, ' ') : fixer.replaceTextRange([prevToken.range[1], commaToken.range[0]], '');
          }
        });
      }

      if (nextToken && util_1.isClosingParenToken(nextToken)) {
        return;
      }

      if (!spaceAfter && nextToken && nextToken.type === experimental_utils_1.AST_TOKEN_TYPES.Line) {
        return;
      }

      if (nextToken && util_1.isTokenOnSameLine(commaToken, nextToken) && spaceAfter !== sourceCode.isSpaceBetween(commaToken, nextToken)) {
        context.report({
          node: commaToken,
          data: {
            loc: 'after'
          },
          messageId: spaceAfter ? 'missing' : 'unexpected',
          fix: function fix(fixer) {
            return spaceAfter ? fixer.insertTextAfter(commaToken, ' ') : fixer.replaceTextRange([commaToken.range[1], nextToken.range[0]], '');
          }
        });
      }
    }

    return {
      TSTypeParameterDeclaration: addTypeParametersTrailingCommaToIgnoreList,
      ArrayExpression: addNullElementsToIgnoreList,
      ArrayPattern: addNullElementsToIgnoreList,
      'Program:exit': function ProgramExit() {
        tokensAndComments.forEach(function (token, i) {
          if (!util_1.isCommaToken(token)) {
            return;
          }

          var prevToken = tokensAndComments[i - 1];
          var nextToken = tokensAndComments[i + 1];
          validateCommaSpacing(token, util_1.isCommaToken(prevToken) || ignoredTokens.has(token) ? null : prevToken, util_1.isCommaToken(nextToken) || ignoredTokens.has(token) ? null : nextToken);
        });
      }
    };
  }
});