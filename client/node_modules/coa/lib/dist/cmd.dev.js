/* eslint-disable class-methods-use-this */
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var UTIL = require('util'),
    PATH = require('path'),
    EOL = require('os').EOL,
    Q = require('q'),
    chalk = require('chalk'),
    CoaObject = require('./coaobject'),
    Opt = require('./opt'),
    Arg = require('./arg'),
    completion = require('./completion');
/**
 * Command
 *
 * Top level entity. Commands may have options and arguments.
 *
 * @namespace
 * @class Cmd
 * @extends CoaObject
 */


var Cmd =
/*#__PURE__*/
function (_CoaObject) {
  _inherits(Cmd, _CoaObject);

  /**
   * @constructs
   * @param {COA.Cmd} [cmd] parent command
   */
  function Cmd(cmd) {
    var _this2;

    _classCallCheck(this, Cmd);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Cmd).call(this, cmd));

    _this2._parent(cmd);

    _this2._cmds = [];
    _this2._cmdsByName = {};
    _this2._opts = [];
    _this2._optsByKey = {};
    _this2._args = [];
    _this2._api = null;
    _this2._ext = false;
    return _this2;
  }

  _createClass(Cmd, [{
    key: "_parent",
    value: function _parent(cmd) {
      this._cmd = cmd || this;
      this.isRootCmd || cmd._cmds.push(this) && this._name && (this._cmd._cmdsByName[this._name] = this);
      return this;
    }
  }, {
    key: "name",

    /**
     * Set a canonical command identifier to be used anywhere in the API.
     *
     * @param {String} name - command name
     * @returns {COA.Cmd} - this instance (for chainability)
     */
    value: function name(_name) {
      _get(_getPrototypeOf(Cmd.prototype), "name", this).call(this, _name);

      this.isRootCmd || (this._cmd._cmdsByName[_name] = this);
      return this;
    }
    /**
     * Create new or add existing subcommand for current command.
     *
     * @param {COA.Cmd} [cmd] existing command instance
     * @returns {COA.Cmd} new subcommand instance
     */

  }, {
    key: "cmd",
    value: function cmd(_cmd) {
      return _cmd ? _cmd._parent(this) : new Cmd(this);
    }
    /**
     * Create option for current command.
     *
     * @returns {COA.Opt} new option instance
     */

  }, {
    key: "opt",
    value: function opt() {
      return new Opt(this);
    }
    /**
     * Create argument for current command.
     *
     * @returns {COA.Opt} new argument instance
     */

  }, {
    key: "arg",
    value: function arg() {
      return new Arg(this);
    }
    /**
     * Add (or set) action for current command.
     *
     * @param {Function} act - action function,
     *         invoked in the context of command instance
     *         and has the parameters:
     *                 - {Object} opts - parsed options
     *                 - {String[]} args - parsed arguments
     *                 - {Object} res - actions result accumulator
     *         It can return rejected promise by Cmd.reject (in case of error)
     *         or any other value treated as result.
     * @param {Boolean} [force=false] flag for set action instead add to existings
     * @returns {COA.Cmd} - this instance (for chainability)
     */

  }, {
    key: "act",
    value: function act(_act, force) {
      if (!_act) return this;
      (!this._act || force) && (this._act = []);

      this._act.push(_act);

      return this;
    }
    /**
     * Make command "helpful", i.e. add -h --help flags for print usage.
     *
     * @returns {COA.Cmd} - this instance (for chainability)
     */

  }, {
    key: "helpful",
    value: function helpful() {
      return this.opt().name('help').title('Help')["short"]('h')["long"]('help').flag().only().act(function () {
        return this.usage();
      }).end();
    }
    /**
     * Adds shell completion to command, adds "completion" subcommand,
     * that makes all the magic.
     * Must be called only on root command.
     *
     * @returns {COA.Cmd} - this instance (for chainability)
     */

  }, {
    key: "completable",
    value: function completable() {
      return this.cmd().name('completion').apply(completion).end();
    }
    /**
     * Allow command to be extendable by external node.js modules.
     *
     * @param {String} [pattern]  Pattern of node.js module to find subcommands at.
     * @returns {COA.Cmd} - this instance (for chainability)
     */

  }, {
    key: "extendable",
    value: function extendable(pattern) {
      this._ext = pattern || true;
      return this;
    }
  }, {
    key: "_exit",
    value: function _exit(msg, code) {
      return process.once('exit', function (exitCode) {
        msg && console[code === 0 ? 'log' : 'error'](msg);
        process.exit(code || exitCode || 0);
      });
    }
    /**
     * Build full usage text for current command instance.
     *
     * @returns {String} usage text
     */

  }, {
    key: "usage",
    value: function usage() {
      var res = [];
      this._title && res.push(this._fullTitle());
      res.push('', 'Usage:');
      this._cmds.length && res.push(['', '', chalk.redBright(this._fullName()), chalk.blueBright('COMMAND'), chalk.greenBright('[OPTIONS]'), chalk.magentaBright('[ARGS]')].join(' '));
      this._opts.length + this._args.length && res.push(['', '', chalk.redBright(this._fullName()), chalk.greenBright('[OPTIONS]'), chalk.magentaBright('[ARGS]')].join(' '));
      res.push(this._usages(this._cmds, 'Commands'), this._usages(this._opts, 'Options'), this._usages(this._args, 'Arguments'));
      return res.join(EOL);
    }
  }, {
    key: "_usage",
    value: function _usage() {
      return chalk.blueBright(this._name) + ' : ' + this._title;
    }
  }, {
    key: "_usages",
    value: function _usages(os, title) {
      if (!os.length) return;
      return ['', title + ':'].concat(os.map(function (o) {
        return "  ".concat(o._usage());
      })).join(EOL);
    }
  }, {
    key: "_fullTitle",
    value: function _fullTitle() {
      return "".concat(this.isRootCmd ? '' : this._cmd._fullTitle() + EOL).concat(this._title);
    }
  }, {
    key: "_fullName",
    value: function _fullName() {
      return "".concat(this.isRootCmd ? '' : this._cmd._fullName() + ' ').concat(PATH.basename(this._name));
    }
  }, {
    key: "_ejectOpt",
    value: function _ejectOpt(opts, opt) {
      var pos = opts.indexOf(opt);
      if (pos === -1) return;
      return opts[pos]._arr ? opts[pos] : opts.splice(pos, 1)[0];
    }
  }, {
    key: "_checkRequired",
    value: function _checkRequired(opts, args) {
      if (this._opts.some(function (opt) {
        return opt._only && opts.hasOwnProperty(opt._name);
      })) return;

      var all = this._opts.concat(this._args);

      var i;

      while (i = all.shift()) {
        if (i._req && i._checkParsed(opts, args)) return this.reject(i._requiredText());
      }
    }
  }, {
    key: "_parseCmd",
    value: function _parseCmd(argv, unparsed) {
      unparsed || (unparsed = []);
      var i,
          optSeen = false;

      while (i = argv.shift()) {
        i.indexOf('-') || (optSeen = true);

        if (optSeen || !/^\w[\w-_]*$/.test(i)) {
          unparsed.push(i);
          continue;
        }

        var pkg = void 0,
            cmd = this._cmdsByName[i];

        if (!cmd && this._ext) {
          if (this._ext === true) {
            pkg = i;
            var c = this;

            while (true) {
              // eslint-disable-line
              pkg = c._name + '-' + pkg;
              if (c.isRootCmd) break;
              c = c._cmd;
            }
          } else if (typeof this._ext === 'string') pkg = ~this._ext.indexOf('%s') ? UTIL.format(this._ext, i) : this._ext + i;

          var cmdDesc = void 0;

          try {
            cmdDesc = require(pkg);
          } catch (e) {// Dummy
          }

          if (cmdDesc) {
            if (typeof cmdDesc === 'function') {
              this.cmd().name(i).apply(cmdDesc).end();
            } else if (_typeof(cmdDesc) === 'object') {
              this.cmd(cmdDesc);
              cmdDesc.name(i);
            } else throw new Error('Error: Unsupported command declaration type, ' + 'should be a function or COA.Cmd() object');

            cmd = this._cmdsByName[i];
          }
        }

        if (cmd) return cmd._parseCmd(argv, unparsed);
        unparsed.push(i);
      }

      return {
        cmd: this,
        argv: unparsed
      };
    }
  }, {
    key: "_parseOptsAndArgs",
    value: function _parseOptsAndArgs(argv) {
      var opts = {},
          args = {},
          nonParsedOpts = this._opts.concat(),
          nonParsedArgs = this._args.concat();

      var res, i;

      while (i = argv.shift()) {
        if (i !== '--' && i[0] === '-') {
          var m = i.match(/^(--\w[\w-_]*)=(.*)$/);

          if (m) {
            i = m[1];
            this._optsByKey[i]._flag || argv.unshift(m[2]);
          }

          var opt = this._ejectOpt(nonParsedOpts, this._optsByKey[i]);

          if (!opt) return this.reject("Unknown option: ".concat(i));
          if (Q.isRejected(res = opt._parse(argv, opts))) return res;
          continue;
        }

        i === '--' && (i = argv.splice(0));
        Array.isArray(i) || (i = [i]);
        var a = void 0;

        while (a = i.shift()) {
          var arg = nonParsedArgs.shift();
          if (!arg) return this.reject("Unknown argument: ".concat(a));
          arg._arr && nonParsedArgs.unshift(arg);
          if (Q.isRejected(res = arg._parse(a, args))) return res;
        }
      }

      return {
        opts: this._setDefaults(opts, nonParsedOpts),
        args: this._setDefaults(args, nonParsedArgs)
      };
    }
  }, {
    key: "_setDefaults",
    value: function _setDefaults(params, desc) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = desc[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          item._def !== undefined && !params.hasOwnProperty(item._name) && item._saveVal(params, item._def);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return params;
    }
  }, {
    key: "_processParams",
    value: function _processParams(params, desc) {
      var notExists = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = desc[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;
          var n = item._name;

          if (!params.hasOwnProperty(n)) {
            notExists.push(item);
            continue;
          }

          var vals = Array.isArray(params[n]) ? params[n] : [params[n]];
          delete params[n];
          var res = void 0;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = vals[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var v = _step3.value;
              if (Q.isRejected(res = item._saveVal(params, v))) return res;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this._setDefaults(params, notExists);
    }
  }, {
    key: "_parseArr",
    value: function _parseArr(argv) {
      return Q.when(this._parseCmd(argv), function (p) {
        return Q.when(p.cmd._parseOptsAndArgs(p.argv), function (r) {
          return {
            cmd: p.cmd,
            opts: r.opts,
            args: r.args
          };
        });
      });
    }
  }, {
    key: "_do",
    value: function _do(inputPromise) {
      var _this3 = this;

      return Q.when(inputPromise, function (input) {
        return [_this3._checkRequired].concat(input.cmd._act || []).reduce(function (res, act) {
          return Q.when(res, function (prev) {
            return act.call(input.cmd, input.opts, input.args, prev);
          });
        }, undefined);
      });
    }
    /**
     * Parse arguments from simple format like NodeJS process.argv
     * and run ahead current program, i.e. call process.exit when all actions done.
     *
     * @param {String[]} argv - arguments
     * @returns {COA.Cmd} - this instance (for chainability)
     */

  }, {
    key: "run",
    value: function run(argv) {
      var _this4 = this;

      argv || (argv = process.argv.slice(2));

      var cb = function cb(code) {
        return function (res) {
          return res ? _this4._exit(res.stack || res.toString(), (res.hasOwnProperty('exitCode') ? res.exitCode : code) || 0) : _this4._exit();
        };
      };

      Q.when(this["do"](argv), cb(0), cb(1)).done();
      return this;
    }
    /**
     * Invoke specified (or current) command using provided
     * options and arguments.
     *
     * @param {String|String[]} [cmds] - subcommand to invoke (optional)
     * @param {Object} [opts] - command options (optional)
     * @param {Object} [args] - command arguments (optional)
     * @returns {Q.Promise}
     */

  }, {
    key: "invoke",
    value: function invoke(cmds, opts, args) {
      var _this5 = this;

      cmds || (cmds = []);
      opts || (opts = {});
      args || (args = {});
      typeof cmds === 'string' && (cmds = cmds.split(' '));

      if (arguments.length < 3 && !Array.isArray(cmds)) {
        args = opts;
        opts = cmds;
        cmds = [];
      }

      return Q.when(this._parseCmd(cmds), function (p) {
        if (p.argv.length) return _this5.reject("Unknown command: ".concat(cmds.join(' ')));
        return Q.all([_this5._processParams(opts, _this5._opts), _this5._processParams(args, _this5._args)]).spread(function (_opts, _args) {
          return _this5._do({
            cmd: p.cmd,
            opts: _opts,
            args: _args
          }).fail(function (res) {
            return res && res.exitCode === 0 ? res.toString() : _this5.reject(res);
          });
        });
      });
    }
  }, {
    key: "api",

    /**
     * Returns object containing all its subcommands as methods
     * to use from other programs.
     *
     * @returns {Object}
     */
    get: function get() {
      var _this6 = this;

      // Need _this here because of passed arguments into _api
      var _this = this;

      this._api || (this._api = function () {
        return _this.invoke.apply(_this, arguments);
      });
      var cmds = this._cmdsByName;
      Object.keys(cmds).forEach(function (cmd) {
        _this6._api[cmd] = cmds[cmd].api;
      });
      return this._api;
    }
  }, {
    key: "isRootCmd",
    get: function get() {
      return this._cmd === this;
    }
  }], [{
    key: "create",
    value: function create(cmd) {
      return new Cmd(cmd);
    }
  }]);

  return Cmd;
}(CoaObject);
/**
 * Convenient function to run command from tests.
 *
 * @param {String[]} argv - arguments
 * @returns {Q.Promise}
 */


Cmd.prototype["do"] = function (argv) {
  return this._do(this._parseArr(argv || []));
};

module.exports = Cmd;