'use strict';

var path = require('path');

var niceTry = require('nice-try');

var resolveCommand = require('./util/resolveCommand');

var escape = require('./util/escape');

var readShebang = require('./util/readShebang');

var semver = require('semver');

var isWin = process.platform === 'win32';
var isExecutableRegExp = /\.(?:com|exe)$/i;
var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i; // `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0

var supportsShellOption = niceTry(function () {
  return semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true);
}) || false;

function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  var shebang = parsed.file && readShebang(parsed.file);

  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }

  return parsed.file;
}

function parseNonShell(parsed) {
  if (!isWin) {
    return parsed;
  } // Detect & add support for shebangs


  var commandFile = detectShebang(parsed); // We don't need a shell if the command filename is an executable

  var needsShell = !isExecutableRegExp.test(commandFile); // If a shell is required, use cmd.exe and take care of escaping everything correctly
  // Note that `forceShell` is an hidden option used only in tests

  if (parsed.options.forceShell || needsShell) {
    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
    // we need to double escape them
    var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile); // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
    // This is necessary otherwise it will always fail with ENOENT in those cases

    parsed.command = path.normalize(parsed.command); // Escape command & arguments

    parsed.command = escape.command(parsed.command);
    parsed.args = parsed.args.map(function (arg) {
      return escape.argument(arg, needsDoubleEscapeMetaChars);
    });
    var shellCommand = [parsed.command].concat(parsed.args).join(' ');
    parsed.args = ['/d', '/s', '/c', "\"".concat(shellCommand, "\"")];
    parsed.command = process.env.comspec || 'cmd.exe';
    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
  }

  return parsed;
}

function parseShell(parsed) {
  // If node supports the shell option, there's no need to mimic its behavior
  if (supportsShellOption) {
    return parsed;
  } // Mimic node shell option
  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335


  var shellCommand = [parsed.command].concat(parsed.args).join(' ');

  if (isWin) {
    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';
    parsed.args = ['/d', '/s', '/c', "\"".concat(shellCommand, "\"")];
    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
  } else {
    if (typeof parsed.options.shell === 'string') {
      parsed.command = parsed.options.shell;
    } else if (process.platform === 'android') {
      parsed.command = '/system/bin/sh';
    } else {
      parsed.command = '/bin/sh';
    }

    parsed.args = ['-c', shellCommand];
  }

  return parsed;
}

function parse(command, args, options) {
  // Normalize arguments, similar to nodejs
  if (args && !Array.isArray(args)) {
    options = args;
    args = null;
  }

  args = args ? args.slice(0) : []; // Clone array to avoid changing the original

  options = Object.assign({}, options); // Clone object to avoid changing the original
  // Build our parsed object

  var parsed = {
    command: command,
    args: args,
    options: options,
    file: undefined,
    original: {
      command: command,
      args: args
    }
  }; // Delegate further parsing to shell or non-shell

  return options.shell ? parseShell(parsed) : parseNonShell(parsed);
}

module.exports = parse;