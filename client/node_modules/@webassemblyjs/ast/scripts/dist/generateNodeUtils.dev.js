"use strict";

var definitions = require("../src/definitions");

var flatMap = require("array.prototype.flatmap");

var _require = require("./util"),
    typeSignature = _require.typeSignature,
    iterateProps = _require.iterateProps,
    mapProps = _require.mapProps,
    filterProps = _require.filterProps,
    unique = _require.unique;

var stdout = process.stdout;
var jsTypes = ["string", "number", "boolean"];

var quote = function quote(value) {
  return "\"".concat(value, "\"");
};

function params(fields) {
  var optionalDefault = function optionalDefault(field) {
    return field["default"] ? " = ".concat(field["default"]) : "";
  };

  return mapProps(fields).map(function (field) {
    return "".concat(typeSignature(field)).concat(optionalDefault(field));
  }).join(",");
}

function assertParamType(_ref) {
  var assertNodeType = _ref.assertNodeType,
      array = _ref.array,
      name = _ref.name,
      type = _ref.type;

  if (array) {
    // TODO - assert contents of array?
    return "assert(typeof ".concat(name, " === \"object\" && typeof ").concat(name, ".length !== \"undefined\")\n");
  } else {
    if (jsTypes.includes(type)) {
      return "assert(\n          typeof ".concat(name, " === \"").concat(type, "\",\n          \"Argument ").concat(name, " must be of type ").concat(type, ", given: \" + typeof ").concat(name, "\n      )");
    }

    if (assertNodeType === true) {
      return "assert(\n        ".concat(name, ".type === \"").concat(type, "\",\n        \"Argument ").concat(name, " must be of type ").concat(type, ", given: \" + ").concat(name, ".type\n      )");
    }

    return "";
  }
}

function assertParam(meta) {
  var paramAssertion = assertParamType(meta);

  if (paramAssertion === "") {
    return "";
  }

  if (meta.maybe || meta.optional) {
    return "\n      if (".concat(meta.name, " !== null && ").concat(meta.name, " !== undefined) {\n        ").concat(paramAssertion, ";\n      }\n    ");
  } else {
    return paramAssertion;
  }
}

function assertParams(fields) {
  return mapProps(fields).map(assertParam).join("\n");
}

function buildObject(typeDef) {
  var optionalField = function optionalField(meta) {
    if (meta.array) {
      // omit optional array properties if the constructor function was supplied
      // with an empty array
      return "\n        if (typeof ".concat(meta.name, " !== \"undefined\" && ").concat(meta.name, ".length > 0) {\n          node.").concat(meta.name, " = ").concat(meta.name, ";\n        }\n      ");
    } else if (meta.type === "Object") {
      // omit optional object properties if they have no keys
      return "\n        if (typeof ".concat(meta.name, " !== \"undefined\" && Object.keys(").concat(meta.name, ").length !== 0) {\n          node.").concat(meta.name, " = ").concat(meta.name, ";\n        }\n      ");
    } else if (meta.type === "boolean") {
      // omit optional boolean properties if they are not true
      return "\n        if (".concat(meta.name, " === true) {\n          node.").concat(meta.name, " = true;\n        }\n      ");
    } else {
      return "\n        if (typeof ".concat(meta.name, " !== \"undefined\") {\n          node.").concat(meta.name, " = ").concat(meta.name, ";\n        }\n      ");
    }
  };

  var fields = mapProps(typeDef.fields).filter(function (f) {
    return !f.optional && !f.constant;
  }).map(function (f) {
    return f.name;
  });
  var constants = mapProps(typeDef.fields).filter(function (f) {
    return f.constant;
  }).map(function (f) {
    return "".concat(f.name, ": \"").concat(f.value, "\"");
  });
  return "\n    const node: ".concat(typeDef.flowTypeName || typeDef.name, " = {\n      type: \"").concat(typeDef.name, "\",\n      ").concat(constants.concat(fields).join(","), "\n    }\n\n    ").concat(mapProps(typeDef.fields).filter(function (f) {
    return f.optional;
  }).map(optionalField).join(""), "\n  ");
}

function lowerCamelCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
}

function generate() {
  stdout.write("\n    // @flow\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateNodeUtils.js\n\n    import { assert } from \"mamacro\";\n\n    function isTypeOf(t: string) {\n      return (n: Node) => n.type === t;\n    }\n\n    function assertTypeOf(t: string) {\n      return (n: Node) => assert(n.type === t);\n    }\n  "); // Node builders

  iterateProps(definitions, function (typeDefinition) {
    stdout.write("\n      export function ".concat(lowerCamelCase(typeDefinition.name), " (\n        ").concat(params(filterProps(typeDefinition.fields, function (f) {
      return !f.constant;
    })), "\n      ): ").concat(typeDefinition.name, " {\n\n        ").concat(assertParams(filterProps(typeDefinition.fields, function (f) {
      return !f.constant;
    })), "\n        ").concat(buildObject(typeDefinition), " \n\n        return node;\n      }\n    "));
  }); // Node testers

  iterateProps(definitions, function (typeDefinition) {
    stdout.write("\n      export const is".concat(typeDefinition.name, " =\n        isTypeOf(\"").concat(typeDefinition.name, "\");\n    "));
  }); // Node union type testers

  var unionTypes = unique(flatMap(mapProps(definitions).filter(function (d) {
    return d.unionType;
  }), function (d) {
    return d.unionType;
  }));
  unionTypes.forEach(function (unionType) {
    stdout.write("\n      export const is".concat(unionType, " = (node: Node) => ") + mapProps(definitions).filter(function (d) {
      return d.unionType && d.unionType.includes(unionType);
    }).map(function (d) {
      return "is".concat(d.name, "(node) ");
    }).join("||") + ";\n\n");
  }); // Node assertion

  iterateProps(definitions, function (typeDefinition) {
    stdout.write("\n      export const assert".concat(typeDefinition.name, " =\n        assertTypeOf(\"").concat(typeDefinition.name, "\");\n    "));
  }); // a map from node type to its set of union types

  stdout.write("\n    export const unionTypesMap = {" + mapProps(definitions).filter(function (d) {
    return d.unionType;
  }).map(function (t) {
    return "\"".concat(t.name, "\": [").concat(t.unionType.map(quote).join(","), "]\n");
  }) + "};\n      "); // an array of all node and union types

  stdout.write("\n    export const nodeAndUnionTypes = [" + mapProps(definitions).map(function (t) {
    return "\"".concat(t.name, "\"");
  }).concat(unionTypes.map(quote)).join(",") + "];");
}

generate();