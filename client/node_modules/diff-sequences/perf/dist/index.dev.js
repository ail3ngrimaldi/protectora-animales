"use strict";

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Make sure to run node with --expose-gc option!
// The times are reliable if about 1% relative mean error if you run it:
// * immediately after restart
// * with 100% battery charge
// * not connected to network

/* eslint import/no-extraneous-dependencies: "off" */
var Benchmark = require('benchmark');

var diffBaseline = require('diff').diffLines;

var diffImproved = require('../build/index.js')["default"];

var testBaseline = function testBaseline(a, b) {
  var benchmark = new Benchmark({
    fn: function fn() {
      diffBaseline(a, b);
    },
    name: 'baseline',
    onCycle: function onCycle() {
      global.gc(); // after run cycle
    },
    onStart: function onStart() {
      global.gc(); // when benchmark starts
    }
  });
  benchmark.run({
    async: false
  });
  return benchmark.stats;
};

var testImproved = function testImproved(a, b) {
  var benchmark = new Benchmark({
    fn: function fn() {
      // Split string arguments to make fair comparison with baseline.
      var aItems = a.split('\n');
      var bItems = b.split('\n');

      var isCommon = function isCommon(aIndex, bIndex) {
        return aItems[aIndex] === bItems[bIndex];
      }; // This callback obviously does less than baseline `diff` package,
      // but avoiding double work and memory churn is the goal.
      // For example, `jest-diff` has had to split strings that `diff` joins.


      var foundSubsequence = function foundSubsequence() {};

      diffImproved(aItems.length, bItems.length, isCommon, foundSubsequence);
    },
    name: 'improved',
    onCycle: function onCycle() {
      global.gc(); // after run cycle
    },
    onStart: function onStart() {
      global.gc(); // when benchmark starts
    }
  });
  benchmark.run({
    async: false
  });
  return benchmark.stats;
};

var writeHeading2 = function writeHeading2() {
  console.log('## Benchmark time for `diff-sequences` versus `diff`\n');
  console.log('A ratio less than 1.0 means `diff-sequences` is faster.');
};

var writeHeading3 = function writeHeading3(n) {
  console.log("\n### n = ".concat(n, "\n"));
  console.log('| name | % | ratio | improved | rme | baseline | rme |');
  console.log('| :--- | ---: | :--- | :--- | ---: | :--- | ---: |');
};

var writeRow = function writeRow(name, percent, statsImproved, statsBaseline) {
  var meanImproved = statsImproved.mean,
      rmeImproved = statsImproved.rme;
  var meanBaseline = statsBaseline.mean,
      rmeBaseline = statsBaseline.rme;
  var ratio = meanImproved / meanBaseline;
  console.log("| ".concat(name, " | ").concat(percent, "% | ").concat(ratio.toFixed(4), " | ").concat(meanImproved.toExponential(4), " | ").concat(rmeImproved.toFixed(2), "% | ").concat(meanBaseline.toExponential(4), " | ").concat(rmeBaseline.toFixed(2), "% |"));
};

var testDeleteInsert = function testDeleteInsert(tenths, more, less) {
  // For improved `diff-sequences` package, delete is often slower than insert.
  var statsDeleteImproved = testImproved(more, less);
  var statsDeleteBaseline = testBaseline(more, less);
  writeRow('delete', tenths * 10, statsDeleteImproved, statsDeleteBaseline); // For baseline `diff` package, many insertions is serious perf problem.
  // However, the benchmark package cannot accurately measure for large n.

  var statsInsertBaseline = testBaseline(less, more);
  var statsInsertImproved = testImproved(less, more);
  writeRow('insert', tenths * 10, statsInsertImproved, statsInsertBaseline);
};

var testChange = function testChange(tenths, expected, received) {
  var statsImproved = testImproved(expected, received);
  var statsBaseline = testBaseline(expected, received);
  writeRow('change', tenths * 10, statsImproved, statsBaseline);
};

var getItems = function getItems(n, callback) {
  var items = [];

  for (var i = 0; i !== n; i += 1) {
    var item = callback(i);

    if (typeof item === 'string') {
      items.push(item);
    }
  }

  return items.join('\n');
}; // Simulate change of property name which is usually not same line.
// Expected: 0 1 2 3 4 5 6 7 8 9 and so on
// Received: 1 2 3 4 x0 5 6 7 8 9 and so on


var change2 = function change2(i) {
  var j = i % 10;
  return j === 4 ? "x".concat(i - 4) : j < 4 ? "".concat(i + 1) : "".concat(i);
};

var testLength = function testLength(n) {
  var all = getItems(n, function (i) {
    return "".concat(i);
  });
  writeHeading3(n);
  [2, 4, 8].forEach(function (tenth) {
    testDeleteInsert(tenth, all, getItems(n, function (i) {
      return i % 10 >= tenth && "".concat(i);
    }));
  });
  testChange(1, all, getItems(n, function (i) {
    return i % 10 === 0 ? "x".concat(i) : "".concat(i);
  }));
  testChange(2, all, getItems(n, change2));
  testChange(5, all, getItems(n, function (i) {
    return i % 2 === 0 ? "x".concat(i) : "".concat(i);
  }));
  testChange(10, all, getItems(n, function (i) {
    return "x".concat(i);
  })); // simulate TDD
};

writeHeading2();
testLength(20);
testLength(200);
testLength(2000);