'use strict';
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
// Only used for types
// eslint-disable-next-line
// eslint-disable-next-line

var invariant = function invariant(condition, message) {
  if (!condition) {
    throw new Error('babel-plugin-jest-hoist: ' + message);
  }
}; // We allow `jest`, `expect`, `require`, all default Node.js globals and all
// ES2015 built-ins to be used inside of a `jest.mock` factory.
// We also allow variables prefixed with `mock` as an escape-hatch.


var WHITELISTED_IDENTIFIERS = new Set(['Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'Generator', 'GeneratorFunction', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'InternalError', 'Intl', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'SyntaxError', 'TypeError', 'URIError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'WeakMap', 'WeakSet', 'arguments', 'console', 'expect', 'isNaN', 'jest', 'parseFloat', 'parseInt', 'require', 'undefined']);
Object.getOwnPropertyNames(global).forEach(function (name) {
  WHITELISTED_IDENTIFIERS.add(name);
});
var JEST_GLOBAL = {
  name: 'jest'
}; // TODO: Should be Visitor<{ids: Set<NodePath<Identifier>>}>, but `ReferencedIdentifier` doesn't exist

var IDVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path) {
    // @ts-ignore: passed as Visitor State
    this.ids.add(path);
  },
  blacklist: ['TypeAnnotation', 'TSTypeAnnotation', 'TSTypeReference']
};
var FUNCTIONS = Object.create(null);

FUNCTIONS.mock = function (args) {
  if (args.length === 1) {
    return args[0].isStringLiteral() || args[0].isLiteral();
  } else if (args.length === 2 || args.length === 3) {
    var moduleFactory = args[1];
    invariant(moduleFactory.isFunction(), 'The second argument of `jest.mock` must be an inline function.');
    var ids = new Set();
    var parentScope = moduleFactory.parentPath.scope; // @ts-ignore: Same as above: ReferencedIdentifier doesn't exist

    moduleFactory.traverse(IDVisitor, {
      ids: ids
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = ids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var id = _step.value;
        var name = id.node.name;
        var found = false;
        var scope = id.scope;

        while (scope !== parentScope) {
          if (scope.bindings[name]) {
            found = true;
            break;
          }

          scope = scope.parent;
        }

        if (!found) {
          invariant(scope.hasGlobal(name) && WHITELISTED_IDENTIFIERS.has(name) || /^mock/i.test(name) || // Allow istanbul's coverage variable to pass.
          /^(?:__)?cov/.test(name), 'The module factory of `jest.mock()` is not allowed to ' + 'reference any out-of-scope variables.\n' + 'Invalid variable access: ' + name + '\n' + 'Whitelisted objects: ' + Array.from(WHITELISTED_IDENTIFIERS).join(', ') + '.\n' + 'Note: This is a precaution to guard against uninitialized mock ' + 'variables. If it is ensured that the mock is required lazily, ' + 'variable names prefixed with `mock` (case insensitive) are permitted.');
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return true;
  }

  return false;
};

FUNCTIONS.unmock = function (args) {
  return args.length === 1 && args[0].isStringLiteral();
};

FUNCTIONS.deepUnmock = function (args) {
  return args.length === 1 && args[0].isStringLiteral();
};

FUNCTIONS.disableAutomock = FUNCTIONS.enableAutomock = function (args) {
  return args.length === 0;
};

module.exports = function () {
  var shouldHoistExpression = function shouldHoistExpression(expr) {
    if (!expr.isCallExpression()) {
      return false;
    }

    var callee = expr.get('callee');
    var expressionArguments = expr.get('arguments'); // TODO: avoid type casts - the types can be arrays (is it possible to ignore that without casting?)

    var object = callee.get('object');
    var property = callee.get('property');
    return property.isIdentifier() && FUNCTIONS[property.node.name] && (object.isIdentifier(JEST_GLOBAL) || callee.isMemberExpression() && shouldHoistExpression(object)) && FUNCTIONS[property.node.name](expressionArguments);
  };

  var visitor = {
    ExpressionStatement: function ExpressionStatement(path) {
      if (shouldHoistExpression(path.get('expression'))) {
        // @ts-ignore: private, magical property
        path.node._blockHoist = Infinity;
      }
    }
  };
  return {
    visitor: visitor
  };
};