#!/usr/bin/env node
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _interopDefault(ex) {
  return ex && _typeof(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
}

var fs = _interopDefault(require('fs'));

var postcss = _interopDefault(require('postcss'));

var selectorRegExp = /:blank([^\w-]|$)/gi;
var plugin = postcss.plugin('css-blank-pseudo', function (opts) {
  var replaceWith = String(Object(opts).replaceWith || '[blank]');
  var preserve = Boolean('preserve' in Object(opts) ? opts.preserve : true);
  return function (root) {
    root.walkRules(selectorRegExp, function (rule) {
      var selector = rule.selector.replace(selectorRegExp, function ($0, $1) {
        return "".concat(replaceWith).concat($1);
      });
      var clone = rule.clone({
        selector: selector
      });

      if (preserve) {
        rule.before(clone);
      } else {
        rule.replaceWith(clone);
      }
    });
  };
});

if (process.argv.length < 3) {
  console.log(['CSS Blank Pseudo\n', '  Transforms CSS with :blank {}\n', 'Usage:\n', '  css-blank-pseudo source.css transformed.css', '  css-blank-pseudo --in=source.css --out=transformed.css --opts={}', '  echo "@media (prefers-color-scheme: dark) {}" | css-blank-pseudo\n'].join('\n'));
  process.exit(0);
} // get process and plugin options from the command line


var fileRegExp = /^[\w\/.]+$/;
var argRegExp = /^--(\w+)=("|')?(.+)\2$/;
var relaxedJsonPropRegExp = /(['"])?([a-z0-9A-Z_]+)(['"])?:/g;
var relaxedJsonValueRegExp = /("[a-z0-9A-Z_]+":\s*)'?([A-z0-9]+)'?([,}])/g;
var argo = process.argv.slice(2).reduce(function (object, arg) {
  var argMatch = arg.match(argRegExp);
  var fileMatch = arg.match(fileRegExp);

  if (argMatch) {
    object[argMatch[1]] = argMatch[3];
  } else if (fileMatch) {
    if (object.from === '<stdin>') {
      object.from = arg;
    } else if (object.to === '<stdout>') {
      object.to = arg;
    }
  }

  return object;
}, {
  from: '<stdin>',
  to: '<stdout>',
  opts: 'null'
}); // get css from command line arguments or stdin

(argo.from === '<stdin>' ? getStdin() : readFile(argo.from)).then(function (css) {
  var pluginOpts = JSON.parse(argo.opts.replace(relaxedJsonPropRegExp, '"$2": ').replace(relaxedJsonValueRegExp, '$1"$2"$3'));
  var processOptions = Object.assign({
    from: argo.from,
    to: argo.to || argo.from
  }, argo.map ? {
    map: JSON.parse(argo.map)
  } : {});
  var result = plugin.process(css, processOptions, pluginOpts);

  if (argo.to === '<stdout>') {
    return result.css;
  } else {
    return writeFile(argo.to, result.css).then(function () {
      return "CSS was written to \"".concat(argo.to, "\"");
    });
  }
}).then(function (result) {
  console.log(result);
  process.exit(0);
}, function (error) {
  console.error(error);
  process.exit(1);
});

function readFile(pathname) {
  return new Promise(function (resolve, reject) {
    fs.readFile(pathname, 'utf8', function (error, data) {
      if (error) {
        reject(error);
      } else {
        resolve(data);
      }
    });
  });
}

function writeFile(pathname, data) {
  return new Promise(function (resolve, reject) {
    fs.writeFile(pathname, data, function (error, content) {
      if (error) {
        reject(error);
      } else {
        resolve(content);
      }
    });
  });
}

function getStdin() {
  return new Promise(function (resolve) {
    var data = '';

    if (process.stdin.isTTY) {
      resolve(data);
    } else {
      process.stdin.setEncoding('utf8');
      process.stdin.on('readable', function () {
        var chunk;

        while (chunk = process.stdin.read()) {
          data += chunk;
        }
      });
      process.stdin.on('end', function () {
        resolve(data);
      });
    }
  });
}