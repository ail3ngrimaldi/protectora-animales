'use strict';

var util = require('util');

var figgyPudding = require('figgy-pudding');

var fs = require('graceful-fs');

var fsm = require('fs-minipass');

var ssri = require('ssri');

var contentPath = require('./path');

var Pipeline = require('minipass-pipeline');

var lstat = util.promisify(fs.lstat);
var readFile = util.promisify(fs.readFile);
var ReadOpts = figgyPudding({
  size: {}
});
module.exports = read;
var MAX_SINGLE_READ_SIZE = 64 * 1024 * 1024;

function read(cache, integrity, opts) {
  opts = ReadOpts(opts);
  return withContentSri(cache, integrity, function (cpath, sri) {
    // get size
    return lstat(cpath).then(function (stat) {
      return {
        stat: stat,
        cpath: cpath,
        sri: sri
      };
    });
  }).then(function (_ref) {
    var stat = _ref.stat,
        cpath = _ref.cpath,
        sri = _ref.sri;

    if (typeof opts.size === 'number' && stat.size !== opts.size) {
      throw sizeError(opts.size, stat.size);
    }

    if (stat.size > MAX_SINGLE_READ_SIZE) {
      return readPipeline(cpath, stat.size, sri, new Pipeline()).concat();
    }

    return readFile(cpath, null).then(function (data) {
      if (!ssri.checkData(data, sri)) {
        throw integrityError(sri, cpath);
      }

      return data;
    });
  });
}

var readPipeline = function readPipeline(cpath, size, sri, stream) {
  stream.push(new fsm.ReadStream(cpath, {
    size: size,
    readSize: MAX_SINGLE_READ_SIZE
  }), ssri.integrityStream({
    integrity: sri,
    size: size
  }));
  return stream;
};

module.exports.sync = readSync;

function readSync(cache, integrity, opts) {
  opts = ReadOpts(opts);
  return withContentSriSync(cache, integrity, function (cpath, sri) {
    var data = fs.readFileSync(cpath);

    if (typeof opts.size === 'number' && opts.size !== data.length) {
      throw sizeError(opts.size, data.length);
    }

    if (ssri.checkData(data, sri)) {
      return data;
    }

    throw integrityError(sri, cpath);
  });
}

module.exports.stream = readStream;
module.exports.readStream = readStream;

function readStream(cache, integrity, opts) {
  opts = ReadOpts(opts);
  var stream = new Pipeline();
  withContentSri(cache, integrity, function (cpath, sri) {
    // just lstat to ensure it exists
    return lstat(cpath).then(function (stat) {
      return {
        stat: stat,
        cpath: cpath,
        sri: sri
      };
    });
  }).then(function (_ref2) {
    var stat = _ref2.stat,
        cpath = _ref2.cpath,
        sri = _ref2.sri;

    if (typeof opts.size === 'number' && opts.size !== stat.size) {
      return stream.emit('error', sizeError(opts.size, stat.size));
    }

    readPipeline(cpath, stat.size, sri, stream);
  }, function (er) {
    return stream.emit('error', er);
  });
  return stream;
}

var copyFile;

if (fs.copyFile) {
  module.exports.copy = copy;
  module.exports.copy.sync = copySync;
  copyFile = util.promisify(fs.copyFile);
}

function copy(cache, integrity, dest, opts) {
  opts = ReadOpts(opts);
  return withContentSri(cache, integrity, function (cpath, sri) {
    return copyFile(cpath, dest);
  });
}

function copySync(cache, integrity, dest, opts) {
  opts = ReadOpts(opts);
  return withContentSriSync(cache, integrity, function (cpath, sri) {
    return fs.copyFileSync(cpath, dest);
  });
}

module.exports.hasContent = hasContent;

function hasContent(cache, integrity) {
  if (!integrity) {
    return Promise.resolve(false);
  }

  return withContentSri(cache, integrity, function (cpath, sri) {
    return lstat(cpath).then(function (stat) {
      return {
        size: stat.size,
        sri: sri,
        stat: stat
      };
    });
  })["catch"](function (err) {
    if (err.code === 'ENOENT') {
      return false;
    }

    if (err.code === 'EPERM') {
      if (process.platform !== 'win32') {
        throw err;
      } else {
        return false;
      }
    }
  });
}

module.exports.hasContent.sync = hasContentSync;

function hasContentSync(cache, integrity) {
  if (!integrity) {
    return false;
  }

  return withContentSriSync(cache, integrity, function (cpath, sri) {
    try {
      var stat = fs.lstatSync(cpath);
      return {
        size: stat.size,
        sri: sri,
        stat: stat
      };
    } catch (err) {
      if (err.code === 'ENOENT') {
        return false;
      }

      if (err.code === 'EPERM') {
        if (process.platform !== 'win32') {
          throw err;
        } else {
          return false;
        }
      }
    }
  });
}

function withContentSri(cache, integrity, fn) {
  var tryFn = function tryFn() {
    var sri = ssri.parse(integrity); // If `integrity` has multiple entries, pick the first digest
    // with available local data.

    var algo = sri.pickAlgorithm();
    var digests = sri[algo];

    if (digests.length <= 1) {
      var cpath = contentPath(cache, digests[0]);
      return fn(cpath, digests[0]);
    } else {
      // Can't use race here because a generic error can happen before a ENOENT error, and can happen before a valid result
      return Promise.all(sri[sri.pickAlgorithm()].map(function (meta) {
        return withContentSri(cache, meta, fn)["catch"](function (err) {
          if (err.code === 'ENOENT') {
            return Object.assign(new Error('No matching content found for ' + sri.toString()), {
              code: 'ENOENT'
            });
          }

          return err;
        });
      })).then(function (results) {
        // Return the first non error if it is found
        var result = results.find(function (r) {
          return !(r instanceof Error);
        });

        if (result) {
          return result;
        } // Throw the No matching content found error


        var enoentError = results.find(function (r) {
          return r.code === 'ENOENT';
        });

        if (enoentError) {
          throw enoentError;
        } // Throw generic error


        var genericError = results.find(function (r) {
          return r instanceof Error;
        });

        if (genericError) {
          throw genericError;
        }
      });
    }
  };

  return new Promise(function (resolve, reject) {
    try {
      tryFn().then(resolve)["catch"](reject);
    } catch (err) {
      reject(err);
    }
  });
}

function withContentSriSync(cache, integrity, fn) {
  var sri = ssri.parse(integrity); // If `integrity` has multiple entries, pick the first digest
  // with available local data.

  var algo = sri.pickAlgorithm();
  var digests = sri[algo];

  if (digests.length <= 1) {
    var cpath = contentPath(cache, digests[0]);
    return fn(cpath, digests[0]);
  } else {
    var lastErr = null;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = sri[sri.pickAlgorithm()][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var meta = _step.value;

        try {
          return withContentSriSync(cache, meta, fn);
        } catch (err) {
          lastErr = err;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (lastErr) {
      throw lastErr;
    }
  }
}

function sizeError(expected, found) {
  var err = new Error("Bad data size: expected inserted data to be ".concat(expected, " bytes, but got ").concat(found, " instead"));
  err.expected = expected;
  err.found = found;
  err.code = 'EBADSIZE';
  return err;
}

function integrityError(sri, path) {
  var err = new Error("Integrity verification failed for ".concat(sri, " (").concat(path, ")"));
  err.code = 'EINTEGRITY';
  err.sri = sri;
  err.path = path;
  return err;
}