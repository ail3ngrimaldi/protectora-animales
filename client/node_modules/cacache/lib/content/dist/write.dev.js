'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var util = require('util');

var contentPath = require('./path');

var fixOwner = require('../util/fix-owner');

var fs = require('graceful-fs');

var moveFile = require('../util/move-file');

var Minipass = require('minipass');

var Pipeline = require('minipass-pipeline');

var Flush = require('minipass-flush');

var path = require('path');

var rimraf = util.promisify(require('rimraf'));

var ssri = require('ssri');

var uniqueFilename = require('unique-filename');

var _require = require('./../util/disposer'),
    disposer = _require.disposer;

var fsm = require('fs-minipass');

var writeFile = util.promisify(fs.writeFile);
module.exports = write;

function write(cache, data, opts) {
  opts = opts || {};

  if (opts.algorithms && opts.algorithms.length > 1) {
    throw new Error('opts.algorithms only supports a single algorithm for now');
  }

  if (typeof opts.size === 'number' && data.length !== opts.size) {
    return Promise.reject(sizeError(opts.size, data.length));
  }

  var sri = ssri.fromData(data, {
    algorithms: opts.algorithms
  });

  if (opts.integrity && !ssri.checkData(data, opts.integrity, opts)) {
    return Promise.reject(checksumError(opts.integrity, sri));
  }

  return disposer(makeTmp(cache, opts), makeTmpDisposer, function (tmp) {
    return writeFile(tmp.target, data, {
      flag: 'wx'
    }).then(function () {
      return moveToDestination(tmp, cache, sri, opts);
    });
  }).then(function () {
    return {
      integrity: sri,
      size: data.length
    };
  });
}

module.exports.stream = writeStream; // writes proxied to the 'inputStream' that is passed to the Promise
// 'end' is deferred until content is handled.

var CacacheWriteStream =
/*#__PURE__*/
function (_Flush) {
  _inherits(CacacheWriteStream, _Flush);

  function CacacheWriteStream(cache, opts) {
    var _this;

    _classCallCheck(this, CacacheWriteStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CacacheWriteStream).call(this));
    _this.opts = opts;
    _this.cache = cache;
    _this.inputStream = new Minipass();

    _this.inputStream.on('error', function (er) {
      return _this.emit('error', er);
    });

    _this.inputStream.on('drain', function () {
      return _this.emit('drain');
    });

    _this.handleContentP = null;
    return _this;
  }

  _createClass(CacacheWriteStream, [{
    key: "write",
    value: function write(chunk, encoding, cb) {
      if (!this.handleContentP) {
        this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);
      }

      return this.inputStream.write(chunk, encoding, cb);
    }
  }, {
    key: "flush",
    value: function flush(cb) {
      var _this2 = this;

      this.inputStream.end(function () {
        if (!_this2.handleContentP) {
          var e = new Error('Cache input stream was empty');
          e.code = 'ENODATA'; // empty streams are probably emitting end right away.
          // defer this one tick by rejecting a promise on it.

          return Promise.reject(e)["catch"](cb);
        }

        _this2.handleContentP.then(function (res) {
          res.integrity && _this2.emit('integrity', res.integrity);
          res.size !== null && _this2.emit('size', res.size);
          cb();
        }, function (er) {
          return cb(er);
        });
      });
    }
  }]);

  return CacacheWriteStream;
}(Flush);

function writeStream(cache, opts) {
  opts = opts || {};
  return new CacacheWriteStream(cache, opts);
}

function handleContent(inputStream, cache, opts) {
  return disposer(makeTmp(cache, opts), makeTmpDisposer, function (tmp) {
    return pipeToTmp(inputStream, cache, tmp.target, opts).then(function (res) {
      return moveToDestination(tmp, cache, res.integrity, opts).then(function () {
        return res;
      });
    });
  });
}

function pipeToTmp(inputStream, cache, tmpTarget, opts) {
  var integrity;
  var size;
  var hashStream = ssri.integrityStream({
    integrity: opts.integrity,
    algorithms: opts.algorithms,
    size: opts.size
  });
  hashStream.on('integrity', function (i) {
    integrity = i;
  });
  hashStream.on('size', function (s) {
    size = s;
  });
  var outStream = new fsm.WriteStream(tmpTarget, {
    flags: 'wx'
  }); // NB: this can throw if the hashStream has a problem with
  // it, and the data is fully written.  but pipeToTmp is only
  // called in promisory contexts where that is handled.

  var pipeline = new Pipeline(inputStream, hashStream, outStream);
  return pipeline.promise().then(function () {
    return {
      integrity: integrity,
      size: size
    };
  })["catch"](function (er) {
    return rimraf(tmpTarget).then(function () {
      throw er;
    });
  });
}

function makeTmp(cache, opts) {
  var tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);
  return fixOwner.mkdirfix(cache, path.dirname(tmpTarget)).then(function () {
    return {
      target: tmpTarget,
      moved: false
    };
  });
}

function makeTmpDisposer(tmp) {
  if (tmp.moved) {
    return Promise.resolve();
  }

  return rimraf(tmp.target);
}

function moveToDestination(tmp, cache, sri, opts) {
  var destination = contentPath(cache, sri);
  var destDir = path.dirname(destination);
  return fixOwner.mkdirfix(cache, destDir).then(function () {
    return moveFile(tmp.target, destination);
  }).then(function () {
    tmp.moved = true;
    return fixOwner.chownr(cache, destination);
  });
}

function sizeError(expected, found) {
  var err = new Error("Bad data size: expected inserted data to be ".concat(expected, " bytes, but got ").concat(found, " instead"));
  err.expected = expected;
  err.found = found;
  err.code = 'EBADSIZE';
  return err;
}

function checksumError(expected, found) {
  var err = new Error("Integrity check failed:\n  Wanted: ".concat(expected, "\n   Found: ").concat(found));
  err.code = 'EINTEGRITY';
  err.expected = expected;
  err.found = found;
  return err;
}