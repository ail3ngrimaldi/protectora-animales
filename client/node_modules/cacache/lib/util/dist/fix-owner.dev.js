'use strict';

var util = require('util');

var chownr = util.promisify(require('chownr'));
var mkdirp = util.promisify(require('mkdirp'));

var inflight = require('promise-inflight');

var inferOwner = require('infer-owner'); // Memoize getuid()/getgid() calls.
// patch process.setuid/setgid to invalidate cached value on change


var self = {
  uid: null,
  gid: null
};

var getSelf = function getSelf() {
  if (typeof self.uid !== 'number') {
    self.uid = process.getuid();
    var setuid = process.setuid;

    process.setuid = function (uid) {
      self.uid = null;
      process.setuid = setuid;
      return process.setuid(uid);
    };
  }

  if (typeof self.gid !== 'number') {
    self.gid = process.getgid();
    var setgid = process.setgid;

    process.setgid = function (gid) {
      self.gid = null;
      process.setgid = setgid;
      return process.setgid(gid);
    };
  }
};

module.exports.chownr = fixOwner;

function fixOwner(cache, filepath) {
  if (!process.getuid) {
    // This platform doesn't need ownership fixing
    return Promise.resolve();
  }

  getSelf();

  if (self.uid !== 0) {
    // almost certainly can't chown anyway
    return Promise.resolve();
  }

  return Promise.resolve(inferOwner(cache)).then(function (owner) {
    var uid = owner.uid,
        gid = owner.gid; // No need to override if it's already what we used.

    if (self.uid === uid && self.gid === gid) {
      return;
    }

    return inflight('fixOwner: fixing ownership on ' + filepath, function () {
      return chownr(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid)["catch"](function (err) {
        if (err.code === 'ENOENT') {
          return null;
        }

        throw err;
      });
    });
  });
}

module.exports.chownr.sync = fixOwnerSync;

function fixOwnerSync(cache, filepath) {
  if (!process.getuid) {
    // This platform doesn't need ownership fixing
    return;
  }

  var _inferOwner$sync = inferOwner.sync(cache),
      uid = _inferOwner$sync.uid,
      gid = _inferOwner$sync.gid;

  getSelf();

  if (self.uid !== 0) {
    // almost certainly can't chown anyway
    return;
  }

  if (self.uid === uid && self.gid === gid) {
    // No need to override if it's already what we used.
    return;
  }

  try {
    chownr.sync(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid);
  } catch (err) {
    // only catch ENOENT, any other error is a problem.
    if (err.code === 'ENOENT') {
      return null;
    }

    throw err;
  }
}

module.exports.mkdirfix = mkdirfix;

function mkdirfix(cache, p, cb) {
  // we have to infer the owner _before_ making the directory, even though
  // we aren't going to use the results, since the cache itself might not
  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed
  // to be correct if it creates the cache folder in the process.
  return Promise.resolve(inferOwner(cache)).then(function () {
    return mkdirp(p).then(function (made) {
      if (made) {
        return fixOwner(cache, made).then(function () {
          return made;
        });
      }
    })["catch"](function (err) {
      if (err.code === 'EEXIST') {
        return fixOwner(cache, p).then(function () {
          return null;
        });
      }

      throw err;
    });
  });
}

module.exports.mkdirfix.sync = mkdirfixSync;

function mkdirfixSync(cache, p) {
  try {
    inferOwner.sync(cache);
    var made = mkdirp.sync(p);

    if (made) {
      fixOwnerSync(cache, made);
      return made;
    }
  } catch (err) {
    if (err.code === 'EEXIST') {
      fixOwnerSync(cache, p);
      return null;
    } else {
      throw err;
    }
  }
}