'use strict';

var fs = require('graceful-fs');

var util = require('util');

var chmod = util.promisify(fs.chmod);
var unlink = util.promisify(fs.unlink);
var stat = util.promisify(fs.stat);

var move = require('move-concurrently');

var pinflight = require('promise-inflight');

module.exports = moveFile;

function moveFile(src, dest) {
  // This isn't quite an fs.rename -- the assumption is that
  // if `dest` already exists, and we get certain errors while
  // trying to move it, we should just not bother.
  //
  // In the case of cache corruption, users will receive an
  // EINTEGRITY error elsewhere, and can remove the offending
  // content their own way.
  //
  // Note that, as the name suggests, this strictly only supports file moves.
  return new Promise(function (resolve, reject) {
    fs.link(src, dest, function (err) {
      if (err) {
        if (err.code === 'EEXIST' || err.code === 'EBUSY') {// file already exists, so whatever
        } else if (err.code === 'EPERM' && process.platform === 'win32') {// file handle stayed open even past graceful-fs limits
        } else {
          return reject(err);
        }
      }

      return resolve();
    });
  }).then(function () {
    // content should never change for any reason, so make it read-only
    return Promise.all([unlink(src), process.platform !== 'win32' && chmod(dest, '0444')]);
  })["catch"](function () {
    return pinflight('cacache-move-file:' + dest, function () {
      return stat(dest)["catch"](function (err) {
        if (err.code !== 'ENOENT') {
          // Something else is wrong here. Bail bail bail
          throw err;
        } // file doesn't already exist! let's try a rename -> copy fallback


        return move(src, dest, {
          Promise: Promise,
          fs: fs
        });
      });
    });
  });
}