'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var util = require('util');

var crypto = require('crypto');

var figgyPudding = require('figgy-pudding');

var fs = require('graceful-fs');

var Minipass = require('minipass');

var path = require('path');

var ssri = require('ssri');

var contentPath = require('./content/path');

var fixOwner = require('./util/fix-owner');

var hashToSegments = require('./util/hash-to-segments');

var indexV = require('../package.json')['cache-version'].index;

var appendFile = util.promisify(fs.appendFile);
var readFile = util.promisify(fs.readFile);
var readdir = util.promisify(fs.readdir);

module.exports.NotFoundError =
/*#__PURE__*/
function (_Error) {
  _inherits(NotFoundError, _Error);

  function NotFoundError(cache, key) {
    var _this;

    _classCallCheck(this, NotFoundError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NotFoundError).call(this, "No cache entry for ".concat(key, " found in ").concat(cache)));
    _this.code = 'ENOENT';
    _this.cache = cache;
    _this.key = key;
    return _this;
  }

  return NotFoundError;
}(_wrapNativeSuper(Error));

var IndexOpts = figgyPudding({
  metadata: {},
  size: {}
});
module.exports.insert = insert;

function insert(cache, key, integrity, opts) {
  opts = IndexOpts(opts);
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: opts.size,
    metadata: opts.metadata
  };
  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(function () {
    var stringified = JSON.stringify(entry); // NOTE - Cleverness ahoy!
    //
    // This works because it's tremendously unlikely for an entry to corrupt
    // another while still preserving the string length of the JSON in
    // question. So, we just slap the length in there and verify it on read.
    //
    // Thanks to @isaacs for the whiteboarding session that ended up with this.

    return appendFile(bucket, "\n".concat(hashEntry(stringified), "\t").concat(stringified));
  }).then(function () {
    return fixOwner.chownr(cache, bucket);
  })["catch"](function (err) {
    if (err.code === 'ENOENT') {
      return undefined;
    }

    throw err; // There's a class of race conditions that happen when things get deleted
    // during fixOwner, or between the two mkdirfix/chownr calls.
    //
    // It's perfectly fine to just not bother in those cases and lie
    // that the index entry was written. Because it's a cache.
  }).then(function () {
    return formatEntry(cache, entry);
  });
}

module.exports.insert.sync = insertSync;

function insertSync(cache, key, integrity, opts) {
  opts = IndexOpts(opts);
  var bucket = bucketPath(cache, key);
  var entry = {
    key: key,
    integrity: integrity && ssri.stringify(integrity),
    time: Date.now(),
    size: opts.size,
    metadata: opts.metadata
  };
  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));
  var stringified = JSON.stringify(entry);
  fs.appendFileSync(bucket, "\n".concat(hashEntry(stringified), "\t").concat(stringified));

  try {
    fixOwner.chownr.sync(cache, bucket);
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  return formatEntry(cache, entry);
}

module.exports.find = find;

function find(cache, key) {
  var bucket = bucketPath(cache, key);
  return bucketEntries(bucket).then(function (entries) {
    return entries.reduce(function (latest, next) {
      if (next && next.key === key) {
        return formatEntry(cache, next);
      } else {
        return latest;
      }
    }, null);
  })["catch"](function (err) {
    if (err.code === 'ENOENT') {
      return null;
    } else {
      throw err;
    }
  });
}

module.exports.find.sync = findSync;

function findSync(cache, key) {
  var bucket = bucketPath(cache, key);

  try {
    return bucketEntriesSync(bucket).reduce(function (latest, next) {
      if (next && next.key === key) {
        return formatEntry(cache, next);
      } else {
        return latest;
      }
    }, null);
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    } else {
      throw err;
    }
  }
}

module.exports["delete"] = del;

function del(cache, key, opts) {
  return insert(cache, key, null, opts);
}

module.exports["delete"].sync = delSync;

function delSync(cache, key, opts) {
  return insertSync(cache, key, null, opts);
}

module.exports.lsStream = lsStream;

function lsStream(cache) {
  var indexDir = bucketDir(cache);
  var stream = new Minipass({
    objectMode: true
  });
  readdirOrEmpty(indexDir).then(function (buckets) {
    return Promise.all(buckets.map(function (bucket) {
      var bucketPath = path.join(indexDir, bucket);
      return readdirOrEmpty(bucketPath).then(function (subbuckets) {
        return Promise.all(subbuckets.map(function (subbucket) {
          var subbucketPath = path.join(bucketPath, subbucket); // "/cachename/<bucket 0xFF>/<bucket 0xFF>./*"

          return readdirOrEmpty(subbucketPath).then(function (entries) {
            return Promise.all(entries.map(function (entry) {
              var entryPath = path.join(subbucketPath, entry);
              return bucketEntries(entryPath).then(function (entries) {
                return (// using a Map here prevents duplicate keys from
                  // showing up twice, I guess?
                  entries.reduce(function (acc, entry) {
                    acc.set(entry.key, entry);
                    return acc;
                  }, new Map())
                );
              }).then(function (reduced) {
                // reduced is a map of key => entry
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = reduced.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _entry = _step.value;
                    var formatted = formatEntry(cache, _entry);

                    if (formatted) {
                      stream.write(formatted);
                    }
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
              })["catch"](function (err) {
                if (err.code === 'ENOENT') {
                  return undefined;
                }

                throw err;
              });
            }));
          });
        }));
      });
    }));
  }).then(function () {
    return stream.end();
  }, function (err) {
    return stream.emit('error', err);
  });
  return stream;
}

module.exports.ls = ls;

function ls(cache) {
  return lsStream(cache).collect().then(function (entries) {
    return entries.reduce(function (acc, xs) {
      acc[xs.key] = xs;
      return acc;
    }, {});
  });
}

function bucketEntries(bucket, filter) {
  return readFile(bucket, 'utf8').then(function (data) {
    return _bucketEntries(data, filter);
  });
}

function bucketEntriesSync(bucket, filter) {
  var data = fs.readFileSync(bucket, 'utf8');
  return _bucketEntries(data, filter);
}

function _bucketEntries(data, filter) {
  var entries = [];
  data.split('\n').forEach(function (entry) {
    if (!entry) {
      return;
    }

    var pieces = entry.split('\t');

    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {
      // Hash is no good! Corruption or malice? Doesn't matter!
      // EJECT EJECT
      return;
    }

    var obj;

    try {
      obj = JSON.parse(pieces[1]);
    } catch (e) {
      // Entry is corrupted!
      return;
    }

    if (obj) {
      entries.push(obj);
    }
  });
  return entries;
}

module.exports.bucketDir = bucketDir;

function bucketDir(cache) {
  return path.join(cache, "index-v".concat(indexV));
}

module.exports.bucketPath = bucketPath;

function bucketPath(cache, key) {
  var hashed = hashKey(key);
  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));
}

module.exports.hashKey = hashKey;

function hashKey(key) {
  return hash(key, 'sha256');
}

module.exports.hashEntry = hashEntry;

function hashEntry(str) {
  return hash(str, 'sha1');
}

function hash(str, digest) {
  return crypto.createHash(digest).update(str).digest('hex');
}

function formatEntry(cache, entry) {
  // Treat null digests as deletions. They'll shadow any previous entries.
  if (!entry.integrity) {
    return null;
  }

  return {
    key: entry.key,
    integrity: entry.integrity,
    path: contentPath(cache, entry.integrity),
    size: entry.size,
    time: entry.time,
    metadata: entry.metadata
  };
}

function readdirOrEmpty(dir) {
  return readdir(dir)["catch"](function (err) {
    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {
      return [];
    }

    throw err;
  });
}