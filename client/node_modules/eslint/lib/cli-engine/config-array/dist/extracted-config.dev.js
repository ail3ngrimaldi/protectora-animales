/**
 * @fileoverview `ExtractedConfig` class.
 *
 * `ExtractedConfig` class expresses a final configuration for a specific file.
 *
 * It provides one method.
 *
 * - `toCompatibleObjectAsConfigFileContent()`
 *      Convert this configuration to the compatible object as the content of
 *      config files. It converts the loaded parser and plugins to strings.
 *      `CLIEngine#getConfigForFile(filePath)` method uses this method.
 *
 * `ConfigArray#extractConfig(filePath)` creates a `ExtractedConfig` instance.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("./ignore-pattern"),
    IgnorePattern = _require.IgnorePattern; // For VSCode intellisense

/** @typedef {import("../../shared/types").ConfigData} ConfigData */

/** @typedef {import("../../shared/types").GlobalConf} GlobalConf */

/** @typedef {import("../../shared/types").SeverityConf} SeverityConf */

/** @typedef {import("./config-dependency").DependentParser} DependentParser */

/** @typedef {import("./config-dependency").DependentPlugin} DependentPlugin */

/**
 * Check if `xs` starts with `ys`.
 * @template T
 * @param {T[]} xs The array to check.
 * @param {T[]} ys The array that may be the first part of `xs`.
 * @returns {boolean} `true` if `xs` starts with `ys`.
 */


function startsWith(xs, ys) {
  return xs.length >= ys.length && ys.every(function (y, i) {
    return y === xs[i];
  });
}
/**
 * The class for extracted config data.
 */


var ExtractedConfig =
/*#__PURE__*/
function () {
  function ExtractedConfig() {
    _classCallCheck(this, ExtractedConfig);

    /**
     * The config name what `noInlineConfig` setting came from.
     * @type {string}
     */
    this.configNameOfNoInlineConfig = "";
    /**
     * Environments.
     * @type {Record<string, boolean>}
     */

    this.env = {};
    /**
     * Global variables.
     * @type {Record<string, GlobalConf>}
     */

    this.globals = {};
    /**
     * The glob patterns that ignore to lint.
     * @type {(((filePath:string, dot?:boolean) => boolean) & { basePath:string; patterns:string[] }) | undefined}
     */

    this.ignores = void 0;
    /**
     * The flag that disables directive comments.
     * @type {boolean|undefined}
     */

    this.noInlineConfig = void 0;
    /**
     * Parser definition.
     * @type {DependentParser|null}
     */

    this.parser = null;
    /**
     * Options for the parser.
     * @type {Object}
     */

    this.parserOptions = {};
    /**
     * Plugin definitions.
     * @type {Record<string, DependentPlugin>}
     */

    this.plugins = {};
    /**
     * Processor ID.
     * @type {string|null}
     */

    this.processor = null;
    /**
     * The flag that reports unused `eslint-disable` directive comments.
     * @type {boolean|undefined}
     */

    this.reportUnusedDisableDirectives = void 0;
    /**
     * Rule settings.
     * @type {Record<string, [SeverityConf, ...any[]]>}
     */

    this.rules = {};
    /**
     * Shared settings.
     * @type {Object}
     */

    this.settings = {};
  }
  /**
   * Convert this config to the compatible object as a config file content.
   * @returns {ConfigData} The converted object.
   */


  _createClass(ExtractedConfig, [{
    key: "toCompatibleObjectAsConfigFileContent",
    value: function toCompatibleObjectAsConfigFileContent() {
      var _ignore1 = this.configNameOfNoInlineConfig,
          _ignore2 = this.processor,
          ignores = this.ignores,
          config = _objectWithoutProperties(this, ["configNameOfNoInlineConfig", "processor", "ignores"]);

      config.parser = config.parser && config.parser.filePath;
      config.plugins = Object.keys(config.plugins).filter(Boolean).reverse();
      config.ignorePatterns = ignores ? ignores.patterns : []; // Strip the default patterns from `ignorePatterns`.

      if (startsWith(config.ignorePatterns, IgnorePattern.DefaultPatterns)) {
        config.ignorePatterns = config.ignorePatterns.slice(IgnorePattern.DefaultPatterns.length);
      }

      return config;
    }
  }]);

  return ExtractedConfig;
}();

module.exports = {
  ExtractedConfig: ExtractedConfig
};