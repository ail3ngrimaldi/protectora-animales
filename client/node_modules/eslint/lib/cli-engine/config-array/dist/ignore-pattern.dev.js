/**
 * @fileoverview `IgnorePattern` class.
 *
 * `IgnorePattern` class has the set of glob patterns and the base path.
 *
 * It provides two static methods.
 *
 * - `IgnorePattern.createDefaultIgnore(cwd)`
 *      Create the default predicate function.
 * - `IgnorePattern.createIgnore(ignorePatterns)`
 *      Create the predicate function from multiple `IgnorePattern` objects.
 *
 * It provides two properties and a method.
 *
 * - `patterns`
 *      The glob patterns that ignore to lint.
 * - `basePath`
 *      The base path of the glob patterns. If absolute paths existed in the
 *      glob patterns, those are handled as relative paths to the base path.
 * - `getPatternsRelativeTo(basePath)`
 *      Get `patterns` as modified for a given base path. It modifies the
 *      absolute paths in the patterns as prepending the difference of two base
 *      paths.
 *
 * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes
 * `ignorePatterns` properties.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var assert = require("assert");

var path = require("path");

var ignore = require("ignore");

var debug = require("debug")("eslint:ignore-pattern");
/** @typedef {ReturnType<import("ignore").default>} Ignore */
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Get the path to the common ancestor directory of given paths.
 * @param {string[]} sourcePaths The paths to calculate the common ancestor.
 * @returns {string} The path to the common ancestor directory.
 */


function getCommonAncestorPath(sourcePaths) {
  var result = sourcePaths[0];

  for (var i = 1; i < sourcePaths.length; ++i) {
    var a = result;
    var b = sourcePaths[i]; // Set the shorter one (it's the common ancestor if one includes the other).

    result = a.length < b.length ? a : b; // Set the common ancestor.

    for (var j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {
      if (a[j] !== b[j]) {
        result = a.slice(0, lastSepPos);
        break;
      }

      if (a[j] === path.sep) {
        lastSepPos = j;
      }
    }
  }

  return result || path.sep;
}
/**
 * Make relative path.
 * @param {string} from The source path to get relative path.
 * @param {string} to The destination path to get relative path.
 * @returns {string} The relative path.
 */


function relative(from, to) {
  var relPath = path.relative(from, to);

  if (path.sep === "/") {
    return relPath;
  }

  return relPath.split(path.sep).join("/");
}
/**
 * Get the trailing slash if existed.
 * @param {string} filePath The path to check.
 * @returns {string} The trailing slash if existed.
 */


function dirSuffix(filePath) {
  var isDir = filePath.endsWith(path.sep) || process.platform === "win32" && filePath.endsWith("/");
  return isDir ? "/" : "";
}

var DefaultPatterns = Object.freeze(["/node_modules/*", "/bower_components/*"]);
var DotPatterns = Object.freeze([".*", "!../"]); //------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

var IgnorePattern =
/*#__PURE__*/
function () {
  _createClass(IgnorePattern, null, [{
    key: "createDefaultIgnore",

    /**
     * Create the default predicate function.
     * @param {string} cwd The current working directory.
     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}
     * The preficate function.
     * The first argument is an absolute path that is checked.
     * The second argument is the flag to not ignore dotfiles.
     * If the predicate function returned `true`, it means the path should be ignored.
     */
    value: function createDefaultIgnore(cwd) {
      return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);
    }
    /**
     * Create the predicate function from multiple `IgnorePattern` objects.
     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.
     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}
     * The preficate function.
     * The first argument is an absolute path that is checked.
     * The second argument is the flag to not ignore dotfiles.
     * If the predicate function returned `true`, it means the path should be ignored.
     */

  }, {
    key: "createIgnore",
    value: function createIgnore(ignorePatterns) {
      var _ref;

      debug("Create with: %o", ignorePatterns);
      var basePath = getCommonAncestorPath(ignorePatterns.map(function (p) {
        return p.basePath;
      }));

      var patterns = (_ref = []).concat.apply(_ref, _toConsumableArray(ignorePatterns.map(function (p) {
        return p.getPatternsRelativeTo(basePath);
      })));

      var ig = ignore().add([].concat(_toConsumableArray(DotPatterns), _toConsumableArray(patterns)));
      var dotIg = ignore().add(patterns);
      debug("  processed: %o", {
        basePath: basePath,
        patterns: patterns
      });
      return Object.assign(function (filePath) {
        var dot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert(path.isAbsolute(filePath), "'filePath' should be an absolute path.");
        var relPathRaw = relative(basePath, filePath);
        var relPath = relPathRaw && relPathRaw + dirSuffix(filePath);
        var adoptedIg = dot ? dotIg : ig;
        var result = relPath !== "" && adoptedIg.ignores(relPath);
        debug("Check", {
          filePath: filePath,
          dot: dot,
          relativePath: relPath,
          result: result
        });
        return result;
      }, {
        basePath: basePath,
        patterns: patterns
      });
    }
    /**
     * Initialize a new `IgnorePattern` instance.
     * @param {string[]} patterns The glob patterns that ignore to lint.
     * @param {string} basePath The base path of `patterns`.
     */

  }, {
    key: "DefaultPatterns",

    /**
     * The default patterns.
     * @type {string[]}
     */
    get: function get() {
      return DefaultPatterns;
    }
  }]);

  function IgnorePattern(patterns, basePath) {
    _classCallCheck(this, IgnorePattern);

    assert(path.isAbsolute(basePath), "'basePath' should be an absolute path.");
    /**
     * The glob patterns that ignore to lint.
     * @type {string[]}
     */

    this.patterns = patterns;
    /**
     * The base path of `patterns`.
     * @type {string}
     */

    this.basePath = basePath;
    /**
     * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.
     *
     * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.
     * It's `false` as-is for `ignorePatterns` property in config files.
     * @type {boolean}
     */

    this.loose = false;
  }
  /**
   * Get `patterns` as modified for a given base path. It modifies the
   * absolute paths in the patterns as prepending the difference of two base
   * paths.
   * @param {string} newBasePath The base path.
   * @returns {string[]} Modifired patterns.
   */


  _createClass(IgnorePattern, [{
    key: "getPatternsRelativeTo",
    value: function getPatternsRelativeTo(newBasePath) {
      assert(path.isAbsolute(newBasePath), "'newBasePath' should be an absolute path.");
      var basePath = this.basePath,
          loose = this.loose,
          patterns = this.patterns;

      if (newBasePath === basePath) {
        return patterns;
      }

      var prefix = "/".concat(relative(newBasePath, basePath));
      return patterns.map(function (pattern) {
        var negative = pattern.startsWith("!");
        var head = negative ? "!" : "";
        var body = negative ? pattern.slice(1) : pattern;

        if (body.startsWith("/") || body.startsWith("../")) {
          return "".concat(head).concat(prefix).concat(body);
        }

        return loose ? pattern : "".concat(head).concat(prefix, "/**/").concat(body);
      });
    }
  }]);

  return IgnorePattern;
}();

module.exports = {
  IgnorePattern: IgnorePattern
};