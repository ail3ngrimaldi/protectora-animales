/**
 * @fileoverview `ConfigDependency` class.
 *
 * `ConfigDependency` class expresses a loaded parser or plugin.
 *
 * If the parser or plugin was loaded successfully, it has `definition` property
 * and `filePath` property. Otherwise, it has `error` property.
 *
 * When `JSON.stringify()` converted a `ConfigDependency` object to a JSON, it
 * omits `definition` property.
 *
 * `ConfigArrayFactory` creates `ConfigDependency` objects when it loads parsers
 * or plugins.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var util = require("util");
/**
 * The class is to store parsers or plugins.
 * This class hides the loaded object from `JSON.stringify()` and `console.log`.
 * @template T
 */


var ConfigDependency =
/*#__PURE__*/
function () {
  /**
   * Initialize this instance.
   * @param {Object} data The dependency data.
   * @param {T} [data.definition] The dependency if the loading succeeded.
   * @param {Error} [data.error] The error object if the loading failed.
   * @param {string} [data.filePath] The actual path to the dependency if the loading succeeded.
   * @param {string} data.id The ID of this dependency.
   * @param {string} data.importerName The name of the config file which loads this dependency.
   * @param {string} data.importerPath The path to the config file which loads this dependency.
   */
  function ConfigDependency(_ref) {
    var _ref$definition = _ref.definition,
        definition = _ref$definition === void 0 ? null : _ref$definition,
        _ref$error = _ref.error,
        error = _ref$error === void 0 ? null : _ref$error,
        _ref$filePath = _ref.filePath,
        filePath = _ref$filePath === void 0 ? null : _ref$filePath,
        id = _ref.id,
        importerName = _ref.importerName,
        importerPath = _ref.importerPath;

    _classCallCheck(this, ConfigDependency);

    /**
     * The loaded dependency if the loading succeeded.
     * @type {T|null}
     */
    this.definition = definition;
    /**
     * The error object if the loading failed.
     * @type {Error|null}
     */

    this.error = error;
    /**
     * The loaded dependency if the loading succeeded.
     * @type {string|null}
     */

    this.filePath = filePath;
    /**
     * The ID of this dependency.
     * @type {string}
     */

    this.id = id;
    /**
     * The name of the config file which loads this dependency.
     * @type {string}
     */

    this.importerName = importerName;
    /**
     * The path to the config file which loads this dependency.
     * @type {string}
     */

    this.importerPath = importerPath;
  } // eslint-disable-next-line jsdoc/require-description

  /**
   * @returns {Object} a JSON compatible object.
   */


  _createClass(ConfigDependency, [{
    key: "toJSON",
    value: function toJSON() {
      var obj = this[util.inspect.custom](); // Display `error.message` (`Error#message` is unenumerable).

      if (obj.error instanceof Error) {
        obj.error = _objectSpread({}, obj.error, {
          message: obj.error.message
        });
      }

      return obj;
    } // eslint-disable-next-line jsdoc/require-description

    /**
     * @returns {Object} an object to display by `console.log()`.
     */

  }, {
    key: util.inspect.custom,
    value: function value() {
      var _ignore = this.definition,
          obj = _objectWithoutProperties(this, ["definition"]);

      return obj;
    }
  }]);

  return ConfigDependency;
}();
/** @typedef {ConfigDependency<import("../../shared/types").Parser>} DependentParser */

/** @typedef {ConfigDependency<import("../../shared/types").Plugin>} DependentPlugin */


module.exports = {
  ConfigDependency: ConfigDependency
};