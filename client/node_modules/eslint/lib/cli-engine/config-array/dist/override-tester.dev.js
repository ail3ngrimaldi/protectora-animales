/**
 * @fileoverview `OverrideTester` class.
 *
 * `OverrideTester` class handles `files` property and `excludedFiles` property
 * of `overrides` config.
 *
 * It provides one method.
 *
 * - `test(filePath)`
 *      Test if a file path matches the pair of `files` property and
 *      `excludedFiles` property. The `filePath` argument must be an absolute
 *      path.
 *
 * `ConfigArrayFactory` creates `OverrideTester` objects when it processes
 * `overrides` properties.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assert = require("assert");

var path = require("path");

var util = require("util");

var _require = require("minimatch"),
    Minimatch = _require.Minimatch;

var minimatchOpts = {
  dot: true,
  matchBase: true
};
/**
 * @typedef {Object} Pattern
 * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.
 * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.
 */

/**
 * Normalize a given pattern to an array.
 * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.
 * @returns {string[]|null} Normalized patterns.
 * @private
 */

function normalizePatterns(patterns) {
  if (Array.isArray(patterns)) {
    return patterns.filter(Boolean);
  }

  if (typeof patterns === "string" && patterns) {
    return [patterns];
  }

  return [];
}
/**
 * Create the matchers of given patterns.
 * @param {string[]} patterns The patterns.
 * @returns {InstanceType<Minimatch>[] | null} The matchers.
 */


function toMatcher(patterns) {
  if (patterns.length === 0) {
    return null;
  }

  return patterns.map(function (pattern) {
    if (/^\.[\/\\]/.test(pattern)) {
      return new Minimatch(pattern.slice(2), // `./*.js` should not match with `subdir/foo.js`
      _objectSpread({}, minimatchOpts, {
        matchBase: false
      }));
    }

    return new Minimatch(pattern, minimatchOpts);
  });
}
/**
 * Convert a given matcher to string.
 * @param {Pattern} matchers The matchers.
 * @returns {string} The string expression of the matcher.
 */


function patternToJson(_ref) {
  var includes = _ref.includes,
      excludes = _ref.excludes;
  return {
    includes: includes && includes.map(function (m) {
      return m.pattern;
    }),
    excludes: excludes && excludes.map(function (m) {
      return m.pattern;
    })
  };
}
/**
 * The class to test given paths are matched by the patterns.
 */


var OverrideTester =
/*#__PURE__*/
function () {
  _createClass(OverrideTester, null, [{
    key: "create",

    /**
     * Create a tester with given criteria.
     * If there are no criteria, returns `null`.
     * @param {string|string[]} files The glob patterns for included files.
     * @param {string|string[]} excludedFiles The glob patterns for excluded files.
     * @param {string} basePath The path to the base directory to test paths.
     * @returns {OverrideTester|null} The created instance or `null`.
     */
    value: function create(files, excludedFiles, basePath) {
      var includePatterns = normalizePatterns(files);
      var excludePatterns = normalizePatterns(excludedFiles);
      var allPatterns = includePatterns.concat(excludePatterns);

      if (allPatterns.length === 0) {
        return null;
      } // Rejects absolute paths or relative paths to parents.


      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = allPatterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pattern = _step.value;

          if (path.isAbsolute(pattern) || pattern.includes("..")) {
            throw new Error("Invalid override pattern (expected relative path not containing '..'): ".concat(pattern));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var includes = toMatcher(includePatterns);
      var excludes = toMatcher(excludePatterns);
      return new OverrideTester([{
        includes: includes,
        excludes: excludes
      }], basePath);
    }
    /**
     * Combine two testers by logical and.
     * If either of the testers was `null`, returns the other tester.
     * The `basePath` property of the two must be the same value.
     * @param {OverrideTester|null} a A tester.
     * @param {OverrideTester|null} b Another tester.
     * @returns {OverrideTester|null} Combined tester.
     */

  }, {
    key: "and",
    value: function and(a, b) {
      if (!b) {
        return a && new OverrideTester(a.patterns, a.basePath);
      }

      if (!a) {
        return new OverrideTester(b.patterns, b.basePath);
      }

      assert.strictEqual(a.basePath, b.basePath);
      return new OverrideTester(a.patterns.concat(b.patterns), a.basePath);
    }
    /**
     * Initialize this instance.
     * @param {Pattern[]} patterns The matchers.
     * @param {string} basePath The base path.
     */

  }]);

  function OverrideTester(patterns, basePath) {
    _classCallCheck(this, OverrideTester);

    /** @type {Pattern[]} */
    this.patterns = patterns;
    /** @type {string} */

    this.basePath = basePath;
  }
  /**
   * Test if a given path is matched or not.
   * @param {string} filePath The absolute path to the target file.
   * @returns {boolean} `true` if the path was matched.
   */


  _createClass(OverrideTester, [{
    key: "test",
    value: function test(filePath) {
      if (typeof filePath !== "string" || !path.isAbsolute(filePath)) {
        throw new Error("'filePath' should be an absolute path, but got ".concat(filePath, "."));
      }

      var relativePath = path.relative(this.basePath, filePath);
      return this.patterns.every(function (_ref2) {
        var includes = _ref2.includes,
            excludes = _ref2.excludes;
        return (!includes || includes.some(function (m) {
          return m.match(relativePath);
        })) && (!excludes || !excludes.some(function (m) {
          return m.match(relativePath);
        }));
      });
    } // eslint-disable-next-line jsdoc/require-description

    /**
     * @returns {Object} a JSON compatible object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      if (this.patterns.length === 1) {
        return _objectSpread({}, patternToJson(this.patterns[0]), {
          basePath: this.basePath
        });
      }

      return {
        AND: this.patterns.map(patternToJson),
        basePath: this.basePath
      };
    } // eslint-disable-next-line jsdoc/require-description

    /**
     * @returns {Object} an object to display by `console.log()`.
     */

  }, {
    key: util.inspect.custom,
    value: function value() {
      return this.toJSON();
    }
  }]);

  return OverrideTester;
}();

module.exports = {
  OverrideTester: OverrideTester
};