/**
 * @fileoverview `CascadingConfigArrayFactory` class.
 *
 * `CascadingConfigArrayFactory` class has a responsibility:
 *
 * 1. Handles cascading of config files.
 *
 * It provides two methods:
 *
 * - `getConfigArrayForFile(filePath)`
 *     Get the corresponded configuration of a given file. This method doesn't
 *     throw even if the given file didn't exist.
 * - `clearCache()`
 *     Clear the internal cache. You have to call this method when
 *     `additionalPluginPool` was updated if `baseConfig` or `cliConfig` depends
 *     on the additional plugins. (`CLIEngine#addPlugin()` method calls this.)
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var os = require("os");

var path = require("path");

var _require = require("../shared/config-validator"),
    validateConfigArray = _require.validateConfigArray;

var _require2 = require("./config-array-factory"),
    ConfigArrayFactory = _require2.ConfigArrayFactory;

var _require3 = require("./config-array"),
    ConfigArray = _require3.ConfigArray,
    ConfigDependency = _require3.ConfigDependency,
    IgnorePattern = _require3.IgnorePattern;

var loadRules = require("./load-rules");

var debug = require("debug")("eslint:cascading-config-array-factory"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
// Define types for VSCode IntelliSense.

/** @typedef {import("../shared/types").ConfigData} ConfigData */

/** @typedef {import("../shared/types").Parser} Parser */

/** @typedef {import("../shared/types").Plugin} Plugin */

/** @typedef {ReturnType<ConfigArrayFactory["create"]>} ConfigArray */

/**
 * @typedef {Object} CascadingConfigArrayFactoryOptions
 * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.
 * @property {ConfigData} [baseConfig] The config by `baseConfig` option.
 * @property {ConfigData} [cliConfig] The config by CLI options (`--env`, `--global`, `--ignore-pattern`, `--parser`, `--parser-options`, `--plugin`, and `--rule`). CLI options overwrite the setting in config files.
 * @property {string} [cwd] The base directory to start lookup.
 * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.
 * @property {string[]} [rulePaths] The value of `--rulesdir` option.
 * @property {string} [specificConfigPath] The value of `--config` option.
 * @property {boolean} [useEslintrc] if `false` then it doesn't load config files.
 */

/**
 * @typedef {Object} CascadingConfigArrayFactoryInternalSlots
 * @property {ConfigArray} baseConfigArray The config array of `baseConfig` option.
 * @property {ConfigData} baseConfigData The config data of `baseConfig` option. This is used to reset `baseConfigArray`.
 * @property {ConfigArray} cliConfigArray The config array of CLI options.
 * @property {ConfigData} cliConfigData The config data of CLI options. This is used to reset `cliConfigArray`.
 * @property {ConfigArrayFactory} configArrayFactory The factory for config arrays.
 * @property {Map<string, ConfigArray>} configCache The cache from directory paths to config arrays.
 * @property {string} cwd The base directory to start lookup.
 * @property {WeakMap<ConfigArray, ConfigArray>} finalizeCache The cache from config arrays to finalized config arrays.
 * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.
 * @property {string[]|null} rulePaths The value of `--rulesdir` option. This is used to reset `baseConfigArray`.
 * @property {string|null} specificConfigPath The value of `--config` option. This is used to reset `cliConfigArray`.
 * @property {boolean} useEslintrc if `false` then it doesn't load config files.
 */

/** @type {WeakMap<CascadingConfigArrayFactory, CascadingConfigArrayFactoryInternalSlots>} */


var internalSlotsMap = new WeakMap();
/**
 * Create the config array from `baseConfig` and `rulePaths`.
 * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.
 * @returns {ConfigArray} The config array of the base configs.
 */

function createBaseConfigArray(_ref) {
  var configArrayFactory = _ref.configArrayFactory,
      baseConfigData = _ref.baseConfigData,
      rulePaths = _ref.rulePaths,
      cwd = _ref.cwd;
  var baseConfigArray = configArrayFactory.create(baseConfigData, {
    name: "BaseConfig"
  });
  /*
   * Create the config array element for the default ignore patterns.
   * This element has `ignorePattern` property that ignores the default
   * patterns in the current working directory.
   */

  baseConfigArray.unshift(configArrayFactory.create({
    ignorePatterns: IgnorePattern.DefaultPatterns
  }, {
    name: "DefaultIgnorePattern"
  })[0]);
  /*
   * Load rules `--rulesdir` option as a pseudo plugin.
   * Use a pseudo plugin to define rules of `--rulesdir`, so we can validate
   * the rule's options with only information in the config array.
   */

  if (rulePaths && rulePaths.length > 0) {
    baseConfigArray.push({
      name: "--rulesdir",
      filePath: "",
      plugins: {
        "": new ConfigDependency({
          definition: {
            rules: rulePaths.reduce(function (map, rulesPath) {
              return Object.assign(map, loadRules(rulesPath, cwd));
            }, {})
          },
          filePath: "",
          id: "",
          importerName: "--rulesdir",
          importerPath: ""
        })
      }
    });
  }

  return baseConfigArray;
}
/**
 * Create the config array from CLI options.
 * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.
 * @returns {ConfigArray} The config array of the base configs.
 */


function createCLIConfigArray(_ref2) {
  var cliConfigData = _ref2.cliConfigData,
      configArrayFactory = _ref2.configArrayFactory,
      ignorePath = _ref2.ignorePath,
      specificConfigPath = _ref2.specificConfigPath;
  var cliConfigArray = configArrayFactory.create(cliConfigData, {
    name: "CLIOptions"
  });
  cliConfigArray.unshift.apply(cliConfigArray, _toConsumableArray(ignorePath ? configArrayFactory.loadESLintIgnore(ignorePath) : configArrayFactory.loadDefaultESLintIgnore()));

  if (specificConfigPath) {
    cliConfigArray.unshift.apply(cliConfigArray, _toConsumableArray(configArrayFactory.loadFile(specificConfigPath, {
      name: "--config"
    })));
  }

  return cliConfigArray;
}
/**
 * The error type when there are files matched by a glob, but all of them have been ignored.
 */


var ConfigurationNotFoundError =
/*#__PURE__*/
function (_Error) {
  _inherits(ConfigurationNotFoundError, _Error);

  // eslint-disable-next-line jsdoc/require-description

  /**
   * @param {string} directoryPath The directory path.
   */
  function ConfigurationNotFoundError(directoryPath) {
    var _this;

    _classCallCheck(this, ConfigurationNotFoundError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConfigurationNotFoundError).call(this, "No ESLint configuration found in ".concat(directoryPath, ".")));
    _this.messageTemplate = "no-config-found";
    _this.messageData = {
      directoryPath: directoryPath
    };
    return _this;
  }

  return ConfigurationNotFoundError;
}(_wrapNativeSuper(Error));
/**
 * This class provides the functionality that enumerates every file which is
 * matched by given glob patterns and that configuration.
 */


var CascadingConfigArrayFactory =
/*#__PURE__*/
function () {
  /**
   * Initialize this enumerator.
   * @param {CascadingConfigArrayFactoryOptions} options The options.
   */
  function CascadingConfigArrayFactory() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$additionalPlugi = _ref3.additionalPluginPool,
        additionalPluginPool = _ref3$additionalPlugi === void 0 ? new Map() : _ref3$additionalPlugi,
        _ref3$baseConfig = _ref3.baseConfig,
        baseConfigData = _ref3$baseConfig === void 0 ? null : _ref3$baseConfig,
        _ref3$cliConfig = _ref3.cliConfig,
        cliConfigData = _ref3$cliConfig === void 0 ? null : _ref3$cliConfig,
        _ref3$cwd = _ref3.cwd,
        cwd = _ref3$cwd === void 0 ? process.cwd() : _ref3$cwd,
        ignorePath = _ref3.ignorePath,
        _ref3$resolvePluginsR = _ref3.resolvePluginsRelativeTo,
        resolvePluginsRelativeTo = _ref3$resolvePluginsR === void 0 ? cwd : _ref3$resolvePluginsR,
        _ref3$rulePaths = _ref3.rulePaths,
        rulePaths = _ref3$rulePaths === void 0 ? [] : _ref3$rulePaths,
        _ref3$specificConfigP = _ref3.specificConfigPath,
        specificConfigPath = _ref3$specificConfigP === void 0 ? null : _ref3$specificConfigP,
        _ref3$useEslintrc = _ref3.useEslintrc,
        useEslintrc = _ref3$useEslintrc === void 0 ? true : _ref3$useEslintrc;

    _classCallCheck(this, CascadingConfigArrayFactory);

    var configArrayFactory = new ConfigArrayFactory({
      additionalPluginPool: additionalPluginPool,
      cwd: cwd,
      resolvePluginsRelativeTo: resolvePluginsRelativeTo
    });
    internalSlotsMap.set(this, {
      baseConfigArray: createBaseConfigArray({
        baseConfigData: baseConfigData,
        configArrayFactory: configArrayFactory,
        cwd: cwd,
        rulePaths: rulePaths
      }),
      baseConfigData: baseConfigData,
      cliConfigArray: createCLIConfigArray({
        cliConfigData: cliConfigData,
        configArrayFactory: configArrayFactory,
        ignorePath: ignorePath,
        specificConfigPath: specificConfigPath
      }),
      cliConfigData: cliConfigData,
      configArrayFactory: configArrayFactory,
      configCache: new Map(),
      cwd: cwd,
      finalizeCache: new WeakMap(),
      ignorePath: ignorePath,
      rulePaths: rulePaths,
      specificConfigPath: specificConfigPath,
      useEslintrc: useEslintrc
    });
  }
  /**
   * The path to the current working directory.
   * This is used by tests.
   * @type {string}
   */


  _createClass(CascadingConfigArrayFactory, [{
    key: "getConfigArrayForFile",

    /**
     * Get the config array of a given file.
     * If `filePath` was not given, it returns the config which contains only
     * `baseConfigData` and `cliConfigData`.
     * @param {string} [filePath] The file path to a file.
     * @param {Object} [options] The options.
     * @param {boolean} [options.ignoreNotFoundError] If `true` then it doesn't throw `ConfigurationNotFoundError`.
     * @returns {ConfigArray} The config array of the file.
     */
    value: function getConfigArrayForFile(filePath) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref4$ignoreNotFoundE = _ref4.ignoreNotFoundError,
          ignoreNotFoundError = _ref4$ignoreNotFoundE === void 0 ? false : _ref4$ignoreNotFoundE;

      var _internalSlotsMap$get = internalSlotsMap.get(this),
          baseConfigArray = _internalSlotsMap$get.baseConfigArray,
          cliConfigArray = _internalSlotsMap$get.cliConfigArray,
          cwd = _internalSlotsMap$get.cwd;

      if (!filePath) {
        return _construct(ConfigArray, _toConsumableArray(baseConfigArray).concat(_toConsumableArray(cliConfigArray)));
      }

      var directoryPath = path.dirname(path.resolve(cwd, filePath));
      debug("Load config files for ".concat(directoryPath, "."));
      return this._finalizeConfigArray(this._loadConfigInAncestors(directoryPath), directoryPath, ignoreNotFoundError);
    }
    /**
     * Clear config cache.
     * @returns {void}
     */

  }, {
    key: "clearCache",
    value: function clearCache() {
      var slots = internalSlotsMap.get(this);
      slots.baseConfigArray = createBaseConfigArray(slots);
      slots.cliConfigArray = createCLIConfigArray(slots);
      slots.configCache.clear();
    }
    /**
     * Load and normalize config files from the ancestor directories.
     * @param {string} directoryPath The path to a leaf directory.
     * @returns {ConfigArray} The loaded config.
     * @private
     */

  }, {
    key: "_loadConfigInAncestors",
    value: function _loadConfigInAncestors(directoryPath) {
      var _internalSlotsMap$get2 = internalSlotsMap.get(this),
          baseConfigArray = _internalSlotsMap$get2.baseConfigArray,
          configArrayFactory = _internalSlotsMap$get2.configArrayFactory,
          configCache = _internalSlotsMap$get2.configCache,
          cwd = _internalSlotsMap$get2.cwd,
          useEslintrc = _internalSlotsMap$get2.useEslintrc;

      if (!useEslintrc) {
        return baseConfigArray;
      }

      var configArray = configCache.get(directoryPath); // Hit cache.

      if (configArray) {
        debug("Cache hit: ".concat(directoryPath, "."));
        return configArray;
      }

      debug("No cache found: ".concat(directoryPath, "."));
      var homePath = os.homedir(); // Consider this is root.

      if (directoryPath === homePath && cwd !== homePath) {
        debug("Stop traversing because of considered root.");
        return this._cacheConfig(directoryPath, baseConfigArray);
      } // Load the config on this directory.


      try {
        configArray = configArrayFactory.loadInDirectory(directoryPath);
      } catch (error) {
        /* istanbul ignore next */
        if (error.code === "EACCES") {
          debug("Stop traversing because of 'EACCES' error.");
          return this._cacheConfig(directoryPath, baseConfigArray);
        }

        throw error;
      }

      if (configArray.length > 0 && configArray.isRoot()) {
        var _configArray;

        debug("Stop traversing because of 'root:true'.");

        (_configArray = configArray).unshift.apply(_configArray, _toConsumableArray(baseConfigArray));

        return this._cacheConfig(directoryPath, configArray);
      } // Load from the ancestors and merge it.


      var parentPath = path.dirname(directoryPath);
      var parentConfigArray = parentPath && parentPath !== directoryPath ? this._loadConfigInAncestors(parentPath) : baseConfigArray;

      if (configArray.length > 0) {
        var _configArray2;

        (_configArray2 = configArray).unshift.apply(_configArray2, _toConsumableArray(parentConfigArray));
      } else {
        configArray = parentConfigArray;
      } // Cache and return.


      return this._cacheConfig(directoryPath, configArray);
    }
    /**
     * Freeze and cache a given config.
     * @param {string} directoryPath The path to a directory as a cache key.
     * @param {ConfigArray} configArray The config array as a cache value.
     * @returns {ConfigArray} The `configArray` (frozen).
     */

  }, {
    key: "_cacheConfig",
    value: function _cacheConfig(directoryPath, configArray) {
      var _internalSlotsMap$get3 = internalSlotsMap.get(this),
          configCache = _internalSlotsMap$get3.configCache;

      Object.freeze(configArray);
      configCache.set(directoryPath, configArray);
      return configArray;
    }
    /**
     * Finalize a given config array.
     * Concatenate `--config` and other CLI options.
     * @param {ConfigArray} configArray The parent config array.
     * @param {string} directoryPath The path to the leaf directory to find config files.
     * @param {boolean} ignoreNotFoundError If `true` then it doesn't throw `ConfigurationNotFoundError`.
     * @returns {ConfigArray} The loaded config.
     * @private
     */

  }, {
    key: "_finalizeConfigArray",
    value: function _finalizeConfigArray(configArray, directoryPath, ignoreNotFoundError) {
      var _internalSlotsMap$get4 = internalSlotsMap.get(this),
          cliConfigArray = _internalSlotsMap$get4.cliConfigArray,
          configArrayFactory = _internalSlotsMap$get4.configArrayFactory,
          finalizeCache = _internalSlotsMap$get4.finalizeCache,
          useEslintrc = _internalSlotsMap$get4.useEslintrc;

      var finalConfigArray = finalizeCache.get(configArray);

      if (!finalConfigArray) {
        finalConfigArray = configArray; // Load the personal config if there are no regular config files.

        if (useEslintrc && configArray.every(function (c) {
          return !c.filePath;
        }) && cliConfigArray.every(function (c) {
          return !c.filePath;
        }) // `--config` option can be a file.
        ) {
            debug("Loading the config file of the home directory.");
            finalConfigArray = configArrayFactory.loadInDirectory(os.homedir(), {
              name: "PersonalConfig",
              parent: finalConfigArray
            });
          } // Apply CLI options.


        if (cliConfigArray.length > 0) {
          finalConfigArray = finalConfigArray.concat(cliConfigArray);
        } // Validate rule settings and environments.


        validateConfigArray(finalConfigArray); // Cache it.

        Object.freeze(finalConfigArray);
        finalizeCache.set(configArray, finalConfigArray);
        debug("Configuration was determined: %o on %s", finalConfigArray, directoryPath);
      } // At least one element (the default ignore patterns) exists.


      if (!ignoreNotFoundError && useEslintrc && finalConfigArray.length <= 1) {
        throw new ConfigurationNotFoundError(directoryPath);
      }

      return finalConfigArray;
    }
  }, {
    key: "cwd",
    get: function get() {
      var _internalSlotsMap$get5 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get5.cwd;

      return cwd;
    }
  }]);

  return CascadingConfigArrayFactory;
}(); //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


module.exports = {
  CascadingConfigArrayFactory: CascadingConfigArrayFactory
};