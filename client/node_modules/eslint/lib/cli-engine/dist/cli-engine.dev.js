/**
 * @fileoverview Main CLI object.
 * @author Nicholas C. Zakas
 */
"use strict";
/*
 * The CLI object should *not* call process.exit() directly. It should only return
 * exit codes. This allows other programs to use the CLI object and still control
 * when the program exits.
 */
//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(iterateRuleDeprecationWarnings);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var fs = require("fs");

var path = require("path");

var defaultOptions = require("../../conf/default-cli-options");

var pkg = require("../../package.json");

var ConfigOps = require("../shared/config-ops");

var naming = require("../shared/naming");

var ModuleResolver = require("../shared/relative-module-resolver");

var _require = require("../linter"),
    Linter = _require.Linter;

var builtInRules = require("../rules");

var _require2 = require("./cascading-config-array-factory"),
    CascadingConfigArrayFactory = _require2.CascadingConfigArrayFactory;

var _require3 = require("./config-array"),
    IgnorePattern = _require3.IgnorePattern,
    getUsedExtractedConfigs = _require3.getUsedExtractedConfigs;

var _require4 = require("./file-enumerator"),
    FileEnumerator = _require4.FileEnumerator;

var hash = require("./hash");

var LintResultCache = require("./lint-result-cache");

var debug = require("debug")("eslint:cli-engine");

var validFixTypes = new Set(["problem", "suggestion", "layout"]); //------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------
// For VSCode IntelliSense

/** @typedef {import("../shared/types").ConfigData} ConfigData */

/** @typedef {import("../shared/types").LintMessage} LintMessage */

/** @typedef {import("../shared/types").ParserOptions} ParserOptions */

/** @typedef {import("../shared/types").Plugin} Plugin */

/** @typedef {import("../shared/types").RuleConf} RuleConf */

/** @typedef {import("../shared/types").Rule} Rule */

/** @typedef {ReturnType<CascadingConfigArrayFactory["getConfigArrayForFile"]>} ConfigArray */

/** @typedef {ReturnType<ConfigArray["extractConfig"]>} ExtractedConfig */

/**
 * The options to configure a CLI engine with.
 * @typedef {Object} CLIEngineOptions
 * @property {boolean} allowInlineConfig Enable or disable inline configuration comments.
 * @property {ConfigData} baseConfig Base config object, extended by all configs used with this CLIEngine instance
 * @property {boolean} cache Enable result caching.
 * @property {string} cacheLocation The cache file to use instead of .eslintcache.
 * @property {string} configFile The configuration file to use.
 * @property {string} cwd The value to use for the current working directory.
 * @property {string[]} envs An array of environments to load.
 * @property {string[]} extensions An array of file extensions to check.
 * @property {boolean|Function} fix Execute in autofix mode. If a function, should return a boolean.
 * @property {string[]} fixTypes Array of rule types to apply fixes for.
 * @property {string[]} globals An array of global variables to declare.
 * @property {boolean} ignore False disables use of .eslintignore.
 * @property {string} ignorePath The ignore file to use instead of .eslintignore.
 * @property {string|string[]} ignorePattern One or more glob patterns to ignore.
 * @property {boolean} useEslintrc False disables looking for .eslintrc
 * @property {string} parser The name of the parser to use.
 * @property {ParserOptions} parserOptions An object of parserOption settings to use.
 * @property {string[]} plugins An array of plugins to load.
 * @property {Record<string,RuleConf>} rules An object of rules to use.
 * @property {string[]} rulePaths An array of directories to load custom rules from.
 * @property {boolean} reportUnusedDisableDirectives `true` adds reports for unused eslint-disable directives
 * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {string} resolvePluginsRelativeTo The folder where plugins should be resolved from, defaulting to the CWD
 */

/**
 * A linting result.
 * @typedef {Object} LintResult
 * @property {string} filePath The path to the file that was linted.
 * @property {LintMessage[]} messages All of the messages for the result.
 * @property {number} errorCount Number of errors for the result.
 * @property {number} warningCount Number of warnings for the result.
 * @property {number} fixableErrorCount Number of fixable errors for the result.
 * @property {number} fixableWarningCount Number of fixable warnings for the result.
 * @property {string} [source] The source code of the file that was linted.
 * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.
 */

/**
 * Information of deprecated rules.
 * @typedef {Object} DeprecatedRuleInfo
 * @property {string} ruleId The rule ID.
 * @property {string[]} replacedBy The rule IDs that replace this deprecated rule.
 */

/**
 * Linting results.
 * @typedef {Object} LintReport
 * @property {LintResult[]} results All of the result.
 * @property {number} errorCount Number of errors for the result.
 * @property {number} warningCount Number of warnings for the result.
 * @property {number} fixableErrorCount Number of fixable errors for the result.
 * @property {number} fixableWarningCount Number of fixable warnings for the result.
 * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.
 */

/**
 * Private data for CLIEngine.
 * @typedef {Object} CLIEngineInternalSlots
 * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.
 * @property {string} cacheFilePath The path to the cache of lint results.
 * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.
 * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.
 * @property {FileEnumerator} fileEnumerator The file enumerator.
 * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.
 * @property {LintResultCache|null} lintResultCache The cache of lint results.
 * @property {Linter} linter The linter instance which has loaded rules.
 * @property {CLIEngineOptions} options The normalized options of this instance.
 */
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */

var internalSlotsMap = new WeakMap();
/**
 * Determines if each fix type in an array is supported by ESLint and throws
 * an error if not.
 * @param {string[]} fixTypes An array of fix types to check.
 * @returns {void}
 * @throws {Error} If an invalid fix type is found.
 */

function validateFixTypes(fixTypes) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fixTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fixType = _step.value;

      if (!validFixTypes.has(fixType)) {
        throw new Error("Invalid fix type \"".concat(fixType, "\" found."));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
/**
 * It will calculate the error and warning count for collection of messages per file
 * @param {LintMessage[]} messages Collection of messages
 * @returns {Object} Contains the stats
 * @private
 */


function calculateStatsPerFile(messages) {
  return messages.reduce(function (stat, message) {
    if (message.fatal || message.severity === 2) {
      stat.errorCount++;

      if (message.fix) {
        stat.fixableErrorCount++;
      }
    } else {
      stat.warningCount++;

      if (message.fix) {
        stat.fixableWarningCount++;
      }
    }

    return stat;
  }, {
    errorCount: 0,
    warningCount: 0,
    fixableErrorCount: 0,
    fixableWarningCount: 0
  });
}
/**
 * It will calculate the error and warning count for collection of results from all files
 * @param {LintResult[]} results Collection of messages from all the files
 * @returns {Object} Contains the stats
 * @private
 */


function calculateStatsPerRun(results) {
  return results.reduce(function (stat, result) {
    stat.errorCount += result.errorCount;
    stat.warningCount += result.warningCount;
    stat.fixableErrorCount += result.fixableErrorCount;
    stat.fixableWarningCount += result.fixableWarningCount;
    return stat;
  }, {
    errorCount: 0,
    warningCount: 0,
    fixableErrorCount: 0,
    fixableWarningCount: 0
  });
}
/**
 * Processes an source code using ESLint.
 * @param {Object} config The config object.
 * @param {string} config.text The source code to verify.
 * @param {string} config.cwd The path to the current working directory.
 * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.
 * @param {ConfigArray} config.config The config.
 * @param {boolean} config.fix If `true` then it does fix.
 * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.
 * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.
 * @param {RegExp} config.extensionRegExp The `RegExp` object that tests if a file path has the allowed file extensions.
 * @param {Linter} config.linter The linter instance to verify.
 * @returns {LintResult} The result of linting.
 * @private
 */


function verifyText(_ref) {
  var text = _ref.text,
      cwd = _ref.cwd,
      providedFilePath = _ref.filePath,
      config = _ref.config,
      fix = _ref.fix,
      allowInlineConfig = _ref.allowInlineConfig,
      reportUnusedDisableDirectives = _ref.reportUnusedDisableDirectives,
      extensionRegExp = _ref.extensionRegExp,
      linter = _ref.linter;
  var filePath = providedFilePath || "<text>";
  debug("Lint ".concat(filePath));
  /*
   * Verify.
   * `config.extractConfig(filePath)` requires an absolute path, but `linter`
   * doesn't know CWD, so it gives `linter` an absolute path always.
   */

  var filePathToVerify = filePath === "<text>" ? path.join(cwd, filePath) : filePath;

  var _linter$verifyAndFix = linter.verifyAndFix(text, config, {
    allowInlineConfig: allowInlineConfig,
    filename: filePathToVerify,
    fix: fix,
    reportUnusedDisableDirectives: reportUnusedDisableDirectives,

    /**
     * Check if the linter should adopt a given code block or not.
     * Currently, the linter adopts code blocks if the name matches `--ext` option.
     * In the future, `overrides` in the configuration would affect the adoption (https://github.com/eslint/rfcs/pull/20).
     * @param {string} blockFilename The virtual filename of a code block.
     * @returns {boolean} `true` if the linter should adopt the code block.
     */
    filterCodeBlock: function filterCodeBlock(blockFilename) {
      return extensionRegExp.test(blockFilename);
    }
  }),
      fixed = _linter$verifyAndFix.fixed,
      messages = _linter$verifyAndFix.messages,
      output = _linter$verifyAndFix.output; // Tweak and return.


  var result = _objectSpread({
    filePath: filePath,
    messages: messages
  }, calculateStatsPerFile(messages));

  if (fixed) {
    result.output = output;
  }

  if (result.errorCount + result.warningCount > 0 && typeof result.output === "undefined") {
    result.source = text;
  }

  return result;
}
/**
 * Returns result with warning by ignore settings
 * @param {string} filePath File path of checked code
 * @param {string} baseDir  Absolute path of base directory
 * @returns {LintResult} Result with single warning
 * @private
 */


function createIgnoreResult(filePath, baseDir) {
  var message;
  var isHidden = /^\./.test(path.basename(filePath));
  var isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith("node_modules");
  var isInBowerComponents = baseDir && path.relative(baseDir, filePath).startsWith("bower_components");

  if (isHidden) {
    message = "File ignored by default.  Use a negated ignore pattern (like \"--ignore-pattern '!<relative/path/to/filename>'\") to override.";
  } else if (isInNodeModules) {
    message = "File ignored by default. Use \"--ignore-pattern '!node_modules/*'\" to override.";
  } else if (isInBowerComponents) {
    message = "File ignored by default. Use \"--ignore-pattern '!bower_components/*'\" to override.";
  } else {
    message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.";
  }

  return {
    filePath: path.resolve(filePath),
    messages: [{
      fatal: false,
      severity: 1,
      message: message
    }],
    errorCount: 0,
    warningCount: 1,
    fixableErrorCount: 0,
    fixableWarningCount: 0
  };
}
/**
 * Get a rule.
 * @param {string} ruleId The rule ID to get.
 * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.
 * @returns {Rule|null} The rule or null.
 */


function getRule(ruleId, configArrays) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = configArrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var configArray = _step2.value;
      var rule = configArray.pluginRules.get(ruleId);

      if (rule) {
        return rule;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return builtInRules.get(ruleId) || null;
}
/**
 * Collect used deprecated rules.
 * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.
 * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.
 */


function iterateRuleDeprecationWarnings(usedConfigArrays) {
  var _ref2;

  var processedRuleIds, configs, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, config, _i, _Object$entries, _Object$entries$_i, ruleId, ruleConfig, rule;

  return regeneratorRuntime.wrap(function iterateRuleDeprecationWarnings$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          processedRuleIds = new Set(); // Flatten used configs.

          /** @type {ExtractedConfig[]} */

          configs = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(usedConfigArrays.map(getUsedExtractedConfigs))); // Traverse rule configs.

          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context.prev = 5;
          _iterator3 = configs[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context.next = 28;
            break;
          }

          config = _step3.value;
          _i = 0, _Object$entries = Object.entries(config.rules);

        case 10:
          if (!(_i < _Object$entries.length)) {
            _context.next = 25;
            break;
          }

          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), ruleId = _Object$entries$_i[0], ruleConfig = _Object$entries$_i[1];

          if (!processedRuleIds.has(ruleId)) {
            _context.next = 14;
            break;
          }

          return _context.abrupt("continue", 22);

        case 14:
          processedRuleIds.add(ruleId); // Skip if it's not used.

          if (ConfigOps.getRuleSeverity(ruleConfig)) {
            _context.next = 17;
            break;
          }

          return _context.abrupt("continue", 22);

        case 17:
          rule = getRule(ruleId, usedConfigArrays); // Skip if it's not deprecated.

          if (rule && rule.meta && rule.meta.deprecated) {
            _context.next = 20;
            break;
          }

          return _context.abrupt("continue", 22);

        case 20:
          _context.next = 22;
          return {
            ruleId: ruleId,
            replacedBy: rule.meta.replacedBy || []
          };

        case 22:
          _i++;
          _context.next = 10;
          break;

        case 25:
          _iteratorNormalCompletion3 = true;
          _context.next = 7;
          break;

        case 28:
          _context.next = 34;
          break;

        case 30:
          _context.prev = 30;
          _context.t0 = _context["catch"](5);
          _didIteratorError3 = true;
          _iteratorError3 = _context.t0;

        case 34:
          _context.prev = 34;
          _context.prev = 35;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 37:
          _context.prev = 37;

          if (!_didIteratorError3) {
            _context.next = 40;
            break;
          }

          throw _iteratorError3;

        case 40:
          return _context.finish(37);

        case 41:
          return _context.finish(34);

        case 42:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[5, 30, 34, 42], [35,, 37, 41]]);
}
/**
 * Checks if the given message is an error message.
 * @param {LintMessage} message The message to check.
 * @returns {boolean} Whether or not the message is an error message.
 * @private
 */


function isErrorMessage(message) {
  return message.severity === 2;
}
/**
 * return the cacheFile to be used by eslint, based on whether the provided parameter is
 * a directory or looks like a directory (ends in `path.sep`), in which case the file
 * name will be the `cacheFile/.cache_hashOfCWD`
 *
 * if cacheFile points to a file or looks like a file then in will just use that file
 * @param {string} cacheFile The name of file to be used to store the cache
 * @param {string} cwd Current working directory
 * @returns {string} the resolved path to the cache file
 */


function getCacheFile(cacheFile, cwd) {
  /*
   * make sure the path separators are normalized for the environment/os
   * keeping the trailing path separator if present
   */
  var normalizedCacheFile = path.normalize(cacheFile);
  var resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);
  var looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;
  /**
   * return the name for the cache file in case the provided parameter is a directory
   * @returns {string} the resolved path to the cacheFile
   */

  function getCacheFileForDirectory() {
    return path.join(resolvedCacheFile, ".cache_".concat(hash(cwd)));
  }

  var fileStats;

  try {
    fileStats = fs.lstatSync(resolvedCacheFile);
  } catch (ex) {
    fileStats = null;
  }
  /*
   * in case the file exists we need to verify if the provided path
   * is a directory or a file. If it is a directory we want to create a file
   * inside that directory
   */


  if (fileStats) {
    /*
     * is a directory or is a file, but the original file the user provided
     * looks like a directory but `path.resolve` removed the `last path.sep`
     * so we need to still treat this like a directory
     */
    if (fileStats.isDirectory() || looksLikeADirectory) {
      return getCacheFileForDirectory();
    } // is file so just use that file


    return resolvedCacheFile;
  }
  /*
   * here we known the file or directory doesn't exist,
   * so we will try to infer if its a directory if it looks like a directory
   * for the current operating system.
   */
  // if the last character passed is a path separator we assume is a directory


  if (looksLikeADirectory) {
    return getCacheFileForDirectory();
  }

  return resolvedCacheFile;
}
/**
 * Convert a string array to a boolean map.
 * @param {string[]|null} keys The keys to assign true.
 * @param {boolean} defaultValue The default value for each property.
 * @param {string} displayName The property name which is used in error message.
 * @returns {Record<string,boolean>} The boolean map.
 */


function toBooleanMap(keys, defaultValue, displayName) {
  if (keys && !Array.isArray(keys)) {
    throw new Error("".concat(displayName, " must be an array."));
  }

  if (keys && keys.length > 0) {
    return keys.reduce(function (map, def) {
      var _def$split = def.split(":"),
          _def$split2 = _slicedToArray(_def$split, 2),
          key = _def$split2[0],
          value = _def$split2[1];

      if (key !== "__proto__") {
        map[key] = value === void 0 ? defaultValue : value === "true";
      }

      return map;
    }, {});
  }

  return void 0;
}
/**
 * Create a config data from CLI options.
 * @param {CLIEngineOptions} options The options
 * @returns {ConfigData|null} The created config data.
 */


function createConfigDataFromOptions(options) {
  var ignorePattern = options.ignorePattern,
      parser = options.parser,
      parserOptions = options.parserOptions,
      plugins = options.plugins,
      rules = options.rules;
  var env = toBooleanMap(options.envs, true, "envs");
  var globals = toBooleanMap(options.globals, false, "globals");

  if (env === void 0 && globals === void 0 && (ignorePattern === void 0 || ignorePattern.length === 0) && parser === void 0 && parserOptions === void 0 && plugins === void 0 && rules === void 0) {
    return null;
  }

  return {
    env: env,
    globals: globals,
    ignorePatterns: ignorePattern,
    parser: parser,
    parserOptions: parserOptions,
    plugins: plugins,
    rules: rules
  };
}
/**
 * Checks whether a directory exists at the given location
 * @param {string} resolvedPath A path from the CWD
 * @returns {boolean} `true` if a directory exists
 */


function directoryExists(resolvedPath) {
  try {
    return fs.statSync(resolvedPath).isDirectory();
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return false;
    }

    throw error;
  }
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


var CLIEngine =
/*#__PURE__*/
function () {
  /**
   * Creates a new instance of the core CLI engine.
   * @param {CLIEngineOptions} providedOptions The options for this instance.
   */
  function CLIEngine(providedOptions) {
    _classCallCheck(this, CLIEngine);

    var options = Object.assign(Object.create(null), defaultOptions, {
      cwd: process.cwd()
    }, providedOptions);

    if (options.fix === void 0) {
      options.fix = false;
    }

    var additionalPluginPool = new Map();
    var cacheFilePath = getCacheFile(options.cacheLocation || options.cacheFile, options.cwd);
    var configArrayFactory = new CascadingConfigArrayFactory({
      additionalPluginPool: additionalPluginPool,
      baseConfig: options.baseConfig || null,
      cliConfig: createConfigDataFromOptions(options),
      cwd: options.cwd,
      ignorePath: options.ignorePath,
      resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,
      rulePaths: options.rulePaths,
      specificConfigPath: options.configFile,
      useEslintrc: options.useEslintrc
    });
    var fileEnumerator = new FileEnumerator({
      configArrayFactory: configArrayFactory,
      cwd: options.cwd,
      extensions: options.extensions,
      globInputPaths: options.globInputPaths,
      errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,
      ignore: options.ignore
    });
    var lintResultCache = options.cache ? new LintResultCache(cacheFilePath) : null;
    var linter = new Linter({
      cwd: options.cwd
    });
    /** @type {ConfigArray[]} */

    var lastConfigArrays = [configArrayFactory.getConfigArrayForFile()]; // Store private data.

    internalSlotsMap.set(this, {
      additionalPluginPool: additionalPluginPool,
      cacheFilePath: cacheFilePath,
      configArrayFactory: configArrayFactory,
      defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),
      fileEnumerator: fileEnumerator,
      lastConfigArrays: lastConfigArrays,
      lintResultCache: lintResultCache,
      linter: linter,
      options: options
    }); // setup special filter for fixes

    if (options.fix && options.fixTypes && options.fixTypes.length > 0) {
      debug("Using fix types ".concat(options.fixTypes)); // throw an error if any invalid fix types are found

      validateFixTypes(options.fixTypes); // convert to Set for faster lookup

      var fixTypes = new Set(options.fixTypes); // save original value of options.fix in case it's a function

      var originalFix = typeof options.fix === "function" ? options.fix : function () {
        return true;
      };

      options.fix = function (message) {
        var rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);
        var matches = rule && rule.meta && fixTypes.has(rule.meta.type);
        return matches && originalFix(message);
      };
    }
  }

  _createClass(CLIEngine, [{
    key: "getRules",
    value: function getRules() {
      var _internalSlotsMap$get = internalSlotsMap.get(this),
          lastConfigArrays = _internalSlotsMap$get.lastConfigArrays;

      return new Map(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, configArray;

        return regeneratorRuntime.wrap(function _callee$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.delegateYield(builtInRules, "t0", 1);

              case 1:
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                _context2.prev = 4;
                _iterator4 = lastConfigArrays[Symbol.iterator]();

              case 6:
                if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                  _context2.next = 12;
                  break;
                }

                configArray = _step4.value;
                return _context2.delegateYield(configArray.pluginRules, "t1", 9);

              case 9:
                _iteratorNormalCompletion4 = true;
                _context2.next = 6;
                break;

              case 12:
                _context2.next = 18;
                break;

              case 14:
                _context2.prev = 14;
                _context2.t2 = _context2["catch"](4);
                _didIteratorError4 = true;
                _iteratorError4 = _context2.t2;

              case 18:
                _context2.prev = 18;
                _context2.prev = 19;

                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }

              case 21:
                _context2.prev = 21;

                if (!_didIteratorError4) {
                  _context2.next = 24;
                  break;
                }

                throw _iteratorError4;

              case 24:
                return _context2.finish(21);

              case 25:
                return _context2.finish(18);

              case 26:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee, null, [[4, 14, 18, 26], [19,, 21, 25]]);
      })());
    }
    /**
     * Returns results that only contains errors.
     * @param {LintResult[]} results The results to filter.
     * @returns {LintResult[]} The filtered results.
     */

  }, {
    key: "addPlugin",

    /**
     * Add a plugin by passing its configuration
     * @param {string} name Name of the plugin.
     * @param {Plugin} pluginObject Plugin configuration object.
     * @returns {void}
     */
    value: function addPlugin(name, pluginObject) {
      var _internalSlotsMap$get2 = internalSlotsMap.get(this),
          additionalPluginPool = _internalSlotsMap$get2.additionalPluginPool,
          configArrayFactory = _internalSlotsMap$get2.configArrayFactory,
          lastConfigArrays = _internalSlotsMap$get2.lastConfigArrays;

      additionalPluginPool.set(name, pluginObject);
      configArrayFactory.clearCache();
      lastConfigArrays.length = 1;
      lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();
    }
    /**
     * Resolves the patterns passed into executeOnFiles() into glob-based patterns
     * for easier handling.
     * @param {string[]} patterns The file patterns passed on the command line.
     * @returns {string[]} The equivalent glob patterns.
     */

  }, {
    key: "resolveFileGlobPatterns",
    value: function resolveFileGlobPatterns(patterns) {
      var _internalSlotsMap$get3 = internalSlotsMap.get(this),
          options = _internalSlotsMap$get3.options;

      if (options.globInputPaths === false) {
        return patterns.filter(Boolean);
      }

      var extensions = options.extensions.map(function (ext) {
        return ext.replace(/^\./, "");
      });
      var dirSuffix = "/**/*.{".concat(extensions.join(","), "}");
      return patterns.filter(Boolean).map(function (pathname) {
        var resolvedPath = path.resolve(options.cwd, pathname);
        var newPath = directoryExists(resolvedPath) ? pathname.replace(/[\/\\]$/, "") + dirSuffix : pathname;
        return path.normalize(newPath).replace(/\\/g, "/");
      });
    }
    /**
     * Executes the current configuration on an array of file and directory names.
     * @param {string[]} patterns An array of file and directory names.
     * @returns {LintReport} The results for all files that were linted.
     */

  }, {
    key: "executeOnFiles",
    value: function executeOnFiles(patterns) {
      var _internalSlotsMap$get4 = internalSlotsMap.get(this),
          cacheFilePath = _internalSlotsMap$get4.cacheFilePath,
          fileEnumerator = _internalSlotsMap$get4.fileEnumerator,
          lastConfigArrays = _internalSlotsMap$get4.lastConfigArrays,
          lintResultCache = _internalSlotsMap$get4.lintResultCache,
          linter = _internalSlotsMap$get4.linter,
          _internalSlotsMap$get5 = _internalSlotsMap$get4.options,
          allowInlineConfig = _internalSlotsMap$get5.allowInlineConfig,
          cache = _internalSlotsMap$get5.cache,
          cwd = _internalSlotsMap$get5.cwd,
          fix = _internalSlotsMap$get5.fix,
          reportUnusedDisableDirectives = _internalSlotsMap$get5.reportUnusedDisableDirectives;

      var results = [];
      var startTime = Date.now(); // Clear the last used config arrays.

      lastConfigArrays.length = 0; // Delete cache file; should this do here?

      if (!cache) {
        try {
          fs.unlinkSync(cacheFilePath);
        } catch (error) {
          var errorCode = error && error.code; // Ignore errors when no such file exists or file system is read only (and cache file does not exist)

          if (errorCode !== "ENOENT" && !(errorCode === "EROFS" && !fs.existsSync(cacheFilePath))) {
            throw error;
          }
        }
      } // Iterate source code files.


      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = fileEnumerator.iterateFiles(patterns)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = _step5.value,
              config = _step5$value.config,
              filePath = _step5$value.filePath,
              ignored = _step5$value.ignored;

          if (ignored) {
            results.push(createIgnoreResult(filePath, cwd));
            continue;
          }
          /*
           * Store used configs for:
           * - this method uses to collect used deprecated rules.
           * - `getRules()` method uses to collect all loaded rules.
           * - `--fix-type` option uses to get the loaded rule's meta data.
           */


          if (!lastConfigArrays.includes(config)) {
            lastConfigArrays.push(config);
          } // Skip if there is cached result.


          if (lintResultCache) {
            var cachedResult = lintResultCache.getCachedLintResults(filePath, config);

            if (cachedResult) {
              var hadMessages = cachedResult.messages && cachedResult.messages.length > 0;

              if (hadMessages && fix) {
                debug("Reprocessing cached file to allow autofix: ".concat(filePath));
              } else {
                debug("Skipping file since it hasn't changed: ".concat(filePath));
                results.push(cachedResult);
                continue;
              }
            }
          } // Do lint.


          var result = verifyText({
            text: fs.readFileSync(filePath, "utf8"),
            filePath: filePath,
            config: config,
            cwd: cwd,
            fix: fix,
            allowInlineConfig: allowInlineConfig,
            reportUnusedDisableDirectives: reportUnusedDisableDirectives,
            extensionRegExp: fileEnumerator.extensionRegExp,
            linter: linter
          });
          results.push(result);
          /*
           * Store the lint result in the LintResultCache.
           * NOTE: The LintResultCache will remove the file source and any
           * other properties that are difficult to serialize, and will
           * hydrate those properties back in on future lint runs.
           */

          if (lintResultCache) {
            lintResultCache.setCachedLintResults(filePath, config, result);
          }
        } // Persist the cache to disk.

      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      if (lintResultCache) {
        lintResultCache.reconcile();
      } // Collect used deprecated rules.


      var usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));
      debug("Linting complete in: ".concat(Date.now() - startTime, "ms"));
      return _objectSpread({
        results: results
      }, calculateStatsPerRun(results), {
        usedDeprecatedRules: usedDeprecatedRules
      });
    }
    /**
     * Executes the current configuration on text.
     * @param {string} text A string of JavaScript code to lint.
     * @param {string} [filename] An optional string representing the texts filename.
     * @param {boolean} [warnIgnored] Always warn when a file is ignored
     * @returns {LintReport} The results for the linting.
     */

  }, {
    key: "executeOnText",
    value: function executeOnText(text, filename, warnIgnored) {
      var _internalSlotsMap$get6 = internalSlotsMap.get(this),
          configArrayFactory = _internalSlotsMap$get6.configArrayFactory,
          fileEnumerator = _internalSlotsMap$get6.fileEnumerator,
          lastConfigArrays = _internalSlotsMap$get6.lastConfigArrays,
          linter = _internalSlotsMap$get6.linter,
          _internalSlotsMap$get7 = _internalSlotsMap$get6.options,
          allowInlineConfig = _internalSlotsMap$get7.allowInlineConfig,
          cwd = _internalSlotsMap$get7.cwd,
          fix = _internalSlotsMap$get7.fix,
          reportUnusedDisableDirectives = _internalSlotsMap$get7.reportUnusedDisableDirectives;

      var results = [];
      var startTime = Date.now();
      var resolvedFilename = filename && path.resolve(cwd, filename); // Clear the last used config arrays.

      lastConfigArrays.length = 0;

      if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {
        if (warnIgnored) {
          results.push(createIgnoreResult(resolvedFilename, cwd));
        }
      } else {
        var config = configArrayFactory.getConfigArrayForFile(resolvedFilename || "__placeholder__.js");
        /*
         * Store used configs for:
         * - this method uses to collect used deprecated rules.
         * - `getRules()` method uses to collect all loaded rules.
         * - `--fix-type` option uses to get the loaded rule's meta data.
         */

        lastConfigArrays.push(config); // Do lint.

        results.push(verifyText({
          text: text,
          filePath: resolvedFilename,
          config: config,
          cwd: cwd,
          fix: fix,
          allowInlineConfig: allowInlineConfig,
          reportUnusedDisableDirectives: reportUnusedDisableDirectives,
          extensionRegExp: fileEnumerator.extensionRegExp,
          linter: linter
        }));
      } // Collect used deprecated rules.


      var usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));
      debug("Linting complete in: ".concat(Date.now() - startTime, "ms"));
      return _objectSpread({
        results: results
      }, calculateStatsPerRun(results), {
        usedDeprecatedRules: usedDeprecatedRules
      });
    }
    /**
     * Returns a configuration object for the given file based on the CLI options.
     * This is the same logic used by the ESLint CLI executable to determine
     * configuration for each file it processes.
     * @param {string} filePath The path of the file to retrieve a config object for.
     * @returns {ConfigData} A configuration object for the file.
     */

  }, {
    key: "getConfigForFile",
    value: function getConfigForFile(filePath) {
      var _internalSlotsMap$get8 = internalSlotsMap.get(this),
          configArrayFactory = _internalSlotsMap$get8.configArrayFactory,
          options = _internalSlotsMap$get8.options;

      var absolutePath = path.resolve(options.cwd, filePath);

      if (directoryExists(absolutePath)) {
        throw Object.assign(new Error("'filePath' should not be a directory path."), {
          messageTemplate: "print-config-with-directory-path"
        });
      }

      return configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath).toCompatibleObjectAsConfigFileContent();
    }
    /**
     * Checks if a given path is ignored by ESLint.
     * @param {string} filePath The path of the file to check.
     * @returns {boolean} Whether or not the given path is ignored.
     */

  }, {
    key: "isPathIgnored",
    value: function isPathIgnored(filePath) {
      var _internalSlotsMap$get9 = internalSlotsMap.get(this),
          configArrayFactory = _internalSlotsMap$get9.configArrayFactory,
          defaultIgnores = _internalSlotsMap$get9.defaultIgnores,
          _internalSlotsMap$get10 = _internalSlotsMap$get9.options,
          cwd = _internalSlotsMap$get10.cwd,
          ignore = _internalSlotsMap$get10.ignore;

      var absolutePath = path.resolve(cwd, filePath);

      if (ignore) {
        var config = configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath);
        var ignores = config.ignores || defaultIgnores;
        return ignores(absolutePath);
      }

      return defaultIgnores(absolutePath);
    }
    /**
     * Returns the formatter representing the given format or null if no formatter
     * with the given name can be found.
     * @param {string} [format] The name of the format to load or the path to a
     *      custom formatter.
     * @returns {Function} The formatter function or null if not found.
     */

  }, {
    key: "getFormatter",
    value: function getFormatter(format) {
      // default is stylish
      var resolvedFormatName = format || "stylish"; // only strings are valid formatters

      if (typeof resolvedFormatName === "string") {
        // replace \ with / for Windows compatibility
        var normalizedFormatName = resolvedFormatName.replace(/\\/g, "/");
        var slots = internalSlotsMap.get(this);
        var cwd = slots ? slots.options.cwd : process.cwd();
        var namespace = naming.getNamespaceFromTerm(normalizedFormatName);
        var formatterPath; // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)

        if (!namespace && normalizedFormatName.indexOf("/") > -1) {
          formatterPath = path.resolve(cwd, normalizedFormatName);
        } else {
          try {
            var npmFormat = naming.normalizePackageName(normalizedFormatName, "eslint-formatter");
            formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, "__placeholder__.js"));
          } catch (e) {
            formatterPath = path.resolve(__dirname, "formatters", normalizedFormatName);
          }
        }

        try {
          return require(formatterPath);
        } catch (ex) {
          ex.message = "There was a problem loading formatter: ".concat(formatterPath, "\nError: ").concat(ex.message);
          throw ex;
        }
      } else {
        return null;
      }
    }
  }], [{
    key: "getErrorResults",
    value: function getErrorResults(results) {
      var filtered = [];
      results.forEach(function (result) {
        var filteredMessages = result.messages.filter(isErrorMessage);

        if (filteredMessages.length > 0) {
          filtered.push(_objectSpread({}, result, {
            messages: filteredMessages,
            errorCount: filteredMessages.length,
            warningCount: 0,
            fixableErrorCount: result.fixableErrorCount,
            fixableWarningCount: 0
          }));
        }
      });
      return filtered;
    }
    /**
     * Outputs fixes from the given results to files.
     * @param {LintReport} report The report object created by CLIEngine.
     * @returns {void}
     */

  }, {
    key: "outputFixes",
    value: function outputFixes(report) {
      report.results.filter(function (result) {
        return Object.prototype.hasOwnProperty.call(result, "output");
      }).forEach(function (result) {
        fs.writeFileSync(result.filePath, result.output);
      });
    }
  }]);

  return CLIEngine;
}();

CLIEngine.version = pkg.version;
CLIEngine.getFormatter = CLIEngine.prototype.getFormatter;
module.exports = {
  CLIEngine: CLIEngine,

  /**
   * Get the internal slots of a given CLIEngine instance for tests.
   * @param {CLIEngine} instance The CLIEngine instance to get.
   * @returns {CLIEngineInternalSlots} The internal slots.
   */
  getCLIEngineInternalSlots: function getCLIEngineInternalSlots(instance) {
    return internalSlotsMap.get(instance);
  }
};