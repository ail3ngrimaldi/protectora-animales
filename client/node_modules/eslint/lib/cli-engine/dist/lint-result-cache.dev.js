/**
 * @fileoverview Utility for caching lint results.
 * @author Kevin Partington
 */
"use strict"; //-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var assert = require("assert");

var fs = require("fs");

var fileEntryCache = require("file-entry-cache");

var stringify = require("json-stable-stringify-without-jsonify");

var pkg = require("../../package.json");

var hash = require("./hash"); //-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------


var configHashCache = new WeakMap();
var nodeVersion = process && process.version;
/**
 * Calculates the hash of the config
 * @param {ConfigArray} config The config.
 * @returns {string} The hash of the config
 */

function hashOfConfigFor(config) {
  if (!configHashCache.has(config)) {
    configHashCache.set(config, hash("".concat(pkg.version, "_").concat(nodeVersion, "_").concat(stringify(config))));
  }

  return configHashCache.get(config);
} //-----------------------------------------------------------------------------
// Public Interface
//-----------------------------------------------------------------------------

/**
 * Lint result cache. This wraps around the file-entry-cache module,
 * transparently removing properties that are difficult or expensive to
 * serialize and adding them back in on retrieval.
 */


var LintResultCache =
/*#__PURE__*/
function () {
  /**
   * Creates a new LintResultCache instance.
   * @param {string} cacheFileLocation The cache file location.
   *   configuration lookup by file path).
   */
  function LintResultCache(cacheFileLocation) {
    _classCallCheck(this, LintResultCache);

    assert(cacheFileLocation, "Cache file location is required");
    this.fileEntryCache = fileEntryCache.create(cacheFileLocation);
  }
  /**
   * Retrieve cached lint results for a given file path, if present in the
   * cache. If the file is present and has not been changed, rebuild any
   * missing result information.
   * @param {string} filePath The file for which to retrieve lint results.
   * @param {ConfigArray} config The config of the file.
   * @returns {Object|null} The rebuilt lint results, or null if the file is
   *   changed or not in the filesystem.
   */


  _createClass(LintResultCache, [{
    key: "getCachedLintResults",
    value: function getCachedLintResults(filePath, config) {
      /*
       * Cached lint results are valid if and only if:
       * 1. The file is present in the filesystem
       * 2. The file has not changed since the time it was previously linted
       * 3. The ESLint configuration has not changed since the time the file
       *    was previously linted
       * If any of these are not true, we will not reuse the lint results.
       */
      var fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);
      var hashOfConfig = hashOfConfigFor(config);
      var changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;

      if (fileDescriptor.notFound || changed) {
        return null;
      } // If source is present but null, need to reread the file from the filesystem.


      if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {
        fileDescriptor.meta.results.source = fs.readFileSync(filePath, "utf-8");
      }

      return fileDescriptor.meta.results;
    }
    /**
     * Set the cached lint results for a given file path, after removing any
     * information that will be both unnecessary and difficult to serialize.
     * Avoids caching results with an "output" property (meaning fixes were
     * applied), to prevent potentially incorrect results if fixes are not
     * written to disk.
     * @param {string} filePath The file for which to set lint results.
     * @param {ConfigArray} config The config of the file.
     * @param {Object} result The lint result to be set for the file.
     * @returns {void}
     */

  }, {
    key: "setCachedLintResults",
    value: function setCachedLintResults(filePath, config, result) {
      if (result && Object.prototype.hasOwnProperty.call(result, "output")) {
        return;
      }

      var fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);

      if (fileDescriptor && !fileDescriptor.notFound) {
        // Serialize the result, except that we want to remove the file source if present.
        var resultToSerialize = Object.assign({}, result);
        /*
         * Set result.source to null.
         * In `getCachedLintResults`, if source is explicitly null, we will
         * read the file from the filesystem to set the value again.
         */

        if (Object.prototype.hasOwnProperty.call(resultToSerialize, "source")) {
          resultToSerialize.source = null;
        }

        fileDescriptor.meta.results = resultToSerialize;
        fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);
      }
    }
    /**
     * Persists the in-memory cache to disk.
     * @returns {void}
     */

  }, {
    key: "reconcile",
    value: function reconcile() {
      this.fileEntryCache.reconcile();
    }
  }]);

  return LintResultCache;
}();

module.exports = LintResultCache;