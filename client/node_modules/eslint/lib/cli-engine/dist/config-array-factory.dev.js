/**
 * @fileoverview The factory of `ConfigArray` objects.
 *
 * This class provides methods to create `ConfigArray` instance.
 *
 * - `create(configData, options)`
 *     Create a `ConfigArray` instance from a config data. This is to handle CLI
 *     options except `--config`.
 * - `loadFile(filePath, options)`
 *     Create a `ConfigArray` instance from a config file. This is to handle
 *     `--config` option. If the file was not found, throws the following error:
 *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.
 *      - If the filename was `package.json`, an IO error or an
 *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.
 *      - Otherwise, an IO error such as `ENOENT`.
 * - `loadInDirectory(directoryPath, options)`
 *     Create a `ConfigArray` instance from a config file which is on a given
 *     directory. This tries to load `.eslintrc.*` or `package.json`. If not
 *     found, returns an empty `ConfigArray`.
 * - `loadESLintIgnore(filePath)`
 *     Create a `ConfigArray` instance from a config file that is `.eslintignore`
 *     format. This is to handle `--ignore-path` option.
 * - `loadDefaultESLintIgnore()`
 *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in
 *     the current working directory.
 *
 * `ConfigArrayFactory` class has the responsibility that loads configuration
 * files, including loading `extends`, `parser`, and `plugins`. The created
 * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.
 *
 * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class
 * handles cascading and hierarchy.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fs = require("fs");

var path = require("path");

var importFresh = require("import-fresh");

var stripComments = require("strip-json-comments");

var _require = require("../shared/config-validator"),
    validateConfigSchema = _require.validateConfigSchema;

var naming = require("../shared/naming");

var ModuleResolver = require("../shared/relative-module-resolver");

var _require2 = require("./config-array"),
    ConfigArray = _require2.ConfigArray,
    ConfigDependency = _require2.ConfigDependency,
    IgnorePattern = _require2.IgnorePattern,
    OverrideTester = _require2.OverrideTester;

var debug = require("debug")("eslint:config-array-factory"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var eslintRecommendedPath = path.resolve(__dirname, "../../conf/eslint-recommended.js");
var eslintAllPath = path.resolve(__dirname, "../../conf/eslint-all.js");
var configFilenames = [".eslintrc.js", ".eslintrc.cjs", ".eslintrc.yaml", ".eslintrc.yml", ".eslintrc.json", ".eslintrc", "package.json"]; // Define types for VSCode IntelliSense.

/** @typedef {import("../shared/types").ConfigData} ConfigData */

/** @typedef {import("../shared/types").OverrideConfigData} OverrideConfigData */

/** @typedef {import("../shared/types").Parser} Parser */

/** @typedef {import("../shared/types").Plugin} Plugin */

/** @typedef {import("./config-array/config-dependency").DependentParser} DependentParser */

/** @typedef {import("./config-array/config-dependency").DependentPlugin} DependentPlugin */

/** @typedef {ConfigArray[0]} ConfigArrayElement */

/**
 * @typedef {Object} ConfigArrayFactoryOptions
 * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.
 * @property {string} [cwd] The path to the current working directory.
 * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.
 */

/**
 * @typedef {Object} ConfigArrayFactoryInternalSlots
 * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.
 * @property {string} cwd The path to the current working directory.
 * @property {string} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.
 */

/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */

var internalSlotsMap = new WeakMap();
/**
 * Check if a given string is a file path.
 * @param {string} nameOrPath A module name or file path.
 * @returns {boolean} `true` if the `nameOrPath` is a file path.
 */

function isFilePath(nameOrPath) {
  return /^\.{1,2}[\/\\]/.test(nameOrPath) || path.isAbsolute(nameOrPath);
}
/**
 * Convenience wrapper for synchronously reading file contents.
 * @param {string} filePath The filename to read.
 * @returns {string} The file contents, with the BOM removed.
 * @private
 */


function readFile(filePath) {
  return fs.readFileSync(filePath, "utf8").replace(/^\uFEFF/, "");
}
/**
 * Loads a YAML configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadYAMLConfigFile(filePath) {
  debug("Loading YAML config file: ".concat(filePath)); // lazy load YAML to improve performance when not used

  var yaml = require("js-yaml");

  try {
    // empty YAML file can be null, so always use
    return yaml.safeLoad(readFile(filePath)) || {};
  } catch (e) {
    debug("Error reading YAML file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a JSON configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadJSONConfigFile(filePath) {
  debug("Loading JSON config file: ".concat(filePath));

  try {
    return JSON.parse(stripComments(readFile(filePath)));
  } catch (e) {
    debug("Error reading JSON file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    e.messageTemplate = "failed-to-read-json";
    e.messageData = {
      path: filePath,
      message: e.message
    };
    throw e;
  }
}
/**
 * Loads a legacy (.eslintrc) configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadLegacyConfigFile(filePath) {
  debug("Loading legacy config file: ".concat(filePath)); // lazy load YAML to improve performance when not used

  var yaml = require("js-yaml");

  try {
    return yaml.safeLoad(stripComments(readFile(filePath))) ||
    /* istanbul ignore next */
    {};
  } catch (e) {
    debug("Error reading YAML file: %s\n%o", filePath, e);
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a JavaScript configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadJSConfigFile(filePath) {
  debug("Loading JS config file: ".concat(filePath));

  try {
    return importFresh(filePath);
  } catch (e) {
    debug("Error reading JavaScript file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a configuration from a package.json file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */


function loadPackageJSONConfigFile(filePath) {
  debug("Loading package.json config file: ".concat(filePath));

  try {
    var packageData = loadJSONConfigFile(filePath);

    if (!Object.hasOwnProperty.call(packageData, "eslintConfig")) {
      throw Object.assign(new Error("package.json file doesn't have 'eslintConfig' field."), {
        code: "ESLINT_CONFIG_FIELD_NOT_FOUND"
      });
    }

    return packageData.eslintConfig;
  } catch (e) {
    debug("Error reading package.json file: ".concat(filePath));
    e.message = "Cannot read config file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Loads a `.eslintignore` from a file.
 * @param {string} filePath The filename to load.
 * @returns {string[]} The ignore patterns from the file.
 * @private
 */


function loadESLintIgnoreFile(filePath) {
  debug("Loading .eslintignore file: ".concat(filePath));

  try {
    return readFile(filePath).split(/\r?\n/g).filter(function (line) {
      return line.trim() !== "" && !line.startsWith("#");
    });
  } catch (e) {
    debug("Error reading .eslintignore file: ".concat(filePath));
    e.message = "Cannot read .eslintignore file: ".concat(filePath, "\nError: ").concat(e.message);
    throw e;
  }
}
/**
 * Creates an error to notify about a missing config to extend from.
 * @param {string} configName The name of the missing config.
 * @param {string} importerName The name of the config that imported the missing config
 * @returns {Error} The error object to throw
 * @private
 */


function configMissingError(configName, importerName) {
  return Object.assign(new Error("Failed to load config \"".concat(configName, "\" to extend from.")), {
    messageTemplate: "extend-config-missing",
    messageData: {
      configName: configName,
      importerName: importerName
    }
  });
}
/**
 * Loads a configuration file regardless of the source. Inspects the file path
 * to determine the correctly way to load the config file.
 * @param {string} filePath The path to the configuration.
 * @returns {ConfigData|null} The configuration information.
 * @private
 */


function loadConfigFile(filePath) {
  switch (path.extname(filePath)) {
    case ".js":
    case ".cjs":
      return loadJSConfigFile(filePath);

    case ".json":
      if (path.basename(filePath) === "package.json") {
        return loadPackageJSONConfigFile(filePath);
      }

      return loadJSONConfigFile(filePath);

    case ".yaml":
    case ".yml":
      return loadYAMLConfigFile(filePath);

    default:
      return loadLegacyConfigFile(filePath);
  }
}
/**
 * Write debug log.
 * @param {string} request The requested module name.
 * @param {string} relativeTo The file path to resolve the request relative to.
 * @param {string} filePath The resolved file path.
 * @returns {void}
 */


function writeDebugLogForLoading(request, relativeTo, filePath) {
  /* istanbul ignore next */
  if (debug.enabled) {
    var nameAndVersion = null;

    try {
      var packageJsonPath = ModuleResolver.resolve("".concat(request, "/package.json"), relativeTo);

      var _require3 = require(packageJsonPath),
          _require3$version = _require3.version,
          version = _require3$version === void 0 ? "unknown" : _require3$version;

      nameAndVersion = "".concat(request, "@").concat(version);
    } catch (error) {
      debug("package.json was not found:", error.message);
      nameAndVersion = request;
    }

    debug("Loaded: %s (%s)", nameAndVersion, filePath);
  }
}
/**
 * Concatenate two config data.
 * @param {IterableIterator<ConfigArrayElement>|null} elements The config elements.
 * @param {ConfigArray|null} parentConfigArray The parent config array.
 * @returns {ConfigArray} The concatenated config array.
 */


function createConfigArray(elements, parentConfigArray) {
  if (!elements) {
    return parentConfigArray || new ConfigArray();
  }

  var configArray = _construct(ConfigArray, _toConsumableArray(elements));

  if (parentConfigArray && !configArray.isRoot()) {
    configArray.unshift.apply(configArray, _toConsumableArray(parentConfigArray));
  }

  return configArray;
}
/**
 * Normalize a given plugin.
 * - Ensure the object to have four properties: configs, environments, processors, and rules.
 * - Ensure the object to not have other properties.
 * @param {Plugin} plugin The plugin to normalize.
 * @returns {Plugin} The normalized plugin.
 */


function normalizePlugin(plugin) {
  return {
    configs: plugin.configs || {},
    environments: plugin.environments || {},
    processors: plugin.processors || {},
    rules: plugin.rules || {}
  };
} //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The factory of `ConfigArray` objects.
 */


var ConfigArrayFactory =
/*#__PURE__*/
function () {
  /**
   * Initialize this instance.
   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.
   */
  function ConfigArrayFactory() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$additionalPlugin = _ref.additionalPluginPool,
        additionalPluginPool = _ref$additionalPlugin === void 0 ? new Map() : _ref$additionalPlugin,
        _ref$cwd = _ref.cwd,
        cwd = _ref$cwd === void 0 ? process.cwd() : _ref$cwd,
        _ref$resolvePluginsRe = _ref.resolvePluginsRelativeTo,
        resolvePluginsRelativeTo = _ref$resolvePluginsRe === void 0 ? cwd : _ref$resolvePluginsRe;

    _classCallCheck(this, ConfigArrayFactory);

    internalSlotsMap.set(this, {
      additionalPluginPool: additionalPluginPool,
      cwd: cwd,
      resolvePluginsRelativeTo: path.resolve(cwd, resolvePluginsRelativeTo)
    });
  }
  /**
   * Create `ConfigArray` instance from a config data.
   * @param {ConfigData|null} configData The config data to create.
   * @param {Object} [options] The options.
   * @param {string} [options.filePath] The path to this config data.
   * @param {string} [options.name] The config name.
   * @param {ConfigArray} [options.parent] The parent config array.
   * @returns {ConfigArray} Loaded config.
   */


  _createClass(ConfigArrayFactory, [{
    key: "create",
    value: function create(configData) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          filePath = _ref2.filePath,
          name = _ref2.name,
          parent = _ref2.parent;

      return createConfigArray(configData ? this._normalizeConfigData(configData, filePath, name) : null, parent);
    }
    /**
     * Load a config file.
     * @param {string} filePath The path to a config file.
     * @param {Object} [options] The options.
     * @param {string} [options.name] The config name.
     * @param {ConfigArray} [options.parent] The parent config array.
     * @returns {ConfigArray} Loaded config.
     */

  }, {
    key: "loadFile",
    value: function loadFile(filePath) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          name = _ref3.name,
          parent = _ref3.parent;

      var _internalSlotsMap$get = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get.cwd;

      var absolutePath = path.resolve(cwd, filePath);
      return createConfigArray(this._loadConfigData(absolutePath, name), parent);
    }
    /**
     * Load the config file on a given directory if exists.
     * @param {string} directoryPath The path to a directory.
     * @param {Object} [options] The options.
     * @param {string} [options.name] The config name.
     * @param {ConfigArray} [options.parent] The parent config array.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */

  }, {
    key: "loadInDirectory",
    value: function loadInDirectory(directoryPath) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          name = _ref4.name,
          parent = _ref4.parent;

      var _internalSlotsMap$get2 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get2.cwd;

      var absolutePath = path.resolve(cwd, directoryPath);
      return createConfigArray(this._loadConfigDataInDirectory(absolutePath, name), parent);
    }
    /**
     * Load `.eslintignore` file.
     * @param {string} filePath The path to a `.eslintignore` file to load.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */

  }, {
    key: "loadESLintIgnore",
    value: function loadESLintIgnore(filePath) {
      var _internalSlotsMap$get3 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get3.cwd;

      var absolutePath = path.resolve(cwd, filePath);
      var name = path.relative(cwd, absolutePath);
      var ignorePatterns = loadESLintIgnoreFile(absolutePath);
      return createConfigArray(this._normalizeESLintIgnoreData(ignorePatterns, absolutePath, name));
    }
    /**
     * Load `.eslintignore` file in the current working directory.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */

  }, {
    key: "loadDefaultESLintIgnore",
    value: function loadDefaultESLintIgnore() {
      var _internalSlotsMap$get4 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get4.cwd;

      var eslintIgnorePath = path.resolve(cwd, ".eslintignore");
      var packageJsonPath = path.resolve(cwd, "package.json");

      if (fs.existsSync(eslintIgnorePath)) {
        return this.loadESLintIgnore(eslintIgnorePath);
      }

      if (fs.existsSync(packageJsonPath)) {
        var data = loadJSONConfigFile(packageJsonPath);

        if (Object.hasOwnProperty.call(data, "eslintIgnore")) {
          if (!Array.isArray(data.eslintIgnore)) {
            throw new Error("Package.json eslintIgnore property requires an array of paths");
          }

          return createConfigArray(this._normalizeESLintIgnoreData(data.eslintIgnore, packageJsonPath, "eslintIgnore in package.json"));
        }
      }

      return new ConfigArray();
    }
    /**
     * Load a given config file.
     * @param {string} filePath The path to a config file.
     * @param {string} name The config name.
     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.
     * @private
     */

  }, {
    key: "_loadConfigData",
    value: function _loadConfigData(filePath, name) {
      return this._normalizeConfigData(loadConfigFile(filePath), filePath, name);
    }
    /**
     * Load the config file in a given directory if exists.
     * @param {string} directoryPath The path to a directory.
     * @param {string} name The config name.
     * @returns {IterableIterator<ConfigArrayElement> | null} Loaded config. `null` if any config doesn't exist.
     * @private
     */

  }, {
    key: "_loadConfigDataInDirectory",
    value: function _loadConfigDataInDirectory(directoryPath, name) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = configFilenames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var filename = _step.value;
          var filePath = path.join(directoryPath, filename);

          if (fs.existsSync(filePath)) {
            var configData = void 0;

            try {
              configData = loadConfigFile(filePath);
            } catch (error) {
              if (!error || error.code !== "ESLINT_CONFIG_FIELD_NOT_FOUND") {
                throw error;
              }
            }

            if (configData) {
              debug("Config file found: ".concat(filePath));
              return this._normalizeConfigData(configData, filePath, name);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      debug("Config file not found on ".concat(directoryPath));
      return null;
    }
    /**
     * Normalize a given `.eslintignore` data to config array elements.
     * @param {string[]} ignorePatterns The patterns to ignore files.
     * @param {string|undefined} filePath The file path of this config.
     * @param {string|undefined} name The name of this config.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeESLintIgnoreData",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _normalizeESLintIgnoreData(ignorePatterns, filePath, name) {
      var elements, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, element;

      return regeneratorRuntime.wrap(function _normalizeESLintIgnoreData$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              elements = this._normalizeObjectConfigData({
                ignorePatterns: ignorePatterns
              }, filePath, name); // Set `ignorePattern.loose` flag for backward compatibility.

              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 4;
              _iterator2 = elements[Symbol.iterator]();

            case 6:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 14;
                break;
              }

              element = _step2.value;

              if (element.ignorePattern) {
                element.ignorePattern.loose = true;
              }

              _context.next = 11;
              return element;

            case 11:
              _iteratorNormalCompletion2 = true;
              _context.next = 6;
              break;

            case 14:
              _context.next = 20;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](4);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t0;

            case 20:
              _context.prev = 20;
              _context.prev = 21;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 23:
              _context.prev = 23;

              if (!_didIteratorError2) {
                _context.next = 26;
                break;
              }

              throw _iteratorError2;

            case 26:
              return _context.finish(23);

            case 27:
              return _context.finish(20);

            case 28:
            case "end":
              return _context.stop();
          }
        }
      }, _normalizeESLintIgnoreData, this, [[4, 16, 20, 28], [21,, 23, 27]]);
    })
    /**
     * Normalize a given config to an array.
     * @param {ConfigData} configData The config data to normalize.
     * @param {string|undefined} providedFilePath The file path of this config.
     * @param {string|undefined} providedName The name of this config.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeConfigData",
    value: function _normalizeConfigData(configData, providedFilePath, providedName) {
      var _internalSlotsMap$get5 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get5.cwd;

      var filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : "";
      var name = providedName || filePath && path.relative(cwd, filePath);
      validateConfigSchema(configData, name || filePath);
      return this._normalizeObjectConfigData(configData, filePath, name);
    }
    /**
     * Normalize a given config to an array.
     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.
     * @param {string} filePath The file path of this config.
     * @param {string} name The name of this config.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeObjectConfigData",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _normalizeObjectConfigData(configData, filePath, name) {
      var _internalSlotsMap$get6, cwd, files, excludedFiles, configBody, basePath, criteria, elements, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, element;

      return regeneratorRuntime.wrap(function _normalizeObjectConfigData$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _internalSlotsMap$get6 = internalSlotsMap.get(this), cwd = _internalSlotsMap$get6.cwd;
              files = configData.files, excludedFiles = configData.excludedFiles, configBody = _objectWithoutProperties(configData, ["files", "excludedFiles"]);
              basePath = filePath ? path.dirname(filePath) : cwd;
              criteria = OverrideTester.create(files, excludedFiles, basePath);
              elements = this._normalizeObjectConfigDataBody(configBody, filePath, name); // Apply the criteria to every element.

              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 8;
              _iterator3 = elements[Symbol.iterator]();

            case 10:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context2.next = 21;
                break;
              }

              element = _step3.value;

              // Adopt the base path of the entry file (the outermost base path).
              if (element.criteria) {
                element.criteria.basePath = basePath;
              }

              if (element.ignorePattern) {
                element.ignorePattern.basePath = basePath;
              }
              /*
               * Merge the criteria; this is for only file extension processors in
               * `overrides` section for now.
               */


              element.criteria = OverrideTester.and(criteria, element.criteria);
              /*
               * Remove `root` property to ignore `root` settings which came from
               * `extends` in `overrides`.
               */

              if (element.criteria) {
                element.root = void 0;
              }

              _context2.next = 18;
              return element;

            case 18:
              _iteratorNormalCompletion3 = true;
              _context2.next = 10;
              break;

            case 21:
              _context2.next = 27;
              break;

            case 23:
              _context2.prev = 23;
              _context2.t0 = _context2["catch"](8);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t0;

            case 27:
              _context2.prev = 27;
              _context2.prev = 28;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 30:
              _context2.prev = 30;

              if (!_didIteratorError3) {
                _context2.next = 33;
                break;
              }

              throw _iteratorError3;

            case 33:
              return _context2.finish(30);

            case 34:
              return _context2.finish(27);

            case 35:
            case "end":
              return _context2.stop();
          }
        }
      }, _normalizeObjectConfigData, this, [[8, 23, 27, 35], [28,, 30, 34]]);
    })
    /**
     * Normalize a given config to an array.
     * @param {ConfigData} configData The config data to normalize.
     * @param {string} filePath The file path of this config.
     * @param {string} name The name of this config.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_normalizeObjectConfigDataBody",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _normalizeObjectConfigDataBody(_ref5, filePath, name) {
      var env, extend, globals, ignorePatterns, noInlineConfig, parserName, parserOptions, pluginList, processor, reportUnusedDisableDirectives, root, rules, settings, _ref5$overrides, overrideList, extendList, ignorePattern, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, extendName, parser, plugins, i;

      return regeneratorRuntime.wrap(function _normalizeObjectConfigDataBody$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              env = _ref5.env, extend = _ref5["extends"], globals = _ref5.globals, ignorePatterns = _ref5.ignorePatterns, noInlineConfig = _ref5.noInlineConfig, parserName = _ref5.parser, parserOptions = _ref5.parserOptions, pluginList = _ref5.plugins, processor = _ref5.processor, reportUnusedDisableDirectives = _ref5.reportUnusedDisableDirectives, root = _ref5.root, rules = _ref5.rules, settings = _ref5.settings, _ref5$overrides = _ref5.overrides, overrideList = _ref5$overrides === void 0 ? [] : _ref5$overrides;
              extendList = Array.isArray(extend) ? extend : [extend];
              ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], filePath ? path.dirname(filePath) : internalSlotsMap.get(this).cwd); // Flatten `extends`.

              _iteratorNormalCompletion4 = true;
              _didIteratorError4 = false;
              _iteratorError4 = undefined;
              _context3.prev = 6;
              _iterator4 = extendList.filter(Boolean)[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
                _context3.next = 14;
                break;
              }

              extendName = _step4.value;
              return _context3.delegateYield(this._loadExtends(extendName, filePath, name), "t0", 11);

            case 11:
              _iteratorNormalCompletion4 = true;
              _context3.next = 8;
              break;

            case 14:
              _context3.next = 20;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t1 = _context3["catch"](6);
              _didIteratorError4 = true;
              _iteratorError4 = _context3.t1;

            case 20:
              _context3.prev = 20;
              _context3.prev = 21;

              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }

            case 23:
              _context3.prev = 23;

              if (!_didIteratorError4) {
                _context3.next = 26;
                break;
              }

              throw _iteratorError4;

            case 26:
              return _context3.finish(23);

            case 27:
              return _context3.finish(20);

            case 28:
              // Load parser & plugins.
              parser = parserName && this._loadParser(parserName, filePath, name);
              plugins = pluginList && this._loadPlugins(pluginList, filePath, name); // Yield pseudo config data for file extension processors.

              if (!plugins) {
                _context3.next = 32;
                break;
              }

              return _context3.delegateYield(this._takeFileExtensionProcessors(plugins, filePath, name), "t2", 32);

            case 32:
              _context3.next = 34;
              return {
                // Debug information.
                name: name,
                filePath: filePath,
                // Config data.
                criteria: null,
                env: env,
                globals: globals,
                ignorePattern: ignorePattern,
                noInlineConfig: noInlineConfig,
                parser: parser,
                parserOptions: parserOptions,
                plugins: plugins,
                processor: processor,
                reportUnusedDisableDirectives: reportUnusedDisableDirectives,
                root: root,
                rules: rules,
                settings: settings
              };

            case 34:
              i = 0;

            case 35:
              if (!(i < overrideList.length)) {
                _context3.next = 40;
                break;
              }

              return _context3.delegateYield(this._normalizeObjectConfigData(overrideList[i], filePath, "".concat(name, "#overrides[").concat(i, "]")), "t3", 37);

            case 37:
              ++i;
              _context3.next = 35;
              break;

            case 40:
            case "end":
              return _context3.stop();
          }
        }
      }, _normalizeObjectConfigDataBody, this, [[6, 16, 20, 28], [21,, 23, 27]]);
    })
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {string} importerPath The file path which has the `extends` property.
     * @param {string} importerName The name of the config which has the `extends` property.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtends",
    value: function _loadExtends(extendName, importerPath, importerName) {
      debug("Loading {extends:%j} relative to %s", extendName, importerPath);

      try {
        if (extendName.startsWith("eslint:")) {
          return this._loadExtendedBuiltInConfig(extendName, importerName);
        }

        if (extendName.startsWith("plugin:")) {
          return this._loadExtendedPluginConfig(extendName, importerPath, importerName);
        }

        return this._loadExtendedShareableConfig(extendName, importerPath, importerName);
      } catch (error) {
        error.message += "\nReferenced from: ".concat(importerPath || importerName);
        throw error;
      }
    }
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {string} importerName The name of the config which has the `extends` property.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtendedBuiltInConfig",
    value: function _loadExtendedBuiltInConfig(extendName, importerName) {
      var name = "".concat(importerName, " \xBB ").concat(extendName);

      if (extendName === "eslint:recommended") {
        return this._loadConfigData(eslintRecommendedPath, name);
      }

      if (extendName === "eslint:all") {
        return this._loadConfigData(eslintAllPath, name);
      }

      throw configMissingError(extendName, importerName);
    }
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {string} importerPath The file path which has the `extends` property.
     * @param {string} importerName The name of the config which has the `extends` property.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtendedPluginConfig",
    value: function _loadExtendedPluginConfig(extendName, importerPath, importerName) {
      var slashIndex = extendName.lastIndexOf("/");
      var pluginName = extendName.slice("plugin:".length, slashIndex);
      var configName = extendName.slice(slashIndex + 1);

      if (isFilePath(pluginName)) {
        throw new Error("'extends' cannot use a file path for plugins.");
      }

      var plugin = this._loadPlugin(pluginName, importerPath, importerName);

      var configData = plugin.definition && plugin.definition.configs[configName];

      if (configData) {
        return this._normalizeConfigData(configData, plugin.filePath, "".concat(importerName, " \xBB plugin:").concat(plugin.id, "/").concat(configName));
      }

      throw plugin.error || configMissingError(extendName, importerPath);
    }
    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {string} importerPath The file path which has the `extends` property.
     * @param {string} importerName The name of the config which has the `extends` property.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */

  }, {
    key: "_loadExtendedShareableConfig",
    value: function _loadExtendedShareableConfig(extendName, importerPath, importerName) {
      var _internalSlotsMap$get7 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get7.cwd;

      var relativeTo = importerPath || path.join(cwd, "__placeholder__.js");
      var request;

      if (isFilePath(extendName)) {
        request = extendName;
      } else if (extendName.startsWith(".")) {
        request = "./".concat(extendName); // For backward compatibility. A ton of tests depended on this behavior.
      } else {
        request = naming.normalizePackageName(extendName, "eslint-config");
      }

      var filePath;

      try {
        filePath = ModuleResolver.resolve(request, relativeTo);
      } catch (error) {
        /* istanbul ignore else */
        if (error && error.code === "MODULE_NOT_FOUND") {
          throw configMissingError(extendName, importerPath);
        }

        throw error;
      }

      writeDebugLogForLoading(request, relativeTo, filePath);
      return this._loadConfigData(filePath, "".concat(importerName, " \xBB ").concat(request));
    }
    /**
     * Load given plugins.
     * @param {string[]} names The plugin names to load.
     * @param {string} importerPath The path to a config file that imports it. This is just a debug info.
     * @param {string} importerName The name of a config file that imports it. This is just a debug info.
     * @returns {Record<string,DependentPlugin>} The loaded parser.
     * @private
     */

  }, {
    key: "_loadPlugins",
    value: function _loadPlugins(names, importerPath, importerName) {
      var _this = this;

      return names.reduce(function (map, name) {
        if (isFilePath(name)) {
          throw new Error("Plugins array cannot includes file paths.");
        }

        var plugin = _this._loadPlugin(name, importerPath, importerName);

        map[plugin.id] = plugin;
        return map;
      }, {});
    }
    /**
     * Load a given parser.
     * @param {string} nameOrPath The package name or the path to a parser file.
     * @param {string} importerPath The path to a config file that imports it.
     * @param {string} importerName The name of a config file that imports it. This is just a debug info.
     * @returns {DependentParser} The loaded parser.
     */

  }, {
    key: "_loadParser",
    value: function _loadParser(nameOrPath, importerPath, importerName) {
      debug("Loading parser %j from %s", nameOrPath, importerPath);

      var _internalSlotsMap$get8 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get8.cwd;

      var relativeTo = importerPath || path.join(cwd, "__placeholder__.js");

      try {
        var filePath = ModuleResolver.resolve(nameOrPath, relativeTo);
        writeDebugLogForLoading(nameOrPath, relativeTo, filePath);
        return new ConfigDependency({
          definition: require(filePath),
          filePath: filePath,
          id: nameOrPath,
          importerName: importerName,
          importerPath: importerPath
        });
      } catch (error) {
        // If the parser name is "espree", load the espree of ESLint.
        if (nameOrPath === "espree") {
          debug("Fallback espree.");
          return new ConfigDependency({
            definition: require("espree"),
            filePath: require.resolve("espree"),
            id: nameOrPath,
            importerName: importerName,
            importerPath: importerPath
          });
        }

        debug("Failed to load parser '%s' declared in '%s'.", nameOrPath, importerName);
        error.message = "Failed to load parser '".concat(nameOrPath, "' declared in '").concat(importerName, "': ").concat(error.message);
        return new ConfigDependency({
          error: error,
          id: nameOrPath,
          importerName: importerName,
          importerPath: importerPath
        });
      }
    }
    /**
     * Load a given plugin.
     * @param {string} name The plugin name to load.
     * @param {string} importerPath The path to a config file that imports it. This is just a debug info.
     * @param {string} importerName The name of a config file that imports it. This is just a debug info.
     * @returns {DependentPlugin} The loaded plugin.
     * @private
     */

  }, {
    key: "_loadPlugin",
    value: function _loadPlugin(name, importerPath, importerName) {
      debug("Loading plugin %j from %s", name, importerPath);

      var _internalSlotsMap$get9 = internalSlotsMap.get(this),
          additionalPluginPool = _internalSlotsMap$get9.additionalPluginPool,
          resolvePluginsRelativeTo = _internalSlotsMap$get9.resolvePluginsRelativeTo;

      var request = naming.normalizePackageName(name, "eslint-plugin");
      var id = naming.getShorthandName(request, "eslint-plugin");
      var relativeTo = path.join(resolvePluginsRelativeTo, "__placeholder__.js");

      if (name.match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/)) {
        var _error = Object.assign(new Error("Whitespace found in plugin name '".concat(name, "'")), {
          messageTemplate: "whitespace-found",
          messageData: {
            pluginName: request
          }
        });

        return new ConfigDependency({
          error: _error,
          id: id,
          importerName: importerName,
          importerPath: importerPath
        });
      } // Check for additional pool.


      var plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);

      if (plugin) {
        return new ConfigDependency({
          definition: normalizePlugin(plugin),
          filePath: importerPath,
          id: id,
          importerName: importerName,
          importerPath: importerPath
        });
      }

      var filePath;
      var error;

      try {
        filePath = ModuleResolver.resolve(request, relativeTo);
      } catch (resolveError) {
        error = resolveError;
        /* istanbul ignore else */

        if (error && error.code === "MODULE_NOT_FOUND") {
          error.messageTemplate = "plugin-missing";
          error.messageData = {
            pluginName: request,
            resolvePluginsRelativeTo: resolvePluginsRelativeTo,
            importerName: importerName
          };
        }
      }

      if (filePath) {
        try {
          writeDebugLogForLoading(request, relativeTo, filePath);
          var startTime = Date.now();

          var pluginDefinition = require(filePath);

          debug("Plugin ".concat(filePath, " loaded in: ").concat(Date.now() - startTime, "ms"));
          return new ConfigDependency({
            definition: normalizePlugin(pluginDefinition),
            filePath: filePath,
            id: id,
            importerName: importerName,
            importerPath: importerPath
          });
        } catch (loadError) {
          error = loadError;
        }
      }

      debug("Failed to load plugin '%s' declared in '%s'.", name, importerName);
      error.message = "Failed to load plugin '".concat(name, "' declared in '").concat(importerName, "': ").concat(error.message);
      return new ConfigDependency({
        error: error,
        id: id,
        importerName: importerName,
        importerPath: importerPath
      });
    }
    /**
     * Take file expression processors as config array elements.
     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.
     * @param {string} filePath The file path of this config.
     * @param {string} name The name of this config.
     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.
     * @private
     */

  }, {
    key: "_takeFileExtensionProcessors",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _takeFileExtensionProcessors(plugins, filePath, name) {
      var _i, _Object$keys, pluginId, processors, _i2, _Object$keys2, processorId;

      return regeneratorRuntime.wrap(function _takeFileExtensionProcessors$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _i = 0, _Object$keys = Object.keys(plugins);

            case 1:
              if (!(_i < _Object$keys.length)) {
                _context4.next = 17;
                break;
              }

              pluginId = _Object$keys[_i];
              processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;

              if (processors) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("continue", 14);

            case 6:
              _i2 = 0, _Object$keys2 = Object.keys(processors);

            case 7:
              if (!(_i2 < _Object$keys2.length)) {
                _context4.next = 14;
                break;
              }

              processorId = _Object$keys2[_i2];

              if (!processorId.startsWith(".")) {
                _context4.next = 11;
                break;
              }

              return _context4.delegateYield(this._normalizeObjectConfigData({
                files: ["*".concat(processorId)],
                processor: "".concat(pluginId, "/").concat(processorId)
              }, filePath, "".concat(name, "#processors[\"").concat(pluginId, "/").concat(processorId, "\"]")), "t0", 11);

            case 11:
              _i2++;
              _context4.next = 7;
              break;

            case 14:
              _i++;
              _context4.next = 1;
              break;

            case 17:
            case "end":
              return _context4.stop();
          }
        }
      }, _takeFileExtensionProcessors, this);
    })
  }]);

  return ConfigArrayFactory;
}();

module.exports = {
  ConfigArrayFactory: ConfigArrayFactory
};