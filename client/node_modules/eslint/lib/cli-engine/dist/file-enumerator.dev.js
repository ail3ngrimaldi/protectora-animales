/**
 * @fileoverview `FileEnumerator` class.
 *
 * `FileEnumerator` class has two responsibilities:
 *
 * 1. Find target files by processing glob patterns.
 * 2. Tie each target file and appropriate configuration.
 *
 * It provies a method:
 *
 * - `iterateFiles(patterns)`
 *     Iterate files which are matched by given patterns together with the
 *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.
 *     While iterating files, it loads the configuration file of each directory
 *     before iterate files on the directory, so we can use the configuration
 *     files to determine target files.
 *
 * @example
 * const enumerator = new FileEnumerator();
 * const linter = new Linter();
 *
 * for (const { config, filePath } of enumerator.iterateFiles(["*.js"])) {
 *     const code = fs.readFileSync(filePath, "utf8");
 *     const messages = linter.verify(code, config, filePath);
 *
 *     console.log(messages);
 * }
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var fs = require("fs");

var path = require("path");

var getGlobParent = require("glob-parent");

var isGlob = require("is-glob");

var _require = require("lodash"),
    escapeRegExp = _require.escapeRegExp;

var _require2 = require("minimatch"),
    Minimatch = _require2.Minimatch;

var _require3 = require("./config-array"),
    IgnorePattern = _require3.IgnorePattern;

var _require4 = require("./cascading-config-array-factory"),
    CascadingConfigArrayFactory = _require4.CascadingConfigArrayFactory;

var debug = require("debug")("eslint:file-enumerator"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var minimatchOpts = {
  dot: true,
  matchBase: true
};
var dotfilesPattern = /(?:(?:^\.)|(?:[\/\\]\.))(?:[\0-\x2D0-\[\]-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*/;
var NONE = 0;
var IGNORED_SILENTLY = 1;
var IGNORED = 2; // For VSCode intellisense

/** @typedef {ReturnType<CascadingConfigArrayFactory["getConfigArrayForFile"]>} ConfigArray */

/**
 * @typedef {Object} FileEnumeratorOptions
 * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.
 * @property {string} [cwd] The base directory to start lookup.
 * @property {string[]} [extensions] The extensions to match files for directory patterns.
 * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean} [ignore] The flag to check ignored files.
 * @property {string[]} [rulePaths] The value of `--rulesdir` option.
 */

/**
 * @typedef {Object} FileAndConfig
 * @property {string} filePath The path to a target file.
 * @property {ConfigArray} config The config entries of that file.
 * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.
 */

/**
 * @typedef {Object} FileEntry
 * @property {string} filePath The path to a target file.
 * @property {ConfigArray} config The config entries of that file.
 * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.
 * - `NONE` means the file is a target file.
 * - `IGNORED_SILENTLY` means the file should be ignored silently.
 * - `IGNORED` means the file should be ignored and warned because it was directly specified.
 */

/**
 * @typedef {Object} FileEnumeratorInternalSlots
 * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.
 * @property {string} cwd The base directory to start lookup.
 * @property {RegExp} extensionRegExp The RegExp to test if a string ends with specific file extensions.
 * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean} ignoreFlag The flag to check ignored files.
 * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.
 */

/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */

var internalSlotsMap = new WeakMap();
/**
 * Check if a string is a glob pattern or not.
 * @param {string} pattern A glob pattern.
 * @returns {boolean} `true` if the string is a glob pattern.
 */

function isGlobPattern(pattern) {
  return isGlob(path.sep === "\\" ? pattern.replace(/\\/g, "/") : pattern);
}
/**
 * Get stats of a given path.
 * @param {string} filePath The path to target file.
 * @returns {fs.Stats|null} The stats.
 * @private
 */


function statSafeSync(filePath) {
  try {
    return fs.statSync(filePath);
  } catch (error) {
    /* istanbul ignore next */
    if (error.code !== "ENOENT") {
      throw error;
    }

    return null;
  }
}
/**
 * Get filenames in a given path to a directory.
 * @param {string} directoryPath The path to target directory.
 * @returns {string[]} The filenames.
 * @private
 */


function readdirSafeSync(directoryPath) {
  try {
    return fs.readdirSync(directoryPath);
  } catch (error) {
    /* istanbul ignore next */
    if (error.code !== "ENOENT") {
      throw error;
    }

    return [];
  }
}
/**
 * The error type when no files match a glob.
 */


var NoFilesFoundError =
/*#__PURE__*/
function (_Error) {
  _inherits(NoFilesFoundError, _Error);

  // eslint-disable-next-line jsdoc/require-description

  /**
   * @param {string} pattern The glob pattern which was not found.
   * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.
   */
  function NoFilesFoundError(pattern, globDisabled) {
    var _this;

    _classCallCheck(this, NoFilesFoundError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NoFilesFoundError).call(this, "No files matching '".concat(pattern, "' were found").concat(globDisabled ? " (glob was disabled)" : "", ".")));
    _this.messageTemplate = "file-not-found";
    _this.messageData = {
      pattern: pattern,
      globDisabled: globDisabled
    };
    return _this;
  }

  return NoFilesFoundError;
}(_wrapNativeSuper(Error));
/**
 * The error type when there are files matched by a glob, but all of them have been ignored.
 */


var AllFilesIgnoredError =
/*#__PURE__*/
function (_Error2) {
  _inherits(AllFilesIgnoredError, _Error2);

  // eslint-disable-next-line jsdoc/require-description

  /**
   * @param {string} pattern The glob pattern which was not found.
   */
  function AllFilesIgnoredError(pattern) {
    var _this2;

    _classCallCheck(this, AllFilesIgnoredError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AllFilesIgnoredError).call(this, "All files matched by '".concat(pattern, "' are ignored.")));
    _this2.messageTemplate = "all-files-ignored";
    _this2.messageData = {
      pattern: pattern
    };
    return _this2;
  }

  return AllFilesIgnoredError;
}(_wrapNativeSuper(Error));
/**
 * This class provides the functionality that enumerates every file which is
 * matched by given glob patterns and that configuration.
 */


var FileEnumerator =
/*#__PURE__*/
function () {
  /**
   * Initialize this enumerator.
   * @param {FileEnumeratorOptions} options The options.
   */
  function FileEnumerator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cwd = _ref.cwd,
        cwd = _ref$cwd === void 0 ? process.cwd() : _ref$cwd,
        _ref$configArrayFacto = _ref.configArrayFactory,
        configArrayFactory = _ref$configArrayFacto === void 0 ? new CascadingConfigArrayFactory({
      cwd: cwd
    }) : _ref$configArrayFacto,
        _ref$extensions = _ref.extensions,
        extensions = _ref$extensions === void 0 ? [".js"] : _ref$extensions,
        _ref$globInputPaths = _ref.globInputPaths,
        globInputPaths = _ref$globInputPaths === void 0 ? true : _ref$globInputPaths,
        _ref$errorOnUnmatched = _ref.errorOnUnmatchedPattern,
        errorOnUnmatchedPattern = _ref$errorOnUnmatched === void 0 ? true : _ref$errorOnUnmatched,
        _ref$ignore = _ref.ignore,
        ignore = _ref$ignore === void 0 ? true : _ref$ignore;

    _classCallCheck(this, FileEnumerator);

    internalSlotsMap.set(this, {
      configArrayFactory: configArrayFactory,
      cwd: cwd,
      defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),
      extensionRegExp: new RegExp(".\\.(?:".concat(extensions.map(function (ext) {
        return escapeRegExp(ext.startsWith(".") ? ext.slice(1) : ext);
      }).join("|"), ")$"), "u"),
      globInputPaths: globInputPaths,
      errorOnUnmatchedPattern: errorOnUnmatchedPattern,
      ignoreFlag: ignore
    });
  }
  /**
   * The `RegExp` object that tests if a file path has the allowed file extensions.
   * @type {RegExp}
   */


  _createClass(FileEnumerator, [{
    key: "iterateFiles",

    /**
     * Iterate files which are matched by given glob patterns.
     * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.
     * @returns {IterableIterator<FileAndConfig>} The found files.
     */
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function iterateFiles(patternOrPatterns) {
      var _internalSlotsMap$get, globInputPaths, errorOnUnmatchedPattern, patterns, set, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pattern, foundRegardlessOfIgnored, found, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, config, filePath, flag;

      return regeneratorRuntime.wrap(function iterateFiles$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _internalSlotsMap$get = internalSlotsMap.get(this), globInputPaths = _internalSlotsMap$get.globInputPaths, errorOnUnmatchedPattern = _internalSlotsMap$get.errorOnUnmatchedPattern;
              patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];
              debug("Start to iterate files: %o", patterns); // The set of paths to remove duplicate.

              set = new Set();
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 7;
              _iterator = patterns[Symbol.iterator]();

            case 9:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 55;
                break;
              }

              pattern = _step.value;
              foundRegardlessOfIgnored = false;
              found = false; // Skip empty string.

              if (pattern) {
                _context.next = 15;
                break;
              }

              return _context.abrupt("continue", 52);

            case 15:
              // Iterate files of this pttern.
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 18;
              _iterator2 = this._iterateFiles(pattern)[Symbol.iterator]();

            case 20:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 33;
                break;
              }

              _step2$value = _step2.value, config = _step2$value.config, filePath = _step2$value.filePath, flag = _step2$value.flag;
              foundRegardlessOfIgnored = true;

              if (!(flag === IGNORED_SILENTLY)) {
                _context.next = 25;
                break;
              }

              return _context.abrupt("continue", 30);

            case 25:
              found = true; // Remove duplicate paths while yielding paths.

              if (set.has(filePath)) {
                _context.next = 30;
                break;
              }

              set.add(filePath);
              _context.next = 30;
              return {
                config: config,
                filePath: filePath,
                ignored: flag === IGNORED
              };

            case 30:
              _iteratorNormalCompletion2 = true;
              _context.next = 20;
              break;

            case 33:
              _context.next = 39;
              break;

            case 35:
              _context.prev = 35;
              _context.t0 = _context["catch"](18);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t0;

            case 39:
              _context.prev = 39;
              _context.prev = 40;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 42:
              _context.prev = 42;

              if (!_didIteratorError2) {
                _context.next = 45;
                break;
              }

              throw _iteratorError2;

            case 45:
              return _context.finish(42);

            case 46:
              return _context.finish(39);

            case 47:
              if (!errorOnUnmatchedPattern) {
                _context.next = 52;
                break;
              }

              if (foundRegardlessOfIgnored) {
                _context.next = 50;
                break;
              }

              throw new NoFilesFoundError(pattern, !globInputPaths && isGlob(pattern));

            case 50:
              if (found) {
                _context.next = 52;
                break;
              }

              throw new AllFilesIgnoredError(pattern);

            case 52:
              _iteratorNormalCompletion = true;
              _context.next = 9;
              break;

            case 55:
              _context.next = 61;
              break;

            case 57:
              _context.prev = 57;
              _context.t1 = _context["catch"](7);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 61:
              _context.prev = 61;
              _context.prev = 62;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 64:
              _context.prev = 64;

              if (!_didIteratorError) {
                _context.next = 67;
                break;
              }

              throw _iteratorError;

            case 67:
              return _context.finish(64);

            case 68:
              return _context.finish(61);

            case 69:
              debug("Complete iterating files: ".concat(JSON.stringify(patterns)));

            case 70:
            case "end":
              return _context.stop();
          }
        }
      }, iterateFiles, this, [[7, 57, 61, 69], [18, 35, 39, 47], [40,, 42, 46], [62,, 64, 68]]);
    })
    /**
     * Iterate files which are matched by a given glob pattern.
     * @param {string} pattern The glob pattern to iterate files.
     * @returns {IterableIterator<FileEntry>} The found files.
     */

  }, {
    key: "_iterateFiles",
    value: function _iterateFiles(pattern) {
      var _internalSlotsMap$get2 = internalSlotsMap.get(this),
          cwd = _internalSlotsMap$get2.cwd,
          globInputPaths = _internalSlotsMap$get2.globInputPaths;

      var absolutePath = path.resolve(cwd, pattern);
      var isDot = dotfilesPattern.test(pattern);
      var stat = statSafeSync(absolutePath);

      if (stat && stat.isDirectory()) {
        return this._iterateFilesWithDirectory(absolutePath, isDot);
      }

      if (stat && stat.isFile()) {
        return this._iterateFilesWithFile(absolutePath);
      }

      if (globInputPaths && isGlobPattern(pattern)) {
        return this._iterateFilesWithGlob(absolutePath, isDot);
      }

      return [];
    }
    /**
     * Iterate a file which is matched by a given path.
     * @param {string} filePath The path to the target file.
     * @returns {IterableIterator<FileEntry>} The found files.
     * @private
     */

  }, {
    key: "_iterateFilesWithFile",
    value: function _iterateFilesWithFile(filePath) {
      debug("File: ".concat(filePath));

      var _internalSlotsMap$get3 = internalSlotsMap.get(this),
          configArrayFactory = _internalSlotsMap$get3.configArrayFactory;

      var config = configArrayFactory.getConfigArrayForFile(filePath);

      var ignored = this._isIgnoredFile(filePath, {
        config: config,
        direct: true
      });

      var flag = ignored ? IGNORED : NONE;
      return [{
        config: config,
        filePath: filePath,
        flag: flag
      }];
    }
    /**
     * Iterate files in a given path.
     * @param {string} directoryPath The path to the target directory.
     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.
     * @returns {IterableIterator<FileEntry>} The found files.
     * @private
     */

  }, {
    key: "_iterateFilesWithDirectory",
    value: function _iterateFilesWithDirectory(directoryPath, dotfiles) {
      debug("Directory: ".concat(directoryPath));
      return this._iterateFilesRecursive(directoryPath, {
        dotfiles: dotfiles,
        recursive: true,
        selector: null
      });
    }
    /**
     * Iterate files which are matched by a given glob pattern.
     * @param {string} pattern The glob pattern to iterate files.
     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.
     * @returns {IterableIterator<FileEntry>} The found files.
     * @private
     */

  }, {
    key: "_iterateFilesWithGlob",
    value: function _iterateFilesWithGlob(pattern, dotfiles) {
      debug("Glob: ".concat(pattern));
      var directoryPath = path.resolve(getGlobParent(pattern));
      var globPart = pattern.slice(directoryPath.length + 1);
      /*
       * recursive if there are `**` or path separators in the glob part.
       * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.
       */

      var recursive = /\*\*|\/|\\/.test(globPart);
      var selector = new Minimatch(pattern, minimatchOpts);
      debug("recursive? ".concat(recursive));
      return this._iterateFilesRecursive(directoryPath, {
        dotfiles: dotfiles,
        recursive: recursive,
        selector: selector
      });
    }
    /**
     * Iterate files in a given path.
     * @param {string} directoryPath The path to the target directory.
     * @param {Object} options The options to iterate files.
     * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.
     * @param {boolean} [options.recursive] If `true` then it dives into sub directories.
     * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.
     * @returns {IterableIterator<FileEntry>} The found files.
     * @private
     */

  }, {
    key: "_iterateFilesRecursive",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _iterateFilesRecursive(directoryPath, options) {
      var _internalSlotsMap$get4, configArrayFactory, extensionRegExp, config, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, filename, filePath, stat, ignored, flag, matched, _ignored;

      return regeneratorRuntime.wrap(function _iterateFilesRecursive$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              debug("Enter the directory: ".concat(directoryPath));
              _internalSlotsMap$get4 = internalSlotsMap.get(this), configArrayFactory = _internalSlotsMap$get4.configArrayFactory, extensionRegExp = _internalSlotsMap$get4.extensionRegExp;
              /** @type {ConfigArray|null} */

              config = null; // Enumerate the files of this directory.

              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 6;
              _iterator3 = readdirSafeSync(directoryPath)[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context2.next = 34;
                break;
              }

              filename = _step3.value;
              filePath = path.join(directoryPath, filename);
              stat = statSafeSync(filePath); // TODO: Use `withFileTypes` in the future.
              // Check if the file is matched.

              if (!(stat && stat.isFile())) {
                _context2.next = 26;
                break;
              }

              if (!config) {
                config = configArrayFactory.getConfigArrayForFile(filePath,
                /*
                 * We must ignore `ConfigurationNotFoundError` at this
                 * point because we don't know if target files exist in
                 * this directory.
                 */
                {
                  ignoreNotFoundError: true
                });
              }

              ignored = this._isIgnoredFile(filePath, _objectSpread({}, options, {
                config: config
              }));
              flag = ignored ? IGNORED_SILENTLY : NONE;
              matched = options.selector // Started with a glob pattern; choose by the pattern.
              ? options.selector.match(filePath) // Started with a directory path; choose by file extensions.
              : extensionRegExp.test(filePath);

              if (!matched) {
                _context2.next = 23;
                break;
              }

              debug("Yield: ".concat(filename).concat(ignored ? " but ignored" : ""));
              _context2.next = 21;
              return {
                config: configArrayFactory.getConfigArrayForFile(filePath),
                filePath: filePath,
                flag: flag
              };

            case 21:
              _context2.next = 24;
              break;

            case 23:
              debug("Didn't match: ".concat(filename));

            case 24:
              _context2.next = 31;
              break;

            case 26:
              if (!(options.recursive && stat && stat.isDirectory())) {
                _context2.next = 31;
                break;
              }

              if (!config) {
                config = configArrayFactory.getConfigArrayForFile(filePath, {
                  ignoreNotFoundError: true
                });
              }

              _ignored = this._isIgnoredFile(filePath + path.sep, _objectSpread({}, options, {
                config: config
              }));

              if (_ignored) {
                _context2.next = 31;
                break;
              }

              return _context2.delegateYield(this._iterateFilesRecursive(filePath, options), "t0", 31);

            case 31:
              _iteratorNormalCompletion3 = true;
              _context2.next = 8;
              break;

            case 34:
              _context2.next = 40;
              break;

            case 36:
              _context2.prev = 36;
              _context2.t1 = _context2["catch"](6);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t1;

            case 40:
              _context2.prev = 40;
              _context2.prev = 41;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 43:
              _context2.prev = 43;

              if (!_didIteratorError3) {
                _context2.next = 46;
                break;
              }

              throw _iteratorError3;

            case 46:
              return _context2.finish(43);

            case 47:
              return _context2.finish(40);

            case 48:
              debug("Leave the directory: ".concat(directoryPath));

            case 49:
            case "end":
              return _context2.stop();
          }
        }
      }, _iterateFilesRecursive, this, [[6, 36, 40, 48], [41,, 43, 47]]);
    })
    /**
     * Check if a given file should be ignored.
     * @param {string} filePath The path to a file to check.
     * @param {Object} options Options
     * @param {ConfigArray} [options.config] The config for this file.
     * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.
     * @param {boolean} [options.direct] If `true` then this is a direct specified file.
     * @returns {boolean} `true` if the file should be ignored.
     * @private
     */

  }, {
    key: "_isIgnoredFile",
    value: function _isIgnoredFile(filePath, _ref2) {
      var providedConfig = _ref2.config,
          _ref2$dotfiles = _ref2.dotfiles,
          dotfiles = _ref2$dotfiles === void 0 ? false : _ref2$dotfiles,
          _ref2$direct = _ref2.direct,
          direct = _ref2$direct === void 0 ? false : _ref2$direct;

      var _internalSlotsMap$get5 = internalSlotsMap.get(this),
          configArrayFactory = _internalSlotsMap$get5.configArrayFactory,
          defaultIgnores = _internalSlotsMap$get5.defaultIgnores,
          ignoreFlag = _internalSlotsMap$get5.ignoreFlag;

      if (ignoreFlag) {
        var config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {
          ignoreNotFoundError: true
        });
        var ignores = config.extractConfig(filePath).ignores || defaultIgnores;
        return ignores(filePath, dotfiles);
      }

      return !direct && defaultIgnores(filePath, dotfiles);
    }
  }, {
    key: "extensionRegExp",
    get: function get() {
      return internalSlotsMap.get(this).extensionRegExp;
    }
  }]);

  return FileEnumerator;
}(); //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------


module.exports = {
  FileEnumerator: FileEnumerator
};