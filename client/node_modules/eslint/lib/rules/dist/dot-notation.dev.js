/**
 * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
 * @author Josh Perez
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var astUtils = require("./utils/ast-utils");

var keywords = require("./utils/keywords"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


var validIdentifier = /^[\$A-Z_a-z][\$0-9A-Z_a-z]*$/; // `null` literal must be handled separately.

var literalTypesToCheck = new Set(["string", "boolean"]);
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce dot notation whenever possible",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/dot-notation"
    },
    schema: [{
      type: "object",
      properties: {
        allowKeywords: {
          type: "boolean",
          "default": true
        },
        allowPattern: {
          type: "string",
          "default": ""
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      useDot: "[{{key}}] is better written in dot notation.",
      useBrackets: ".{{key}} is a syntax error."
    }
  },
  create: function create(context) {
    var options = context.options[0] || {};
    var allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;
    var sourceCode = context.getSourceCode();
    var allowPattern;

    if (options.allowPattern) {
      allowPattern = new RegExp(options.allowPattern, "u");
    }
    /**
     * Check if the property is valid dot notation
     * @param {ASTNode} node The dot notation node
     * @param {string} value Value which is to be checked
     * @returns {void}
     */


    function checkComputedProperty(node, value) {
      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {
        var formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : "`".concat(value, "`");
        context.report({
          node: node.property,
          messageId: "useDot",
          data: {
            key: formattedValue
          },
          fix: function fix(fixer) {
            var leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
            var rightBracket = sourceCode.getLastToken(node);

            if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, {
              includeComments: true,
              filter: astUtils.isCommentToken
            })) {
              // Don't perform any fixes if there are comments inside the brackets.
              return null;
            }

            var tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
            var needsSpaceAfterProperty = tokenAfterProperty && rightBracket.range[1] === tokenAfterProperty.range[0] && !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);
            var textBeforeDot = astUtils.isDecimalInteger(node.object) ? " " : "";
            var textAfterProperty = needsSpaceAfterProperty ? " " : "";
            return fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], "".concat(textBeforeDot, ".").concat(value).concat(textAfterProperty));
          }
        });
      }
    }

    return {
      MemberExpression: function MemberExpression(node) {
        if (node.computed && node.property.type === "Literal" && (literalTypesToCheck.has(_typeof(node.property.value)) || astUtils.isNullLiteral(node.property))) {
          checkComputedProperty(node, node.property.value);
        }

        if (node.computed && node.property.type === "TemplateLiteral" && node.property.expressions.length === 0) {
          checkComputedProperty(node, node.property.quasis[0].value.cooked);
        }

        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
          context.report({
            node: node.property,
            messageId: "useBrackets",
            data: {
              key: node.property.name
            },
            fix: function fix(fixer) {
              var dot = sourceCode.getTokenBefore(node.property);
              var textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);

              if (textAfterDot.trim()) {
                // Don't perform any fixes if there are comments between the dot and the property name.
                return null;
              }

              if (node.object.type === "Identifier" && node.object.name === "let") {
                /*
                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not
                 * a MemberExpression.
                 */
                return null;
              }

              return fixer.replaceTextRange([dot.range[0], node.property.range[1]], "[".concat(textAfterDot, "\"").concat(node.property.name, "\"]"));
            }
          });
        }
      }
    };
  }
};