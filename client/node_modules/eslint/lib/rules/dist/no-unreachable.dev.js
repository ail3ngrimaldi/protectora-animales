/**
 * @fileoverview Checks for unreachable code due to return, throws, break, and continue.
 * @author Joel Feenstra
 */
"use strict"; //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given variable declarator has the initializer.
 * @param {ASTNode} node A VariableDeclarator node to check.
 * @returns {boolean} `true` if the node has the initializer.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function isInitialized(node) {
  return Boolean(node.init);
}
/**
 * Checks whether or not a given code path segment is unreachable.
 * @param {CodePathSegment} segment A CodePathSegment to check.
 * @returns {boolean} `true` if the segment is unreachable.
 */


function isUnreachable(segment) {
  return !segment.reachable;
}
/**
 * The class to distinguish consecutive unreachable statements.
 */


var ConsecutiveRange =
/*#__PURE__*/
function () {
  function ConsecutiveRange(sourceCode) {
    _classCallCheck(this, ConsecutiveRange);

    this.sourceCode = sourceCode;
    this.startNode = null;
    this.endNode = null;
  }
  /**
   * The location object of this range.
   * @type {Object}
   */


  _createClass(ConsecutiveRange, [{
    key: "contains",

    /**
     * Checks whether the given node is inside of this range.
     * @param {ASTNode|Token} node The node to check.
     * @returns {boolean} `true` if the node is inside of this range.
     */
    value: function contains(node) {
      return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
    }
    /**
     * Checks whether the given node is consecutive to this range.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} `true` if the node is consecutive to this range.
     */

  }, {
    key: "isConsecutive",
    value: function isConsecutive(node) {
      return this.contains(this.sourceCode.getTokenBefore(node));
    }
    /**
     * Merges the given node to this range.
     * @param {ASTNode} node The node to merge.
     * @returns {void}
     */

  }, {
    key: "merge",
    value: function merge(node) {
      this.endNode = node;
    }
    /**
     * Resets this range by the given node or null.
     * @param {ASTNode|null} node The node to reset, or null.
     * @returns {void}
     */

  }, {
    key: "reset",
    value: function reset(node) {
      this.startNode = this.endNode = node;
    }
  }, {
    key: "location",
    get: function get() {
      return {
        start: this.startNode.loc.start,
        end: this.endNode.loc.end
      };
    }
    /**
     * `true` if this range is empty.
     * @type {boolean}
     */

  }, {
    key: "isEmpty",
    get: function get() {
      return !(this.startNode && this.endNode);
    }
  }]);

  return ConsecutiveRange;
}(); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unreachable"
    },
    schema: []
  },
  create: function create(context) {
    var currentCodePath = null;
    var range = new ConsecutiveRange(context.getSourceCode());
    /**
     * Reports a given node if it's unreachable.
     * @param {ASTNode} node A statement node to report.
     * @returns {void}
     */

    function reportIfUnreachable(node) {
      var nextNode = null;

      if (node && currentCodePath.currentSegments.every(isUnreachable)) {
        // Store this statement to distinguish consecutive statements.
        if (range.isEmpty) {
          range.reset(node);
          return;
        } // Skip if this statement is inside of the current range.


        if (range.contains(node)) {
          return;
        } // Merge if this statement is consecutive to the current range.


        if (range.isConsecutive(node)) {
          range.merge(node);
          return;
        }

        nextNode = node;
      }
      /*
       * Report the current range since this statement is reachable or is
       * not consecutive to the current range.
       */


      if (!range.isEmpty) {
        context.report({
          message: "Unreachable code.",
          loc: range.location,
          node: range.startNode
        });
      } // Update the current range.


      range.reset(nextNode);
    }

    return {
      // Manages the current code path.
      onCodePathStart: function onCodePathStart(codePath) {
        currentCodePath = codePath;
      },
      onCodePathEnd: function onCodePathEnd() {
        currentCodePath = currentCodePath.upper;
      },
      // Registers for all statement nodes (excludes FunctionDeclaration).
      BlockStatement: reportIfUnreachable,
      BreakStatement: reportIfUnreachable,
      ClassDeclaration: reportIfUnreachable,
      ContinueStatement: reportIfUnreachable,
      DebuggerStatement: reportIfUnreachable,
      DoWhileStatement: reportIfUnreachable,
      ExpressionStatement: reportIfUnreachable,
      ForInStatement: reportIfUnreachable,
      ForOfStatement: reportIfUnreachable,
      ForStatement: reportIfUnreachable,
      IfStatement: reportIfUnreachable,
      ImportDeclaration: reportIfUnreachable,
      LabeledStatement: reportIfUnreachable,
      ReturnStatement: reportIfUnreachable,
      SwitchStatement: reportIfUnreachable,
      ThrowStatement: reportIfUnreachable,
      TryStatement: reportIfUnreachable,
      VariableDeclaration: function VariableDeclaration(node) {
        if (node.kind !== "var" || node.declarations.some(isInitialized)) {
          reportIfUnreachable(node);
        }
      },
      WhileStatement: reportIfUnreachable,
      WithStatement: reportIfUnreachable,
      ExportNamedDeclaration: reportIfUnreachable,
      ExportDefaultDeclaration: reportIfUnreachable,
      ExportAllDeclaration: reportIfUnreachable,
      "Program:exit": function ProgramExit() {
        reportIfUnreachable();
      }
    };
  }
};