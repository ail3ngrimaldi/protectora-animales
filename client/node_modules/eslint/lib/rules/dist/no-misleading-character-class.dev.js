/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(iterateCharacterSequence);

var _require = require("eslint-utils"),
    CALL = _require.CALL,
    CONSTRUCT = _require.CONSTRUCT,
    ReferenceTracker = _require.ReferenceTracker,
    getStringIfConstant = _require.getStringIfConstant;

var _require2 = require("regexpp"),
    RegExpParser = _require2.RegExpParser,
    visitRegExpAST = _require2.visitRegExpAST;

var _require3 = require("./utils/unicode"),
    isCombiningCharacter = _require3.isCombiningCharacter,
    isEmojiModifier = _require3.isEmojiModifier,
    isRegionalIndicatorSymbol = _require3.isRegionalIndicatorSymbol,
    isSurrogatePair = _require3.isSurrogatePair; //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Iterate character sequences of a given nodes.
 *
 * CharacterClassRange syntax can steal a part of character sequence,
 * so this function reverts CharacterClassRange syntax and restore the sequence.
 * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.
 * @returns {IterableIterator<number[]>} The list of character sequences.
 */


function iterateCharacterSequence(nodes) {
  var seq, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, node;

  return regeneratorRuntime.wrap(function iterateCharacterSequence$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          seq = [];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 4;
          _iterator = nodes[Symbol.iterator]();

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 26;
            break;
          }

          node = _step.value;
          _context.t0 = node.type;
          _context.next = _context.t0 === "Character" ? 11 : _context.t0 === "CharacterClassRange" ? 13 : _context.t0 === "CharacterSet" ? 18 : 23;
          break;

        case 11:
          seq.push(node.value);
          return _context.abrupt("break", 23);

        case 13:
          seq.push(node.min.value);
          _context.next = 16;
          return seq;

        case 16:
          seq = [node.max.value];
          return _context.abrupt("break", 23);

        case 18:
          if (!(seq.length > 0)) {
            _context.next = 22;
            break;
          }

          _context.next = 21;
          return seq;

        case 21:
          seq = [];

        case 22:
          return _context.abrupt("break", 23);

        case 23:
          _iteratorNormalCompletion = true;
          _context.next = 6;
          break;

        case 26:
          _context.next = 32;
          break;

        case 28:
          _context.prev = 28;
          _context.t1 = _context["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 32:
          _context.prev = 32;
          _context.prev = 33;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 35:
          _context.prev = 35;

          if (!_didIteratorError) {
            _context.next = 38;
            break;
          }

          throw _iteratorError;

        case 38:
          return _context.finish(35);

        case 39:
          return _context.finish(32);

        case 40:
          if (!(seq.length > 0)) {
            _context.next = 43;
            break;
          }

          _context.next = 43;
          return seq;

        case 43:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[4, 28, 32, 40], [33,, 35, 39]]);
}

var hasCharacterSequence = {
  surrogatePairWithoutUFlag: function surrogatePairWithoutUFlag(chars) {
    return chars.some(function (c, i) {
      return i !== 0 && isSurrogatePair(chars[i - 1], c);
    });
  },
  combiningClass: function combiningClass(chars) {
    return chars.some(function (c, i) {
      return i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]);
    });
  },
  emojiModifier: function emojiModifier(chars) {
    return chars.some(function (c, i) {
      return i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]);
    });
  },
  regionalIndicatorSymbol: function regionalIndicatorSymbol(chars) {
    return chars.some(function (c, i) {
      return i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]);
    });
  },
  zwj: function zwj(chars) {
    var lastIndex = chars.length - 1;
    return chars.some(function (c, i) {
      return i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d;
    });
  }
};
var kinds = Object.keys(hasCharacterSequence); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow characters which are made with multiple code points in character class syntax",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-misleading-character-class"
    },
    schema: [],
    messages: {
      surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
      combiningClass: "Unexpected combined character in character class.",
      emojiModifier: "Unexpected modified Emoji in character class.",
      regionalIndicatorSymbol: "Unexpected national flag in character class.",
      zwj: "Unexpected joined character sequence in character class."
    }
  },
  create: function create(context) {
    var parser = new RegExpParser();
    /**
     * Verify a given regular expression.
     * @param {Node} node The node to report.
     * @param {string} pattern The regular expression pattern to verify.
     * @param {string} flags The flags of the regular expression.
     * @returns {void}
     */

    function verify(node, pattern, flags) {
      var has = {
        surrogatePairWithoutUFlag: false,
        combiningClass: false,
        variationSelector: false,
        emojiModifier: false,
        regionalIndicatorSymbol: false,
        zwj: false
      };
      var patternNode;

      try {
        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
      } catch (e) {
        // Ignore regular expressions with syntax errors
        return;
      }

      visitRegExpAST(patternNode, {
        onCharacterClassEnter: function onCharacterClassEnter(ccNode) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = iterateCharacterSequence(ccNode.elements)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var chars = _step2.value;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = kinds[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var kind = _step3.value;
                  has[kind] = has[kind] || hasCharacterSequence[kind](chars);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      });
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = kinds[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var kind = _step4.value;

          if (has[kind]) {
            context.report({
              node: node,
              messageId: kind
            });
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    return {
      "Literal[regex]": function LiteralRegex(node) {
        verify(node, node.regex.pattern, node.regex.flags);
      },
      "Program": function Program() {
        var scope = context.getScope();
        var tracker = new ReferenceTracker(scope);
        /*
         * Iterate calls of RegExp.
         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,
         *       `const {RegExp: a} = window; new a()`, etc...
         */

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = tracker.iterateGlobalReferences({
            RegExp: (_RegExp = {}, _defineProperty(_RegExp, CALL, true), _defineProperty(_RegExp, CONSTRUCT, true), _RegExp)
          })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _RegExp;

            var node = _step5.value.node;

            var _node$arguments = _slicedToArray(node.arguments, 2),
                patternNode = _node$arguments[0],
                flagsNode = _node$arguments[1];

            var pattern = getStringIfConstant(patternNode, scope);
            var flags = getStringIfConstant(flagsNode, scope);

            if (typeof pattern === "string") {
              verify(node, pattern, flags || "");
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
    };
  }
};