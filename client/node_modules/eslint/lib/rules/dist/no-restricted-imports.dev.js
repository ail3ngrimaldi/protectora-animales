/**
 * @fileoverview Restrict usage of specified node imports.
 * @author Guy Ellis
 */
"use strict"; //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ignore = require("ignore");

var arrayOfStrings = {
  type: "array",
  items: {
    type: "string"
  },
  uniqueItems: true
};
var arrayOfStringsOrObjects = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        },
        importNames: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false,
      required: ["name"]
    }]
  },
  uniqueItems: true
};
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `import`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-imports"
    },
    messages: {
      path: "'{{importSource}}' import is restricted from being used.",
      // eslint-disable-next-line eslint-plugin/report-message-format
      pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}",
      patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
      everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
      // eslint-disable-next-line eslint-plugin/report-message-format
      everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}"
    },
    schema: {
      anyOf: [arrayOfStringsOrObjects, {
        type: "array",
        items: [{
          type: "object",
          properties: {
            paths: arrayOfStringsOrObjects,
            patterns: arrayOfStrings
          },
          additionalProperties: false
        }],
        additionalItems: false
      }]
    }
  },
  create: function create(context) {
    var options = Array.isArray(context.options) ? context.options : [];
    var isPathAndPatternsObject = _typeof(options[0]) === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
    var restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
    var restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
    var restrictedPathMessages = restrictedPaths.reduce(function (memo, importSource) {
      if (typeof importSource === "string") {
        memo[importSource] = {
          message: null
        };
      } else {
        memo[importSource.name] = {
          message: importSource.message,
          importNames: importSource.importNames
        };
      }

      return memo;
    }, {}); // if no imports are restricted we don"t need to check

    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
      return {};
    }

    var restrictedPatternsMatcher = ignore().add(restrictedPatterns);
    /**
     * Checks to see if "*" is being used to import everything.
     * @param {Set.<string>} importNames Set of import names that are being imported
     * @returns {boolean} whether everything is imported or not
     */

    function isEverythingImported(importNames) {
      return importNames.has("*");
    }
    /**
     * Report a restricted path.
     * @param {node} node representing the restricted path reference
     * @returns {void}
     * @private
     */


    function reportPath(node) {
      var importSource = node.source.value.trim();
      var customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;
      context.report({
        node: node,
        messageId: customMessage ? "pathWithCustomMessage" : "path",
        data: {
          importSource: importSource,
          customMessage: customMessage
        }
      });
    }
    /**
     * Report a restricted path specifically for patterns.
     * @param {node} node representing the restricted path reference
     * @returns {void}
     * @private
     */


    function reportPathForPatterns(node) {
      var importSource = node.source.value.trim();
      context.report({
        node: node,
        messageId: "patterns",
        data: {
          importSource: importSource
        }
      });
    }
    /**
     * Report a restricted path specifically when using the '*' import.
     * @param {string} importSource path of the import
     * @param {node} node representing the restricted path reference
     * @returns {void}
     * @private
     */


    function reportPathForEverythingImported(importSource, node) {
      var importNames = restrictedPathMessages[importSource].importNames;
      var customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;
      context.report({
        node: node,
        messageId: customMessage ? "everythingWithCustomMessage" : "everything",
        data: {
          importSource: importSource,
          importNames: importNames,
          customMessage: customMessage
        }
      });
    }
    /**
     * Check if the given importSource is restricted because '*' is being imported.
     * @param {string} importSource path of the import
     * @param {Set.<string>} importNames Set of import names that are being imported
     * @returns {boolean} whether the path is restricted
     * @private
     */


    function isRestrictedForEverythingImported(importSource, importNames) {
      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) && restrictedPathMessages[importSource].importNames && isEverythingImported(importNames);
    }
    /**
     * Check if the given importNames are restricted given a list of restrictedImportNames.
     * @param {Set.<string>} importNames Set of import names that are being imported
     * @param {string[]} restrictedImportNames array of import names that are restricted for this import
     * @returns {boolean} whether the objectName is restricted
     * @private
     */


    function isRestrictedObject(importNames, restrictedImportNames) {
      return restrictedImportNames.some(function (restrictedObjectName) {
        return importNames.has(restrictedObjectName);
      });
    }
    /**
     * Check if the given importSource is a restricted path.
     * @param {string} importSource path of the import
     * @param {Set.<string>} importNames Set of import names that are being imported
     * @returns {boolean} whether the variable is a restricted path or not
     * @private
     */


    function isRestrictedPath(importSource, importNames) {
      var isRestricted = false;

      if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
        if (restrictedPathMessages[importSource].importNames) {
          isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);
        } else {
          isRestricted = true;
        }
      }

      return isRestricted;
    }
    /**
     * Check if the given importSource is restricted by a pattern.
     * @param {string} importSource path of the import
     * @returns {boolean} whether the variable is a restricted pattern or not
     * @private
     */


    function isRestrictedPattern(importSource) {
      return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);
    }
    /**
     * Checks a node to see if any problems should be reported.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */


    function checkNode(node) {
      var importSource = node.source.value.trim();
      var importNames = node.specifiers ? node.specifiers.reduce(function (set, specifier) {
        if (specifier.type === "ImportDefaultSpecifier") {
          set.add("default");
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          set.add("*");
        } else if (specifier.imported) {
          set.add(specifier.imported.name);
        } else if (specifier.local) {
          set.add(specifier.local.name);
        }

        return set;
      }, new Set()) : new Set();

      if (isRestrictedForEverythingImported(importSource, importNames)) {
        reportPathForEverythingImported(importSource, node);
      }

      if (isRestrictedPath(importSource, importNames)) {
        reportPath(node);
      }

      if (isRestrictedPattern(importSource)) {
        reportPathForPatterns(node);
      }
    }

    return {
      ImportDeclaration: checkNode,
      ExportNamedDeclaration: function ExportNamedDeclaration(node) {
        if (node.source) {
          checkNode(node);
        }
      },
      ExportAllDeclaration: checkNode
    };
  }
};