/**
 * @fileoverview A rule to suggest using arrow functions as callbacks.
 * @author Toru Nagashima
 */
"use strict"; //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given variable is a function name.
 * @param {eslint-scope.Variable} variable A variable to check.
 * @returns {boolean} `true` if the variable is a function name.
 */

function isFunctionName(variable) {
  return variable && variable.defs[0].type === "FunctionName";
}
/**
 * Checks whether or not a given MetaProperty node equals to a given value.
 * @param {ASTNode} node A MetaProperty node to check.
 * @param {string} metaName The name of `MetaProperty.meta`.
 * @param {string} propertyName The name of `MetaProperty.property`.
 * @returns {boolean} `true` if the node is the specific value.
 */


function checkMetaProperty(node, metaName, propertyName) {
  return node.meta.name === metaName && node.property.name === propertyName;
}
/**
 * Gets the variable object of `arguments` which is defined implicitly.
 * @param {eslint-scope.Scope} scope A scope to get.
 * @returns {eslint-scope.Variable} The found variable object.
 */


function getVariableOfArguments(scope) {
  var variables = scope.variables;

  for (var i = 0; i < variables.length; ++i) {
    var variable = variables[i];

    if (variable.name === "arguments") {
      /*
       * If there was a parameter which is named "arguments", the
       * implicit "arguments" is not defined.
       * So does fast return with null.
       */
      return variable.identifiers.length === 0 ? variable : null;
    }
  }
  /* istanbul ignore next */


  return null;
}
/**
 * Checkes whether or not a given node is a callback.
 * @param {ASTNode} node A node to check.
 * @returns {Object}
 *   {boolean} retv.isCallback - `true` if the node is a callback.
 *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.
 */


function getCallbackInfo(node) {
  var retv = {
    isCallback: false,
    isLexicalThis: false
  };
  var currentNode = node;
  var parent = node.parent;

  while (currentNode) {
    switch (parent.type) {
      // Checks parents recursively.
      case "LogicalExpression":
      case "ConditionalExpression":
        break;
      // Checks whether the parent node is `.bind(this)` call.

      case "MemberExpression":
        if (parent.object === currentNode && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind" && parent.parent.type === "CallExpression" && parent.parent.callee === parent) {
          retv.isLexicalThis = parent.parent.arguments.length === 1 && parent.parent.arguments[0].type === "ThisExpression";
          parent = parent.parent;
        } else {
          return retv;
        }

        break;
      // Checks whether the node is a callback.

      case "CallExpression":
      case "NewExpression":
        if (parent.callee !== currentNode) {
          retv.isCallback = true;
        }

        return retv;

      default:
        return retv;
    }

    currentNode = parent;
    parent = parent.parent;
  }
  /* istanbul ignore next */


  throw new Error("unreachable");
}
/**
 * Checks whether a simple list of parameters contains any duplicates. This does not handle complex
 * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate
 * parameter names anyway. Instead, it always returns `false` for complex parameter lists.
 * @param {ASTNode[]} paramsList The list of parameters for a function
 * @returns {boolean} `true` if the list of parameters contains any duplicates
 */


function hasDuplicateParams(paramsList) {
  return paramsList.every(function (param) {
    return param.type === "Identifier";
  }) && paramsList.length !== new Set(paramsList.map(function (param) {
    return param.name;
  })).size;
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using arrow functions for callbacks",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-arrow-callback"
    },
    schema: [{
      type: "object",
      properties: {
        allowNamedFunctions: {
          type: "boolean",
          "default": false
        },
        allowUnboundThis: {
          type: "boolean",
          "default": true
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create: function create(context) {
    var options = context.options[0] || {};
    var allowUnboundThis = options.allowUnboundThis !== false; // default to true

    var allowNamedFunctions = options.allowNamedFunctions;
    var sourceCode = context.getSourceCode();
    /*
     * {Array<{this: boolean, super: boolean, meta: boolean}>}
     * - this - A flag which shows there are one or more ThisExpression.
     * - super - A flag which shows there are one or more Super.
     * - meta - A flag which shows there are one or more MethProperty.
     */

    var stack = [];
    /**
     * Pushes new function scope with all `false` flags.
     * @returns {void}
     */

    function enterScope() {
      stack.push({
        "this": false,
        "super": false,
        meta: false
      });
    }
    /**
     * Pops a function scope from the stack.
     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.
     */


    function exitScope() {
      return stack.pop();
    }

    return {
      // Reset internal state.
      Program: function Program() {
        stack = [];
      },
      // If there are below, it cannot replace with arrow functions merely.
      ThisExpression: function ThisExpression() {
        var info = stack[stack.length - 1];

        if (info) {
          info["this"] = true;
        }
      },
      Super: function Super() {
        var info = stack[stack.length - 1];

        if (info) {
          info["super"] = true;
        }
      },
      MetaProperty: function MetaProperty(node) {
        var info = stack[stack.length - 1];

        if (info && checkMetaProperty(node, "new", "target")) {
          info.meta = true;
        }
      },
      // To skip nested scopes.
      FunctionDeclaration: enterScope,
      "FunctionDeclaration:exit": exitScope,
      // Main.
      FunctionExpression: enterScope,
      "FunctionExpression:exit": function FunctionExpressionExit(node) {
        var scopeInfo = exitScope(); // Skip named function expressions

        if (allowNamedFunctions && node.id && node.id.name) {
          return;
        } // Skip generators.


        if (node.generator) {
          return;
        } // Skip recursive functions.


        var nameVar = context.getDeclaredVariables(node)[0];

        if (isFunctionName(nameVar) && nameVar.references.length > 0) {
          return;
        } // Skip if it's using arguments.


        var variable = getVariableOfArguments(context.getScope());

        if (variable && variable.references.length > 0) {
          return;
        } // Reports if it's a callback which can replace with arrows.


        var callbackInfo = getCallbackInfo(node);

        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo["this"] || callbackInfo.isLexicalThis) && !scopeInfo["super"] && !scopeInfo.meta) {
          context.report({
            node: node,
            message: "Unexpected function expression.",
            fix: function fix(fixer) {
              if (!callbackInfo.isLexicalThis && scopeInfo["this"] || hasDuplicateParams(node.params)) {
                /*
                 * If the callback function does not have .bind(this) and contains a reference to `this`, there
                 * is no way to determine what `this` should be, so don't perform any fixes.
                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),
                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.
                 */
                return null;
              }

              var paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
              var paramsRightParen = sourceCode.getTokenBefore(node.body);
              var asyncKeyword = node.async ? "async " : "";
              var paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
              var arrowFunctionText = "".concat(asyncKeyword).concat(paramsFullText, " => ").concat(sourceCode.getText(node.body));
              /*
               * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.
               * Otherwise, just replace the arrow function itself.
               */

              var replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
              /*
               * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then
               * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even
               * though `foo || function() {}` is valid.
               */

              var needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
              var replacementText = needsParens ? "(".concat(arrowFunctionText, ")") : arrowFunctionText;
              return fixer.replaceText(replacedNode, replacementText);
            }
          });
        }
      }
    };
  }
};