/**
 * @fileoverview enforce a particular style for multiline comments
 * @author Teddy Katz
 */
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a particular style for multiline comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/multiline-comment-style"
    },
    fixable: "whitespace",
    schema: [{
      "enum": ["starred-block", "separate-lines", "bare-block"]
    }],
    messages: {
      expectedBlock: "Expected a block comment instead of consecutive line comments.",
      expectedBareBlock: "Expected a block comment without padding stars.",
      startNewline: "Expected a linebreak after '/*'.",
      endNewline: "Expected a linebreak before '*/'.",
      missingStar: "Expected a '*' at the start of this line.",
      alignment: "Expected this line to be aligned with the start of the comment.",
      expectedLines: "Expected multiple line comments instead of a block comment."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    var option = context.options[0] || "starred-block"; //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Checks if a comment line is starred.
     * @param {string} line A string representing a comment line.
     * @returns {boolean} Whether or not the comment line is starred.
     */

    function isStarredCommentLine(line) {
      return /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/.test(line);
    }
    /**
     * Checks if a comment group is in starred-block form.
     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.
     * @returns {boolean} Whether or not the comment group is in starred block form.
     */


    function isStarredBlockComment(_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          firstComment = _ref2[0];

      if (firstComment.type !== "Block") {
        return false;
      }

      var lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER); // The first and last lines can only contain whitespace.

      return lines.length > 0 && lines.every(function (line, i) {
        return (i === 0 || i === lines.length - 1 ? /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/ : /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/).test(line);
      });
    }
    /**
     * Checks if a comment group is in JSDoc form.
     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.
     * @returns {boolean} Whether or not the comment group is in JSDoc form.
     */


    function isJSDocComment(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
          firstComment = _ref4[0];

      if (firstComment.type !== "Block") {
        return false;
      }

      var lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
      return /^\*[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(lines[0]) && lines.slice(1, -1).every(function (line) {
        return /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]* /.test(line);
      }) && /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(lines[lines.length - 1]);
    }
    /**
     * Processes a comment group that is currently in separate-line form, calculating the offset for each line.
     * @param {Token[]} commentGroup A group of comments containing multiple line comments.
     * @returns {string[]} An array of the processed lines.
     */


    function processSeparateLineComments(commentGroup) {
      var allLinesHaveLeadingSpace = commentGroup.map(function (_ref5) {
        var value = _ref5.value;
        return value;
      }).filter(function (line) {
        return line.trim().length;
      }).every(function (line) {
        return line.startsWith(" ");
      });
      return commentGroup.map(function (_ref6) {
        var value = _ref6.value;
        return allLinesHaveLeadingSpace ? value.replace(/^ /, "") : value;
      });
    }
    /**
     * Processes a comment group that is currently in starred-block form, calculating the offset for each line.
     * @param {Token} comment A single block comment token in starred-block form.
     * @returns {string[]} An array of the processed lines.
     */


    function processStarredBlockComment(comment) {
      var lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter(function (line, i, linesArr) {
        return !(i === 0 || i === linesArr.length - 1);
      }).map(function (line) {
        return line.replace(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/, "");
      });
      var allLinesHaveLeadingSpace = lines.map(function (line) {
        return line.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/, "");
      }).filter(function (line) {
        return line.trim().length;
      }).every(function (line) {
        return line.startsWith(" ");
      });
      return lines.map(function (line) {
        return line.replace(allLinesHaveLeadingSpace ? /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\* ?/ : /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/, "");
      });
    }
    /**
     * Processes a comment group that is currently in bare-block form, calculating the offset for each line.
     * @param {Token} comment A single block comment token in bare-block form.
     * @returns {string[]} An array of the processed lines.
     */


    function processBareBlockComment(comment) {
      var lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(function (line) {
        return line.replace(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/, "");
      });
      var leadingWhitespace = "".concat(sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]), "   ");
      var offset = "";
      /*
       * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.
       * The first line should not be checked because it is inline with the opening block comment delimiter.
       */

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = lines.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              i = _step$value[0],
              line = _step$value[1];

          if (!line.trim().length || i === 0) {
            continue;
          }

          var _line$match = line.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)/),
              _line$match2 = _slicedToArray(_line$match, 2),
              lineOffset = _line$match2[1];

          if (lineOffset.length < leadingWhitespace.length) {
            var newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);

            if (newOffset.length > offset.length) {
              offset = newOffset;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return lines.map(function (line) {
        var match = line.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)/);

        var _match = _slicedToArray(match, 3),
            lineOffset = _match[1],
            lineContents = _match[2];

        if (lineOffset.length > leadingWhitespace.length) {
          return "".concat(lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))).concat(lineContents);
        }

        if (lineOffset.length < leadingWhitespace.length) {
          return "".concat(lineOffset.slice(leadingWhitespace.length)).concat(lineContents);
        }

        return lineContents;
      });
    }
    /**
     * Gets a list of comment lines in a group, formatting leading whitespace as necessary.
     * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.
     * @returns {string[]} A list of comment lines.
     */


    function getCommentLines(commentGroup) {
      var _commentGroup = _slicedToArray(commentGroup, 1),
          firstComment = _commentGroup[0];

      if (firstComment.type === "Line") {
        return processSeparateLineComments(commentGroup);
      }

      if (isStarredBlockComment(commentGroup)) {
        return processStarredBlockComment(firstComment);
      }

      return processBareBlockComment(firstComment);
    }
    /**
     * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.
     * @param {Token} comment The token to check.
     * @returns {string} The offset from the beginning of a line to the token.
     */


    function getInitialOffset(comment) {
      return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);
    }
    /**
     * Converts a comment into starred-block form
     * @param {Token} firstComment The first comment of the group being converted
     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
     * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers
     */


    function convertToStarredBlock(firstComment, commentLinesList) {
      var initialOffset = getInitialOffset(firstComment);
      return "/*\n".concat(commentLinesList.map(function (line) {
        return "".concat(initialOffset, " * ").concat(line);
      }).join("\n"), "\n").concat(initialOffset, " */");
    }
    /**
     * Converts a comment into separate-line form
     * @param {Token} firstComment The first comment of the group being converted
     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
     * @returns {string} A representation of the comment value in separate-line form
     */


    function convertToSeparateLines(firstComment, commentLinesList) {
      return commentLinesList.map(function (line) {
        return "// ".concat(line);
      }).join("\n".concat(getInitialOffset(firstComment)));
    }
    /**
     * Converts a comment into bare-block form
     * @param {Token} firstComment The first comment of the group being converted
     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
     * @returns {string} A representation of the comment value in bare-block form
     */


    function convertToBlock(firstComment, commentLinesList) {
      return "/* ".concat(commentLinesList.join("\n".concat(getInitialOffset(firstComment), "   ")), " */");
    }
    /**
     * Each method checks a group of comments to see if it's valid according to the given option.
     * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single
     * block comment or multiple line comments.
     * @returns {void}
     */


    var commentGroupCheckers = {
      "starred-block": function starredBlock(commentGroup) {
        var _commentGroup2 = _slicedToArray(commentGroup, 1),
            firstComment = _commentGroup2[0];

        var commentLines = getCommentLines(commentGroup);

        if (commentLines.some(function (value) {
          return value.includes("*/");
        })) {
          return;
        }

        if (commentGroup.length > 1) {
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: commentGroup[commentGroup.length - 1].loc.end
            },
            messageId: "expectedBlock",
            fix: function fix(fixer) {
              var range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];
              return commentLines.some(function (value) {
                return value.startsWith("/");
              }) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));
            }
          });
        } else {
          (function () {
            var lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
            var expectedLeadingWhitespace = getInitialOffset(firstComment);
            var expectedLinePrefix = "".concat(expectedLeadingWhitespace, " *");

            if (!/^\*?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(lines[0])) {
              var start = firstComment.value.startsWith("*") ? firstComment.range[0] + 1 : firstComment.range[0];
              context.report({
                loc: {
                  start: firstComment.loc.start,
                  end: {
                    line: firstComment.loc.start.line,
                    column: firstComment.loc.start.column + 2
                  }
                },
                messageId: "startNewline",
                fix: function fix(fixer) {
                  return fixer.insertTextAfterRange([start, start + 2], "\n".concat(expectedLinePrefix));
                }
              });
            }

            if (!/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(lines[lines.length - 1])) {
              context.report({
                loc: {
                  start: {
                    line: firstComment.loc.end.line,
                    column: firstComment.loc.end.column - 2
                  },
                  end: firstComment.loc.end
                },
                messageId: "endNewline",
                fix: function fix(fixer) {
                  return fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], "\n".concat(expectedLinePrefix, "/"));
                }
              });
            }

            var _loop = function _loop(lineNumber) {
              var lineText = sourceCode.lines[lineNumber - 1];
              var errorType = isStarredCommentLine(lineText) ? "alignment" : "missingStar";

              if (!lineText.startsWith(expectedLinePrefix)) {
                context.report({
                  loc: {
                    start: {
                      line: lineNumber,
                      column: 0
                    },
                    end: {
                      line: lineNumber,
                      column: lineText.length
                    }
                  },
                  messageId: errorType,
                  fix: function fix(fixer) {
                    var lineStartIndex = sourceCode.getIndexFromLoc({
                      line: lineNumber,
                      column: 0
                    });

                    if (errorType === "alignment") {
                      var _ref7 = lineText.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*)/) || [],
                          _ref8 = _slicedToArray(_ref7, 2),
                          _ref8$ = _ref8[1],
                          _commentTextPrefix = _ref8$ === void 0 ? "" : _ref8$;

                      var _commentTextStartIndex = lineStartIndex + _commentTextPrefix.length;

                      return fixer.replaceTextRange([lineStartIndex, _commentTextStartIndex], expectedLinePrefix);
                    }

                    var _ref9 = lineText.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)/) || [],
                        _ref10 = _slicedToArray(_ref9, 2),
                        _ref10$ = _ref10[1],
                        commentTextPrefix = _ref10$ === void 0 ? "" : _ref10$;

                    var commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                    var offset;
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                      for (var _iterator2 = lines.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var _step2$value = _slicedToArray(_step2.value, 2),
                            idx = _step2$value[0],
                            line = _step2$value[1];

                        if (!/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+/.test(line)) {
                          continue;
                        }

                        var lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];

                        var _ref11 = lineTextToAlignWith.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:\/?\*)?([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*))/) || [],
                            _ref12 = _slicedToArray(_ref11, 3),
                            _ref12$ = _ref12[1],
                            prefix = _ref12$ === void 0 ? "" : _ref12$,
                            _ref12$2 = _ref12[2],
                            initialOffset = _ref12$2 === void 0 ? "" : _ref12$2;

                        offset = "".concat(commentTextPrefix.slice(prefix.length)).concat(initialOffset);
                        break;
                      }
                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }

                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], "".concat(expectedLinePrefix).concat(offset));
                  }
                });
              }
            };

            for (var lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {
              _loop(lineNumber);
            }
          })();
        }
      },
      "separate-lines": function separateLines(commentGroup) {
        var _commentGroup3 = _slicedToArray(commentGroup, 1),
            firstComment = _commentGroup3[0];

        if (firstComment.type !== "Block" || isJSDocComment(commentGroup)) {
          return;
        }

        var commentLines = getCommentLines(commentGroup);
        var tokenAfter = sourceCode.getTokenAfter(firstComment, {
          includeComments: true
        });

        if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {
          return;
        }

        context.report({
          loc: {
            start: firstComment.loc.start,
            end: {
              line: firstComment.loc.start.line,
              column: firstComment.loc.start.column + 2
            }
          },
          messageId: "expectedLines",
          fix: function fix(fixer) {
            return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));
          }
        });
      },
      "bare-block": function bareBlock(commentGroup) {
        if (isJSDocComment(commentGroup)) {
          return;
        }

        var _commentGroup4 = _slicedToArray(commentGroup, 1),
            firstComment = _commentGroup4[0];

        var commentLines = getCommentLines(commentGroup); // Disallows consecutive line comments in favor of using a block comment.

        if (firstComment.type === "Line" && commentLines.length > 1 && !commentLines.some(function (value) {
          return value.includes("*/");
        })) {
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: commentGroup[commentGroup.length - 1].loc.end
            },
            messageId: "expectedBlock",
            fix: function fix(fixer) {
              return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));
            }
          });
        } // Prohibits block comments from having a * at the beginning of each line.


        if (isStarredBlockComment(commentGroup)) {
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: {
                line: firstComment.loc.start.line,
                column: firstComment.loc.start.column + 2
              }
            },
            messageId: "expectedBareBlock",
            fix: function fix(fixer) {
              return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));
            }
          });
        }
      }
    }; //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      Program: function Program() {
        return sourceCode.getAllComments().filter(function (comment) {
          return comment.type !== "Shebang";
        }).filter(function (comment) {
          return !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value);
        }).filter(function (comment) {
          var tokenBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });
          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
        }).reduce(function (commentGroups, comment, index, commentList) {
          var tokenBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });

          if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
            commentGroups[commentGroups.length - 1].push(comment);
          } else {
            commentGroups.push([comment]);
          }

          return commentGroups;
        }, []).filter(function (commentGroup) {
          return !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line);
        }).forEach(commentGroupCheckers[option]);
      }
    };
  }
};