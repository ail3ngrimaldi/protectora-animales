/**
 * @fileoverview Rule to disallow duplicate conditions in if-else-if chains
 * @author Milos Djermanovic
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determines whether the first given array is a subset of the second given array.
 * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.
 * @param {Array} arrA The array to compare from.
 * @param {Array} arrB The array to compare against.
 * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.
 */


function isSubsetByComparator(comparator, arrA, arrB) {
  return arrA.every(function (a) {
    return arrB.some(function (b) {
      return comparator(a, b);
    });
  });
}
/**
 * Splits the given node by the given logical operator.
 * @param {string} operator Logical operator `||` or `&&`.
 * @param {ASTNode} node The node to split.
 * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.
 */


function splitByLogicalOperator(operator, node) {
  if (node.type === "LogicalExpression" && node.operator === operator) {
    return [].concat(_toConsumableArray(splitByLogicalOperator(operator, node.left)), _toConsumableArray(splitByLogicalOperator(operator, node.right)));
  }

  return [node];
}

var splitByOr = splitByLogicalOperator.bind(null, "||");
var splitByAnd = splitByLogicalOperator.bind(null, "&&"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate conditions in if-else-if chains",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-dupe-else-if"
    },
    schema: [],
    messages: {
      unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    /**
     * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes
     * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.
     * @param {ASTNode} a First node.
     * @param {ASTNode} b Second node.
     * @returns {boolean} `true` if the nodes are considered to be equal.
     */

    function equal(a, b) {
      if (a.type !== b.type) {
        return false;
      }

      if (a.type === "LogicalExpression" && (a.operator === "||" || a.operator === "&&") && a.operator === b.operator) {
        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);
      }

      return astUtils.equalTokens(a, b, sourceCode);
    }

    var isSubset = isSubsetByComparator.bind(null, equal);
    return {
      IfStatement: function IfStatement(node) {
        var test = node.test,
            conditionsToCheck = test.type === "LogicalExpression" && test.operator === "&&" ? [test].concat(_toConsumableArray(splitByAnd(test))) : [test];
        var current = node,
            listToCheck = conditionsToCheck.map(function (c) {
          return splitByOr(c).map(splitByAnd);
        });

        var _loop = function _loop() {
          current = current.parent;
          var currentOrOperands = splitByOr(current.test).map(splitByAnd);
          listToCheck = listToCheck.map(function (orOperands) {
            return orOperands.filter(function (orOperand) {
              return !currentOrOperands.some(function (currentOrOperand) {
                return isSubset(currentOrOperand, orOperand);
              });
            });
          });

          if (listToCheck.some(function (orOperands) {
            return orOperands.length === 0;
          })) {
            context.report({
              node: test,
              messageId: "unexpected"
            });
            return "break";
          }
        };

        while (current.parent && current.parent.type === "IfStatement" && current.parent.alternate === current) {
          var _ret = _loop();

          if (_ret === "break") break;
        }
      }
    };
  }
};