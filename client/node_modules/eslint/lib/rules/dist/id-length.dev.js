/**
 * @fileoverview Rule that warns when identifier names are shorter or longer
 * than the values provided in configuration.
 * @author Burak Yigit Kaya aka BYK
 */
"use strict"; //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce minimum and maximum identifier lengths",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-length"
    },
    schema: [{
      type: "object",
      properties: {
        min: {
          type: "integer",
          "default": 2
        },
        max: {
          type: "integer"
        },
        exceptions: {
          type: "array",
          uniqueItems: true,
          items: {
            type: "string"
          }
        },
        properties: {
          "enum": ["always", "never"]
        }
      },
      additionalProperties: false
    }],
    messages: {
      tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
      tooLong: "Identifier name '{{name}}' is too long (> {{max}})."
    }
  },
  create: function create(context) {
    var options = context.options[0] || {};
    var minLength = typeof options.min !== "undefined" ? options.min : 2;
    var maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
    var properties = options.properties !== "never";
    var exceptions = (options.exceptions ? options.exceptions : []).reduce(function (obj, item) {
      obj[item] = true;
      return obj;
    }, {});
    var SUPPORTED_EXPRESSIONS = {
      MemberExpression: properties && function (parent) {
        return !parent.computed && ( // regular property assignment
        parent.parent.left === parent && parent.parent.type === "AssignmentExpression" || // or the last identifier in an ObjectPattern destructuring
        parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
      },
      AssignmentPattern: function AssignmentPattern(parent, node) {
        return parent.left === node;
      },
      VariableDeclarator: function VariableDeclarator(parent, node) {
        return parent.id === node;
      },
      Property: properties && function (parent, node) {
        return parent.key === node;
      },
      ImportDefaultSpecifier: true,
      RestElement: true,
      FunctionExpression: true,
      ArrowFunctionExpression: true,
      ClassDeclaration: true,
      FunctionDeclaration: true,
      MethodDefinition: true,
      CatchClause: true
    };
    return {
      Identifier: function Identifier(node) {
        var name = node.name;
        var parent = node.parent;
        var isShort = name.length < minLength;
        var isLong = name.length > maxLength;

        if (!(isShort || isLong) || exceptions[name]) {
          return; // Nothing to report
        }

        var isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

        if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
          context.report({
            node: node,
            messageId: isShort ? "tooShort" : "tooLong",
            data: {
              name: name,
              min: minLength,
              max: maxLength
            }
          });
        }
      }
    };
  }
};