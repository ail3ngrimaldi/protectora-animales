/**
 * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals
 * @author Annie Zhang, Henry Zhu
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var radixMap = new Map([[2, {
  system: "binary",
  literalPrefix: "0b"
}], [8, {
  system: "octal",
  literalPrefix: "0o"
}], [16, {
  system: "hexadecimal",
  literalPrefix: "0x"
}]]);
/**
 * Checks to see if a CallExpression's callee node is `parseInt` or
 * `Number.parseInt`.
 * @param {ASTNode} calleeNode The callee node to evaluate.
 * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,
 * false otherwise.
 */

function isParseInt(calleeNode) {
  switch (calleeNode.type) {
    case "Identifier":
      return calleeNode.name === "parseInt";

    case "MemberExpression":
      return calleeNode.object.type === "Identifier" && calleeNode.object.name === "Number" && calleeNode.property.type === "Identifier" && calleeNode.property.name === "parseInt";
    // no default
  }

  return false;
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-numeric-literals"
    },
    schema: [],
    messages: {
      useLiteral: "Use {{system}} literals instead of {{functionName}}()."
    },
    fixable: "code"
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode(); //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      "CallExpression[arguments.length=2]": function CallExpressionArgumentsLength2(node) {
        var _node$arguments = _slicedToArray(node.arguments, 2),
            strNode = _node$arguments[0],
            radixNode = _node$arguments[1],
            str = strNode.value,
            radix = radixNode.value;

        if (strNode.type === "Literal" && radixNode.type === "Literal" && typeof str === "string" && typeof radix === "number" && radixMap.has(radix) && isParseInt(node.callee)) {
          var _radixMap$get = radixMap.get(radix),
              system = _radixMap$get.system,
              literalPrefix = _radixMap$get.literalPrefix;

          context.report({
            node: node,
            messageId: "useLiteral",
            data: {
              system: system,
              functionName: sourceCode.getText(node.callee)
            },
            fix: function fix(fixer) {
              if (sourceCode.getCommentsInside(node).length) {
                return null;
              }

              var replacement = "".concat(literalPrefix).concat(str);

              if (+replacement !== parseInt(str, radix)) {
                /*
                 * If the newly-produced literal would be invalid, (e.g. 0b1234),
                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.
                 */
                return null;
              }

              var tokenBefore = sourceCode.getTokenBefore(node),
                  tokenAfter = sourceCode.getTokenAfter(node);
              var prefix = "",
                  suffix = "";

              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {
                prefix = " ";
              }

              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {
                suffix = " ";
              }

              return fixer.replaceText(node, "".concat(prefix).concat(replacement).concat(suffix));
            }
          });
        }
      }
    };
  }
};