/**
 * @fileoverview Rule to forbid control charactes from regular expressions.
 * @author Nicholas C. Zakas
 */
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RegExpValidator = require("regexpp").RegExpValidator;

var collector = new (
/*#__PURE__*/
function () {
  function _class() {
    _classCallCheck(this, _class);

    this.ecmaVersion = 2018;
    this._source = "";
    this._controlChars = [];
    this._validator = new RegExpValidator(this);
  }

  _createClass(_class, [{
    key: "onPatternEnter",
    value: function onPatternEnter() {
      this._controlChars = [];
    }
  }, {
    key: "onCharacter",
    value: function onCharacter(start, end, cp) {
      if (cp >= 0x00 && cp <= 0x1F && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith("\\x") || this._source.slice(start, end).startsWith("\\u"))) {
        this._controlChars.push("\\x".concat("0".concat(cp.toString(16)).slice(-2)));
      }
    }
  }, {
    key: "collectControlChars",
    value: function collectControlChars(regexpStr) {
      try {
        this._source = regexpStr;

        this._validator.validatePattern(regexpStr); // Call onCharacter hook

      } catch (err) {// Ignore syntax errors in RegExp.
      }

      return this._controlChars;
    }
  }]);

  return _class;
}())(); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control characters in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-control-regex"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
    }
  },
  create: function create(context) {
    /**
     * Get the regex expression
     * @param {ASTNode} node node to evaluate
     * @returns {RegExp|null} Regex if found else null
     * @private
     */
    function getRegExpPattern(node) {
      if (node.regex) {
        return node.regex.pattern;
      }

      if (typeof node.value === "string" && (node.parent.type === "NewExpression" || node.parent.type === "CallExpression") && node.parent.callee.type === "Identifier" && node.parent.callee.name === "RegExp" && node.parent.arguments[0] === node) {
        return node.value;
      }

      return null;
    }

    return {
      Literal: function Literal(node) {
        var pattern = getRegExpPattern(node);

        if (pattern) {
          var controlCharacters = collector.collectControlChars(pattern);

          if (controlCharacters.length > 0) {
            context.report({
              node: node,
              messageId: "unexpected",
              data: {
                controlChars: controlCharacters.join(", ")
              }
            });
          }
        }
      }
    };
  }
};