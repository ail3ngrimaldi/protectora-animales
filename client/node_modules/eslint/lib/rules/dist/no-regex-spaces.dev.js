/**
 * @fileoverview Rule to count multiple spaces in regular expressions
 * @author Matt DuVall <http://www.mattduvall.com/>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var astUtils = require("./utils/ast-utils");

var regexpp = require("regexpp"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var regExpParser = new regexpp.RegExpParser();
var DOUBLE_SPACE = / {2}/;
/**
 * Check if node is a string
 * @param {ASTNode} node node to evaluate
 * @returns {boolean} True if its a string
 * @private
 */

function isString(node) {
  return node && node.type === "Literal" && typeof node.value === "string";
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiple spaces in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-regex-spaces"
    },
    schema: [],
    fixable: "code"
  },
  create: function create(context) {
    /**
     * Validate regular expression
     * @param {ASTNode} nodeToReport Node to report.
     * @param {string} pattern Regular expression pattern to validate.
     * @param {string} rawPattern Raw representation of the pattern in the source code.
     * @param {number} rawPatternStartRange Start range of the pattern in the source code.
     * @param {string} flags Regular expression flags.
     * @returns {void}
     * @private
     */
    function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {
      // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \ ').
      if (!DOUBLE_SPACE.test(rawPattern)) {
        return;
      }

      var characterClassNodes = [];
      var regExpAST;

      try {
        regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
      } catch (e) {
        // Ignore regular expressions with syntax errors
        return;
      }

      regexpp.visitRegExpAST(regExpAST, {
        onCharacterClassEnter: function onCharacterClassEnter(ccNode) {
          characterClassNodes.push(ccNode);
        }
      });
      var spacesPattern = /( {2,})(?: [\*\+\?\{]|(?:[\0-\),->@-z\|-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])|$)/g;
      var match;

      var _loop = function _loop() {
        var _match = match,
            length = _match[1].length,
            index = _match.index; // Report only consecutive spaces that are not in character classes.

        if (characterClassNodes.every(function (_ref) {
          var start = _ref.start,
              end = _ref.end;
          return index < start || end <= index;
        })) {
          context.report({
            node: nodeToReport,
            message: "Spaces are hard to count. Use {{{length}}}.",
            data: {
              length: length
            },
            fix: function fix(fixer) {
              if (pattern !== rawPattern) {
                return null;
              }

              return fixer.replaceTextRange([rawPatternStartRange + index, rawPatternStartRange + index + length], " {".concat(length, "}"));
            }
          }); // Report only the first occurence of consecutive spaces

          return {
            v: void 0
          };
        }
      };

      while (match = spacesPattern.exec(pattern)) {
        var _ret = _loop();

        if (_typeof(_ret) === "object") return _ret.v;
      }
    }
    /**
     * Validate regular expression literals
     * @param {ASTNode} node node to validate
     * @returns {void}
     * @private
     */


    function checkLiteral(node) {
      if (node.regex) {
        var pattern = node.regex.pattern;
        var rawPattern = node.raw.slice(1, node.raw.lastIndexOf("/"));
        var rawPatternStartRange = node.range[0] + 1;
        var flags = node.regex.flags;
        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);
      }
    }
    /**
     * Validate strings passed to the RegExp constructor
     * @param {ASTNode} node node to validate
     * @returns {void}
     * @private
     */


    function checkFunction(node) {
      var scope = context.getScope();
      var regExpVar = astUtils.getVariableByName(scope, "RegExp");
      var shadowed = regExpVar && regExpVar.defs.length > 0;
      var patternNode = node.arguments[0];
      var flagsNode = node.arguments[1];

      if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(patternNode) && !shadowed) {
        var pattern = patternNode.value;
        var rawPattern = patternNode.raw.slice(1, -1);
        var rawPatternStartRange = patternNode.range[0] + 1;
        var flags = isString(flagsNode) ? flagsNode.value : "";
        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);
      }
    }

    return {
      Literal: checkLiteral,
      CallExpression: checkFunction,
      NewExpression: checkFunction
    };
  }
};