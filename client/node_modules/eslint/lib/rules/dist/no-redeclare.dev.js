/**
 * @fileoverview Rule to flag when the same variable is declared more then once.
 * @author Ilya Volodin
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable redeclaration",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-redeclare"
    },
    messages: {
      redeclared: "'{{id}}' is already defined.",
      redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
      redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          "default": true
        }
      },
      additionalProperties: false
    }]
  },
  create: function create(context) {
    var _marked =
    /*#__PURE__*/
    regeneratorRuntime.mark(iterateDeclarations);

    var options = {
      builtinGlobals: Boolean(context.options.length === 0 || context.options[0].builtinGlobals)
    };
    var sourceCode = context.getSourceCode();
    /**
     * Iterate declarations of a given variable.
     * @param {escope.variable} variable The variable object to iterate declarations.
     * @returns {IterableIterator<{type:string,node:ASTNode,loc:SourceLocation}>} The declarations.
     */

    function iterateDeclarations(variable) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, id, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, comment;

      return regeneratorRuntime.wrap(function iterateDeclarations$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(options.builtinGlobals && (variable.eslintImplicitGlobalSetting === "readonly" || variable.eslintImplicitGlobalSetting === "writable"))) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return {
                type: "builtin"
              };

            case 3:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 6;
              _iterator = variable.identifiers[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 15;
                break;
              }

              id = _step.value;
              _context.next = 12;
              return {
                type: "syntax",
                node: id,
                loc: id.loc
              };

            case 12:
              _iteratorNormalCompletion = true;
              _context.next = 8;
              break;

            case 15:
              _context.next = 21;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](6);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 21:
              _context.prev = 21;
              _context.prev = 22;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 24:
              _context.prev = 24;

              if (!_didIteratorError) {
                _context.next = 27;
                break;
              }

              throw _iteratorError;

            case 27:
              return _context.finish(24);

            case 28:
              return _context.finish(21);

            case 29:
              if (!variable.eslintExplicitGlobalComments) {
                _context.next = 56;
                break;
              }

              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 33;
              _iterator2 = variable.eslintExplicitGlobalComments[Symbol.iterator]();

            case 35:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 42;
                break;
              }

              comment = _step2.value;
              _context.next = 39;
              return {
                type: "comment",
                node: comment,
                loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, comment, variable.name)
              };

            case 39:
              _iteratorNormalCompletion2 = true;
              _context.next = 35;
              break;

            case 42:
              _context.next = 48;
              break;

            case 44:
              _context.prev = 44;
              _context.t1 = _context["catch"](33);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t1;

            case 48:
              _context.prev = 48;
              _context.prev = 49;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 51:
              _context.prev = 51;

              if (!_didIteratorError2) {
                _context.next = 54;
                break;
              }

              throw _iteratorError2;

            case 54:
              return _context.finish(51);

            case 55:
              return _context.finish(48);

            case 56:
            case "end":
              return _context.stop();
          }
        }
      }, _marked, null, [[6, 17, 21, 29], [22,, 24, 28], [33, 44, 48, 56], [49,, 51, 55]]);
    }
    /**
     * Find variables in a given scope and flag redeclared ones.
     * @param {Scope} scope An eslint-scope scope object.
     * @returns {void}
     * @private
     */


    function findVariablesInScope(scope) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = scope.variables[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var variable = _step3.value;

          var _iterateDeclarations = iterateDeclarations(variable),
              _iterateDeclarations2 = _toArray(_iterateDeclarations),
              declaration = _iterateDeclarations2[0],
              extraDeclarations = _iterateDeclarations2.slice(1);

          if (extraDeclarations.length === 0) {
            continue;
          }
          /*
           * If the type of a declaration is different from the type of
           * the first declaration, it shows the location of the first
           * declaration.
           */


          var detailMessageId = declaration.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax";
          var data = {
            id: variable.name
          }; // Report extra declarations.

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = extraDeclarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _step4$value = _step4.value,
                  type = _step4$value.type,
                  node = _step4$value.node,
                  loc = _step4$value.loc;
              var messageId = type === declaration.type ? "redeclared" : detailMessageId;
              context.report({
                node: node,
                loc: loc,
                messageId: messageId,
                data: data
              });
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * Find variables in the current scope.
     * @param {ASTNode} node The node of the current scope.
     * @returns {void}
     * @private
     */


    function checkForBlock(node) {
      var scope = context.getScope();
      /*
       * In ES5, some node type such as `BlockStatement` doesn't have that scope.
       * `scope.block` is a different node in such a case.
       */

      if (scope.block === node) {
        findVariablesInScope(scope);
      }
    }

    return {
      Program: function Program() {
        var scope = context.getScope();
        findVariablesInScope(scope); // Node.js or ES modules has a special scope.

        if (scope.type === "global" && scope.childScopes[0] && // The special scope's block is the Program node.
        scope.block === scope.childScopes[0].block) {
          findVariablesInScope(scope.childScopes[0]);
        }
      },
      FunctionDeclaration: checkForBlock,
      FunctionExpression: checkForBlock,
      ArrowFunctionExpression: checkForBlock,
      BlockStatement: checkForBlock,
      ForStatement: checkForBlock,
      ForInStatement: checkForBlock,
      ForOfStatement: checkForBlock,
      SwitchStatement: checkForBlock
    };
  }
};