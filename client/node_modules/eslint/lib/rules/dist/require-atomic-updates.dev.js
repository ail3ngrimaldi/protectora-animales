/**
 * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`
 * @author Teddy Katz
 * @author Toru Nagashima
 */
"use strict";
/**
 * Make the map from identifiers to each reference.
 * @param {escope.Scope} scope The scope to get references.
 * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.
 * @returns {Map<Identifier, escope.Reference>} `referenceMap`.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function createReferenceMap(scope) {
  var outReferenceMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = scope.references[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var reference = _step.value;
      outReferenceMap.set(reference.identifier, reference);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = scope.childScopes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var childScope = _step2.value;

      if (childScope.type !== "function") {
        createReferenceMap(childScope, outReferenceMap);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return outReferenceMap;
}
/**
 * Get `reference.writeExpr` of a given reference.
 * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`
 * @param {escope.Reference} reference The reference to get.
 * @returns {Expression|null} The `reference.writeExpr`.
 */


function getWriteExpr(reference) {
  if (reference.writeExpr) {
    return reference.writeExpr;
  }

  var node = reference.identifier;

  while (node) {
    var t = node.parent.type;

    if (t === "AssignmentExpression" && node.parent.left === node) {
      return node.parent.right;
    }

    if (t === "MemberExpression" && node.parent.object === node) {
      node = node.parent;
      continue;
    }

    break;
  }

  return null;
}
/**
 * Checks if an expression is a variable that can only be observed within the given function.
 * @param {Variable|null} variable The variable to check
 * @param {boolean} isMemberAccess If `true` then this is a member access.
 * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.
 */


function isLocalVariableWithoutEscape(variable, isMemberAccess) {
  if (!variable) {
    return false; // A global variable which was not defined.
  } // If the reference is a property access and the variable is a parameter, it handles the variable is not local.


  if (isMemberAccess && variable.defs.some(function (d) {
    return d.type === "Parameter";
  })) {
    return false;
  }

  var functionScope = variable.scope.variableScope;
  return variable.references.every(function (reference) {
    return reference.from.variableScope === functionScope;
  });
}

var SegmentInfo =
/*#__PURE__*/
function () {
  function SegmentInfo() {
    _classCallCheck(this, SegmentInfo);

    this.info = new WeakMap();
  }
  /**
   * Initialize the segment information.
   * @param {PathSegment} segment The segment to initialize.
   * @returns {void}
   */


  _createClass(SegmentInfo, [{
    key: "initialize",
    value: function initialize(segment) {
      var outdatedReadVariableNames = new Set();
      var freshReadVariableNames = new Set();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = segment.prevSegments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var prevSegment = _step3.value;
          var info = this.info.get(prevSegment);

          if (info) {
            info.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);
            info.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.info.set(segment, {
        outdatedReadVariableNames: outdatedReadVariableNames,
        freshReadVariableNames: freshReadVariableNames
      });
    }
    /**
     * Mark a given variable as read on given segments.
     * @param {PathSegment[]} segments The segments that it read the variable on.
     * @param {string} variableName The variable name to be read.
     * @returns {void}
     */

  }, {
    key: "markAsRead",
    value: function markAsRead(segments, variableName) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = segments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var segment = _step4.value;
          var info = this.info.get(segment);

          if (info) {
            info.freshReadVariableNames.add(variableName);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    /**
     * Move `freshReadVariableNames` to `outdatedReadVariableNames`.
     * @param {PathSegment[]} segments The segments to process.
     * @returns {void}
     */

  }, {
    key: "makeOutdated",
    value: function makeOutdated(segments) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = segments[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var segment = _step5.value;
          var info = this.info.get(segment);

          if (info) {
            info.freshReadVariableNames.forEach(Set.prototype.add, info.outdatedReadVariableNames);
            info.freshReadVariableNames.clear();
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
    /**
     * Check if a given variable is outdated on the current segments.
     * @param {PathSegment[]} segments The current segments.
     * @param {string} variableName The variable name to check.
     * @returns {boolean} `true` if the variable is outdated on the segments.
     */

  }, {
    key: "isOutdated",
    value: function isOutdated(segments, variableName) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = segments[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var segment = _step6.value;
          var info = this.info.get(segment);

          if (info && info.outdatedReadVariableNames.has(variableName)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return false;
    }
  }]);

  return SegmentInfo;
}(); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-atomic-updates"
    },
    fixable: null,
    schema: [],
    messages: {
      nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    var assignmentReferences = new Map();
    var segmentInfo = new SegmentInfo();
    var stack = null;
    return {
      onCodePathStart: function onCodePathStart(codePath) {
        var scope = context.getScope();
        var shouldVerify = scope.type === "function" && (scope.block.async || scope.block.generator);
        stack = {
          upper: stack,
          codePath: codePath,
          referenceMap: shouldVerify ? createReferenceMap(scope) : null
        };
      },
      onCodePathEnd: function onCodePathEnd() {
        stack = stack.upper;
      },
      // Initialize the segment information.
      onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
        segmentInfo.initialize(segment);
      },
      // Handle references to prepare verification.
      Identifier: function Identifier(node) {
        var _stack = stack,
            codePath = _stack.codePath,
            referenceMap = _stack.referenceMap;
        var reference = referenceMap && referenceMap.get(node); // Ignore if this is not a valid variable reference.

        if (!reference) {
          return;
        }

        var name = reference.identifier.name;
        var variable = reference.resolved;
        var writeExpr = getWriteExpr(reference);
        var isMemberAccess = reference.identifier.parent.type === "MemberExpression"; // Add a fresh read variable.

        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
          segmentInfo.markAsRead(codePath.currentSegments, name);
        }
        /*
         * Register the variable to verify after ESLint traversed the `writeExpr` node
         * if this reference is an assignment to a variable which is referred from other clausure.
         */


        if (writeExpr && writeExpr.parent.right === writeExpr && // ← exclude variable declarations.
        !isLocalVariableWithoutEscape(variable, isMemberAccess)) {
          var refs = assignmentReferences.get(writeExpr);

          if (!refs) {
            refs = [];
            assignmentReferences.set(writeExpr, refs);
          }

          refs.push(reference);
        }
      },

      /*
       * Verify assignments.
       * If the reference exists in `outdatedReadVariableNames` list, report it.
       */
      ":expression:exit": function expressionExit(node) {
        var _stack2 = stack,
            codePath = _stack2.codePath,
            referenceMap = _stack2.referenceMap; // referenceMap exists if this is in a resumable function scope.

        if (!referenceMap) {
          return;
        } // Mark the read variables on this code path as outdated.


        if (node.type === "AwaitExpression" || node.type === "YieldExpression") {
          segmentInfo.makeOutdated(codePath.currentSegments);
        } // Verify.


        var references = assignmentReferences.get(node);

        if (references) {
          assignmentReferences["delete"](node);
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = references[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var reference = _step7.value;
              var name = reference.identifier.name;

              if (segmentInfo.isOutdated(codePath.currentSegments, name)) {
                context.report({
                  node: node.parent,
                  messageId: "nonAtomicUpdate",
                  data: {
                    value: sourceCode.getText(node.parent.left)
                  }
                });
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
      }
    };
  }
};