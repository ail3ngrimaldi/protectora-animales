/**
 * @fileoverview Rule to disallow certain object properties
 * @author Will Klein & Eli White
 */
"use strict";

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow certain properties on certain objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-properties"
    },
    schema: {
      type: "array",
      items: {
        anyOf: [// `object` and `property` are both optional, but at least one of them must be provided.
        {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: false,
          required: ["object"]
        }, {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: false,
          required: ["property"]
        }]
      },
      uniqueItems: true
    }
  },
  create: function create(context) {
    var restrictedCalls = context.options;

    if (restrictedCalls.length === 0) {
      return {};
    }

    var restrictedProperties = new Map();
    var globallyRestrictedObjects = new Map();
    var globallyRestrictedProperties = new Map();
    restrictedCalls.forEach(function (option) {
      var objectName = option.object;
      var propertyName = option.property;

      if (typeof objectName === "undefined") {
        globallyRestrictedProperties.set(propertyName, {
          message: option.message
        });
      } else if (typeof propertyName === "undefined") {
        globallyRestrictedObjects.set(objectName, {
          message: option.message
        });
      } else {
        if (!restrictedProperties.has(objectName)) {
          restrictedProperties.set(objectName, new Map());
        }

        restrictedProperties.get(objectName).set(propertyName, {
          message: option.message
        });
      }
    });
    /**
     * Checks to see whether a property access is restricted, and reports it if so.
     * @param {ASTNode} node The node to report
     * @param {string} objectName The name of the object
     * @param {string} propertyName The name of the property
     * @returns {undefined}
     */

    function checkPropertyAccess(node, objectName, propertyName) {
      if (propertyName === null) {
        return;
      }

      var matchedObject = restrictedProperties.get(objectName);
      var matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
      var globalMatchedProperty = globallyRestrictedProperties.get(propertyName);

      if (matchedObjectProperty) {
        var message = matchedObjectProperty.message ? " ".concat(matchedObjectProperty.message) : "";
        context.report({
          node: node,
          // eslint-disable-next-line eslint-plugin/report-message-format
          message: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
          data: {
            objectName: objectName,
            propertyName: propertyName,
            message: message
          }
        });
      } else if (globalMatchedProperty) {
        var _message = globalMatchedProperty.message ? " ".concat(globalMatchedProperty.message) : "";

        context.report({
          node: node,
          // eslint-disable-next-line eslint-plugin/report-message-format
          message: "'{{propertyName}}' is restricted from being used.{{message}}",
          data: {
            propertyName: propertyName,
            message: _message
          }
        });
      }
    }
    /**
     * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`
     * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node
     * @returns {undefined}
     */


    function checkDestructuringAssignment(node) {
      if (node.right.type === "Identifier") {
        var objectName = node.right.name;

        if (node.left.type === "ObjectPattern") {
          node.left.properties.forEach(function (property) {
            checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
          });
        }
      }
    }

    return {
      MemberExpression: function MemberExpression(node) {
        checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
      },
      VariableDeclarator: function VariableDeclarator(node) {
        if (node.init && node.init.type === "Identifier") {
          var objectName = node.init.name;

          if (node.id.type === "ObjectPattern") {
            node.id.properties.forEach(function (property) {
              checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
            });
          }
        }
      },
      AssignmentExpression: checkDestructuringAssignment,
      AssignmentPattern: checkDestructuringAssignment
    };
  }
};