/**
 * @fileoverview enforce consistent line breaks inside function parentheses
 * @author Teddy Katz
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks inside function parentheses",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/function-paren-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        "enum": ["always", "never", "consistent", "multiline", "multiline-arguments"]
      }, {
        type: "object",
        properties: {
          minItems: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      expectedBefore: "Expected newline before ')'.",
      expectedAfter: "Expected newline after '('.",
      expectedBetween: "Expected newline between arguments/params.",
      unexpectedBefore: "Unexpected newline before ')'.",
      unexpectedAfter: "Unexpected newline after '('."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    var rawOption = context.options[0] || "multiline";
    var multilineOption = rawOption === "multiline";
    var multilineArgumentsOption = rawOption === "multiline-arguments";
    var consistentOption = rawOption === "consistent";
    var minItems;

    if (_typeof(rawOption) === "object") {
      minItems = rawOption.minItems;
    } else if (rawOption === "always") {
      minItems = 0;
    } else if (rawOption === "never") {
      minItems = Infinity;
    } else {
      minItems = null;
    } //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Determines whether there should be newlines inside function parens
     * @param {ASTNode[]} elements The arguments or parameters in the list
     * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.
     * @returns {boolean} `true` if there should be newlines inside the function parens
     */


    function shouldHaveNewlines(elements, hasLeftNewline) {
      if (multilineArgumentsOption && elements.length === 1) {
        return hasLeftNewline;
      }

      if (multilineOption || multilineArgumentsOption) {
        return elements.some(function (element, index) {
          return index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line;
        });
      }

      if (consistentOption) {
        return hasLeftNewline;
      }

      return elements.length >= minItems;
    }
    /**
     * Validates parens
     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
     * @param {ASTNode[]} elements The arguments or parameters in the list
     * @returns {void}
     */


    function validateParens(parens, elements) {
      var leftParen = parens.leftParen;
      var rightParen = parens.rightParen;
      var tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      var tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
      var hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      var hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
      var needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

      if (hasLeftNewline && !needsNewlines) {
        context.report({
          node: leftParen,
          messageId: "unexpectedAfter",
          fix: function fix(fixer) {
            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() // If there is a comment between the ( and the first element, don't do a fix.
            ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
          }
        });
      } else if (!hasLeftNewline && needsNewlines) {
        context.report({
          node: leftParen,
          messageId: "expectedAfter",
          fix: function fix(fixer) {
            return fixer.insertTextAfter(leftParen, "\n");
          }
        });
      }

      if (hasRightNewline && !needsNewlines) {
        context.report({
          node: rightParen,
          messageId: "unexpectedBefore",
          fix: function fix(fixer) {
            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() // If there is a comment between the last element and the ), don't do a fix.
            ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
          }
        });
      } else if (!hasRightNewline && needsNewlines) {
        context.report({
          node: rightParen,
          messageId: "expectedBefore",
          fix: function fix(fixer) {
            return fixer.insertTextBefore(rightParen, "\n");
          }
        });
      }
    }
    /**
     * Validates a list of arguments or parameters
     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
     * @param {ASTNode[]} elements The arguments or parameters in the list
     * @returns {void}
     */


    function validateArguments(parens, elements) {
      var leftParen = parens.leftParen;
      var tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      var hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      var needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

      var _loop = function _loop(i) {
        var currentElement = elements[i];
        var nextElement = elements[i + 1];
        var hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;

        if (!hasNewLine && needsNewlines) {
          context.report({
            node: currentElement,
            messageId: "expectedBetween",
            fix: function fix(fixer) {
              return fixer.insertTextBefore(nextElement, "\n");
            }
          });
        }
      };

      for (var i = 0; i <= elements.length - 2; i++) {
        _loop(i);
      }
    }
    /**
     * Gets the left paren and right paren tokens of a node.
     * @param {ASTNode} node The node with parens
     * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.
     * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression
     * with a single parameter)
     */


    function getParenTokens(node) {
      switch (node.type) {
        case "NewExpression":
          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {
            skip: 1
          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {
            // If the NewExpression does not have parens (e.g. `new Foo`), return null.
            return null;
          }

        // falls through

        case "CallExpression":
          return {
            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
            rightParen: sourceCode.getLastToken(node)
          };

        case "FunctionDeclaration":
        case "FunctionExpression":
          {
            var leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
            var rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);
            return {
              leftParen: leftParen,
              rightParen: rightParen
            };
          }

        case "ArrowFunctionExpression":
          {
            var firstToken = sourceCode.getFirstToken(node);

            if (!astUtils.isOpeningParenToken(firstToken)) {
              // If the ArrowFunctionExpression has a single param without parens, return null.
              return null;
            }

            return {
              leftParen: firstToken,
              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
            };
          }

        case "ImportExpression":
          {
            var _leftParen = sourceCode.getFirstToken(node, 1);

            var _rightParen = sourceCode.getLastToken(node);

            return {
              leftParen: _leftParen,
              rightParen: _rightParen
            };
          }

        default:
          throw new TypeError("unexpected node with type ".concat(node.type));
      }
    } //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------


    return _defineProperty({}, ["ArrowFunctionExpression", "CallExpression", "FunctionDeclaration", "FunctionExpression", "ImportExpression", "NewExpression"], function (node) {
      var parens = getParenTokens(node);
      var params;

      if (node.type === "ImportExpression") {
        params = [node.source];
      } else if (astUtils.isFunction(node)) {
        params = node.params;
      } else {
        params = node.arguments;
      }

      if (parens) {
        validateParens(parens, params);

        if (multilineArgumentsOption) {
          validateArguments(parens, params);
        }
      }
    });
  }
};