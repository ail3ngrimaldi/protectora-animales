/**
 * @fileoverview Rule to disallow Math.pow in favor of the ** operator
 * @author Milos Djermanovic
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var astUtils = require("./utils/ast-utils");

var _require = require("eslint-utils"),
    CALL = _require.CALL,
    ReferenceTracker = _require.ReferenceTracker; //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({
  type: "BinaryExpression",
  operator: "**"
});
/**
 * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.
 * @param {ASTNode} base The node to check.
 * @returns {boolean} `true` if the node needs to be parenthesised.
 */

function doesBaseNeedParens(base) {
  return (// '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c
    astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || // An unary operator cannot be used immediately before an exponentiation expression
    base.type === "UnaryExpression"
  );
}
/**
 * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.
 * @param {ASTNode} exponent The node to check.
 * @returns {boolean} `true` if the node needs to be parenthesised.
 */


function doesExponentNeedParens(exponent) {
  // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c
  return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;
}
/**
 * Determines whether an exponentiation binary expression at the place of the given node would need parens.
 * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.
 * @param {SourceCode} sourceCode A SourceCode object.
 * @returns {boolean} `true` if the expression needs to be parenthesised.
 */


function doesExponentiationExpressionNeedParens(node, sourceCode) {
  var parent = node.parent;
  var needsParens = parent.type === "ClassDeclaration" || parent.type.endsWith("Expression") && astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR && !(parent.type === "BinaryExpression" && parent.operator === "**" && parent.right === node) && !((parent.type === "CallExpression" || parent.type === "NewExpression") && parent.arguments.includes(node)) && !(parent.type === "MemberExpression" && parent.computed && parent.property === node) && !(parent.type === "ArrayExpression");
  return needsParens && !astUtils.isParenthesised(sourceCode, node);
}
/**
 * Optionally parenthesizes given text.
 * @param {string} text The text to parenthesize.
 * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.
 * @returns {string} parenthesised or unchanged text.
 */


function parenthesizeIfShould(text, shouldParenthesize) {
  return shouldParenthesize ? "(".concat(text, ")") : text;
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `Math.pow` in favor of the `**` operator",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-exponentiation-operator"
    },
    schema: [],
    fixable: "code",
    messages: {
      useExponentiation: "Use the '**' operator instead of 'Math.pow'."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    /**
     * Reports the given node.
     * @param {ASTNode} node 'Math.pow()' node to report.
     * @returns {void}
     */

    function report(node) {
      context.report({
        node: node,
        messageId: "useExponentiation",
        fix: function fix(fixer) {
          if (node.arguments.length !== 2 || node.arguments.some(function (arg) {
            return arg.type === "SpreadElement";
          }) || sourceCode.getCommentsInside(node).length > 0) {
            return null;
          }

          var base = node.arguments[0],
              exponent = node.arguments[1],
              baseText = sourceCode.getText(base),
              exponentText = sourceCode.getText(exponent),
              shouldParenthesizeBase = doesBaseNeedParens(base),
              shouldParenthesizeExponent = doesExponentNeedParens(exponent),
              shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);
          var prefix = "",
              suffix = "";

          if (!shouldParenthesizeAll) {
            if (!shouldParenthesizeBase) {
              var firstReplacementToken = sourceCode.getFirstToken(base),
                  tokenBefore = sourceCode.getTokenBefore(node);

              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                prefix = " "; // a+Math.pow(++b, c) -> a+ ++b**c
              }
            }

            if (!shouldParenthesizeExponent) {
              var lastReplacementToken = sourceCode.getLastToken(exponent),
                  tokenAfter = sourceCode.getTokenAfter(node);

              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {
                suffix = " "; // Math.pow(a, b)in c -> a**b in c
              }
            }
          }

          var baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),
              exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),
              replacement = parenthesizeIfShould("".concat(baseReplacement, "**").concat(exponentReplacement), shouldParenthesizeAll);
          return fixer.replaceText(node, "".concat(prefix).concat(replacement).concat(suffix));
        }
      });
    }

    return {
      Program: function Program() {
        var scope = context.getScope();
        var tracker = new ReferenceTracker(scope);
        var trackMap = {
          Math: {
            pow: _defineProperty({}, CALL, true)
          }
        };
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tracker.iterateGlobalReferences(trackMap)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value.node;
            report(node);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    };
  }
};