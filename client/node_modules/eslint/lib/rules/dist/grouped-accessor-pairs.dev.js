/**
 * @fileoverview Rule to require grouped accessor pairs in object literals and classes
 * @author Milos Djermanovic
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * Property name if it can be computed statically, otherwise the list of the tokens of the key node.
 * @typedef {string|Token[]} Key
 */

/**
 * Accessor nodes with the same key.
 * @typedef {Object} AccessorData
 * @property {Key} key Accessor's key
 * @property {ASTNode[]} getters List of getter nodes.
 * @property {ASTNode[]} setters List of setter nodes.
 */
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not the given lists represent the equal tokens in the same order.
 * Tokens are compared by their properties, not by instance.
 * @param {Token[]} left First list of tokens.
 * @param {Token[]} right Second list of tokens.
 * @returns {boolean} `true` if the lists have same tokens.
 */


function areEqualTokenLists(left, right) {
  if (left.length !== right.length) {
    return false;
  }

  for (var i = 0; i < left.length; i++) {
    var leftToken = left[i],
        rightToken = right[i];

    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
      return false;
    }
  }

  return true;
}
/**
 * Checks whether or not the given keys are equal.
 * @param {Key} left First key.
 * @param {Key} right Second key.
 * @returns {boolean} `true` if the keys are equal.
 */


function areEqualKeys(left, right) {
  if (typeof left === "string" && typeof right === "string") {
    // Statically computed names.
    return left === right;
  }

  if (Array.isArray(left) && Array.isArray(right)) {
    // Token lists.
    return areEqualTokenLists(left, right);
  }

  return false;
}
/**
 * Checks whether or not a given node is of an accessor kind ('get' or 'set').
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node is of an accessor kind.
 */


function isAccessorKind(node) {
  return node.kind === "get" || node.kind === "set";
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require grouped accessor pairs in object literals and classes",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/grouped-accessor-pairs"
    },
    schema: [{
      "enum": ["anyOrder", "getBeforeSet", "setBeforeGet"]
    }],
    messages: {
      notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
      invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
    }
  },
  create: function create(context) {
    var order = context.options[0] || "anyOrder";
    var sourceCode = context.getSourceCode();
    /**
     * Reports the given accessor pair.
     * @param {string} messageId messageId to report.
     * @param {ASTNode} formerNode getter/setter node that is defined before `latterNode`.
     * @param {ASTNode} latterNode getter/setter node that is defined after `formerNode`.
     * @returns {void}
     * @private
     */

    function report(messageId, formerNode, latterNode) {
      context.report({
        node: latterNode,
        messageId: messageId,
        loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),
        data: {
          formerName: astUtils.getFunctionNameWithKind(formerNode.value),
          latterName: astUtils.getFunctionNameWithKind(latterNode.value)
        }
      });
    }
    /**
     * Creates a new `AccessorData` object for the given getter or setter node.
     * @param {ASTNode} node A getter or setter node.
     * @returns {AccessorData} New `AccessorData` object that contains the given node.
     * @private
     */


    function createAccessorData(node) {
      var name = astUtils.getStaticPropertyName(node);
      var key = name !== null ? name : sourceCode.getTokens(node.key);
      return {
        key: key,
        getters: node.kind === "get" ? [node] : [],
        setters: node.kind === "set" ? [node] : []
      };
    }
    /**
     * Merges the given `AccessorData` object into the given accessors list.
     * @param {AccessorData[]} accessors The list to merge into.
     * @param {AccessorData} accessorData The object to merge.
     * @returns {AccessorData[]} The same instance with the merged object.
     * @private
     */


    function mergeAccessorData(accessors, accessorData) {
      var equalKeyElement = accessors.find(function (a) {
        return areEqualKeys(a.key, accessorData.key);
      });

      if (equalKeyElement) {
        var _equalKeyElement$gett, _equalKeyElement$sett;

        (_equalKeyElement$gett = equalKeyElement.getters).push.apply(_equalKeyElement$gett, _toConsumableArray(accessorData.getters));

        (_equalKeyElement$sett = equalKeyElement.setters).push.apply(_equalKeyElement$sett, _toConsumableArray(accessorData.setters));
      } else {
        accessors.push(accessorData);
      }

      return accessors;
    }
    /**
     * Checks accessor pairs in the given list of nodes.
     * @param {ASTNode[]} nodes The list to check.
     * @param {Function} shouldCheck â€“ Predicate that returns `true` if the node should be checked.
     * @returns {void}
     * @private
     */


    function checkList(nodes, shouldCheck) {
      var accessors = nodes.filter(shouldCheck).filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = accessors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _step.value,
              getters = _step$value.getters,
              setters = _step$value.setters;

          // Don't report accessor properties that have duplicate getters or setters.
          if (getters.length === 1 && setters.length === 1) {
            var _getters = _slicedToArray(getters, 1),
                getter = _getters[0],
                _setters = _slicedToArray(setters, 1),
                setter = _setters[0],
                getterIndex = nodes.indexOf(getter),
                setterIndex = nodes.indexOf(setter),
                formerNode = getterIndex < setterIndex ? getter : setter,
                latterNode = getterIndex < setterIndex ? setter : getter;

            if (Math.abs(getterIndex - setterIndex) > 1) {
              report("notGrouped", formerNode, latterNode);
            } else if (order === "getBeforeSet" && getterIndex > setterIndex || order === "setBeforeGet" && getterIndex < setterIndex) {
              report("invalidOrder", formerNode, latterNode);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    return {
      ObjectExpression: function ObjectExpression(node) {
        checkList(node.properties, function (n) {
          return n.type === "Property";
        });
      },
      ClassBody: function ClassBody(node) {
        checkList(node.body, function (n) {
          return n.type === "MethodDefinition" && !n["static"];
        });
        checkList(node.body, function (n) {
          return n.type === "MethodDefinition" && n["static"];
        });
      }
    };
  }
};