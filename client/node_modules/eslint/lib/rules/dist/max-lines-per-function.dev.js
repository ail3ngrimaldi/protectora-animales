/**
 * @fileoverview A rule to set the maximum number of line of code in a function.
 * @author Pete Ward <peteward44@gmail.com>
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var astUtils = require("./utils/ast-utils");

var lodash = require("lodash"); //------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------


var OPTIONS_SCHEMA = {
  type: "object",
  properties: {
    max: {
      type: "integer",
      minimum: 0
    },
    skipComments: {
      type: "boolean"
    },
    skipBlankLines: {
      type: "boolean"
    },
    IIFEs: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
var OPTIONS_OR_INTEGER_SCHEMA = {
  oneOf: [OPTIONS_SCHEMA, {
    type: "integer",
    minimum: 1
  }]
};
/**
 * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.
 * @param {Array} comments An array of comment nodes.
 * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.
 */

function getCommentLineNumbers(comments) {
  var map = new Map();

  if (!comments) {
    return map;
  }

  comments.forEach(function (comment) {
    for (var i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
      map.set(i, comment);
    }
  });
  return map;
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of line of code in a function",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-lines-per-function"
    },
    schema: [OPTIONS_OR_INTEGER_SCHEMA],
    messages: {
      exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    var lines = sourceCode.lines;
    var option = context.options[0];
    var maxLines = 50;
    var skipComments = false;
    var skipBlankLines = false;
    var IIFEs = false;

    if (_typeof(option) === "object") {
      maxLines = typeof option.max === "number" ? option.max : 50;
      skipComments = !!option.skipComments;
      skipBlankLines = !!option.skipBlankLines;
      IIFEs = !!option.IIFEs;
    } else if (typeof option === "number") {
      maxLines = option;
    }

    var commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments()); //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Tells if a comment encompasses the entire line.
     * @param {string} line The source line with a trailing comment
     * @param {number} lineNumber The one-indexed line number this is on
     * @param {ASTNode} comment The comment to remove
     * @returns {boolean} If the comment covers the entire line
     */

    function isFullLineComment(line, lineNumber, comment) {
      var start = comment.loc.start,
          end = comment.loc.end,
          isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),
          isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
      return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
    }
    /**
     * Identifies is a node is a FunctionExpression which is part of an IIFE
     * @param {ASTNode} node Node to test
     * @returns {boolean} True if it's an IIFE
     */


    function isIIFE(node) {
      return node.type === "FunctionExpression" && node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
    }
    /**
     * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property
     * @param {ASTNode} node Node to test
     * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property
     */


    function isEmbedded(node) {
      if (!node.parent) {
        return false;
      }

      if (node !== node.parent.value) {
        return false;
      }

      if (node.parent.type === "MethodDefinition") {
        return true;
      }

      if (node.parent.type === "Property") {
        return node.parent.method === true || node.parent.kind === "get" || node.parent.kind === "set";
      }

      return false;
    }
    /**
     * Count the lines in the function
     * @param {ASTNode} funcNode Function AST node
     * @returns {void}
     * @private
     */


    function processFunction(funcNode) {
      var node = isEmbedded(funcNode) ? funcNode.parent : funcNode;

      if (!IIFEs && isIIFE(node)) {
        return;
      }

      var lineCount = 0;

      for (var i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {
        var line = lines[i];

        if (skipComments) {
          if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {
            continue;
          }
        }

        if (skipBlankLines) {
          if (line.match(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/)) {
            continue;
          }
        }

        lineCount++;
      }

      if (lineCount > maxLines) {
        var name = lodash.upperFirst(astUtils.getFunctionNameWithKind(funcNode));
        context.report({
          node: node,
          messageId: "exceed",
          data: {
            name: name,
            lineCount: lineCount,
            maxLines: maxLines
          }
        });
      }
    } //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------


    return {
      FunctionDeclaration: processFunction,
      FunctionExpression: processFunction,
      ArrowFunctionExpression: processFunction
    };
  }
};