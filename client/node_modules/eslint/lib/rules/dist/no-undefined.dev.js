/**
 * @fileoverview Rule to flag references to the undefined variable.
 * @author Michael Ficarra
 */
"use strict"; //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `undefined` as an identifier",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-undefined"
    },
    schema: []
  },
  create: function create(context) {
    /**
     * Report an invalid "undefined" identifier node.
     * @param {ASTNode} node The node to report.
     * @returns {void}
     */
    function report(node) {
      context.report({
        node: node,
        message: "Unexpected use of undefined."
      });
    }
    /**
     * Checks the given scope for references to `undefined` and reports
     * all references found.
     * @param {eslint-scope.Scope} scope The scope to check.
     * @returns {void}
     */


    function checkScope(scope) {
      var undefinedVar = scope.set.get("undefined");

      if (!undefinedVar) {
        return;
      }

      var references = undefinedVar.references;
      var defs = undefinedVar.defs; // Report non-initializing references (those are covered in defs below)

      references.filter(function (ref) {
        return !ref.init;
      }).forEach(function (ref) {
        return report(ref.identifier);
      });
      defs.forEach(function (def) {
        return report(def.name);
      });
    }

    return {
      "Program:exit": function ProgramExit() {
        var globalScope = context.getScope();
        var stack = [globalScope];

        while (stack.length) {
          var scope = stack.pop();
          stack.push.apply(stack, _toConsumableArray(scope.childScopes));
          checkScope(scope);
        }
      }
    };
  }
};