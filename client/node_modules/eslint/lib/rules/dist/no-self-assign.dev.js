/**
 * @fileoverview Rule to disallow assignments where both sides are exactly the same
 * @author Toru Nagashima
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------


var SPACES = /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/g;
/**
 * Checks whether the property of 2 given member expression nodes are the same
 * property or not.
 * @param {ASTNode} left A member expression node to check.
 * @param {ASTNode} right Another member expression node to check.
 * @returns {boolean} `true` if the member expressions have the same property.
 */

function isSameProperty(left, right) {
  if (left.property.type === "Identifier" && left.property.type === right.property.type && left.property.name === right.property.name && left.computed === right.computed) {
    return true;
  }

  var lname = astUtils.getStaticPropertyName(left);
  var rname = astUtils.getStaticPropertyName(right);
  return lname !== null && lname === rname;
}
/**
 * Checks whether 2 given member expression nodes are the reference to the same
 * property or not.
 * @param {ASTNode} left A member expression node to check.
 * @param {ASTNode} right Another member expression node to check.
 * @returns {boolean} `true` if the member expressions are the reference to the
 *  same property or not.
 */


function isSameMember(left, right) {
  if (!isSameProperty(left, right)) {
    return false;
  }

  var lobj = left.object;
  var robj = right.object;

  if (lobj.type !== robj.type) {
    return false;
  }

  if (lobj.type === "MemberExpression") {
    return isSameMember(lobj, robj);
  }

  if (lobj.type === "ThisExpression") {
    return true;
  }

  return lobj.type === "Identifier" && lobj.name === robj.name;
}
/**
 * Traverses 2 Pattern nodes in parallel, then reports self-assignments.
 * @param {ASTNode|null} left A left node to traverse. This is a Pattern or
 *      a Property.
 * @param {ASTNode|null} right A right node to traverse. This is a Pattern or
 *      a Property.
 * @param {boolean} props The flag to check member expressions as well.
 * @param {Function} report A callback function to report.
 * @returns {void}
 */


function eachSelfAssignment(left, right, props, report) {
  if (!left || !right) {// do nothing
  } else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
    report(right);
  } else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
    var end = Math.min(left.elements.length, right.elements.length);

    for (var i = 0; i < end; ++i) {
      var leftElement = left.elements[i];
      var rightElement = right.elements[i]; // Avoid cases such as [...a] = [...a, 1]

      if (leftElement && leftElement.type === "RestElement" && i < right.elements.length - 1) {
        break;
      }

      eachSelfAssignment(leftElement, rightElement, props, report); // After a spread element, those indices are unknown.

      if (rightElement && rightElement.type === "SpreadElement") {
        break;
      }
    }
  } else if (left.type === "RestElement" && right.type === "SpreadElement") {
    eachSelfAssignment(left.argument, right.argument, props, report);
  } else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
    /*
     * Gets the index of the last spread property.
     * It's possible to overwrite properties followed by it.
     */
    var startJ = 0;

    for (var _i = right.properties.length - 1; _i >= 0; --_i) {
      var propType = right.properties[_i].type;

      if (propType === "SpreadElement" || propType === "ExperimentalSpreadProperty") {
        startJ = _i + 1;
        break;
      }
    }

    for (var _i2 = 0; _i2 < left.properties.length; ++_i2) {
      for (var j = startJ; j < right.properties.length; ++j) {
        eachSelfAssignment(left.properties[_i2], right.properties[j], props, report);
      }
    }
  } else if (left.type === "Property" && right.type === "Property" && right.kind === "init" && !right.method) {
    var leftName = astUtils.getStaticPropertyName(left);

    if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {
      eachSelfAssignment(left.value, right.value, props, report);
    }
  } else if (props && left.type === "MemberExpression" && right.type === "MemberExpression" && isSameMember(left, right)) {
    report(right);
  }
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments where both sides are exactly the same",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-self-assign"
    },
    schema: [{
      type: "object",
      properties: {
        props: {
          type: "boolean",
          "default": true
        }
      },
      additionalProperties: false
    }]
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();

    var _context$options = _slicedToArray(context.options, 1),
        _context$options$ = _context$options[0];

    _context$options$ = _context$options$ === void 0 ? {} : _context$options$;
    var _context$options$$pro = _context$options$.props,
        props = _context$options$$pro === void 0 ? true : _context$options$$pro;
    /**
     * Reports a given node as self assignments.
     * @param {ASTNode} node A node to report. This is an Identifier node.
     * @returns {void}
     */

    function report(node) {
      context.report({
        node: node,
        message: "'{{name}}' is assigned to itself.",
        data: {
          name: sourceCode.getText(node).replace(SPACES, "")
        }
      });
    }

    return {
      AssignmentExpression: function AssignmentExpression(node) {
        if (node.operator === "=") {
          eachSelfAssignment(node.left, node.right, props, report);
        }
      }
    };
  }
};