/**
 * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed
 * @author Jonathan Kingston
 * @author Christophe Porteneuve
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------


var ALL_IRREGULARS = /[\x0B\f\x85\xA0\u1680\u180E\u2000-\u200B\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
var IRREGULAR_WHITESPACE = /[\x0B\f\x85\xA0\u1680\u180E\u2000-\u200B\u202F\u205F\u3000\uFEFF]+/mg;
var IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mg;
var LINE_BREAK = astUtils.createGlobalLinebreakMatcher(); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow irregular whitespace",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-irregular-whitespace"
    },
    schema: [{
      type: "object",
      properties: {
        skipComments: {
          type: "boolean",
          "default": false
        },
        skipStrings: {
          type: "boolean",
          "default": true
        },
        skipTemplates: {
          type: "boolean",
          "default": false
        },
        skipRegExps: {
          type: "boolean",
          "default": false
        }
      },
      additionalProperties: false
    }]
  },
  create: function create(context) {
    // Module store of errors that we have found
    var errors = []; // Lookup the `skipComments` option, which defaults to `false`.

    var options = context.options[0] || {};
    var skipComments = !!options.skipComments;
    var skipStrings = options.skipStrings !== false;
    var skipRegExps = !!options.skipRegExps;
    var skipTemplates = !!options.skipTemplates;
    var sourceCode = context.getSourceCode();
    var commentNodes = sourceCode.getAllComments();
    /**
     * Removes errors that occur inside a string node
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */

    function removeWhitespaceError(node) {
      var locStart = node.loc.start;
      var locEnd = node.loc.end;
      errors = errors.filter(function (_ref) {
        var errorLoc = _ref.loc;

        if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
          if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
            return false;
          }
        }

        return true;
      });
    }
    /**
     * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */


    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
      var shouldCheckStrings = skipStrings && typeof node.value === "string";
      var shouldCheckRegExps = skipRegExps && Boolean(node.regex);

      if (shouldCheckStrings || shouldCheckRegExps) {
        // If we have irregular characters remove them from the errors list
        if (ALL_IRREGULARS.test(node.raw)) {
          removeWhitespaceError(node);
        }
      }
    }
    /**
     * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */


    function removeInvalidNodeErrorsInTemplateLiteral(node) {
      if (typeof node.value.raw === "string") {
        if (ALL_IRREGULARS.test(node.value.raw)) {
          removeWhitespaceError(node);
        }
      }
    }
    /**
     * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */


    function removeInvalidNodeErrorsInComment(node) {
      if (ALL_IRREGULARS.test(node.value)) {
        removeWhitespaceError(node);
      }
    }
    /**
     * Checks the program source for irregular whitespace
     * @param {ASTNode} node The program node
     * @returns {void}
     * @private
     */


    function checkForIrregularWhitespace(node) {
      var sourceLines = sourceCode.lines;
      sourceLines.forEach(function (sourceLine, lineIndex) {
        var lineNumber = lineIndex + 1;
        var match;

        while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
          var location = {
            line: lineNumber,
            column: match.index
          };
          errors.push({
            node: node,
            message: "Irregular whitespace not allowed.",
            loc: location
          });
        }
      });
    }
    /**
     * Checks the program source for irregular line terminators
     * @param {ASTNode} node The program node
     * @returns {void}
     * @private
     */


    function checkForIrregularLineTerminators(node) {
      var source = sourceCode.getText(),
          sourceLines = sourceCode.lines,
          linebreaks = source.match(LINE_BREAK);
      var lastLineIndex = -1,
          match;

      while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
        var lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
        var location = {
          line: lineIndex + 1,
          column: sourceLines[lineIndex].length
        };
        errors.push({
          node: node,
          message: "Irregular whitespace not allowed.",
          loc: location
        });
        lastLineIndex = lineIndex;
      }
    }
    /**
     * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.
     * @returns {void}
     * @private
     */


    function noop() {}

    var nodes = {};

    if (ALL_IRREGULARS.test(sourceCode.getText())) {
      nodes.Program = function (node) {
        /*
         * As we can easily fire warnings for all white space issues with
         * all the source its simpler to fire them here.
         * This means we can check all the application code without having
         * to worry about issues caused in the parser tokens.
         * When writing this code also evaluating per node was missing out
         * connecting tokens in some cases.
         * We can later filter the errors when they are found to be not an
         * issue in nodes we don't care about.
         */
        checkForIrregularWhitespace(node);
        checkForIrregularLineTerminators(node);
      };

      nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
      nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
      nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;

      nodes["Program:exit"] = function () {
        if (skipComments) {
          // First strip errors occurring in comment nodes.
          commentNodes.forEach(removeInvalidNodeErrorsInComment);
        } // If we have any errors remaining report on them


        errors.forEach(function (error) {
          return context.report(error);
        });
      };
    } else {
      nodes.Program = noop;
    }

    return nodes;
  }
};