/**
 * @fileoverview Prefers object spread property over Object.assign
 * @author Sharmila Jesupaul
 * See LICENSE file in root directory for full license.
 */
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require("eslint-utils"),
    CALL = _require.CALL,
    ReferenceTracker = _require.ReferenceTracker;

var _require2 = require("./utils/ast-utils"),
    isCommaToken = _require2.isCommaToken,
    isOpeningParenToken = _require2.isOpeningParenToken,
    isClosingParenToken = _require2.isClosingParenToken,
    isParenthesised = _require2.isParenthesised;

var ANY_SPACE = /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
/**
 * Helper that checks if the Object.assign call has array spread
 * @param {ASTNode} node The node that the rule warns on
 * @returns {boolean} - Returns true if the Object.assign call has array spread
 */

function hasArraySpread(node) {
  return node.arguments.some(function (arg) {
    return arg.type === "SpreadElement";
  });
}
/**
 * Helper that checks if the node needs parentheses to be valid JS.
 * The default is to wrap the node in parentheses to avoid parsing errors.
 * @param {ASTNode} node The node that the rule warns on
 * @param {Object} sourceCode in context sourcecode object
 * @returns {boolean} - Returns true if the node needs parentheses
 */


function needsParens(node, sourceCode) {
  var parent = node.parent;

  switch (parent.type) {
    case "VariableDeclarator":
    case "ArrayExpression":
    case "ReturnStatement":
    case "CallExpression":
    case "Property":
      return false;

    case "AssignmentExpression":
      return parent.left === node && !isParenthesised(sourceCode, node);

    default:
      return !isParenthesised(sourceCode, node);
  }
}
/**
 * Determines if an argument needs parentheses. The default is to not add parens.
 * @param {ASTNode} node The node to be checked.
 * @param {Object} sourceCode in context sourcecode object
 * @returns {boolean} True if the node needs parentheses
 */


function argNeedsParens(node, sourceCode) {
  switch (node.type) {
    case "AssignmentExpression":
    case "ArrowFunctionExpression":
    case "ConditionalExpression":
      return !isParenthesised(sourceCode, node);

    default:
      return false;
  }
}
/**
 * Get the parenthesis tokens of a given ObjectExpression node.
 * This incldues the braces of the object literal and enclosing parentheses.
 * @param {ASTNode} node The node to get.
 * @param {Token} leftArgumentListParen The opening paren token of the argument list.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.
 */


function getParenTokens(node, leftArgumentListParen, sourceCode) {
  var parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];
  var leftNext = sourceCode.getTokenBefore(node);
  var rightNext = sourceCode.getTokenAfter(node); // Note: don't include the parens of the argument list.

  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {
    parens.push(leftNext, rightNext);
    leftNext = sourceCode.getTokenBefore(leftNext);
    rightNext = sourceCode.getTokenAfter(rightNext);
  }

  return parens.sort(function (a, b) {
    return a.range[0] - b.range[0];
  });
}
/**
 * Get the range of a given token and around whitespaces.
 * @param {Token} token The token to get range.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {number} The end of the range of the token and around whitespaces.
 */


function getStartWithSpaces(token, sourceCode) {
  var text = sourceCode.text;
  var start = token.range[0]; // If the previous token is a line comment then skip this step to avoid commenting this token out.

  {
    var prevToken = sourceCode.getTokenBefore(token, {
      includeComments: true
    });

    if (prevToken && prevToken.type === "Line") {
      return start;
    }
  } // Detect spaces before the token.

  while (ANY_SPACE.test(text[start - 1] || "")) {
    start -= 1;
  }

  return start;
}
/**
 * Get the range of a given token and around whitespaces.
 * @param {Token} token The token to get range.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {number} The start of the range of the token and around whitespaces.
 */


function getEndWithSpaces(token, sourceCode) {
  var text = sourceCode.text;
  var end = token.range[1]; // Detect spaces after the token.

  while (ANY_SPACE.test(text[end] || "")) {
    end += 1;
  }

  return end;
}
/**
 * Autofixes the Object.assign call to use an object spread instead.
 * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call
 * @param {string} sourceCode sourceCode of the Object.assign call
 * @returns {Function} autofixer - replaces the Object.assign with a spread object.
 */


function defineFixer(node, sourceCode) {
  return (
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(fixer) {
      var leftParen, rightParen, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, argNode, innerParens, left, right, maybeTrailingComma, maybeArgumentComma, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, innerParen, leftRange, rightRange;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);
              rightParen = sourceCode.getLastToken(node); // Remove the callee `Object.assign`

              _context.next = 4;
              return fixer.remove(node.callee);

            case 4:
              if (!needsParens(node, sourceCode)) {
                _context.next = 11;
                break;
              }

              _context.next = 7;
              return fixer.replaceText(leftParen, "({");

            case 7:
              _context.next = 9;
              return fixer.replaceText(rightParen, "})");

            case 9:
              _context.next = 15;
              break;

            case 11:
              _context.next = 13;
              return fixer.replaceText(leftParen, "{");

            case 13:
              _context.next = 15;
              return fixer.replaceText(rightParen, "}");

            case 15:
              // Process arguments.
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 18;
              _iterator = node.arguments[Symbol.iterator]();

            case 20:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 77;
                break;
              }

              argNode = _step.value;
              innerParens = getParenTokens(argNode, leftParen, sourceCode);
              left = innerParens.shift();
              right = innerParens.pop();

              if (!(argNode.type === "ObjectExpression")) {
                _context.next = 65;
                break;
              }

              maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
              maybeArgumentComma = sourceCode.getTokenAfter(right);
              /*
               * Make bare this object literal.
               * And remove spaces inside of the braces for better formatting.
               */

              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 31;
              _iterator2 = innerParens[Symbol.iterator]();

            case 33:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 40;
                break;
              }

              innerParen = _step2.value;
              _context.next = 37;
              return fixer.remove(innerParen);

            case 37:
              _iteratorNormalCompletion2 = true;
              _context.next = 33;
              break;

            case 40:
              _context.next = 46;
              break;

            case 42:
              _context.prev = 42;
              _context.t0 = _context["catch"](31);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t0;

            case 46:
              _context.prev = 46;
              _context.prev = 47;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 49:
              _context.prev = 49;

              if (!_didIteratorError2) {
                _context.next = 52;
                break;
              }

              throw _iteratorError2;

            case 52:
              return _context.finish(49);

            case 53:
              return _context.finish(46);

            case 54:
              leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];
              rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap
              right.range[1]];
              _context.next = 58;
              return fixer.removeRange(leftRange);

            case 58:
              _context.next = 60;
              return fixer.removeRange(rightRange);

            case 60:
              if (!((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma))) {
                _context.next = 63;
                break;
              }

              _context.next = 63;
              return fixer.remove(maybeArgumentComma);

            case 63:
              _context.next = 74;
              break;

            case 65:
              if (!argNeedsParens(argNode, sourceCode)) {
                _context.next = 72;
                break;
              }

              _context.next = 68;
              return fixer.insertTextBefore(left, "...(");

            case 68:
              _context.next = 70;
              return fixer.insertTextAfter(right, ")");

            case 70:
              _context.next = 74;
              break;

            case 72:
              _context.next = 74;
              return fixer.insertTextBefore(left, "...");

            case 74:
              _iteratorNormalCompletion = true;
              _context.next = 20;
              break;

            case 77:
              _context.next = 83;
              break;

            case 79:
              _context.prev = 79;
              _context.t1 = _context["catch"](18);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 83:
              _context.prev = 83;
              _context.prev = 84;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 86:
              _context.prev = 86;

              if (!_didIteratorError) {
                _context.next = 89;
                break;
              }

              throw _iteratorError;

            case 89:
              return _context.finish(86);

            case 90:
              return _context.finish(83);

            case 91:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[18, 79, 83, 91], [31, 42, 46, 54], [47,, 49, 53], [84,, 86, 90]]);
    })
  );
}

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-object-spread"
    },
    schema: [],
    fixable: "code",
    messages: {
      useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
      useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    return {
      Program: function Program() {
        var scope = context.getScope();
        var tracker = new ReferenceTracker(scope);
        var trackMap = {
          Object: {
            assign: _defineProperty({}, CALL, true)
          }
        }; // Iterate all calls of `Object.assign` (only of the global variable `Object`).

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = tracker.iterateGlobalReferences(trackMap)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var node = _step3.value.node;

            if (node.arguments.length >= 1 && node.arguments[0].type === "ObjectExpression" && !hasArraySpread(node)) {
              var messageId = node.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage";
              var fix = defineFixer(node, sourceCode);
              context.report({
                node: node,
                messageId: messageId,
                fix: fix
              });
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    };
  }
};