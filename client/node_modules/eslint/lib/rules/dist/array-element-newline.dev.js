/**
 * @fileoverview Rule to enforce line breaks after each array element
 * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>
 */
"use strict";

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce line breaks after each array element",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-element-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        "enum": ["always", "never", "consistent"]
      }, {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minItems: {
            type: ["integer", "null"],
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedLineBreak: "There should be no linebreak here.",
      missingLineBreak: "There should be a linebreak after this element."
    }
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode(); //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Normalizes a given option value.
     * @param {string|Object|undefined} providedOption An option value to parse.
     * @returns {{multiline: boolean, minItems: number}} Normalized option object.
     */

    function normalizeOptionValue(providedOption) {
      var consistent = false;
      var multiline = false;
      var minItems;
      var option = providedOption || "always";

      if (!option || option === "always" || option.minItems === 0) {
        minItems = 0;
      } else if (option === "never") {
        minItems = Number.POSITIVE_INFINITY;
      } else if (option === "consistent") {
        consistent = true;
        minItems = Number.POSITIVE_INFINITY;
      } else {
        multiline = Boolean(option.multiline);
        minItems = option.minItems || Number.POSITIVE_INFINITY;
      }

      return {
        consistent: consistent,
        multiline: multiline,
        minItems: minItems
      };
    }
    /**
     * Normalizes a given option value.
     * @param {string|Object|undefined} options An option value to parse.
     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
     */


    function normalizeOptions(options) {
      var value = normalizeOptionValue(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }
    /**
     * Reports that there shouldn't be a line break after the first token
     * @param {Token} token The token to use for the report.
     * @returns {void}
     */


    function reportNoLineBreak(token) {
      var tokenBefore = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedLineBreak",
        fix: function fix(fixer) {
          if (astUtils.isCommentToken(tokenBefore)) {
            return null;
          }

          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
          }
          /*
           * This will check if the comma is on the same line as the next element
           * Following array:
           * [
           *     1
           *     , 2
           *     , 3
           * ]
           *
           * will be fixed to:
           * [
           *     1, 2, 3
           * ]
           */


          var twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {
            includeComments: true
          });

          if (astUtils.isCommentToken(twoTokensBefore)) {
            return null;
          }

          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
        }
      });
    }
    /**
     * Reports that there should be a line break after the first token
     * @param {Token} token The token to use for the report.
     * @returns {void}
     */


    function reportRequiredLineBreak(token) {
      var tokenBefore = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "missingLineBreak",
        fix: function fix(fixer) {
          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
        }
      });
    }
    /**
     * Reports a given node if it violated this rule.
     * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.
     * @returns {void}
     */


    function check(node) {
      var elements = node.elements;
      var normalizedOptions = normalizeOptions(context.options[0]);
      var options = normalizedOptions[node.type];
      var elementBreak = false;
      /*
       * MULTILINE: true
       * loop through every element and check
       * if at least one element has linebreaks inside
       * this ensures that following is not valid (due to elements are on the same line):
       *
       * [
       *      1,
       *      2,
       *      3
       * ]
       */

      if (options.multiline) {
        elementBreak = elements.filter(function (element) {
          return element !== null;
        }).some(function (element) {
          return element.loc.start.line !== element.loc.end.line;
        });
      }

      var linebreaksCount = node.elements.map(function (element, i) {
        var previousElement = elements[i - 1];

        if (i === 0 || element === null || previousElement === null) {
          return false;
        }

        var commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
        var lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        var firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);
      }).filter(function (isBreak) {
        return isBreak === true;
      }).length;
      var needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;
      elements.forEach(function (element, i) {
        var previousElement = elements[i - 1];

        if (i === 0 || element === null || previousElement === null) {
          return;
        }

        var commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
        var lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        var firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);

        if (needsLinebreaks) {
          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            reportRequiredLineBreak(firstTokenOfCurrentElement);
          }
        } else {
          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            reportNoLineBreak(firstTokenOfCurrentElement);
          }
        }
      });
    } //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------


    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }
};