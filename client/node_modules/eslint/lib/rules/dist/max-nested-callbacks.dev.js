/**
 * @fileoverview Rule to enforce a maximum number of nested callbacks.
 * @author Ian Christian Myers
 */
"use strict"; //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that callbacks can be nested",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-nested-callbacks"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
    }
  },
  create: function create(context) {
    //--------------------------------------------------------------------------
    // Constants
    //--------------------------------------------------------------------------
    var option = context.options[0];
    var THRESHOLD = 10;

    if (_typeof(option) === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      THRESHOLD = option.maximum || option.max;
    } else if (typeof option === "number") {
      THRESHOLD = option;
    } //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------


    var callbackStack = [];
    /**
     * Checks a given function node for too many callbacks.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */

    function checkFunction(node) {
      var parent = node.parent;

      if (parent.type === "CallExpression") {
        callbackStack.push(node);
      }

      if (callbackStack.length > THRESHOLD) {
        var opts = {
          num: callbackStack.length,
          max: THRESHOLD
        };
        context.report({
          node: node,
          messageId: "exceed",
          data: opts
        });
      }
    }
    /**
     * Pops the call stack.
     * @returns {void}
     * @private
     */


    function popStack() {
      callbackStack.pop();
    } //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------


    return {
      ArrowFunctionExpression: checkFunction,
      "ArrowFunctionExpression:exit": popStack,
      FunctionExpression: checkFunction,
      "FunctionExpression:exit": popStack
    };
  }
};