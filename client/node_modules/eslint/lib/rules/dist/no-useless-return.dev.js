/**
 * @fileoverview Disallow redundant return statements
 * @author Teddy Katz
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var astUtils = require("./utils/ast-utils"),
    FixTracker = require("./utils/fix-tracker"); //------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Removes the given element from the array.
 * @param {Array} array The source array to remove.
 * @param {any} element The target item to remove.
 * @returns {void}
 */


function remove(array, element) {
  var index = array.indexOf(element);

  if (index !== -1) {
    array.splice(index, 1);
  }
}
/**
 * Checks whether it can remove the given return statement or not.
 * @param {ASTNode} node The return statement node to check.
 * @returns {boolean} `true` if the node is removeable.
 */


function isRemovable(node) {
  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}
/**
 * Checks whether the given return statement is in a `finally` block or not.
 * @param {ASTNode} node The return statement node to check.
 * @returns {boolean} `true` if the node is in a `finally` block.
 */


function isInFinally(node) {
  for (var currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {
    if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
      return true;
    }
  }

  return false;
} //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow redundant return statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-return"
    },
    fixable: "code",
    schema: []
  },
  create: function create(context) {
    var segmentInfoMap = new WeakMap();
    var usedUnreachableSegments = new WeakSet();
    var sourceCode = context.getSourceCode();
    var scopeInfo = null;
    /**
     * Checks whether the given segment is terminated by a return statement or not.
     * @param {CodePathSegment} segment The segment to check.
     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.
     */

    function isReturned(segment) {
      var info = segmentInfoMap.get(segment);
      return !info || info.returned;
    }
    /**
     * Collects useless return statements from the given previous segments.
     *
     * A previous segment may be an unreachable segment.
     * In that case, the information object of the unreachable segment is not
     * initialized because `onCodePathSegmentStart` event is not notified for
     * unreachable segments.
     * This goes to the previous segments of the unreachable segment recursively
     * if the unreachable segment was generated by a return statement. Otherwise,
     * this ignores the unreachable segment.
     *
     * This behavior would simulate code paths for the case that the return
     * statement does not exist.
     * @param {ASTNode[]} uselessReturns The collected return statements.
     * @param {CodePathSegment[]} prevSegments The previous segments to traverse.
     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call
     * @returns {ASTNode[]} `uselessReturns`.
     */


    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {
      var traversedSegments = providedTraversedSegments || new WeakSet();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = prevSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var segment = _step.value;

          if (!segment.reachable) {
            if (!traversedSegments.has(segment)) {
              traversedSegments.add(segment);
              getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
            }

            continue;
          }

          uselessReturns.push.apply(uselessReturns, _toConsumableArray(segmentInfoMap.get(segment).uselessReturns));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return uselessReturns;
    }
    /**
     * Removes the return statements on the given segment from the useless return
     * statement list.
     *
     * This segment may be an unreachable segment.
     * In that case, the information object of the unreachable segment is not
     * initialized because `onCodePathSegmentStart` event is not notified for
     * unreachable segments.
     * This goes to the previous segments of the unreachable segment recursively
     * if the unreachable segment was generated by a return statement. Otherwise,
     * this ignores the unreachable segment.
     *
     * This behavior would simulate code paths for the case that the return
     * statement does not exist.
     * @param {CodePathSegment} segment The segment to get return statements.
     * @returns {void}
     */


    function markReturnStatementsOnSegmentAsUsed(segment) {
      if (!segment.reachable) {
        usedUnreachableSegments.add(segment);
        segment.allPrevSegments.filter(isReturned).filter(function (prevSegment) {
          return !usedUnreachableSegments.has(prevSegment);
        }).forEach(markReturnStatementsOnSegmentAsUsed);
        return;
      }

      var info = segmentInfoMap.get(segment);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = info.uselessReturns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var node = _step2.value;
          remove(scopeInfo.uselessReturns, node);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      info.uselessReturns = [];
    }
    /**
     * Removes the return statements on the current segments from the useless
     * return statement list.
     *
     * This function will be called at every statement except FunctionDeclaration,
     * BlockStatement, and BreakStatement.
     *
     * - FunctionDeclarations are always executed whether it's returned or not.
     * - BlockStatements do nothing.
     * - BreakStatements go the next merely.
     * @returns {void}
     */


    function markReturnStatementsOnCurrentSegmentsAsUsed() {
      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
    } //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------


    return {
      // Makes and pushs a new scope information.
      onCodePathStart: function onCodePathStart(codePath) {
        scopeInfo = {
          upper: scopeInfo,
          uselessReturns: [],
          codePath: codePath
        };
      },
      // Reports useless return statements if exist.
      onCodePathEnd: function onCodePathEnd() {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          var _loop = function _loop() {
            var node = _step3.value;
            context.report({
              node: node,
              loc: node.loc,
              message: "Unnecessary return statement.",
              fix: function fix(fixer) {
                if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {
                  /*
                   * Extend the replacement range to include the
                   * entire function to avoid conflicting with
                   * no-else-return.
                   * https://github.com/eslint/eslint/issues/8026
                   */
                  return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);
                }

                return null;
              }
            });
          };

          for (var _iterator3 = scopeInfo.uselessReturns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            _loop();
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        scopeInfo = scopeInfo.upper;
      },

      /*
       * Initializes segments.
       * NOTE: This event is notified for only reachable segments.
       */
      onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
        var info = {
          uselessReturns: getUselessReturns([], segment.allPrevSegments),
          returned: false
        }; // Stores the info.

        segmentInfoMap.set(segment, info);
      },
      // Adds ReturnStatement node to check whether it's useless or not.
      ReturnStatement: function ReturnStatement(node) {
        if (node.argument) {
          markReturnStatementsOnCurrentSegmentsAsUsed();
        }

        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
        !scopeInfo.codePath.currentSegments.some(function (s) {
          return s.reachable;
        })) {
          return;
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = scopeInfo.codePath.currentSegments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var segment = _step4.value;
            var info = segmentInfoMap.get(segment);

            if (info) {
              info.uselessReturns.push(node);
              info.returned = true;
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        scopeInfo.uselessReturns.push(node);
      },

      /*
       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
       * Removes return statements of the current segments from the useless return statement list.
       */
      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
    };
  }
};