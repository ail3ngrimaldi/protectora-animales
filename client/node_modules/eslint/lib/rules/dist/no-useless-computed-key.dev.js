/**
 * @fileoverview Rule to disallow unnecessary computed property keys in object literals
 * @author Burak Yigit Kaya
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var lodash = require("lodash");

var astUtils = require("./utils/ast-utils"); //------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------


var MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [{{property}}] found.";
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary computed property keys in objects and classes",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-computed-key"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForClassMembers: {
          type: "boolean",
          "default": false
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create: function create(context) {
    var sourceCode = context.getSourceCode();
    var enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;
    /**
     * Reports a given node if it violated this rule.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     */

    function check(node) {
      if (!node.computed) {
        return;
      }

      var key = node.key,
          nodeType = _typeof(key.value);

      var allowedKey;

      if (node.type === "MethodDefinition") {
        allowedKey = node["static"] ? "prototype" : "constructor";
      } else {
        allowedKey = "__proto__";
      }

      if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== allowedKey) {
        context.report({
          node: node,
          message: MESSAGE_UNNECESSARY_COMPUTED,
          data: {
            property: sourceCode.getText(key)
          },
          fix: function fix(fixer) {
            var leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);
            var rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);
            var tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);

            if (tokensBetween.slice(0, -1).some(function (token, index) {
              return sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim();
            })) {
              // If there are comments between the brackets and the property name, don't do a fix.
              return null;
            }

            var tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket); // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })

            var needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));
            var replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
          }
        });
      }
    }

    return {
      Property: check,
      MethodDefinition: enforceForClassMembers ? check : lodash.noop
    };
  }
};