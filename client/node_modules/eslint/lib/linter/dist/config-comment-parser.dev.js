/**
 * @fileoverview Config Comment Parser
 * @author Nicholas C. Zakas
 */

/* eslint-disable class-methods-use-this*/
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var levn = require("levn"),
    ConfigOps = require("../shared/config-ops");

var debug = require("debug")("eslint:config-comment-parser"); //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object to parse ESLint configuration comments inside JavaScript files.
 * @name ConfigCommentParser
 */


module.exports =
/*#__PURE__*/
function () {
  function ConfigCommentParser() {
    _classCallCheck(this, ConfigCommentParser);
  }

  _createClass(ConfigCommentParser, [{
    key: "parseStringConfig",

    /**
     * Parses a list of "name:string_value" or/and "name" options divided by comma or
     * whitespace. Used for "global" and "exported" comments.
     * @param {string} string The string to parse.
     * @param {Comment} comment The comment node which has the string.
     * @returns {Object} Result map object of names and string values, or null values if no value was provided
     */
    value: function parseStringConfig(string, comment) {
      debug("Parsing String config");
      var items = {}; // Collapse whitespace around `:` and `,` to make parsing easier

      var trimmedString = string.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*([,:])[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*/g, "$1");
      trimmedString.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]|,+/).forEach(function (name) {
        if (!name) {
          return;
        } // value defaults to null (if not provided), e.g: "foo" => ["foo", null]


        var _name$split = name.split(":"),
            _name$split2 = _slicedToArray(_name$split, 2),
            key = _name$split2[0],
            _name$split2$ = _name$split2[1],
            value = _name$split2$ === void 0 ? null : _name$split2$;

        items[key] = {
          value: value,
          comment: comment
        };
      });
      return items;
    }
    /**
     * Parses a JSON-like config.
     * @param {string} string The string to parse.
     * @param {Object} location Start line and column of comments for potential error message.
     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object
     */

  }, {
    key: "parseJsonConfig",
    value: function parseJsonConfig(string, location) {
      debug("Parsing JSON config");
      var items = {}; // Parses a JSON-like comment by the same way as parsing CLI option.

      try {
        items = levn.parse("Object", string) || {}; // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.
        // Also, commaless notations have invalid severity:
        //     "no-alert: 2 no-console: 2" --> {"no-alert": "2 no-console: 2"}
        // Should ignore that case as well.

        if (ConfigOps.isEverySeverityValid(items)) {
          return {
            success: true,
            config: items
          };
        }
      } catch (ex) {
        debug("Levn parsing failed; falling back to manual parsing."); // ignore to parse the string by a fallback.
      }
      /*
       * Optionator cannot parse commaless notations.
       * But we are supporting that. So this is a fallback for that.
       */


      items = {};
      var normalizedString = string.replace(/([\x2D\/-9A-Za-z]+):/g, "\"$1\":").replace(/(\]|[0-9])[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+(?=")/, "$1,");

      try {
        items = JSON.parse("{".concat(normalizedString, "}"));
      } catch (ex) {
        debug("Manual parsing failed.");
        return {
          success: false,
          error: {
            ruleId: null,
            fatal: true,
            severity: 2,
            message: "Failed to parse JSON from '".concat(normalizedString, "': ").concat(ex.message),
            line: location.start.line,
            column: location.start.column + 1
          }
        };
      }

      return {
        success: true,
        config: items
      };
    }
    /**
     * Parses a config of values separated by comma.
     * @param {string} string The string to parse.
     * @returns {Object} Result map of values and true values
     */

  }, {
    key: "parseListConfig",
    value: function parseListConfig(string) {
      debug("Parsing list config");
      var items = {}; // Collapse whitespace around commas

      string.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*,[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*/g, ",").split(/,+/).forEach(function (name) {
        var trimmedName = name.trim();

        if (trimmedName) {
          items[trimmedName] = true;
        }
      });
      return items;
    }
  }]);

  return ConfigCommentParser;
}();