/**
 * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects
 * @author Teddy Katz
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var assert = require("assert");

var ruleFixer = require("./rule-fixer");

var interpolate = require("./interpolate"); //------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * An error message description
 * @typedef {Object} MessageDescriptor
 * @property {ASTNode} [node] The reported node
 * @property {Location} loc The location of the problem.
 * @property {string} message The problem message.
 * @property {Object} [data] Optional data to use to fill in placeholders in the
 *      message.
 * @property {Function} [fix] The function to call that creates a fix command.
 * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.
 */

/**
 * Information about the report
 * @typedef {Object} ReportInfo
 * @property {string} ruleId
 * @property {(0|1|2)} severity
 * @property {(string|undefined)} message
 * @property {(string|undefined)} [messageId]
 * @property {number} line
 * @property {number} column
 * @property {(number|undefined)} [endLine]
 * @property {(number|undefined)} [endColumn]
 * @property {(string|null)} nodeType
 * @property {string} source
 * @property {({text: string, range: (number[]|null)}|null)} [fix]
 * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions]
 */
//------------------------------------------------------------------------------
// Module Definition
//------------------------------------------------------------------------------

/**
 * Translates a multi-argument context.report() call into a single object argument call
 * @param {...*} args A list of arguments passed to `context.report`
 * @returns {MessageDescriptor} A normalized object containing report information
 */


function normalizeMultiArgReportCall() {
  // If there is one argument, it is considered to be a new-style call already.
  if (arguments.length === 1) {
    // Shallow clone the object to avoid surprises if reusing the descriptor
    return Object.assign({}, arguments.length <= 0 ? undefined : arguments[0]);
  } // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].


  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === "string") {
    return {
      node: arguments.length <= 0 ? undefined : arguments[0],
      message: arguments.length <= 1 ? undefined : arguments[1],
      data: arguments.length <= 2 ? undefined : arguments[2],
      fix: arguments.length <= 3 ? undefined : arguments[3]
    };
  } // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].


  return {
    node: arguments.length <= 0 ? undefined : arguments[0],
    loc: arguments.length <= 1 ? undefined : arguments[1],
    message: arguments.length <= 2 ? undefined : arguments[2],
    data: arguments.length <= 3 ? undefined : arguments[3],
    fix: arguments.length <= 4 ? undefined : arguments[4]
  };
}
/**
 * Asserts that either a loc or a node was provided, and the node is valid if it was provided.
 * @param {MessageDescriptor} descriptor A descriptor to validate
 * @returns {void}
 * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object
 */


function assertValidNodeInfo(descriptor) {
  if (descriptor.node) {
    assert(_typeof(descriptor.node) === "object", "Node must be an object");
  } else {
    assert(descriptor.loc, "Node must be provided when reporting error if location is not provided");
  }
}
/**
 * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties
 * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.
 * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties
 * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.
 */


function normalizeReportLoc(descriptor) {
  if (descriptor.loc) {
    if (descriptor.loc.start) {
      return descriptor.loc;
    }

    return {
      start: descriptor.loc,
      end: null
    };
  }

  return descriptor.node.loc;
}
/**
 * Compares items in a fixes array by range.
 * @param {Fix} a The first message.
 * @param {Fix} b The second message.
 * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */


function compareFixesByRange(a, b) {
  return a.range[0] - b.range[0] || a.range[1] - b.range[1];
}
/**
 * Merges the given fixes array into one.
 * @param {Fix[]} fixes The fixes to merge.
 * @param {SourceCode} sourceCode The source code object to get the text between fixes.
 * @returns {{text: string, range: number[]}} The merged fixes
 */


function mergeFixes(fixes, sourceCode) {
  if (fixes.length === 0) {
    return null;
  }

  if (fixes.length === 1) {
    return fixes[0];
  }

  fixes.sort(compareFixesByRange);
  var originalText = sourceCode.text;
  var start = fixes[0].range[0];
  var end = fixes[fixes.length - 1].range[1];
  var text = "";
  var lastPos = Number.MIN_SAFE_INTEGER;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = fixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fix = _step.value;
      assert(fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");

      if (fix.range[0] >= 0) {
        text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
      }

      text += fix.text;
      lastPos = fix.range[1];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  text += originalText.slice(Math.max(0, start, lastPos), end);
  return {
    range: [start, end],
    text: text
  };
}
/**
 * Gets one fix object from the given descriptor.
 * If the descriptor retrieves multiple fixes, this merges those to one.
 * @param {MessageDescriptor} descriptor The report descriptor.
 * @param {SourceCode} sourceCode The source code object to get text between fixes.
 * @returns {({text: string, range: number[]}|null)} The fix for the descriptor
 */


function normalizeFixes(descriptor, sourceCode) {
  if (typeof descriptor.fix !== "function") {
    return null;
  } // @type {null | Fix | Fix[] | IterableIterator<Fix>}


  var fix = descriptor.fix(ruleFixer); // Merge to one.

  if (fix && Symbol.iterator in fix) {
    return mergeFixes(Array.from(fix), sourceCode);
  }

  return fix;
}
/**
 * Gets an array of suggestion objects from the given descriptor.
 * @param {MessageDescriptor} descriptor The report descriptor.
 * @param {SourceCode} sourceCode The source code object to get text between fixes.
 * @param {Object} messages Object of meta messages for the rule.
 * @returns {Array<SuggestionResult>} The suggestions for the descriptor
 */


function mapSuggestions(descriptor, sourceCode, messages) {
  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {
    return [];
  }

  return descriptor.suggest.map(function (suggestInfo) {
    var computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];
    return _objectSpread({}, suggestInfo, {
      desc: interpolate(computedDesc, suggestInfo.data),
      fix: normalizeFixes(suggestInfo, sourceCode)
    });
  });
}
/**
 * Creates information about the report from a descriptor
 * @param {Object} options Information about the problem
 * @param {string} options.ruleId Rule ID
 * @param {(0|1|2)} options.severity Rule severity
 * @param {(ASTNode|null)} options.node Node
 * @param {string} options.message Error message
 * @param {string} [options.messageId] The error message ID.
 * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location
 * @param {{text: string, range: (number[]|null)}} options.fix The fix object
 * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects
 * @returns {function(...args): ReportInfo} Function that returns information about the report
 */


function createProblem(options) {
  var problem = {
    ruleId: options.ruleId,
    severity: options.severity,
    message: options.message,
    line: options.loc.start.line,
    column: options.loc.start.column + 1,
    nodeType: options.node && options.node.type || null
  };
  /*
   * If this isn’t in the conditional, some of the tests fail
   * because `messageId` is present in the problem object
   */

  if (options.messageId) {
    problem.messageId = options.messageId;
  }

  if (options.loc.end) {
    problem.endLine = options.loc.end.line;
    problem.endColumn = options.loc.end.column + 1;
  }

  if (options.fix) {
    problem.fix = options.fix;
  }

  if (options.suggestions && options.suggestions.length > 0) {
    problem.suggestions = options.suggestions;
  }

  return problem;
}
/**
 * Validates that suggestions are properly defined. Throws if an error is detected.
 * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.
 * @param {Object} messages Object of meta messages for the rule.
 * @returns {void}
 */


function validateSuggestions(suggest, messages) {
  if (suggest && Array.isArray(suggest)) {
    suggest.forEach(function (suggestion) {
      if (suggestion.messageId) {
        var messageId = suggestion.messageId;

        if (!messages) {
          throw new TypeError("context.report() called with a suggest option with a messageId '".concat(messageId, "', but no messages were present in the rule metadata."));
        }

        if (!messages[messageId]) {
          throw new TypeError("context.report() called with a suggest option with a messageId '".concat(messageId, "' which is not present in the 'messages' config: ").concat(JSON.stringify(messages, null, 2)));
        }

        if (suggestion.desc) {
          throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
        }
      } else if (!suggestion.desc) {
        throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
      }

      if (typeof suggestion.fix !== "function") {
        throw new TypeError("context.report() called with a suggest option without a fix function. See: ".concat(suggestion));
      }
    });
  }
}
/**
 * Returns a function that converts the arguments of a `context.report` call from a rule into a reported
 * problem for the Node.js API.
 * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem
 * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted
 * @returns {function(...args): ReportInfo} Function that returns information about the report
 */


module.exports = function createReportTranslator(metadata) {
  /*
   * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.
   * The report translator itself (i.e. the function that `createReportTranslator` returns) gets
   * called every time a rule reports a problem, which happens much less frequently (usually, the vast
   * majority of rules don't report any problems for a given file).
   */
  return function () {
    var descriptor = normalizeMultiArgReportCall.apply(void 0, arguments);
    var messages = metadata.messageIds;
    assertValidNodeInfo(descriptor);
    var computedMessage;

    if (descriptor.messageId) {
      if (!messages) {
        throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
      }

      var id = descriptor.messageId;

      if (descriptor.message) {
        throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
      }

      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {
        throw new TypeError("context.report() called with a messageId of '".concat(id, "' which is not present in the 'messages' config: ").concat(JSON.stringify(messages, null, 2)));
      }

      computedMessage = messages[id];
    } else if (descriptor.message) {
      computedMessage = descriptor.message;
    } else {
      throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
    }

    validateSuggestions(descriptor.suggest, messages);
    return createProblem({
      ruleId: metadata.ruleId,
      severity: metadata.severity,
      node: descriptor.node,
      message: interpolate(computedMessage, descriptor.data),
      messageId: descriptor.messageId,
      loc: normalizeReportLoc(descriptor),
      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),
      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)
    });
  };
};