/**
 * @fileoverview Main Linter Class
 * @author Gyandeep Singh
 * @author aladdin-add
 */
"use strict"; //------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var path = require("path"),
    eslintScope = require("eslint-scope"),
    evk = require("eslint-visitor-keys"),
    espree = require("espree"),
    lodash = require("lodash"),
    BuiltInEnvironments = require("../../conf/environments"),
    pkg = require("../../package.json"),
    astUtils = require("../shared/ast-utils"),
    ConfigOps = require("../shared/config-ops"),
    validator = require("../shared/config-validator"),
    Traverser = require("../shared/traverser"),
    _require = require("../source-code"),
    SourceCode = _require.SourceCode,
    CodePathAnalyzer = require("./code-path-analysis/code-path-analyzer"),
    applyDisableDirectives = require("./apply-disable-directives"),
    ConfigCommentParser = require("./config-comment-parser"),
    NodeEventGenerator = require("./node-event-generator"),
    createReportTranslator = require("./report-translator"),
    Rules = require("./rules"),
    createEmitter = require("./safe-emitter"),
    SourceCodeFixer = require("./source-code-fixer"),
    timing = require("./timing"),
    ruleReplacements = require("../../conf/replacements.json");

var debug = require("debug")("eslint:linter");

var MAX_AUTOFIX_PASSES = 10;
var DEFAULT_PARSER_NAME = "espree";
var commentParser = new ConfigCommentParser();
var DEFAULT_ERROR_LOC = {
  start: {
    line: 1,
    column: 0
  },
  end: {
    line: 1,
    column: 1
  }
}; //------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @typedef {InstanceType<import("../cli-engine/config-array")["ConfigArray"]>} ConfigArray */

/** @typedef {InstanceType<import("../cli-engine/config-array")["ExtractedConfig"]>} ExtractedConfig */

/** @typedef {import("../shared/types").ConfigData} ConfigData */

/** @typedef {import("../shared/types").Environment} Environment */

/** @typedef {import("../shared/types").GlobalConf} GlobalConf */

/** @typedef {import("../shared/types").LintMessage} LintMessage */

/** @typedef {import("../shared/types").ParserOptions} ParserOptions */

/** @typedef {import("../shared/types").Processor} Processor */

/** @typedef {import("../shared/types").Rule} Rule */

/**
 * @template T
 * @typedef {{ [P in keyof T]-?: T[P] }} Required
 */

/**
 * @typedef {Object} DisableDirective
 * @property {("disable"|"enable"|"disable-line"|"disable-next-line")} type
 * @property {number} line
 * @property {number} column
 * @property {(string|null)} ruleId
 */

/**
 * The private data for `Linter` instance.
 * @typedef {Object} LinterInternalSlots
 * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.
 * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.
 * @property {Map<string, Parser>} parserMap The loaded parsers.
 * @property {Rules} ruleMap The loaded rules.
 */

/**
 * @typedef {Object} VerifyOptions
 * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability
 *      to change config once it is set. Defaults to true if not supplied.
 *      Useful if you want to validate JS without comments overriding rules.
 * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`
 *      properties into the lint result.
 * @property {string} [filename] the filename of the source code.
 * @property {boolean | "off" | "warn" | "error"} [reportUnusedDisableDirectives] Adds reported errors for
 *      unused `eslint-disable` directives.
 */

/**
 * @typedef {Object} ProcessorOptions
 * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the
 *      predicate function that selects adopt code blocks.
 * @property {Processor["postprocess"]} [postprocess] postprocessor for report
 *      messages. If provided, this should accept an array of the message lists
 *      for each code block returned from the preprocessor, apply a mapping to
 *      the messages as appropriate, and return a one-dimensional array of
 *      messages.
 * @property {Processor["preprocess"]} [preprocess] preprocessor for source text.
 *      If provided, this should accept a string of source text, and return an
 *      array of code blocks to lint.
 */

/**
 * @typedef {Object} FixOptions
 * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines
 *      whether fixes should be applied.
 */

/**
 * @typedef {Object} InternalOptions
 * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.
 * @property {"off" | "warn" | "error"} reportUnusedDisableDirectives (boolean values were normalized)
 */
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Ensures that variables representing built-in properties of the Global Object,
 * and any globals declared by special block comments, are present in the global
 * scope.
 * @param {Scope} globalScope The global scope.
 * @param {Object} configGlobals The globals declared in configuration
 * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration
 * @returns {void}
 */

function addDeclaredGlobals(globalScope, configGlobals, _ref) {
  var exportedVariables = _ref.exportedVariables,
      enabledGlobals = _ref.enabledGlobals;
  // Define configured global variables.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = new Set([].concat(_toConsumableArray(Object.keys(configGlobals)), _toConsumableArray(Object.keys(enabledGlobals))))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var id = _step.value;

      /*
       * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would
       * typically be caught when validating a config anyway (validity for inline global comments is checked separately).
       */
      var configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);
      var commentValue = enabledGlobals[id] && enabledGlobals[id].value;
      var value = commentValue || configValue;
      var sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;

      if (value === "off") {
        continue;
      }

      var variable = globalScope.set.get(id);

      if (!variable) {
        variable = new eslintScope.Variable(id, globalScope);
        globalScope.variables.push(variable);
        globalScope.set.set(id, variable);
      }

      variable.eslintImplicitGlobalSetting = configValue;
      variable.eslintExplicitGlobal = sourceComments !== void 0;
      variable.eslintExplicitGlobalComments = sourceComments;
      variable.writeable = value === "writable";
    } // mark all exported variables as such

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  Object.keys(exportedVariables).forEach(function (name) {
    var variable = globalScope.set.get(name);

    if (variable) {
      variable.eslintUsed = true;
    }
  });
  /*
   * "through" contains all references which definitions cannot be found.
   * Since we augment the global scope using configuration, we need to update
   * references and remove the ones that were added by configuration.
   */

  globalScope.through = globalScope.through.filter(function (reference) {
    var name = reference.identifier.name;
    var variable = globalScope.set.get(name);

    if (variable) {
      /*
       * Links the variable and the reference.
       * And this reference is removed from `Scope#through`.
       */
      reference.resolved = variable;
      variable.references.push(reference);
      return false;
    }

    return true;
  });
}
/**
 * creates a missing-rule message.
 * @param {string} ruleId the ruleId to create
 * @returns {string} created error message
 * @private
 */


function createMissingRuleMessage(ruleId) {
  return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? "Rule '".concat(ruleId, "' was removed and replaced by: ").concat(ruleReplacements.rules[ruleId].join(", ")) : "Definition for rule '".concat(ruleId, "' was not found.");
}
/**
 * creates a linting problem
 * @param {Object} options to create linting error
 * @param {string} [options.ruleId] the ruleId to report
 * @param {Object} [options.loc] the loc to report
 * @param {string} [options.message] the error message to report
 * @param {string} [options.severity] the error message to report
 * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.
 * @private
 */


function createLintingProblem(options) {
  var _options$ruleId = options.ruleId,
      ruleId = _options$ruleId === void 0 ? null : _options$ruleId,
      _options$loc = options.loc,
      loc = _options$loc === void 0 ? DEFAULT_ERROR_LOC : _options$loc,
      _options$message = options.message,
      message = _options$message === void 0 ? createMissingRuleMessage(options.ruleId) : _options$message,
      _options$severity = options.severity,
      severity = _options$severity === void 0 ? 2 : _options$severity;
  return {
    ruleId: ruleId,
    message: message,
    line: loc.start.line,
    column: loc.start.column + 1,
    endLine: loc.end.line,
    endColumn: loc.end.column + 1,
    severity: severity,
    nodeType: null
  };
}
/**
 * Creates a collection of disable directives from a comment
 * @param {Object} options to create disable directives
 * @param {("disable"|"enable"|"disable-line"|"disable-next-line")} options.type The type of directive comment
 * @param {{line: number, column: number}} options.loc The 0-based location of the comment token
 * @param {string} options.value The value after the directive in the comment
 * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)
 * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules
 * @returns {Object} Directives and problems from the comment
 */


function createDisableDirectives(options) {
  var type = options.type,
      loc = options.loc,
      value = options.value,
      ruleMapper = options.ruleMapper;
  var ruleIds = Object.keys(commentParser.parseListConfig(value));
  var directiveRules = ruleIds.length ? ruleIds : [null];
  var result = {
    directives: [],
    // valid disable directives
    directiveProblems: [] // problems in directives

  };
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = directiveRules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var ruleId = _step2.value;

      // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)
      if (ruleId === null || ruleMapper(ruleId) !== null) {
        result.directives.push({
          type: type,
          line: loc.start.line,
          column: loc.start.column + 1,
          ruleId: ruleId
        });
      } else {
        result.directiveProblems.push(createLintingProblem({
          ruleId: ruleId,
          loc: loc
        }));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return result;
}
/**
 * Parses comments in file to extract file-specific config of rules, globals
 * and environments and merges them with global config; also code blocks
 * where reporting is disabled or enabled and merges them with reporting config.
 * @param {string} filename The file being checked.
 * @param {ASTNode} ast The top node of the AST.
 * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules
 * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.
 * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}
 * A collection of the directive comments that were found, along with any problems that occurred when parsing
 */


function getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {
  var configuredRules = {};
  var enabledGlobals = Object.create(null);
  var exportedVariables = {};
  var problems = [];
  var disableDirectives = [];
  ast.comments.filter(function (token) {
    return token.type !== "Shebang";
  }).forEach(function (comment) {
    var trimmedCommentText = comment.value.trim();
    var match = /^(eslint(?:\x2Denv|\x2Denable|\x2Ddisable(?:(?:\x2Dnext)?\x2Dline)?)?|exported|globals?)(?:[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]|$)/.exec(trimmedCommentText);

    if (!match) {
      return;
    }

    var directiveText = match[1];
    var lineCommentSupported = /^eslint\x2Ddisable\x2D(next\x2D)?line$/.test(directiveText);

    if (comment.type === "Line" && !lineCommentSupported) {
      return;
    }

    if (warnInlineConfig) {
      var kind = comment.type === "Block" ? "/*".concat(directiveText, "*/") : "//".concat(directiveText);
      problems.push(createLintingProblem({
        ruleId: null,
        message: "'".concat(kind, "' has no effect because you have 'noInlineConfig' setting in ").concat(warnInlineConfig, "."),
        loc: comment.loc,
        severity: 1
      }));
      return;
    }

    if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {
      var message = "".concat(directiveText, " comment should not span multiple lines.");
      problems.push(createLintingProblem({
        ruleId: null,
        message: message,
        loc: comment.loc
      }));
      return;
    }

    var directiveValue = trimmedCommentText.slice(match.index + directiveText.length);

    switch (directiveText) {
      case "eslint-disable":
      case "eslint-enable":
      case "eslint-disable-next-line":
      case "eslint-disable-line":
        {
          var directiveType = directiveText.slice("eslint-".length);
          var options = {
            type: directiveType,
            loc: comment.loc,
            value: directiveValue,
            ruleMapper: ruleMapper
          };

          var _createDisableDirecti = createDisableDirectives(options),
              directives = _createDisableDirecti.directives,
              directiveProblems = _createDisableDirecti.directiveProblems;

          disableDirectives.push.apply(disableDirectives, _toConsumableArray(directives));
          problems.push.apply(problems, _toConsumableArray(directiveProblems));
          break;
        }

      case "exported":
        Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
        break;

      case "globals":
      case "global":
        for (var _i = 0, _Object$entries = Object.entries(commentParser.parseStringConfig(directiveValue, comment)); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              id = _Object$entries$_i[0],
              value = _Object$entries$_i[1].value;

          var normalizedValue = void 0;

          try {
            normalizedValue = ConfigOps.normalizeConfigGlobal(value);
          } catch (err) {
            problems.push(createLintingProblem({
              ruleId: null,
              loc: comment.loc,
              message: err.message
            }));
            continue;
          }

          if (enabledGlobals[id]) {
            enabledGlobals[id].comments.push(comment);
            enabledGlobals[id].value = normalizedValue;
          } else {
            enabledGlobals[id] = {
              comments: [comment],
              value: normalizedValue
            };
          }
        }

        break;

      case "eslint":
        {
          var parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);

          if (parseResult.success) {
            Object.keys(parseResult.config).forEach(function (name) {
              var rule = ruleMapper(name);
              var ruleValue = parseResult.config[name];

              if (rule === null) {
                problems.push(createLintingProblem({
                  ruleId: name,
                  loc: comment.loc
                }));
                return;
              }

              try {
                validator.validateRuleOptions(rule, name, ruleValue);
              } catch (err) {
                problems.push(createLintingProblem({
                  ruleId: name,
                  message: err.message,
                  loc: comment.loc
                })); // do not apply the config, if found invalid options.

                return;
              }

              configuredRules[name] = ruleValue;
            });
          } else {
            problems.push(parseResult.error);
          }

          break;
        }
      // no default
    }
  });
  return {
    configuredRules: configuredRules,
    enabledGlobals: enabledGlobals,
    exportedVariables: exportedVariables,
    problems: problems,
    disableDirectives: disableDirectives
  };
}
/**
 * Normalize ECMAScript version from the initial config
 * @param  {number} ecmaVersion ECMAScript version from the initial config
 * @returns {number} normalized ECMAScript version
 */


function normalizeEcmaVersion(ecmaVersion) {
  /*
   * Calculate ECMAScript edition number from official year version starting with
   * ES2015, which corresponds with ES6 (or a difference of 2009).
   */
  return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;
}

var eslintEnvPattern = /\/\*[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*eslint\x2Denv[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+?)\*\//g;
/**
 * Checks whether or not there is a comment which has "eslint-env *" in a given text.
 * @param {string} text A source code text to check.
 * @returns {Object|null} A result of parseListConfig() with "eslint-env *" comment.
 */

function findEslintEnv(text) {
  var match, retv;
  eslintEnvPattern.lastIndex = 0;

  while (match = eslintEnvPattern.exec(text)) {
    retv = Object.assign(retv || {}, commentParser.parseListConfig(match[1]));
  }

  return retv;
}
/**
 * Convert "/path/to/<text>" to "<text>".
 * `CLIEngine#executeOnText()` method gives "/path/to/<text>" if the filename
 * was omitted because `configArray.extractConfig()` requires an absolute path.
 * But the linter should pass `<text>` to `RuleContext#getFilename()` in that
 * case.
 * Also, code blocks can have their virtual filename. If the parent filename was
 * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,
 * it's not an absolute path).
 * @param {string} filename The filename to normalize.
 * @returns {string} The normalized filename.
 */


function normalizeFilename(filename) {
  var parts = filename.split(path.sep);
  var index = parts.lastIndexOf("<text>");
  return index === -1 ? filename : parts.slice(index).join(path.sep);
}
/**
 * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a
 * consistent shape.
 * @param {VerifyOptions} providedOptions Options
 * @param {ConfigData} config Config.
 * @returns {Required<VerifyOptions> & InternalOptions} Normalized options
 */


function normalizeVerifyOptions(providedOptions, config) {
  var disableInlineConfig = config.noInlineConfig === true;
  var ignoreInlineConfig = providedOptions.allowInlineConfig === false;
  var configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? " (".concat(config.configNameOfNoInlineConfig, ")") : "";
  var reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;

  if (typeof reportUnusedDisableDirectives === "boolean") {
    reportUnusedDisableDirectives = reportUnusedDisableDirectives ? "error" : "off";
  }

  if (typeof reportUnusedDisableDirectives !== "string") {
    reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? "warn" : "off";
  }

  return {
    filename: normalizeFilename(providedOptions.filename || "<input>"),
    allowInlineConfig: !ignoreInlineConfig,
    warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? "your config".concat(configNameOfNoInlineConfig) : null,
    reportUnusedDisableDirectives: reportUnusedDisableDirectives,
    disableFixes: Boolean(providedOptions.disableFixes)
  };
}
/**
 * Combines the provided parserOptions with the options from environments
 * @param {string} parserName The parser name which uses this options.
 * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config
 * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns {ParserOptions} Resulting parser options after merge
 */


function resolveParserOptions(parserName, providedOptions, enabledEnvironments) {
  var parserOptionsFromEnv = enabledEnvironments.filter(function (env) {
    return env.parserOptions;
  }).reduce(function (parserOptions, env) {
    return lodash.merge(parserOptions, env.parserOptions);
  }, {});
  var mergedParserOptions = lodash.merge(parserOptionsFromEnv, providedOptions || {});
  var isModule = mergedParserOptions.sourceType === "module";

  if (isModule) {
    /*
     * can't have global return inside of modules
     * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)
     */
    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {
      globalReturn: false
    });
  }
  /*
   * TODO: @aladdin-add
   * 1. for a 3rd-party parser, do not normalize parserOptions
   * 2. for espree, no need to do this (espree will do it)
   */


  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion);
  return mergedParserOptions;
}
/**
 * Combines the provided globals object with the globals from environments
 * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config
 * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns {Record<string, GlobalConf>} The resolved globals object
 */


function resolveGlobals(providedGlobals, enabledEnvironments) {
  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(enabledEnvironments.filter(function (env) {
    return env.globals;
  }).map(function (env) {
    return env.globals;
  })), [providedGlobals]));
}
/**
 * Strips Unicode BOM from a given text.
 * @param {string} text A text to strip.
 * @returns {string} The stripped text.
 */


function stripUnicodeBOM(text) {
  /*
   * Check Unicode BOM.
   * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.
   * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters
   */
  if (text.charCodeAt(0) === 0xFEFF) {
    return text.slice(1);
  }

  return text;
}
/**
 * Get the options for a rule (not including severity), if any
 * @param {Array|number} ruleConfig rule configuration
 * @returns {Array} of rule options, empty Array if none
 */


function getRuleOptions(ruleConfig) {
  if (Array.isArray(ruleConfig)) {
    return ruleConfig.slice(1);
  }

  return [];
}
/**
 * Analyze scope of the given AST.
 * @param {ASTNode} ast The `Program` node to analyze.
 * @param {ParserOptions} parserOptions The parser options.
 * @param {Record<string, string[]>} visitorKeys The visitor keys.
 * @returns {ScopeManager} The analysis result.
 */


function analyzeScope(ast, parserOptions, visitorKeys) {
  var ecmaFeatures = parserOptions.ecmaFeatures || {};
  var ecmaVersion = parserOptions.ecmaVersion || 5;
  return eslintScope.analyze(ast, {
    ignoreEval: true,
    nodejsScope: ecmaFeatures.globalReturn,
    impliedStrict: ecmaFeatures.impliedStrict,
    ecmaVersion: ecmaVersion,
    sourceType: parserOptions.sourceType || "script",
    childVisitorKeys: visitorKeys || evk.KEYS,
    fallback: Traverser.getKeys
  });
}
/**
 * Parses text into an AST. Moved out here because the try-catch prevents
 * optimization of functions, so it's best to keep the try-catch as isolated
 * as possible
 * @param {string} text The text to parse.
 * @param {Parser} parser The parser to parse.
 * @param {ParserOptions} providedParserOptions Options to pass to the parser
 * @param {string} filePath The path to the file being parsed.
 * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}
 * An object containing the AST and parser services if parsing was successful, or the error if parsing failed
 * @private
 */


function parse(text, parser, providedParserOptions, filePath) {
  var textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, function (match, captured) {
    return "//".concat(captured);
  });
  var parserOptions = Object.assign({}, providedParserOptions, {
    loc: true,
    range: true,
    raw: true,
    tokens: true,
    comment: true,
    eslintVisitorKeys: true,
    eslintScopeManager: true,
    filePath: filePath
  });
  /*
   * Check for parsing errors first. If there's a parsing error, nothing
   * else can happen. However, a parsing error does not throw an error
   * from this method - it's just considered a fatal error message, a
   * problem that ESLint identified just like any other.
   */

  try {
    var parseResult = typeof parser.parseForESLint === "function" ? parser.parseForESLint(textToParse, parserOptions) : {
      ast: parser.parse(textToParse, parserOptions)
    };
    var ast = parseResult.ast;
    var parserServices = parseResult.services || {};
    var visitorKeys = parseResult.visitorKeys || evk.KEYS;
    var scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);
    return {
      success: true,

      /*
       * Save all values that `parseForESLint()` returned.
       * If a `SourceCode` object is given as the first parameter instead of source code text,
       * linter skips the parsing process and reuses the source code object.
       * In that case, linter needs all the values that `parseForESLint()` returned.
       */
      sourceCode: new SourceCode({
        text: text,
        ast: ast,
        parserServices: parserServices,
        scopeManager: scopeManager,
        visitorKeys: visitorKeys
      })
    };
  } catch (ex) {
    // If the message includes a leading line number, strip it:
    var message = "Parsing error: ".concat(ex.message.replace(/^line [0-9]+:/i, "").trim());
    debug("%s\n%s", message, ex.stack);
    return {
      success: false,
      error: {
        ruleId: null,
        fatal: true,
        severity: 2,
        message: message,
        line: ex.lineNumber,
        column: ex.column
      }
    };
  }
}
/**
 * Gets the scope for the current node
 * @param {ScopeManager} scopeManager The scope manager for this AST
 * @param {ASTNode} currentNode The node to get the scope of
 * @returns {eslint-scope.Scope} The scope information for this node
 */


function _getScope(scopeManager, currentNode) {
  // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.
  var inner = currentNode.type !== "Program";

  for (var node = currentNode; node; node = node.parent) {
    var scope = scopeManager.acquire(node, inner);

    if (scope) {
      if (scope.type === "function-expression-name") {
        return scope.childScopes[0];
      }

      return scope;
    }
  }

  return scopeManager.scopes[0];
}
/**
 * Marks a variable as used in the current scope
 * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.
 * @param {ASTNode} currentNode The node currently being traversed
 * @param {Object} parserOptions The options used to parse this text
 * @param {string} name The name of the variable that should be marked as used.
 * @returns {boolean} True if the variable was found and marked as used, false if not.
 */


function _markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
  var hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
  var specialScope = hasGlobalReturn || parserOptions.sourceType === "module";

  var currentScope = _getScope(scopeManager, currentNode); // Special Node.js scope means we need to start one level deeper


  var initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;

  for (var scope = initialScope; scope; scope = scope.upper) {
    var variable = scope.variables.find(function (scopeVar) {
      return scopeVar.name === name;
    });

    if (variable) {
      variable.eslintUsed = true;
      return true;
    }
  }

  return false;
}
/**
 * Runs a rule, and gets its listeners
 * @param {Rule} rule A normalized rule with a `create` method
 * @param {Context} ruleContext The context that should be passed to the rule
 * @returns {Object} A map of selector listeners provided by the rule
 */


function createRuleListeners(rule, ruleContext) {
  try {
    return rule.create(ruleContext);
  } catch (ex) {
    ex.message = "Error while loading rule '".concat(ruleContext.id, "': ").concat(ex.message);
    throw ex;
  }
}
/**
 * Gets all the ancestors of a given node
 * @param {ASTNode} node The node
 * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting
 * from the root node and going inwards to the parent node.
 */


function _getAncestors(node) {
  var ancestorsStartingAtParent = [];

  for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
    ancestorsStartingAtParent.push(ancestor);
  }

  return ancestorsStartingAtParent.reverse();
} // methods that exist on SourceCode object


var DEPRECATED_SOURCECODE_PASSTHROUGHS = {
  getSource: "getText",
  getSourceLines: "getLines",
  getAllComments: "getAllComments",
  getNodeByRangeIndex: "getNodeByRangeIndex",
  getComments: "getComments",
  getCommentsBefore: "getCommentsBefore",
  getCommentsAfter: "getCommentsAfter",
  getCommentsInside: "getCommentsInside",
  getJSDocComment: "getJSDocComment",
  getFirstToken: "getFirstToken",
  getFirstTokens: "getFirstTokens",
  getLastToken: "getLastToken",
  getLastTokens: "getLastTokens",
  getTokenAfter: "getTokenAfter",
  getTokenBefore: "getTokenBefore",
  getTokenByRangeStart: "getTokenByRangeStart",
  getTokens: "getTokens",
  getTokensAfter: "getTokensAfter",
  getTokensBefore: "getTokensBefore",
  getTokensBetween: "getTokensBetween"
};
var BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(function (contextInfo, methodName) {
  return Object.assign(contextInfo, _defineProperty({}, methodName, function () {
    var _this$getSourceCode;

    return (_this$getSourceCode = this.getSourceCode())[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]].apply(_this$getSourceCode, arguments);
  }));
}, {}));
/**
 * Runs the given rules on the given SourceCode object
 * @param {SourceCode} sourceCode A SourceCode object for the given text
 * @param {Object} configuredRules The rules configuration
 * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules
 * @param {Object} parserOptions The options that were passed to the parser
 * @param {string} parserName The name of the parser in the config
 * @param {Object} settings The settings that were enabled in the config
 * @param {string} filename The reported filename of the code
 * @param {boolean} disableFixes If true, it doesn't make `fix` properties.
 * @param {string | undefined} cwd cwd of the cli
 * @returns {Problem[]} An array of reported problems
 */

function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd) {
  var emitter = createEmitter();
  var nodeQueue = [];
  var currentNode = sourceCode.ast;
  Traverser.traverse(sourceCode.ast, {
    enter: function enter(node, parent) {
      node.parent = parent;
      nodeQueue.push({
        isEntering: true,
        node: node
      });
    },
    leave: function leave(node) {
      nodeQueue.push({
        isEntering: false,
        node: node
      });
    },
    visitorKeys: sourceCode.visitorKeys
  });
  /*
   * Create a frozen object with the ruleContext properties and methods that are shared by all rules.
   * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the
   * properties once for each rule.
   */

  var sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {
    getAncestors: function getAncestors() {
      return _getAncestors(currentNode);
    },
    getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),
    getCwd: function getCwd() {
      return cwd;
    },
    getFilename: function getFilename() {
      return filename;
    },
    getScope: function getScope() {
      return _getScope(sourceCode.scopeManager, currentNode);
    },
    getSourceCode: function getSourceCode() {
      return sourceCode;
    },
    markVariableAsUsed: function markVariableAsUsed(name) {
      return _markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name);
    },
    parserOptions: parserOptions,
    parserPath: parserName,
    parserServices: sourceCode.parserServices,
    settings: settings
  }));
  var lintingProblems = [];
  Object.keys(configuredRules).forEach(function (ruleId) {
    var severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]); // not load disabled rules

    if (severity === 0) {
      return;
    }

    var rule = ruleMapper(ruleId);

    if (rule === null) {
      lintingProblems.push(createLintingProblem({
        ruleId: ruleId
      }));
      return;
    }

    var messageIds = rule.meta && rule.meta.messages;
    var reportTranslator = null;
    var ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {
      id: ruleId,
      options: getRuleOptions(configuredRules[ruleId]),
      report: function report() {
        /*
         * Create a report translator lazily.
         * In a vast majority of cases, any given rule reports zero errors on a given
         * piece of code. Creating a translator lazily avoids the performance cost of
         * creating a new translator function for each rule that usually doesn't get
         * called.
         *
         * Using lazy report translators improves end-to-end performance by about 3%
         * with Node 8.4.0.
         */
        if (reportTranslator === null) {
          reportTranslator = createReportTranslator({
            ruleId: ruleId,
            severity: severity,
            sourceCode: sourceCode,
            messageIds: messageIds,
            disableFixes: disableFixes
          });
        }

        var problem = reportTranslator.apply(void 0, arguments);

        if (problem.fix && rule.meta && !rule.meta.fixable) {
          throw new Error("Fixable rules should export a `meta.fixable` property.");
        }

        lintingProblems.push(problem);
      }
    }));
    var ruleListeners = createRuleListeners(rule, ruleContext); // add all the selectors from the rule as listeners

    Object.keys(ruleListeners).forEach(function (selector) {
      emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);
    });
  });
  var eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));
  nodeQueue.forEach(function (traversalInfo) {
    currentNode = traversalInfo.node;

    try {
      if (traversalInfo.isEntering) {
        eventGenerator.enterNode(currentNode);
      } else {
        eventGenerator.leaveNode(currentNode);
      }
    } catch (err) {
      err.currentNode = currentNode;
      throw err;
    }
  });
  return lintingProblems;
}
/**
 * Ensure the source code to be a string.
 * @param {string|SourceCode} textOrSourceCode The text or source code object.
 * @returns {string} The source code text.
 */


function ensureText(textOrSourceCode) {
  if (_typeof(textOrSourceCode) === "object") {
    var hasBOM = textOrSourceCode.hasBOM,
        text = textOrSourceCode.text;
    var bom = hasBOM ? "\uFEFF" : "";
    return bom + text;
  }

  return String(textOrSourceCode);
}
/**
 * Get an environment.
 * @param {LinterInternalSlots} slots The internal slots of Linter.
 * @param {string} envId The environment ID to get.
 * @returns {Environment|null} The environment.
 */


function getEnv(slots, envId) {
  return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;
}
/**
 * Get a rule.
 * @param {LinterInternalSlots} slots The internal slots of Linter.
 * @param {string} ruleId The rule ID to get.
 * @returns {Rule|null} The rule.
 */


function getRule(slots, ruleId) {
  return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);
}
/**
 * Normalize the value of the cwd
 * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.
 * @returns {string | undefined} normalized cwd
 */


function normalizeCwd(cwd) {
  if (cwd) {
    return cwd;
  }

  if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object") {
    return process.cwd();
  } // It's more explicit to assign the undefined
  // eslint-disable-next-line no-undefined


  return undefined;
}
/**
 * The map to store private data.
 * @type {WeakMap<Linter, LinterInternalSlots>}
 */


var internalSlotsMap = new WeakMap(); //------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object that is responsible for verifying JavaScript text
 * @name eslint
 */

var Linter =
/*#__PURE__*/
function () {
  /**
   * Initialize the Linter.
   * @param {Object} [config] the config object
   * @param {string} [config.cwd]  path to a directory that should be considered as the current working directory, can be undefined.
   */
  function Linter() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        cwd = _ref2.cwd;

    _classCallCheck(this, Linter);

    internalSlotsMap.set(this, {
      cwd: normalizeCwd(cwd),
      lastConfigArray: null,
      lastSourceCode: null,
      parserMap: new Map([["espree", espree]]),
      ruleMap: new Rules()
    });
    this.version = pkg.version;
  }
  /**
   * Getter for package version.
   * @static
   * @returns {string} The version from package.json.
   */


  _createClass(Linter, [{
    key: "_verifyWithoutProcessors",

    /**
     * Same as linter.verify, except without support for processors.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.
     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.
     */
    value: function _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
      var slots = internalSlotsMap.get(this);
      var config = providedConfig || {};
      var options = normalizeVerifyOptions(providedOptions, config);
      var text; // evaluate arguments

      if (typeof textOrSourceCode === "string") {
        slots.lastSourceCode = null;
        text = textOrSourceCode;
      } else {
        slots.lastSourceCode = textOrSourceCode;
        text = textOrSourceCode.text;
      } // Resolve parser.


      var parserName = DEFAULT_PARSER_NAME;
      var parser = espree;

      if (_typeof(config.parser) === "object" && config.parser !== null) {
        parserName = config.parser.filePath;
        parser = config.parser.definition;
      } else if (typeof config.parser === "string") {
        if (!slots.parserMap.has(config.parser)) {
          return [{
            ruleId: null,
            fatal: true,
            severity: 2,
            message: "Configured parser '".concat(config.parser, "' was not found."),
            line: 0,
            column: 0
          }];
        }

        parserName = config.parser;
        parser = slots.parserMap.get(config.parser);
      } // search and apply "eslint-env *".


      var envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};
      var resolvedEnvConfig = Object.assign({
        builtin: true
      }, config.env, envInFile);
      var enabledEnvs = Object.keys(resolvedEnvConfig).filter(function (envName) {
        return resolvedEnvConfig[envName];
      }).map(function (envName) {
        return getEnv(slots, envName);
      }).filter(function (env) {
        return env;
      });
      var parserOptions = resolveParserOptions(parserName, config.parserOptions || {}, enabledEnvs);
      var configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);
      var settings = config.settings || {};

      if (!slots.lastSourceCode) {
        var parseResult = parse(text, parser, parserOptions, options.filename);

        if (!parseResult.success) {
          return [parseResult.error];
        }

        slots.lastSourceCode = parseResult.sourceCode;
      } else {
        /*
         * If the given source code object as the first argument does not have scopeManager, analyze the scope.
         * This is for backward compatibility (SourceCode is frozen so it cannot rebind).
         */
        if (!slots.lastSourceCode.scopeManager) {
          slots.lastSourceCode = new SourceCode({
            text: slots.lastSourceCode.text,
            ast: slots.lastSourceCode.ast,
            parserServices: slots.lastSourceCode.parserServices,
            visitorKeys: slots.lastSourceCode.visitorKeys,
            scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)
          });
        }
      }

      var sourceCode = slots.lastSourceCode;
      var commentDirectives = options.allowInlineConfig ? getDirectiveComments(options.filename, sourceCode.ast, function (ruleId) {
        return getRule(slots, ruleId);
      }, options.warnInlineConfig) : {
        configuredRules: {},
        enabledGlobals: {},
        exportedVariables: {},
        problems: [],
        disableDirectives: []
      }; // augment global scope with declared global variables

      addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {
        exportedVariables: commentDirectives.exportedVariables,
        enabledGlobals: commentDirectives.enabledGlobals
      });
      var configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
      var lintingProblems;

      try {
        lintingProblems = runRules(sourceCode, configuredRules, function (ruleId) {
          return getRule(slots, ruleId);
        }, parserOptions, parserName, settings, options.filename, options.disableFixes, slots.cwd);
      } catch (err) {
        err.message += "\nOccurred while linting ".concat(options.filename);
        debug("An error occurred while traversing");
        debug("Filename:", options.filename);

        if (err.currentNode) {
          var line = err.currentNode.loc.start.line;
          debug("Line:", line);
          err.message += ":".concat(line);
        }

        debug("Parser Options:", parserOptions);
        debug("Parser Path:", parserName);
        debug("Settings:", settings);
        throw err;
      }

      return applyDisableDirectives({
        directives: commentDirectives.disableDirectives,
        problems: lintingProblems.concat(commentDirectives.problems).sort(function (problemA, problemB) {
          return problemA.line - problemB.line || problemA.column - problemB.column;
        }),
        reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
      });
    }
    /**
     * Verifies the text against the rules specified by the second argument.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.
     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.
     *      If this is not set, the filename will default to '<input>' in the rule context. If
     *      an object, then it has "filename", "allowInlineConfig", and some properties.
     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.
     */

  }, {
    key: "verify",
    value: function verify(textOrSourceCode, config, filenameOrOptions) {
      debug("Verify");
      var options = typeof filenameOrOptions === "string" ? {
        filename: filenameOrOptions
      } : filenameOrOptions || {}; // CLIEngine passes a `ConfigArray` object.

      if (config && typeof config.extractConfig === "function") {
        return this._verifyWithConfigArray(textOrSourceCode, config, options);
      }
      /*
       * `Linter` doesn't support `overrides` property in configuration.
       * So we cannot apply multiple processors.
       */


      if (options.preprocess || options.postprocess) {
        return this._verifyWithProcessor(textOrSourceCode, config, options);
      }

      return this._verifyWithoutProcessors(textOrSourceCode, config, options);
    }
    /**
     * Verify a given code with `ConfigArray`.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {ConfigArray} configArray The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @returns {LintMessage[]} The found problems.
     */

  }, {
    key: "_verifyWithConfigArray",
    value: function _verifyWithConfigArray(textOrSourceCode, configArray, options) {
      debug("With ConfigArray: %s", options.filename); // Store the config array in order to get plugin envs and rules later.

      internalSlotsMap.get(this).lastConfigArray = configArray; // Extract the final config for this file.

      var config = configArray.extractConfig(options.filename);
      var processor = config.processor && configArray.pluginProcessors.get(config.processor); // Verify.

      if (processor) {
        debug("Apply the processor: %o", config.processor);
        var preprocess = processor.preprocess,
            postprocess = processor.postprocess,
            supportsAutofix = processor.supportsAutofix;
        var disableFixes = options.disableFixes || !supportsAutofix;
        return this._verifyWithProcessor(textOrSourceCode, config, _objectSpread({}, options, {
          disableFixes: disableFixes,
          postprocess: postprocess,
          preprocess: preprocess
        }), configArray);
      }

      return this._verifyWithoutProcessors(textOrSourceCode, config, options);
    }
    /**
     * Verify with a processor.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {ConfigData|ExtractedConfig} config The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {ConfigArray} [configForRecursive] The `CofnigArray` object to apply multiple processors recursively.
     * @returns {LintMessage[]} The found problems.
     */

  }, {
    key: "_verifyWithProcessor",
    value: function _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {
      var _this = this;

      var filename = options.filename || "<input>";
      var filenameToExpose = normalizeFilename(filename);
      var text = ensureText(textOrSourceCode);

      var preprocess = options.preprocess || function (rawText) {
        return [rawText];
      };

      var postprocess = options.postprocess || lodash.flatten;

      var filterCodeBlock = options.filterCodeBlock || function (blockFilename) {
        return blockFilename.endsWith(".js");
      };

      var originalExtname = path.extname(filename);
      var messageLists = preprocess(text, filenameToExpose).map(function (block, i) {
        debug("A code block was found: %o", block.filename || "(unnamed)"); // Keep the legacy behavior.

        if (typeof block === "string") {
          return _this._verifyWithoutProcessors(block, config, options);
        }

        var blockText = block.text;
        var blockName = path.join(filename, "".concat(i, "_").concat(block.filename)); // Skip this block if filtered.

        if (!filterCodeBlock(blockName, blockText)) {
          debug("This code block was skipped.");
          return [];
        } // Resolve configuration again if the file extension was changed.


        if (configForRecursive && path.extname(blockName) !== originalExtname) {
          debug("Resolving configuration again because the file extension was changed.");
          return _this._verifyWithConfigArray(blockText, configForRecursive, _objectSpread({}, options, {
            filename: blockName
          }));
        } // Does lint.


        return _this._verifyWithoutProcessors(blockText, config, _objectSpread({}, options, {
          filename: blockName
        }));
      });
      return postprocess(messageLists, filenameToExpose);
    }
    /**
     * Gets the SourceCode object representing the parsed source.
     * @returns {SourceCode} The SourceCode object.
     */

  }, {
    key: "getSourceCode",
    value: function getSourceCode() {
      return internalSlotsMap.get(this).lastSourceCode;
    }
    /**
     * Defines a new linting rule.
     * @param {string} ruleId A unique rule identifier
     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers
     * @returns {void}
     */

  }, {
    key: "defineRule",
    value: function defineRule(ruleId, ruleModule) {
      internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);
    }
    /**
     * Defines many new linting rules.
     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule
     * @returns {void}
     */

  }, {
    key: "defineRules",
    value: function defineRules(rulesToDefine) {
      var _this2 = this;

      Object.getOwnPropertyNames(rulesToDefine).forEach(function (ruleId) {
        _this2.defineRule(ruleId, rulesToDefine[ruleId]);
      });
    }
    /**
     * Gets an object with all loaded rules.
     * @returns {Map<string, Rule>} All loaded rules
     */

  }, {
    key: "getRules",
    value: function getRules() {
      var _internalSlotsMap$get = internalSlotsMap.get(this),
          lastConfigArray = _internalSlotsMap$get.lastConfigArray,
          ruleMap = _internalSlotsMap$get.ruleMap;

      return new Map(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.delegateYield(ruleMap, "t0", 1);

              case 1:
                if (!lastConfigArray) {
                  _context.next = 3;
                  break;
                }

                return _context.delegateYield(lastConfigArray.pluginRules, "t1", 3);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })());
    }
    /**
     * Define a new parser module
     * @param {string} parserId Name of the parser
     * @param {Parser} parserModule The parser object
     * @returns {void}
     */

  }, {
    key: "defineParser",
    value: function defineParser(parserId, parserModule) {
      internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
    }
    /**
     * Performs multiple autofix passes over the text until as many fixes as possible
     * have been applied.
     * @param {string} text The source text to apply fixes to.
     * @param {ConfigData|ConfigArray} config The ESLint config object to use.
     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.
     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the
     *      SourceCodeFixer.
     */

  }, {
    key: "verifyAndFix",
    value: function verifyAndFix(text, config, options) {
      var messages = [],
          fixedResult,
          fixed = false,
          passNumber = 0,
          currentText = text;
      var debugTextDescription = options && options.filename || "".concat(text.slice(0, 10), "...");
      var shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
      /**
       * This loop continues until one of the following is true:
       *
       * 1. No more fixes have been applied.
       * 2. Ten passes have been made.
       *
       * That means anytime a fix is successfully applied, there will be another pass.
       * Essentially, guaranteeing a minimum of two passes.
       */

      do {
        passNumber++;
        debug("Linting code for ".concat(debugTextDescription, " (pass ").concat(passNumber, ")"));
        messages = this.verify(currentText, config, options);
        debug("Generating fixed text for ".concat(debugTextDescription, " (pass ").concat(passNumber, ")"));
        fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);
        /*
         * stop if there are any syntax errors.
         * 'fixedResult.output' is a empty string.
         */

        if (messages.length === 1 && messages[0].fatal) {
          break;
        } // keep track if any fixes were ever applied - important for return value


        fixed = fixed || fixedResult.fixed; // update to use the fixed output instead of the original text

        currentText = fixedResult.output;
      } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);
      /*
       * If the last result had fixes, we need to lint again to be sure we have
       * the most up-to-date information.
       */


      if (fixedResult.fixed) {
        fixedResult.messages = this.verify(currentText, config, options);
      } // ensure the last result properly reflects if fixes were done


      fixedResult.fixed = fixed;
      fixedResult.output = currentText;
      return fixedResult;
    }
  }], [{
    key: "version",
    get: function get() {
      return pkg.version;
    }
  }]);

  return Linter;
}();

module.exports = {
  Linter: Linter,

  /**
   * Get the internal slots of a given Linter instance for tests.
   * @param {Linter} instance The Linter instance to get.
   * @returns {LinterInternalSlots} The internal slots.
   */
  getLinterInternalSlots: function getLinterInternalSlots(instance) {
    return internalSlotsMap.get(instance);
  }
};