"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var p = require('path');

var resolve = require('resolve'); // const printAST = require('ast-pretty-print')


var macrosRegex = /[./]macro(\.js)?$/;

var testMacrosRegex = function testMacrosRegex(v) {
  return macrosRegex.test(v);
}; // https://stackoverflow.com/a/32749533/971592


var MacroError =
/*#__PURE__*/
function (_Error) {
  _inherits(MacroError, _Error);

  function MacroError(message) {
    var _this;

    _classCallCheck(this, MacroError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MacroError).call(this, message));
    _this.name = 'MacroError';
    /* istanbul ignore else */

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    } else if (!_this.stack) {
      _this.stack = new Error(message).stack;
    }

    return _this;
  }

  return MacroError;
}(_wrapNativeSuper(Error));

var _configExplorer = null;

function getConfigExporer() {
  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle
  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {
    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],
    packageProp: 'babelMacros'
  });
}

function createMacro(macro) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (options.configName === 'options') {
    throw new Error("You cannot use the configName \"options\". It is reserved for babel-plugin-macros.");
  }

  macroWrapper.isBabelMacro = true;
  macroWrapper.options = options;
  return macroWrapper;

  function macroWrapper(args) {
    var source = args.source,
        isBabelMacrosCall = args.isBabelMacrosCall;

    if (!isBabelMacrosCall) {
      throw new MacroError("The macro you imported from \"".concat(source, "\" is being executed outside the context of compilation with babel-plugin-macros. ") + "This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. " + "Please see the documentation for how to configure babel-plugin-macros properly: " + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');
    }

    return macro(args);
  }
}

function nodeResolvePath(source, basedir) {
  return resolve.sync(source, {
    basedir: basedir,
    // This is here to support the package being globally installed
    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138
    paths: [p.resolve(__dirname, '../../')]
  });
}

function macrosPlugin(babel) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _ref$require = _ref.require,
      _require = _ref$require === void 0 ? require : _ref$require,
      _ref$resolvePath = _ref.resolvePath,
      resolvePath = _ref$resolvePath === void 0 ? nodeResolvePath : _ref$resolvePath,
      _ref$isMacrosName = _ref.isMacrosName,
      isMacrosName = _ref$isMacrosName === void 0 ? testMacrosRegex : _ref$isMacrosName,
      options = (0, _objectWithoutPropertiesLoose2["default"])(_ref, ["require", "resolvePath", "isMacrosName"]);

  function interopRequire(path) {
    // eslint-disable-next-line import/no-dynamic-require
    var o = _require(path);

    return o && o.__esModule && o["default"] ? o["default"] : o;
  }

  return {
    name: 'macros',
    visitor: {
      Program: function Program(progPath, state) {
        progPath.traverse({
          ImportDeclaration: function ImportDeclaration(path) {
            var isMacros = looksLike(path, {
              node: {
                source: {
                  value: function value(v) {
                    return isMacrosName(v);
                  }
                }
              }
            });

            if (!isMacros) {
              return;
            }

            var imports = path.node.specifiers.map(function (s) {
              return {
                localName: s.local.name,
                importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name
              };
            });
            var source = path.node.source.value;
            var result = applyMacros({
              path: path,
              imports: imports,
              source: source,
              state: state,
              babel: babel,
              interopRequire: interopRequire,
              resolvePath: resolvePath,
              options: options
            });

            if (!result || !result.keepImports) {
              path.remove();
            }
          },
          VariableDeclaration: function VariableDeclaration(path) {
            var isMacros = function isMacros(child) {
              return looksLike(child, {
                node: {
                  init: {
                    callee: {
                      type: 'Identifier',
                      name: 'require'
                    },
                    arguments: function _arguments(args) {
                      return args.length === 1 && isMacrosName(args[0].value);
                    }
                  }
                }
              });
            };

            path.get('declarations').filter(isMacros).forEach(function (child) {
              var imports = child.node.id.name ? [{
                localName: child.node.id.name,
                importedName: 'default'
              }] : child.node.id.properties.map(function (property) {
                return {
                  localName: property.value.name,
                  importedName: property.key.name
                };
              });
              var call = child.get('init');
              var source = call.node.arguments[0].value;
              var result = applyMacros({
                path: call,
                imports: imports,
                source: source,
                state: state,
                babel: babel,
                interopRequire: interopRequire,
                resolvePath: resolvePath,
                options: options
              });

              if (!result || !result.keepImports) {
                child.remove();
              }
            });
          }
        });
      }
    }
  };
} // eslint-disable-next-line complexity


function applyMacros(_ref2) {
  var path = _ref2.path,
      imports = _ref2.imports,
      source = _ref2.source,
      state = _ref2.state,
      babel = _ref2.babel,
      interopRequire = _ref2.interopRequire,
      resolvePath = _ref2.resolvePath,
      options = _ref2.options;

  /* istanbul ignore next (pretty much only useful for astexplorer I think) */
  var _state$file$opts$file = state.file.opts.filename,
      filename = _state$file$opts$file === void 0 ? '' : _state$file$opts$file;
  var hasReferences = false;
  var referencePathsByImportName = imports.reduce(function (byName, _ref3) {
    var importedName = _ref3.importedName,
        localName = _ref3.localName;
    var binding = path.scope.getBinding(localName);
    byName[importedName] = binding.referencePaths;
    hasReferences = hasReferences || Boolean(byName[importedName].length);
    return byName;
  }, {});
  var isRelative = source.indexOf('.') === 0;
  var requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));
  var macro = interopRequire(requirePath);

  if (!macro.isBabelMacro) {
    throw new Error("The macro imported from \"".concat(source, "\" must be wrapped in \"createMacro\" ") + "which you can get from \"babel-plugin-macros\". " + "Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro");
  }

  var config = getConfig(macro, filename, source, options);
  var result;

  try {
    /**
     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is
     * put into its own replacement. Apparently babel does not update the scope after such
     * an operation. As a remedy, the whole scope is traversed again with an empty "Identifier"
     * visitor - this makes the problem go away.
     *
     * See: https://github.com/kentcdodds/import-all.macro/issues/7
     */
    state.file.scope.path.traverse({
      Identifier: function Identifier() {}
    });
    result = macro({
      references: referencePathsByImportName,
      source: source,
      state: state,
      babel: babel,
      config: config,
      isBabelMacrosCall: true
    });
  } catch (error) {
    if (error.name === 'MacroError') {
      throw error;
    }

    error.message = "".concat(source, ": ").concat(error.message);

    if (!isRelative) {
      error.message = "".concat(error.message, " Learn more: https://www.npmjs.com/package/").concat(source.replace( // remove everything after package name
      // @org/package/macro -> @org/package
      // package/macro      -> package
      /^((?:@[^/]+\/)?[^/]+).*/, '$1'));
    }

    throw error;
  }

  return result;
}

function getConfigFromFile(configName, filename) {
  try {
    var loaded = getConfigExporer().search(filename);

    if (loaded) {
      return {
        options: loaded.config[configName],
        path: loaded.filepath
      };
    }
  } catch (e) {
    return {
      error: e
    };
  }

  return {};
}

function getConfigFromOptions(configName, options) {
  if (options.hasOwnProperty(configName)) {
    if (options[configName] && _typeof(options[configName]) !== 'object') {
      // eslint-disable-next-line no-console
      console.error("The macro plugin options' ".concat(configName, " property was not an object or null."));
    } else {
      return {
        options: options[configName]
      };
    }
  }

  return {};
}

function getConfig(macro, filename, source, options) {
  var configName = macro.options.configName;

  if (configName) {
    var fileConfig = getConfigFromFile(configName, filename);
    var optionsConfig = getConfigFromOptions(configName, options);

    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {
      // eslint-disable-next-line no-console
      console.error("There was an error trying to load the config \"".concat(configName, "\" ") + "for the macro imported from \"".concat(source, ". ") + "Please see the error thrown for more information.");
      throw fileConfig.error;
    }

    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && _typeof(fileConfig.options) !== 'object') {
      throw new Error("".concat(fileConfig.path, " specified a ").concat(configName, " config of type ") + "".concat(_typeof(optionsConfig.options), ", but the the macros plugin's ") + "options.".concat(configName, " did contain an object. Both configs must ") + "contain objects for their options to be mergeable.");
    }

    return (0, _extends2["default"])({}, optionsConfig.options, {}, fileConfig.options);
  }

  return undefined;
}
/*
 istanbul ignore next
 because this is hard to test
 and not worth it...
 */


function getFullFilename(filename) {
  if (p.isAbsolute(filename)) {
    return filename;
  }

  return p.join(process.cwd(), filename);
}

function looksLike(a, b) {
  return a && b && Object.keys(b).every(function (bKey) {
    var bVal = b[bKey];
    var aVal = a[bKey];

    if (typeof bVal === 'function') {
      return bVal(aVal);
    }

    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);
  });
}

function isPrimitive(val) {
  // eslint-disable-next-line
  return val == null || /^[sbn]/.test(_typeof(val));
}

module.exports = macrosPlugin;
Object.assign(module.exports, {
  createMacro: createMacro,
  MacroError: MacroError
});