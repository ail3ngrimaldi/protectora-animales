"use strict";

exports.__esModule = true;
exports["default"] = svgoPlugin;

var _svgo = _interopRequireDefault(require("svgo"));

var _cosmiconfig = _interopRequireDefault(require("cosmiconfig"));

var _mergeDeep = _interopRequireDefault(require("merge-deep"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable no-underscore-dangle */


var explorer = (0, _cosmiconfig["default"])('svgo', {
  searchPlaces: ['package.json', '.svgorc', '.svgorc.json', '.svgorc.yaml', '.svgorc.yml', 'svgo.config.js', '.svgo.yml'],
  transform: function transform(result) {
    return result && result.config;
  },
  cache: true
});

function encodeSVGDatauri(str, type) {
  var prefix = 'data:image/svg+xml'; // base64

  if (!type || type === 'base64') {
    prefix += ';base64,';

    if (Buffer.from) {
      str = prefix + Buffer.from(str).toString('base64');
    } else {
      // eslint-disable-next-line
      str = prefix + new Buffer(str).toString('base64');
    } // URI encoded

  } else if (type === 'enc') {
    str = "".concat(prefix, ",").concat(encodeURIComponent(str)); // unencoded
  } else if (type === 'unenc') {
    str = "".concat(prefix, ",").concat(str);
  }

  return str;
} // See https://github.com/svg/svgo/blob/master/lib/svgo.js#L24
// _optimizeOnce is synchronous internally


function optimizeSync(svgstr, info) {
  var _this = this;

  var config = this.config;

  if (config.error) {
    throw config.error;
  }

  var maxPassCount = config.multipass ? 10 : 1;
  var counter = 0;
  var prevResultSize = Number.POSITIVE_INFINITY;
  var result;

  var optimizeOnceCallback = function optimizeOnceCallback(svgjs) {
    if (svgjs.error) {
      throw svgjs.error;
    } // eslint-disable-next-line no-plusplus


    if (++counter < maxPassCount && svgjs.data.length < prevResultSize) {
      prevResultSize = svgjs.data.length;

      _this._optimizeOnce(svgjs.data, info, optimizeOnceCallback);
    } else {
      if (config.datauri) {
        svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
      }

      if (info.path) {
        svgjs.path = info.path;
      }

      result = svgjs;
    }
  };

  this._optimizeOnce(svgstr, info, optimizeOnceCallback);

  return result;
}

function getBaseSvgoConfig(config) {
  var baseSvgoConfig = {
    plugins: [{
      prefixIds: true
    }]
  };
  if (config.icon || config.dimensions === false) baseSvgoConfig.plugins.push({
    removeViewBox: false
  });
  return baseSvgoConfig;
}

function getFilePath(state) {
  return state.filePath || process.cwd();
}

function createSvgo(config, rcConfig) {
  var mergedConfig = (0, _mergeDeep["default"])(getBaseSvgoConfig(config), rcConfig, config.svgoConfig);
  return new _svgo["default"](mergedConfig);
}

function getInfo(state) {
  return state.filePath ? {
    input: 'file',
    path: state.filePath
  } : {
    input: 'string'
  };
}

function svgoPlugin(code, config, state) {
  if (!config.svgo) return code;
  var filePath = getFilePath(state);
  var svgoRcConfig = config.runtimeConfig ? explorer.searchSync(filePath) : {};
  var svgo = createSvgo(config, svgoRcConfig);

  var _optimizeSync$call = optimizeSync.call(svgo, code, getInfo(state)),
      data = _optimizeSync$call.data;

  return data;
}