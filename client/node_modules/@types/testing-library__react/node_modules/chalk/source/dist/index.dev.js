'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ansiStyles = require('ansi-styles');

var _require = require('supports-color'),
    stdoutColor = _require.stdout,
    stderrColor = _require.stderr;

var _require2 = require('./util'),
    stringReplaceAll = _require2.stringReplaceAll,
    stringEncaseCRLFWithFirstIndex = _require2.stringEncaseCRLFWithFirstIndex; // `supportsColor.level` â†’ `ansiStyles.color[name]` mapping


var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
var styles = Object.create(null);

var applyOptions = function applyOptions(object) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (options.level > 3 || options.level < 0) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  } // Detect level if not set manually


  var colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};

var ChalkClass = function ChalkClass(options) {
  _classCallCheck(this, ChalkClass);

  return chalkFactory(options);
};

var chalkFactory = function chalkFactory(options) {
  var chalk = {};
  applyOptions(chalk, options);

  chalk.template = function () {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    return chalkTag.apply(void 0, [chalk.template].concat(arguments_));
  };

  Object.setPrototypeOf(chalk, Chalk.prototype);
  Object.setPrototypeOf(chalk.template, chalk);

  chalk.template.constructor = function () {
    throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
  };

  chalk.template.Instance = ChalkClass;
  return chalk.template;
};

function Chalk(options) {
  return chalkFactory(options);
}

var _loop = function _loop() {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      styleName = _Object$entries$_i[0],
      style = _Object$entries$_i[1];

  styles[styleName] = {
    get: function get() {
      var builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }
  };
};

for (var _i = 0, _Object$entries = Object.entries(ansiStyles); _i < _Object$entries.length; _i++) {
  _loop();
}

styles.visible = {
  get: function get() {
    var builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, 'visible', {
      value: builder
    });
    return builder;
  }
};
var usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

var _loop2 = function _loop2() {
  var model = _usedModels[_i2];
  styles[model] = {
    get: function get() {
      var level = this.level;
      return function () {
        var _ansiStyles$color$lev;

        var styler = createStyler((_ansiStyles$color$lev = ansiStyles.color[levelMapping[level]])[model].apply(_ansiStyles$color$lev, arguments), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
};

for (var _i2 = 0, _usedModels = usedModels; _i2 < _usedModels.length; _i2++) {
  _loop2();
}

var _loop3 = function _loop3() {
  var model = _usedModels2[_i3];
  var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get: function get() {
      var level = this.level;
      return function () {
        var _ansiStyles$bgColor$l;

        var styler = createStyler((_ansiStyles$bgColor$l = ansiStyles.bgColor[levelMapping[level]])[model].apply(_ansiStyles$bgColor$l, arguments), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
};

for (var _i3 = 0, _usedModels2 = usedModels; _i3 < _usedModels2.length; _i3++) {
  _loop3();
}

var proto = Object.defineProperties(function () {}, _objectSpread({}, styles, {
  level: {
    enumerable: true,
    get: function get() {
      return this._generator.level;
    },
    set: function set(level) {
      this._generator.level = level;
    }
  }
}));

var createStyler = function createStyler(open, close, parent) {
  var openAll;
  var closeAll;

  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }

  return {
    open: open,
    close: close,
    openAll: openAll,
    closeAll: closeAll,
    parent: parent
  };
};

var createBuilder = function createBuilder(self, _styler, _isEmpty) {
  var builder = function builder() {
    for (var _len2 = arguments.length, arguments_ = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      arguments_[_key2] = arguments[_key2];
    }

    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  }; // `__proto__` is used because we must return a function, but there is
  // no way to create a function with a different prototype


  builder.__proto__ = proto; // eslint-disable-line no-proto

  builder._generator = self;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};

var applyStyle = function applyStyle(self, string) {
  if (self.level <= 0 || !string) {
    return self._isEmpty ? '' : string;
  }

  var styler = self._styler;

  if (styler === undefined) {
    return string;
  }

  var _styler2 = styler,
      openAll = _styler2.openAll,
      closeAll = _styler2.closeAll;

  if (string.indexOf("\x1B") !== -1) {
    while (styler !== undefined) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  } // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92


  var lfIndex = string.indexOf('\n');

  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }

  return openAll + string + closeAll;
};

var template;

var chalkTag = function chalkTag(chalk) {
  for (var _len3 = arguments.length, strings = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    strings[_key3 - 1] = arguments[_key3];
  }

  var firstString = strings[0];

  if (!Array.isArray(firstString)) {
    // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return strings.join(' ');
  }

  var arguments_ = strings.slice(1);
  var parts = [firstString.raw[0]];

  for (var i = 1; i < firstString.length; i++) {
    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
  }

  if (template === undefined) {
    template = require('./templates');
  }

  return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);
var chalk = Chalk(); // eslint-disable-line new-cap

chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({
  level: stderrColor ? stderrColor.level : 0
}); // eslint-disable-line new-cap

chalk.stderr.supportsColor = stderrColor; // For TypeScript

chalk.Level = {
  None: 0,
  Basic: 1,
  Ansi256: 2,
  TrueColor: 3,
  0: 'None',
  1: 'Basic',
  2: 'Ansi256',
  3: 'TrueColor'
};
module.exports = chalk;