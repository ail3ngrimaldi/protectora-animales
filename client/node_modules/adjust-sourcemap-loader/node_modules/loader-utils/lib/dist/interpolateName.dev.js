'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = require('path');

var emojisList = require('emojis-list');

var getHashDigest = require('./getHashDigest');

var emojiRegex = /[\uD800-\uDFFF]./;
var emojiList = emojisList.filter(function (emoji) {
  return emojiRegex.test(emoji);
});
var emojiCache = {};

function encodeStringToEmoji(content, length) {
  if (emojiCache[content]) {
    return emojiCache[content];
  }

  length = length || 1;
  var emojis = [];

  do {
    if (!emojiList.length) {
      throw new Error('Ran out of emoji');
    }

    var index = Math.floor(Math.random() * emojiList.length);
    emojis.push(emojiList[index]);
    emojiList.splice(index, 1);
  } while (--length > 0);

  var emojiEncoding = emojis.join('');
  emojiCache[content] = emojiEncoding;
  return emojiEncoding;
}

function interpolateName(loaderContext, name, options) {
  var filename;

  if (typeof name === 'function') {
    filename = name(loaderContext.resourcePath);
  } else {
    filename = name || '[hash].[ext]';
  }

  var context = options.context;
  var content = options.content;
  var regExp = options.regExp;
  var ext = 'bin';
  var basename = 'file';
  var directory = '';
  var folder = '';

  if (loaderContext.resourcePath) {
    var parsed = path.parse(loaderContext.resourcePath);
    var resourcePath = loaderContext.resourcePath;

    if (parsed.ext) {
      ext = parsed.ext.substr(1);
    }

    if (parsed.dir) {
      basename = parsed.name;
      resourcePath = parsed.dir + path.sep;
    }

    if (typeof context !== 'undefined') {
      directory = path.relative(context, resourcePath + '_').replace(/\\/g, '/').replace(/\.\.(\/)?/g, '_$1');
      directory = directory.substr(0, directory.length - 1);
    } else {
      directory = resourcePath.replace(/\\/g, '/').replace(/\.\.(\/)?/g, '_$1');
    }

    if (directory.length === 1) {
      directory = '';
    } else if (directory.length > 1) {
      folder = path.basename(directory);
    }
  }

  var url = filename;

  if (content) {
    // Match hash template
    url = url // `hash` and `contenthash` are same in `loader-utils` context
    // let's keep `hash` for backward compatibility
    .replace(/\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, function (all, hashType, digestType, maxLength) {
      return getHashDigest(content, hashType, digestType, parseInt(maxLength, 10));
    }).replace(/\[emoji(?::(\d+))?\]/gi, function (all, length) {
      return encodeStringToEmoji(content, parseInt(length, 10));
    });
  }

  url = url.replace(/\[ext\]/gi, function () {
    return ext;
  }).replace(/\[name\]/gi, function () {
    return basename;
  }).replace(/\[path\]/gi, function () {
    return directory;
  }).replace(/\[folder\]/gi, function () {
    return folder;
  });

  if (regExp && loaderContext.resourcePath) {
    var match = loaderContext.resourcePath.match(new RegExp(regExp));
    match && match.forEach(function (matched, i) {
      url = url.replace(new RegExp('\\[' + i + '\\]', 'ig'), matched);
    });
  }

  if (_typeof(loaderContext.options) === 'object' && typeof loaderContext.options.customInterpolateName === 'function') {
    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);
  }

  return url;
}

module.exports = interpolateName;