"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.registerFirestore=registerFirestore;var _app=_interopRequireDefault(require("@firebase/app"));var _logger=require("@firebase/logger");var _util=require("util");var _crypto=require("crypto");var _protoLoader=require("@grpc/proto-loader");var _grpcJs=require("@grpc/grpc-js");var _path2=require("path");var _package=require("@grpc/grpc-js/package.json");var _component=require("@firebase/component");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj};}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance");}function _iterableToArrayLimit(arr,i){if(!(Symbol.iterator in Object(arr)||Object.prototype.toString.call(arr)==="[object Arguments]")){return;}var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _get(target,property,receiver){if(typeof Reflect!=="undefined"&&Reflect.get){_get=Reflect.get;}else{_get=function _get(target,property,receiver){var base=_superPropBase(target,property);if(!base)return;var desc=Object.getOwnPropertyDescriptor(base,property);if(desc.get){return desc.get.call(receiver);}return desc.value;};}return _get(target,property,receiver||target);}function _superPropBase(object,property){while(!Object.prototype.hasOwnProperty.call(object,property)){object=_getPrototypeOf(object);if(object===null)break;}return object;}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}}function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass);}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class);};return _wrapNativeSuper(Class);}function isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct;}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf(instance,Class.prototype);return instance;};}return _construct.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1;}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Code={// Causes are copied from:
// https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
/** Not an error; returned on success. */OK:'ok',/** The operation was cancelled (typically by the caller). */CANCELLED:'cancelled',/** Unknown error or an error from a different error domain. */UNKNOWN:'unknown',/**
     * Client specified an invalid argument. Note that this differs from
     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
     * problematic regardless of the state of the system (e.g., a malformed file
     * name).
     */INVALID_ARGUMENT:'invalid-argument',/**
     * Deadline expired before operation could complete. For operations that
     * change the state of the system, this error may be returned even if the
     * operation has completed successfully. For example, a successful response
     * from a server could have been delayed long enough for the deadline to
     * expire.
     */DEADLINE_EXCEEDED:'deadline-exceeded',/** Some requested entity (e.g., file or directory) was not found. */NOT_FOUND:'not-found',/**
     * Some entity that we attempted to create (e.g., file or directory) already
     * exists.
     */ALREADY_EXISTS:'already-exists',/**
     * The caller does not have permission to execute the specified operation.
     * PERMISSION_DENIED must not be used for rejections caused by exhausting
     * some resource (use RESOURCE_EXHAUSTED instead for those errors).
     * PERMISSION_DENIED must not be used if the caller can not be identified
     * (use UNAUTHENTICATED instead for those errors).
     */PERMISSION_DENIED:'permission-denied',/**
     * The request does not have valid authentication credentials for the
     * operation.
     */UNAUTHENTICATED:'unauthenticated',/**
     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
     * entire file system is out of space.
     */RESOURCE_EXHAUSTED:'resource-exhausted',/**
     * Operation was rejected because the system is not in a state required for
     * the operation's execution. For example, directory to be deleted may be
     * non-empty, an rmdir operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *  (a) Use UNAVAILABLE if the client can retry just the failing call.
     *  (b) Use ABORTED if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FAILED_PRECONDITION if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FAILED_PRECONDITION
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FAILED_PRECONDITION if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     */FAILED_PRECONDITION:'failed-precondition',/**
     * The operation was aborted, typically due to a concurrency issue like
     * sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
     * and UNAVAILABLE.
     */ABORTED:'aborted',/**
     * Operation was attempted past the valid range. E.g., seeking or reading
     * past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
     * if the system state changes. For example, a 32-bit file system will
     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
     * an offset past the current file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
     * when it applies so that callers who are iterating through a space can
     * easily look for an OUT_OF_RANGE error to detect when they are done.
     */OUT_OF_RANGE:'out-of-range',/** Operation is not implemented or not supported/enabled in this service. */UNIMPLEMENTED:'unimplemented',/**
     * Internal errors. Means some invariants expected by underlying System has
     * been broken. If you see one of these errors, Something is very broken.
     */INTERNAL:'internal',/**
     * The service is currently unavailable. This is a most likely a transient
     * condition and may be corrected by retrying with a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
     * and UNAVAILABLE.
     */UNAVAILABLE:'unavailable',/** Unrecoverable data loss or corruption. */DATA_LOSS:'data-loss'};/** An error returned by a Firestore operation. */var FirestoreError=/*#__PURE__*/function(_Error){_inherits(FirestoreError,_Error);function FirestoreError(code,message){var _this;_classCallCheck(this,FirestoreError);_this=_possibleConstructorReturn(this,_getPrototypeOf(FirestoreError).call(this,message));_this.code=code;_this.message=message;_this.name='FirebaseError';// HACK: We write a toString property directly because Error is not a real
// class and so inheritance does not work correctly. We could alternatively
// do the same "back-door inheritance" trick that FirebaseError does.
_this.toString=function(){return"".concat(_this.name,": [code=").concat(_this.code,"]: ").concat(_this.message);};return _this;}return FirestoreError;}(_wrapNativeSuper(Error));/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function decodeBase64(encoded){// Node actually doesn't validate base64 strings.
// A quick sanity check that is not a fool-proof validation
if(/[^-A-Za-z0-9+/=]/.test(encoded)){throw new FirestoreError(Code.INVALID_ARGUMENT,'Not a valid Base64 string: '+encoded);}return new Buffer(encoded,'base64').toString('binary');}/** Converts a binary string to a Base64 encoded string. */function encodeBase64(raw){return new Buffer(raw,'binary').toString('base64');}var version="7.22.0";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Formats an object as a JSON string, suitable for logging. */function formatJSON(value){// util.inspect() results in much more readable output than JSON.stringify()
return(0,_util.inspect)(value,{depth:100});}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var logClient=new _logger.Logger('@firebase/firestore');// Helper methods are needed because variables can't be exported as read/write
function getLogLevel(){return logClient.logLevel;}/**
 * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).
 *
 * @param logLevel
 *   The verbosity you set for activity and error logging. Can be any of
 *   the following values:
 *
 *   <ul>
 *     <li>`debug` for the most verbose logging level, primarily for
 *     debugging.</li>
 *     <li>`error` to log errors only.</li>
 *     <li><code>`silent` to turn off logging.</li>
 *   </ul>
 */function _setLogLevel(logLevel){logClient.setLogLevel(logLevel);}function logDebug(msg){if(logClient.logLevel<=_logger.LogLevel.DEBUG){for(var _len=arguments.length,obj=new Array(_len>1?_len-1:0),_key2=1;_key2<_len;_key2++){obj[_key2-1]=arguments[_key2];}var args=obj.map(argToString);logClient.debug.apply(logClient,["Firestore (".concat(version,"): ").concat(msg)].concat(_toConsumableArray(args)));}}function logError(msg){if(logClient.logLevel<=_logger.LogLevel.ERROR){for(var _len2=arguments.length,obj=new Array(_len2>1?_len2-1:0),_key3=1;_key3<_len2;_key3++){obj[_key3-1]=arguments[_key3];}var args=obj.map(argToString);logClient.error.apply(logClient,["Firestore (".concat(version,"): ").concat(msg)].concat(_toConsumableArray(args)));}}function logWarn(msg){if(logClient.logLevel<=_logger.LogLevel.WARN){for(var _len3=arguments.length,obj=new Array(_len3>1?_len3-1:0),_key4=1;_key4<_len3;_key4++){obj[_key4-1]=arguments[_key4];}var args=obj.map(argToString);logClient.warn.apply(logClient,["Firestore (".concat(version,"): ").concat(msg)].concat(_toConsumableArray(args)));}}/**
 * Converts an additional log parameter to a string representation.
 */function argToString(obj){if(typeof obj==='string'){return obj;}else{try{return formatJSON(obj);}catch(e){// Converting to JSON failed, just log the object directly
return obj;}}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Unconditionally fails, throwing an Error with the given message.
 * Messages are stripped in production builds.
 *
 * Returns `never` and can be used in expressions:
 * @example
 * let futureVar = fail('not implemented yet');
 */function fail(){var failure=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'Unexpected state';// Log the failure in addition to throw an exception, just in case the
// exception is swallowed.
var message="FIRESTORE (".concat(version,") INTERNAL ASSERTION FAILED: ")+failure;logError(message);// NOTE: We don't use FirestoreError here because these are internal failures
// that cannot be handled by the user. (Also it would create a circular
// dependency between the error and assert modules which doesn't work.)
throw new Error(message);}/**
 * Fails if the given assertion condition is false, throwing an Error with the
 * given message if it did.
 *
 * Messages are stripped in production builds.
 */function hardAssert(assertion,message){if(!assertion){fail();}}/**
 * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an
 * instance of `T` before casting.
 */function debugCast(obj,// eslint-disable-next-line @typescript-eslint/no-explicit-any
constructor){return obj;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function objectSize(obj){var count=0;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){count++;}}return count;}function _forEach(obj,fn){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){fn(key,obj[key]);}}}function _isEmpty(obj){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){return false;}}return true;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DOCUMENT_KEY_NAME='__name__';/**
 * Path represents an ordered sequence of string segments.
 */var BasePath=/*#__PURE__*/function(){function BasePath(segments,offset,length){_classCallCheck(this,BasePath);if(offset===undefined){offset=0;}else if(offset>segments.length){fail();}if(length===undefined){length=segments.length-offset;}else if(length>segments.length-offset){fail();}this.segments=segments;this.offset=offset;this.len=length;}_createClass(BasePath,[{key:"isEqual",value:function isEqual(other){return BasePath.comparator(this,other)===0;}},{key:"child",value:function child(nameOrPath){var segments=this.segments.slice(this.offset,this.limit());if(nameOrPath instanceof BasePath){nameOrPath.forEach(function(segment){segments.push(segment);});}else{segments.push(nameOrPath);}return this.construct(segments);}/** The index of one past the last segment of the path. */},{key:"limit",value:function limit(){return this.offset+this.length;}},{key:"popFirst",value:function popFirst(size){size=size===undefined?1:size;return this.construct(this.segments,this.offset+size,this.length-size);}},{key:"popLast",value:function popLast(){return this.construct(this.segments,this.offset,this.length-1);}},{key:"firstSegment",value:function firstSegment(){return this.segments[this.offset];}},{key:"lastSegment",value:function lastSegment(){return this.get(this.length-1);}},{key:"get",value:function get(index){return this.segments[this.offset+index];}},{key:"isEmpty",value:function isEmpty(){return this.length===0;}},{key:"isPrefixOf",value:function isPrefixOf(other){if(other.length<this.length){return false;}for(var i=0;i<this.length;i++){if(this.get(i)!==other.get(i)){return false;}}return true;}},{key:"isImmediateParentOf",value:function isImmediateParentOf(potentialChild){if(this.length+1!==potentialChild.length){return false;}for(var i=0;i<this.length;i++){if(this.get(i)!==potentialChild.get(i)){return false;}}return true;}},{key:"forEach",value:function forEach(fn){for(var i=this.offset,end=this.limit();i<end;i++){fn(this.segments[i]);}}},{key:"toArray",value:function toArray(){return this.segments.slice(this.offset,this.limit());}},{key:"length",get:function get(){return this.len;}}],[{key:"comparator",value:function comparator(p1,p2){var len=Math.min(p1.length,p2.length);for(var i=0;i<len;i++){var left=p1.get(i);var right=p2.get(i);if(left<right){return-1;}if(left>right){return 1;}}if(p1.length<p2.length){return-1;}if(p1.length>p2.length){return 1;}return 0;}}]);return BasePath;}();/**
 * A slash-separated path for navigating resources (documents and collections)
 * within Firestore.
 */var ResourcePath=/*#__PURE__*/function(_BasePath){_inherits(ResourcePath,_BasePath);function ResourcePath(){_classCallCheck(this,ResourcePath);return _possibleConstructorReturn(this,_getPrototypeOf(ResourcePath).apply(this,arguments));}_createClass(ResourcePath,[{key:"construct",value:function construct(segments,offset,length){return new ResourcePath(segments,offset,length);}},{key:"canonicalString",value:function canonicalString(){// NOTE: The client is ignorant of any path segments containing escape
// sequences (e.g. __id123__) and just passes them through raw (they exist
// for legacy reasons and should not be used frequently).
return this.toArray().join('/');}},{key:"toString",value:function toString(){return this.canonicalString();}/**
     * Creates a resource path from the given slash-delimited string. If multiple
     * arguments are provided, all components are combined. Leading and trailing
     * slashes from all components are ignored.
     */}],[{key:"fromString",value:function fromString(){// NOTE: The client is ignorant of any path segments containing escape
// sequences (e.g. __id123__) and just passes them through raw (they exist
// for legacy reasons and should not be used frequently).
var segments=[];for(var _len4=arguments.length,pathComponents=new Array(_len4),_key5=0;_key5<_len4;_key5++){pathComponents[_key5]=arguments[_key5];}for(var _i=0,_pathComponents=pathComponents;_i<_pathComponents.length;_i++){var path=_pathComponents[_i];if(path.indexOf('//')>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid segment (".concat(path,"). Paths must not contain // in them."));}// Strip leading and traling slashed.
segments.push.apply(segments,_toConsumableArray(path.split('/').filter(function(segment){return segment.length>0;})));}return new ResourcePath(segments);}},{key:"emptyPath",value:function emptyPath(){return new ResourcePath([]);}}]);return ResourcePath;}(BasePath);var identifierRegExp=/^[_a-zA-Z][_a-zA-Z0-9]*$/;/** A dot-separated path for navigating sub-objects within a document. */var FieldPath=/*#__PURE__*/function(_BasePath2){_inherits(FieldPath,_BasePath2);function FieldPath(){_classCallCheck(this,FieldPath);return _possibleConstructorReturn(this,_getPrototypeOf(FieldPath).apply(this,arguments));}_createClass(FieldPath,[{key:"construct",value:function construct(segments,offset,length){return new FieldPath(segments,offset,length);}/**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */},{key:"canonicalString",value:function canonicalString(){return this.toArray().map(function(str){str=str.replace('\\','\\\\').replace('`','\\`');if(!FieldPath.isValidIdentifier(str)){str='`'+str+'`';}return str;}).join('.');}},{key:"toString",value:function toString(){return this.canonicalString();}/**
     * Returns true if this field references the key of a document.
     */},{key:"isKeyField",value:function isKeyField(){return this.length===1&&this.get(0)===DOCUMENT_KEY_NAME;}/**
     * The field designating the key of a document.
     */}],[{key:"isValidIdentifier",value:function isValidIdentifier(segment){return identifierRegExp.test(segment);}},{key:"keyField",value:function keyField(){return new FieldPath([DOCUMENT_KEY_NAME]);}/**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */},{key:"fromServerFormat",value:function fromServerFormat(path){var segments=[];var current='';var i=0;var addCurrentSegment=function addCurrentSegment(){if(current.length===0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field path (".concat(path,"). Paths must not be empty, begin ")+"with '.', end with '.', or contain '..'");}segments.push(current);current='';};var inBackticks=false;while(i<path.length){var c=path[i];if(c==='\\'){if(i+1===path.length){throw new FirestoreError(Code.INVALID_ARGUMENT,'Path has trailing escape character: '+path);}var next=path[i+1];if(!(next==='\\'||next==='.'||next==='`')){throw new FirestoreError(Code.INVALID_ARGUMENT,'Path has invalid escape sequence: '+path);}current+=next;i+=2;}else if(c==='`'){inBackticks=!inBackticks;i++;}else if(c==='.'&&!inBackticks){addCurrentSegment();i++;}else{current+=c;i++;}}addCurrentSegment();if(inBackticks){throw new FirestoreError(Code.INVALID_ARGUMENT,'Unterminated ` in path: '+path);}return new FieldPath(segments);}},{key:"emptyPath",value:function emptyPath(){return new FieldPath([]);}}]);return FieldPath;}(BasePath);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DocumentKey=/*#__PURE__*/function(){function DocumentKey(path){_classCallCheck(this,DocumentKey);this.path=path;}_createClass(DocumentKey,[{key:"hasCollectionId",/** Returns true if the document is in the specified collectionId. */value:function hasCollectionId(collectionId){return this.path.length>=2&&this.path.get(this.path.length-2)===collectionId;}},{key:"isEqual",value:function isEqual(other){return other!==null&&ResourcePath.comparator(this.path,other.path)===0;}},{key:"toString",value:function toString(){return this.path.toString();}}],[{key:"fromPath",value:function fromPath(path){return new DocumentKey(ResourcePath.fromString(path));}},{key:"fromName",value:function fromName(name){return new DocumentKey(ResourcePath.fromString(name).popFirst(5));}},{key:"comparator",value:function comparator(k1,k2){return ResourcePath.comparator(k1.path,k2.path);}},{key:"isDocumentKey",value:function isDocumentKey(path){return path.length%2===0;}/**
     * Creates and returns a new document key with the given segments.
     *
     * @param segments The segments of the path to the document
     * @return A new instance of DocumentKey
     */},{key:"fromSegments",value:function fromSegments(segments){return new DocumentKey(new ResourcePath(segments.slice()));}}]);return DocumentKey;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Validates that no arguments were passed in the invocation of functionName.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateNoArgs('myFunction', arguments);
 */function validateNoArgs(functionName,args){if(args.length!==0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() does not support arguments, ")+'but was called with '+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the invocation of functionName has the exact number of arguments.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateExactNumberOfArgs('myFunction', arguments, 2);
 */function validateExactNumberOfArgs(functionName,args,numberOfArgs){if(args.length!==numberOfArgs){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires ")+formatPlural(numberOfArgs,'argument')+', but was called with '+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the invocation of functionName has at least the provided number of
 * arguments (but can have many more).
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateAtLeastNumberOfArgs('myFunction', arguments, 2);
 */function validateAtLeastNumberOfArgs(functionName,args,minNumberOfArgs){if(args.length<minNumberOfArgs){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires at least ")+formatPlural(minNumberOfArgs,'argument')+', but was called with '+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the invocation of functionName has number of arguments between
 * the values provided.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);
 */function validateBetweenNumberOfArgs(functionName,args,minNumberOfArgs,maxNumberOfArgs){if(args.length<minNumberOfArgs||args.length>maxNumberOfArgs){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires between ").concat(minNumberOfArgs," and ")+"".concat(maxNumberOfArgs," arguments, but was called with ")+formatPlural(args.length,'argument')+'.');}}/**
 * Validates the provided argument is an array and has as least the expected
 * number of elements.
 */function validateNamedArrayAtLeastNumberOfElements(functionName,value,name,minNumberOfElements){if(!(value instanceof Array)||value.length<minNumberOfElements){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires its ").concat(name," argument to be an ")+'array with at least '+"".concat(formatPlural(minNumberOfElements,'element'),"."));}}/**
 * Validates the provided positional argument has the native JavaScript type
 * using typeof checks.
 */function validateArgType(functionName,type,position,argument){validateType(functionName,type,"".concat(ordinal(position)," argument"),argument);}/**
 * Validates the provided argument has the native JavaScript type using
 * typeof checks or is undefined.
 */function validateOptionalArgType(functionName,type,position,argument){if(argument!==undefined){validateArgType(functionName,type,position,argument);}}/**
 * Validates the provided named option has the native JavaScript type using
 * typeof checks.
 */function validateNamedType(functionName,type,optionName,argument){validateType(functionName,type,"".concat(optionName," option"),argument);}/**
 * Validates the provided named option has the native JavaScript type using
 * typeof checks or is undefined.
 */function validateNamedOptionalType(functionName,type,optionName,argument){if(argument!==undefined){validateNamedType(functionName,type,optionName,argument);}}function validateArrayElements(functionName,optionName,typeDescription,argument,validator){if(!(argument instanceof Array)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires its ").concat(optionName," ")+"option to be an array, but it was: ".concat(valueDescription(argument)));}for(var i=0;i<argument.length;++i){if(!validator(argument[i])){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires all ").concat(optionName," ")+"elements to be ".concat(typeDescription,", but the value at index ").concat(i," ")+"was: ".concat(valueDescription(argument[i])));}}}function validateOptionalArrayElements(functionName,optionName,typeDescription,argument,validator){if(argument!==undefined){validateArrayElements(functionName,optionName,typeDescription,argument,validator);}}/**
 * Validates that the provided named option equals one of the expected values.
 */function validateNamedPropertyEquals(functionName,inputName,optionName,input,expected){var expectedDescription=[];var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=expected[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var val=_step.value;if(val===input){return;}expectedDescription.push(valueDescription(val));}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator["return"]!=null){_iterator["return"]();}}finally{if(_didIteratorError){throw _iteratorError;}}}var actualDescription=valueDescription(input);throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid value ".concat(actualDescription," provided to function ").concat(functionName,"() for option ")+"\"".concat(optionName,"\". Acceptable values: ").concat(expectedDescription.join(', ')));}/**
 * Validates that the provided named option equals one of the expected values or
 * is undefined.
 */function validateNamedOptionalPropertyEquals(functionName,inputName,optionName,input,expected){if(input!==undefined){validateNamedPropertyEquals(functionName,inputName,optionName,input,expected);}}/**
 * Validates that the provided argument is a valid enum.
 *
 * @param functionName Function making the validation call.
 * @param enums Array containing all possible values for the enum.
 * @param position Position of the argument in `functionName`.
 * @param argument Argument to validate.
 * @return The value as T if the argument can be converted.
 */function validateStringEnum(functionName,enums,position,argument){if(!enums.some(function(element){return element===argument;})){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid value ".concat(valueDescription(argument)," provided to function ")+"".concat(functionName,"() for its ").concat(ordinal(position)," argument. Acceptable ")+"values: ".concat(enums.join(', ')));}return argument;}/** Helper to validate the type of a provided input. */function validateType(functionName,type,inputName,input){var valid=false;if(type==='object'){valid=isPlainObject(input);}else if(type==='non-empty string'){valid=typeof input==='string'&&input!=='';}else{valid=_typeof(input)===type;}if(!valid){var description=valueDescription(input);throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires its ").concat(inputName," ")+"to be of type ".concat(type,", but it was: ").concat(description));}}/**
 * Returns true if it's a non-null object without a custom prototype
 * (i.e. excludes Array, Date, etc.).
 */function isPlainObject(input){return _typeof(input)==='object'&&input!==null&&(Object.getPrototypeOf(input)===Object.prototype||Object.getPrototypeOf(input)===null);}/** Returns a string describing the type / value of the provided input. */function valueDescription(input){if(input===undefined){return'undefined';}else if(input===null){return'null';}else if(typeof input==='string'){if(input.length>20){input="".concat(input.substring(0,20),"...");}return JSON.stringify(input);}else if(typeof input==='number'||typeof input==='boolean'){return''+input;}else if(_typeof(input)==='object'){if(input instanceof Array){return'an array';}else{var customObjectName=tryGetCustomObjectType(input);if(customObjectName){return"a custom ".concat(customObjectName," object");}else{return'an object';}}}else if(typeof input==='function'){return'a function';}else{return fail();}}/** Hacky method to try to get the constructor name for an object. */function tryGetCustomObjectType(input){if(input.constructor){var funcNameRegex=/function\s+([^\s(]+)\s*\(/;var results=funcNameRegex.exec(input.constructor.toString());if(results&&results.length>1){return results[1];}}return null;}/** Validates the provided argument is defined. */function validateDefined(functionName,position,argument){if(argument===undefined){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires a valid ").concat(ordinal(position)," ")+"argument, but it was undefined.");}}/**
 * Validates the provided positional argument is an object, and its keys and
 * values match the expected keys and types provided in optionTypes.
 */function validateOptionNames(functionName,options,optionNames){_forEach(options,function(key,_){if(optionNames.indexOf(key)<0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Unknown option '".concat(key,"' passed to function ").concat(functionName,"(). ")+'Available options: '+optionNames.join(', '));}});}/**
 * Helper method to throw an error that the provided argument did not pass
 * an instanceof check.
 */function invalidClassError(functionName,type,position,argument){var description=valueDescription(argument);return new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires its ").concat(ordinal(position)," ")+"argument to be a ".concat(type,", but it was: ").concat(description));}function validatePositiveNumber(functionName,position,n){if(n<=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(functionName,"() requires its ").concat(ordinal(position)," argument to be a positive number, but it was: ").concat(n,"."));}}/** Converts a number to its english word representation */function ordinal(num){switch(num){case 1:return'first';case 2:return'second';case 3:return'third';default:return num+'th';}}/**
 * Formats the given word as plural conditionally given the preceding number.
 */function formatPlural(num,str){return"".concat(num," ").concat(str)+(num===1?'':'s');}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Generates `nBytes` of random bytes.
 *
 * If `nBytes < 0` , an error will be thrown.
 */function randomBytes(nBytes){return(0,_crypto.randomBytes)(nBytes);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var AutoId=/*#__PURE__*/function(){function AutoId(){_classCallCheck(this,AutoId);}_createClass(AutoId,null,[{key:"newId",value:function newId(){// Alphanumeric characters
var chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';// The largest byte value that is a multiple of `char.length`.
var maxMultiple=Math.floor(256/chars.length)*chars.length;var autoId='';var targetLength=20;while(autoId.length<targetLength){var bytes=randomBytes(40);for(var i=0;i<bytes.length;++i){// Only accept values that are [0, maxMultiple), this ensures they can
// be evenly mapped to indices of `chars` via a modulo operation.
if(autoId.length<targetLength&&bytes[i]<maxMultiple){autoId+=chars.charAt(bytes[i]%chars.length);}}}return autoId;}}]);return AutoId;}();function primitiveComparator(left,right){if(left<right){return-1;}if(left>right){return 1;}return 0;}/** Helper to compare arrays using isEqual(). */function arrayEquals(left,right,comparator){if(left.length!==right.length){return false;}return left.every(function(value,index){return comparator(value,right[index]);});}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Immutable class that represents a "proto" byte string.
 *
 * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when
 * sent on the wire. This class abstracts away this differentiation by holding
 * the proto byte string in a common class that must be converted into a string
 * before being sent as a proto.
 */var ByteString=/*#__PURE__*/function(){function ByteString(binaryString){_classCallCheck(this,ByteString);this.binaryString=binaryString;}_createClass(ByteString,[{key:"toBase64",value:function toBase64(){return encodeBase64(this.binaryString);}},{key:"toUint8Array",value:function toUint8Array(){return uint8ArrayFromBinaryString(this.binaryString);}},{key:"approximateByteSize",value:function approximateByteSize(){return this.binaryString.length*2;}},{key:"compareTo",value:function compareTo(other){return primitiveComparator(this.binaryString,other.binaryString);}},{key:"isEqual",value:function isEqual(other){return this.binaryString===other.binaryString;}}],[{key:"fromBase64String",value:function fromBase64String(base64){var binaryString=decodeBase64(base64);return new ByteString(binaryString);}},{key:"fromUint8Array",value:function fromUint8Array(array){var binaryString=binaryStringFromUint8Array(array);return new ByteString(binaryString);}}]);return ByteString;}();ByteString.EMPTY_BYTE_STRING=new ByteString('');/**
 * Helper function to convert an Uint8array to a binary string.
 */function binaryStringFromUint8Array(array){var binaryString='';for(var i=0;i<array.length;++i){binaryString+=String.fromCharCode(array[i]);}return binaryString;}/**
 * Helper function to convert a binary string to an Uint8Array.
 */function uint8ArrayFromBinaryString(binaryString){var buffer=new Uint8Array(binaryString.length);for(var i=0;i<binaryString.length;i++){buffer[i]=binaryString.charCodeAt(i);}return buffer;}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An immutable object representing an array of bytes.
 */var Bytes=/*#__PURE__*/function(){function Bytes(byteString){_classCallCheck(this,Bytes);this._byteString=byteString;}/**
     * Creates a new `Bytes` object from the given Base64 string, converting it to
     * bytes.
     *
     * @param base64 The Base64 string used to create the `Bytes` object.
     */_createClass(Bytes,[{key:"toBase64",/**
     * Returns the underlying bytes as a Base64-encoded string.
     *
     * @return The Base64-encoded string created from the `Bytes` object.
     */value:function toBase64(){return this._byteString.toBase64();}/**
     * Returns the underlying bytes in a new `Uint8Array`.
     *
     * @return The Uint8Array created from the `Bytes` object.
     */},{key:"toUint8Array",value:function toUint8Array(){return this._byteString.toUint8Array();}/**
     * Returns a string representation of the `Bytes` object.
     *
     * @return A string representation of the `Bytes` object.
     */},{key:"toString",value:function toString(){return'Bytes(base64: '+this.toBase64()+')';}/**
     * Returns true if this `Bytes` object is equal to the provided one.
     *
     * @param other The `Bytes` object to compare against.
     * @return true if this `Bytes` object is equal to the provided one.
     */},{key:"isEqual",value:function isEqual(other){return this._byteString.isEqual(other._byteString);}}],[{key:"fromBase64String",value:function fromBase64String(base64){try{return new Bytes(ByteString.fromBase64String(base64));}catch(e){throw new FirestoreError(Code.INVALID_ARGUMENT,'Failed to construct Bytes from Base64 string: '+e);}}/**
     * Creates a new `Bytes` object from the given Uint8Array.
     *
     * @param array The Uint8Array used to create the `Bytes` object.
     */},{key:"fromUint8Array",value:function fromUint8Array(array){return new Bytes(ByteString.fromUint8Array(array));}}]);return Bytes;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Helper function to assert Uint8Array is available at runtime. */function assertUint8ArrayAvailable(){if(typeof Uint8Array==='undefined'){throw new FirestoreError(Code.UNIMPLEMENTED,'Uint8Arrays are not available in this environment.');}}/**
 * Immutable class holding a blob (binary data).
 *
 * This class is directly exposed in the public API. It extends the Bytes class
 * of the firestore-exp API to support `instanceof Bytes` checks during user
 * data conversion.
 *
 * Note that while you can't hide the constructor in JavaScript code, we are
 * using the hack above to make sure no-one outside this module can call it.
 */var Blob=/*#__PURE__*/function(_Bytes){_inherits(Blob,_Bytes);function Blob(){_classCallCheck(this,Blob);return _possibleConstructorReturn(this,_getPrototypeOf(Blob).apply(this,arguments));}_createClass(Blob,[{key:"toBase64",value:function toBase64(){validateExactNumberOfArgs('Blob.toBase64',arguments,0);return _get(_getPrototypeOf(Blob.prototype),"toBase64",this).call(this);}},{key:"toUint8Array",value:function toUint8Array(){validateExactNumberOfArgs('Blob.toUint8Array',arguments,0);assertUint8ArrayAvailable();return _get(_getPrototypeOf(Blob.prototype),"toUint8Array",this).call(this);}},{key:"toString",value:function toString(){return'Blob(base64: '+this.toBase64()+')';}}],[{key:"fromBase64String",value:function fromBase64String(base64){validateExactNumberOfArgs('Blob.fromBase64String',arguments,1);validateArgType('Blob.fromBase64String','string',1,base64);try{return new Blob(ByteString.fromBase64String(base64));}catch(e){throw new FirestoreError(Code.INVALID_ARGUMENT,'Failed to construct Blob from Base64 string: '+e);}}},{key:"fromUint8Array",value:function fromUint8Array(array){validateExactNumberOfArgs('Blob.fromUint8Array',arguments,1);assertUint8ArrayAvailable();if(!(array instanceof Uint8Array)){throw invalidClassError('Blob.fromUint8Array','Uint8Array',1,array);}return new Blob(ByteString.fromUint8Array(array));}}]);return Blob;}(Bytes);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DatabaseInfo=/**
     * Constructs a DatabaseInfo using the provided host, databaseId and
     * persistenceKey.
     *
     * @param databaseId The database to use.
     * @param persistenceKey A unique identifier for this Firestore's local
     * storage (used in conjunction with the databaseId).
     * @param host The Firestore backend host to connect to.
     * @param ssl Whether to use SSL when connecting.
     * @param forceLongPolling Whether to use the forceLongPolling option
     * when using WebChannel as the network transport.
     */function DatabaseInfo(databaseId,persistenceKey,host,ssl,forceLongPolling){_classCallCheck(this,DatabaseInfo);this.databaseId=databaseId;this.persistenceKey=persistenceKey;this.host=host;this.ssl=ssl;this.forceLongPolling=forceLongPolling;};/** The default database name for a project. */var DEFAULT_DATABASE_NAME='(default)';/** Represents the database ID a Firestore client is associated with. */var DatabaseId=/*#__PURE__*/function(){function DatabaseId(projectId,database){_classCallCheck(this,DatabaseId);this.projectId=projectId;this.database=database?database:DEFAULT_DATABASE_NAME;}_createClass(DatabaseId,[{key:"isEqual",value:function isEqual(other){return other instanceof DatabaseId&&other.projectId===this.projectId&&other.database===this.database;}},{key:"compareTo",value:function compareTo(other){return primitiveComparator(this.projectId,other.projectId)||primitiveComparator(this.database,other.database);}},{key:"isDefaultDatabase",get:function get(){return this.database===DEFAULT_DATABASE_NAME;}}]);return DatabaseId;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Simple wrapper around a nullable UID. Mostly exists to make code more
 * readable.
 */var User=/*#__PURE__*/function(){function User(uid){_classCallCheck(this,User);this.uid=uid;}_createClass(User,[{key:"isAuthenticated",value:function isAuthenticated(){return this.uid!=null;}/**
     * Returns a key representing this user, suitable for inclusion in a
     * dictionary.
     */},{key:"toKey",value:function toKey(){if(this.isAuthenticated()){return'uid:'+this.uid;}else{return'anonymous-user';}}},{key:"isEqual",value:function isEqual(otherUser){return otherUser.uid===this.uid;}}]);return User;}();/** A user with a null UID. */User.UNAUTHENTICATED=new User(null);// TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
User.GOOGLE_CREDENTIALS=new User('google-credentials-uid');User.FIRST_PARTY=new User('first-party-uid');/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to
 * exceed. All subsequent calls to next will return increasing values. If provided with a
 * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as
 * well as write out sequence numbers that it produces via `next()`.
 */var ListenSequence=/*#__PURE__*/function(){function ListenSequence(previousValue,sequenceNumberSyncer){var _this2=this;_classCallCheck(this,ListenSequence);this.previousValue=previousValue;if(sequenceNumberSyncer){sequenceNumberSyncer.sequenceNumberHandler=function(sequenceNumber){return _this2.setPreviousValue(sequenceNumber);};this.writeNewSequenceNumber=function(sequenceNumber){return sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);};}}_createClass(ListenSequence,[{key:"setPreviousValue",value:function setPreviousValue(externalPreviousValue){this.previousValue=Math.max(externalPreviousValue,this.previousValue);return this.previousValue;}},{key:"next",value:function next(){var nextValue=++this.previousValue;if(this.writeNewSequenceNumber){this.writeNewSequenceNumber(nextValue);}return nextValue;}}]);return ListenSequence;}();ListenSequence.INVALID=-1;/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // An immutable sorted map implementation, based on a Left-leaning Red-Black
// tree.
var SortedMap=/*#__PURE__*/function(){function SortedMap(comparator,root){_classCallCheck(this,SortedMap);this.comparator=comparator;this.root=root?root:LLRBNode.EMPTY;}// Returns a copy of the map, with the specified key/value added or replaced.
_createClass(SortedMap,[{key:"insert",value:function insert(key,value){return new SortedMap(this.comparator,this.root.insert(key,value,this.comparator).copy(null,null,LLRBNode.BLACK,null,null));}// Returns a copy of the map, with the specified key removed.
},{key:"remove",value:function remove(key){return new SortedMap(this.comparator,this.root.remove(key,this.comparator).copy(null,null,LLRBNode.BLACK,null,null));}// Returns the value of the node with the given key, or null.
},{key:"get",value:function get(key){var node=this.root;while(!node.isEmpty()){var cmp=this.comparator(key,node.key);if(cmp===0){return node.value;}else if(cmp<0){node=node.left;}else if(cmp>0){node=node.right;}}return null;}// Returns the index of the element in this sorted map, or -1 if it doesn't
// exist.
},{key:"indexOf",value:function indexOf(key){// Number of nodes that were pruned when descending right
var prunedNodes=0;var node=this.root;while(!node.isEmpty()){var cmp=this.comparator(key,node.key);if(cmp===0){return prunedNodes+node.left.size;}else if(cmp<0){node=node.left;}else{// Count all nodes left of the node plus the node itself
prunedNodes+=node.left.size+1;node=node.right;}}// Node not found
return-1;}},{key:"isEmpty",value:function isEmpty(){return this.root.isEmpty();}// Returns the total number of nodes in the map.
},{key:"minKey",// Returns the minimum key in the map.
value:function minKey(){return this.root.minKey();}// Returns the maximum key in the map.
},{key:"maxKey",value:function maxKey(){return this.root.maxKey();}// Traverses the map in key order and calls the specified action function
// for each key/value pair. If action returns true, traversal is aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
},{key:"inorderTraversal",value:function inorderTraversal(action){return this.root.inorderTraversal(action);}},{key:"forEach",value:function forEach(fn){this.inorderTraversal(function(k,v){fn(k,v);return false;});}},{key:"toString",value:function toString(){var descriptions=[];this.inorderTraversal(function(k,v){descriptions.push("".concat(k,":").concat(v));return false;});return"{".concat(descriptions.join(', '),"}");}// Traverses the map in reverse key order and calls the specified action
// function for each key/value pair. If action returns true, traversal is
// aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
},{key:"reverseTraversal",value:function reverseTraversal(action){return this.root.reverseTraversal(action);}// Returns an iterator over the SortedMap.
},{key:"getIterator",value:function getIterator(){return new SortedMapIterator(this.root,null,this.comparator,false);}},{key:"getIteratorFrom",value:function getIteratorFrom(key){return new SortedMapIterator(this.root,key,this.comparator,false);}},{key:"getReverseIterator",value:function getReverseIterator(){return new SortedMapIterator(this.root,null,this.comparator,true);}},{key:"getReverseIteratorFrom",value:function getReverseIteratorFrom(key){return new SortedMapIterator(this.root,key,this.comparator,true);}},{key:"size",get:function get(){return this.root.size;}}]);return SortedMap;}();// end SortedMap
// An iterator over an LLRBNode.
var SortedMapIterator=/*#__PURE__*/function(){function SortedMapIterator(node,startKey,comparator,isReverse){_classCallCheck(this,SortedMapIterator);this.isReverse=isReverse;this.nodeStack=[];var cmp=1;while(!node.isEmpty()){cmp=startKey?comparator(node.key,startKey):1;// flip the comparison if we're going in reverse
if(isReverse){cmp*=-1;}if(cmp<0){// This node is less than our start key. ignore it
if(this.isReverse){node=node.left;}else{node=node.right;}}else if(cmp===0){// This node is exactly equal to our start key. Push it on the stack,
// but stop iterating;
this.nodeStack.push(node);break;}else{// This node is greater than our start key, add it to the stack and move
// to the next one
this.nodeStack.push(node);if(this.isReverse){node=node.right;}else{node=node.left;}}}}_createClass(SortedMapIterator,[{key:"getNext",value:function getNext(){var node=this.nodeStack.pop();var result={key:node.key,value:node.value};if(this.isReverse){node=node.left;while(!node.isEmpty()){this.nodeStack.push(node);node=node.right;}}else{node=node.right;while(!node.isEmpty()){this.nodeStack.push(node);node=node.left;}}return result;}},{key:"hasNext",value:function hasNext(){return this.nodeStack.length>0;}},{key:"peek",value:function peek(){if(this.nodeStack.length===0){return null;}var node=this.nodeStack[this.nodeStack.length-1];return{key:node.key,value:node.value};}}]);return SortedMapIterator;}();// end SortedMapIterator
// Represents a node in a Left-leaning Red-Black tree.
var LLRBNode=/*#__PURE__*/function(){function LLRBNode(key,value,color,left,right){_classCallCheck(this,LLRBNode);this.key=key;this.value=value;this.color=color!=null?color:LLRBNode.RED;this.left=left!=null?left:LLRBNode.EMPTY;this.right=right!=null?right:LLRBNode.EMPTY;this.size=this.left.size+1+this.right.size;}// Returns a copy of the current node, optionally replacing pieces of it.
_createClass(LLRBNode,[{key:"copy",value:function copy(key,value,color,left,right){return new LLRBNode(key!=null?key:this.key,value!=null?value:this.value,color!=null?color:this.color,left!=null?left:this.left,right!=null?right:this.right);}},{key:"isEmpty",value:function isEmpty(){return false;}// Traverses the tree in key order and calls the specified action function
// for each node. If action returns true, traversal is aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
},{key:"inorderTraversal",value:function inorderTraversal(action){return this.left.inorderTraversal(action)||action(this.key,this.value)||this.right.inorderTraversal(action);}// Traverses the tree in reverse key order and calls the specified action
// function for each node. If action returns true, traversal is aborted.
// Returns the first truthy value returned by action, or the last falsey
// value returned by action.
},{key:"reverseTraversal",value:function reverseTraversal(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action);}// Returns the minimum node in the tree.
},{key:"min",value:function min(){if(this.left.isEmpty()){return this;}else{return this.left.min();}}// Returns the maximum key in the tree.
},{key:"minKey",value:function minKey(){return this.min().key;}// Returns the maximum key in the tree.
},{key:"maxKey",value:function maxKey(){if(this.right.isEmpty()){return this.key;}else{return this.right.maxKey();}}// Returns new tree, with the key/value added.
},{key:"insert",value:function insert(key,value,comparator){var n=this;var cmp=comparator(key,n.key);if(cmp<0){n=n.copy(null,null,null,n.left.insert(key,value,comparator),null);}else if(cmp===0){n=n.copy(null,value,null,null,null);}else{n=n.copy(null,null,null,null,n.right.insert(key,value,comparator));}return n.fixUp();}},{key:"removeMin",value:function removeMin(){if(this.left.isEmpty()){return LLRBNode.EMPTY;}var n=this;if(!n.left.isRed()&&!n.left.left.isRed()){n=n.moveRedLeft();}n=n.copy(null,null,null,n.left.removeMin(),null);return n.fixUp();}// Returns new tree, with the specified item removed.
},{key:"remove",value:function remove(key,comparator){var smallest;var n=this;if(comparator(key,n.key)<0){if(!n.left.isEmpty()&&!n.left.isRed()&&!n.left.left.isRed()){n=n.moveRedLeft();}n=n.copy(null,null,null,n.left.remove(key,comparator),null);}else{if(n.left.isRed()){n=n.rotateRight();}if(!n.right.isEmpty()&&!n.right.isRed()&&!n.right.left.isRed()){n=n.moveRedRight();}if(comparator(key,n.key)===0){if(n.right.isEmpty()){return LLRBNode.EMPTY;}else{smallest=n.right.min();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin());}}n=n.copy(null,null,null,null,n.right.remove(key,comparator));}return n.fixUp();}},{key:"isRed",value:function isRed(){return this.color;}// Returns new tree after performing any needed rotations.
},{key:"fixUp",value:function fixUp(){var n=this;if(n.right.isRed()&&!n.left.isRed()){n=n.rotateLeft();}if(n.left.isRed()&&n.left.left.isRed()){n=n.rotateRight();}if(n.left.isRed()&&n.right.isRed()){n=n.colorFlip();}return n;}},{key:"moveRedLeft",value:function moveRedLeft(){var n=this.colorFlip();if(n.right.left.isRed()){n=n.copy(null,null,null,null,n.right.rotateRight());n=n.rotateLeft();n=n.colorFlip();}return n;}},{key:"moveRedRight",value:function moveRedRight(){var n=this.colorFlip();if(n.left.left.isRed()){n=n.rotateRight();n=n.colorFlip();}return n;}},{key:"rotateLeft",value:function rotateLeft(){var nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null);}},{key:"rotateRight",value:function rotateRight(){var nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr);}},{key:"colorFlip",value:function colorFlip(){var left=this.left.copy(null,null,!this.left.color,null,null);var right=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right);}// For testing.
},{key:"checkMaxDepth",value:function checkMaxDepth(){var blackDepth=this.check();if(Math.pow(2.0,blackDepth)<=this.size+1){return true;}else{return false;}}// In a balanced RB tree, the black-depth (number of black nodes) from root to
// leaves is equal on both sides.  This function verifies that or asserts.
},{key:"check",value:function check(){if(this.isRed()&&this.left.isRed()){throw fail();}if(this.right.isRed()){throw fail();}var blackDepth=this.left.check();if(blackDepth!==this.right.check()){throw fail();}else{return blackDepth+(this.isRed()?0:1);}}}]);return LLRBNode;}();// end LLRBNode
// Empty node is shared between all LLRB trees.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
LLRBNode.EMPTY=null;LLRBNode.RED=true;LLRBNode.BLACK=false;// Represents an empty node (a leaf node in the Red-Black Tree).
var LLRBEmptyNode=/*#__PURE__*/function(){function LLRBEmptyNode(){_classCallCheck(this,LLRBEmptyNode);this.size=0;}_createClass(LLRBEmptyNode,[{key:"copy",// Returns a copy of the current node.
value:function copy(key,value,color,left,right){return this;}// Returns a copy of the tree, with the specified key/value added.
},{key:"insert",value:function insert(key,value,comparator){return new LLRBNode(key,value);}// Returns a copy of the tree, with the specified key removed.
},{key:"remove",value:function remove(key,comparator){return this;}},{key:"isEmpty",value:function isEmpty(){return true;}},{key:"inorderTraversal",value:function inorderTraversal(action){return false;}},{key:"reverseTraversal",value:function reverseTraversal(action){return false;}},{key:"minKey",value:function minKey(){return null;}},{key:"maxKey",value:function maxKey(){return null;}},{key:"isRed",value:function isRed(){return false;}// For testing.
},{key:"checkMaxDepth",value:function checkMaxDepth(){return true;}},{key:"check",value:function check(){return 0;}},{key:"key",get:function get(){throw fail();}},{key:"value",get:function get(){throw fail();}},{key:"color",get:function get(){throw fail();}},{key:"left",get:function get(){throw fail();}},{key:"right",get:function get(){throw fail();}}]);return LLRBEmptyNode;}();// end LLRBEmptyNode
LLRBNode.EMPTY=new LLRBEmptyNode();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * SortedSet is an immutable (copy-on-write) collection that holds elements
 * in order specified by the provided comparator.
 *
 * NOTE: if provided comparator returns 0 for two elements, we consider them to
 * be equal!
 */var SortedSet=/*#__PURE__*/function(){function SortedSet(comparator){_classCallCheck(this,SortedSet);this.comparator=comparator;this.data=new SortedMap(this.comparator);}_createClass(SortedSet,[{key:"has",value:function has(elem){return this.data.get(elem)!==null;}},{key:"first",value:function first(){return this.data.minKey();}},{key:"last",value:function last(){return this.data.maxKey();}},{key:"indexOf",value:function indexOf(elem){return this.data.indexOf(elem);}/** Iterates elements in order defined by "comparator" */},{key:"forEach",value:function forEach(cb){this.data.inorderTraversal(function(k,v){cb(k);return false;});}/** Iterates over `elem`s such that: range[0] <= elem < range[1]. */},{key:"forEachInRange",value:function forEachInRange(range,cb){var iter=this.data.getIteratorFrom(range[0]);while(iter.hasNext()){var elem=iter.getNext();if(this.comparator(elem.key,range[1])>=0){return;}cb(elem.key);}}/**
     * Iterates over `elem`s such that: start <= elem until false is returned.
     */},{key:"forEachWhile",value:function forEachWhile(cb,start){var iter;if(start!==undefined){iter=this.data.getIteratorFrom(start);}else{iter=this.data.getIterator();}while(iter.hasNext()){var elem=iter.getNext();var result=cb(elem.key);if(!result){return;}}}/** Finds the least element greater than or equal to `elem`. */},{key:"firstAfterOrEqual",value:function firstAfterOrEqual(elem){var iter=this.data.getIteratorFrom(elem);return iter.hasNext()?iter.getNext().key:null;}},{key:"getIterator",value:function getIterator(){return new SortedSetIterator(this.data.getIterator());}},{key:"getIteratorFrom",value:function getIteratorFrom(key){return new SortedSetIterator(this.data.getIteratorFrom(key));}/** Inserts or updates an element */},{key:"add",value:function add(elem){return this.copy(this.data.remove(elem).insert(elem,true));}/** Deletes an element */},{key:"delete",value:function _delete(elem){if(!this.has(elem)){return this;}return this.copy(this.data.remove(elem));}},{key:"isEmpty",value:function isEmpty(){return this.data.isEmpty();}},{key:"unionWith",value:function unionWith(other){var result=this;// Make sure `result` always refers to the larger one of the two sets.
if(result.size<other.size){result=other;other=this;}other.forEach(function(elem){result=result.add(elem);});return result;}},{key:"isEqual",value:function isEqual(other){if(!(other instanceof SortedSet)){return false;}if(this.size!==other.size){return false;}var thisIt=this.data.getIterator();var otherIt=other.data.getIterator();while(thisIt.hasNext()){var thisElem=thisIt.getNext().key;var otherElem=otherIt.getNext().key;if(this.comparator(thisElem,otherElem)!==0){return false;}}return true;}},{key:"toArray",value:function toArray(){var res=[];this.forEach(function(targetId){res.push(targetId);});return res;}},{key:"toString",value:function toString(){var result=[];this.forEach(function(elem){return result.push(elem);});return'SortedSet('+result.toString()+')';}},{key:"copy",value:function copy(data){var result=new SortedSet(this.comparator);result.data=data;return result;}},{key:"size",get:function get(){return this.data.size;}}]);return SortedSet;}();var SortedSetIterator=/*#__PURE__*/function(){function SortedSetIterator(iter){_classCallCheck(this,SortedSetIterator);this.iter=iter;}_createClass(SortedSetIterator,[{key:"getNext",value:function getNext(){return this.iter.getNext().key;}},{key:"hasNext",value:function hasNext(){return this.iter.hasNext();}}]);return SortedSetIterator;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var EMPTY_MAYBE_DOCUMENT_MAP=new SortedMap(DocumentKey.comparator);function maybeDocumentMap(){return EMPTY_MAYBE_DOCUMENT_MAP;}function nullableMaybeDocumentMap(){return maybeDocumentMap();}var EMPTY_DOCUMENT_MAP=new SortedMap(DocumentKey.comparator);function documentMap(){return EMPTY_DOCUMENT_MAP;}var EMPTY_DOCUMENT_VERSION_MAP=new SortedMap(DocumentKey.comparator);function documentVersionMap(){return EMPTY_DOCUMENT_VERSION_MAP;}var EMPTY_DOCUMENT_KEY_SET=new SortedSet(DocumentKey.comparator);function documentKeySet(){var set=EMPTY_DOCUMENT_KEY_SET;for(var _len5=arguments.length,keys=new Array(_len5),_key6=0;_key6<_len5;_key6++){keys[_key6]=arguments[_key6];}for(var _i2=0,_keys=keys;_i2<_keys.length;_i2++){var key=_keys[_i2];set=set.add(key);}return set;}var EMPTY_TARGET_ID_SET=new SortedSet(primitiveComparator);function targetIdSet(){return EMPTY_TARGET_ID_SET;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Returns whether a variable is either undefined or null.
 */function isNullOrUndefined(value){return value===null||value===undefined;}/** Returns whether the value represents -0. */function isNegativeZero(value){// Detect if the value is -0.0. Based on polyfill from
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
return value===0&&1/value===1/-0;}/**
 * Returns whether a value is an integer and in the safe integer range
 * @param value The value to test for being an integer and in the safe range
 */function isSafeInteger(value){return typeof value==='number'&&Number.isInteger(value)&&!isNegativeZero(value)&&value<=Number.MAX_SAFE_INTEGER&&value>=Number.MIN_SAFE_INTEGER;}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Metadata state of the local client. Unlike `RemoteClientState`, this class is
 * mutable and keeps track of all pending mutations, which allows us to
 * update the range of pending mutation batch IDs as new mutations are added or
 * removed.
 *
 * The data in `LocalClientState` is not read from WebStorage and instead
 * updated via its instance methods. The updated state can be serialized via
 * `toWebStorageJSON()`.
 */ // Visible for testing.
var LocalClientState=/*#__PURE__*/function(){function LocalClientState(){_classCallCheck(this,LocalClientState);this.activeTargetIds=targetIdSet();}_createClass(LocalClientState,[{key:"addQueryTarget",value:function addQueryTarget(targetId){this.activeTargetIds=this.activeTargetIds.add(targetId);}},{key:"removeQueryTarget",value:function removeQueryTarget(targetId){this.activeTargetIds=this.activeTargetIds["delete"](targetId);}/**
     * Converts this entry into a JSON-encoded format we can use for WebStorage.
     * Does not encode `clientId` as it is part of the key in WebStorage.
     */},{key:"toWebStorageJSON",value:function toWebStorageJSON(){var data={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()// Modify the existing value to trigger update.
};return JSON.stringify(data);}}]);return LocalClientState;}();/**
 * `MemorySharedClientState` is a simple implementation of SharedClientState for
 * clients using memory persistence. The state in this class remains fully
 * isolated and no synchronization is performed.
 */var MemorySharedClientState=/*#__PURE__*/function(){function MemorySharedClientState(){_classCallCheck(this,MemorySharedClientState);this.localState=new LocalClientState();this.queryState={};this.onlineStateHandler=null;this.sequenceNumberHandler=null;}_createClass(MemorySharedClientState,[{key:"addPendingMutation",value:function addPendingMutation(batchId){// No op.
}},{key:"updateMutationState",value:function updateMutationState(batchId,state,error){// No op.
}},{key:"addLocalQueryTarget",value:function addLocalQueryTarget(targetId){this.localState.addQueryTarget(targetId);return this.queryState[targetId]||'not-current';}},{key:"updateQueryState",value:function updateQueryState(targetId,state,error){this.queryState[targetId]=state;}},{key:"removeLocalQueryTarget",value:function removeLocalQueryTarget(targetId){this.localState.removeQueryTarget(targetId);}},{key:"isLocalQueryTarget",value:function isLocalQueryTarget(targetId){return this.localState.activeTargetIds.has(targetId);}},{key:"clearQueryState",value:function clearQueryState(targetId){delete this.queryState[targetId];}},{key:"getAllActiveQueryTargets",value:function getAllActiveQueryTargets(){return this.localState.activeTargetIds;}},{key:"isActiveQueryTarget",value:function isActiveQueryTarget(targetId){return this.localState.activeTargetIds.has(targetId);}},{key:"start",value:function start(){this.localState=new LocalClientState();return Promise.resolve();}},{key:"handleUserChange",value:function handleUserChange(user,removedBatchIds,addedBatchIds){// No op.
}},{key:"setOnlineState",value:function setOnlineState(onlineState){// No op.
}},{key:"shutdown",value:function shutdown(){}},{key:"writeSequenceNumber",value:function writeSequenceNumber(sequenceNumber){}}]);return MemorySharedClientState;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // The earlist date supported by Firestore timestamps (0001-01-01T00:00:00Z).
var MIN_SECONDS=-62135596800;/**
 * A `Timestamp` represents a point in time independent of any time zone or
 * calendar, represented as seconds and fractions of seconds at nanosecond
 * resolution in UTC Epoch time.
 *
 * It is encoded using the Proleptic Gregorian Calendar which extends the
 * Gregorian calendar backwards to year one. It is encoded assuming all minutes
 * are 60 seconds long, i.e. leap seconds are "smeared" so that no leap second
 * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to
 * 9999-12-31T23:59:59.999999999Z.
 *
 * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto
 */var Timestamp=/*#__PURE__*/function(){/**
     * Creates a new timestamp.
     *
     * @param seconds The number of seconds of UTC time since Unix epoch
     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     *     9999-12-31T23:59:59Z inclusive.
     * @param nanoseconds The non-negative fractions of a second at nanosecond
     *     resolution. Negative second values with fractions must still have
     *     non-negative nanoseconds values that count forward in time. Must be
     *     from 0 to 999,999,999 inclusive.
     */function Timestamp(seconds,nanoseconds){_classCallCheck(this,Timestamp);this.seconds=seconds;this.nanoseconds=nanoseconds;if(nanoseconds<0){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp nanoseconds out of range: '+nanoseconds);}if(nanoseconds>=1e9){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp nanoseconds out of range: '+nanoseconds);}if(seconds<MIN_SECONDS){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp seconds out of range: '+seconds);}// This will break in the year 10,000.
if(seconds>=253402300800){throw new FirestoreError(Code.INVALID_ARGUMENT,'Timestamp seconds out of range: '+seconds);}}/**
     * Creates a new timestamp with the current date, with millisecond precision.
     *
     * @return a new timestamp representing the current date.
     */_createClass(Timestamp,[{key:"toDate",/**
     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion causes
     * a loss of precision since `Date` objects only support millisecond precision.
     *
     * @return JavaScript `Date` object representing the same point in time as
     *     this `Timestamp`, with millisecond precision.
     */value:function toDate(){return new Date(this.toMillis());}/**
     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
     * epoch). This operation causes a loss of precision.
     *
     * @return The point in time corresponding to this timestamp, represented as
     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     */},{key:"toMillis",value:function toMillis(){return this.seconds*1000+this.nanoseconds/1e6;}},{key:"_compareTo",value:function _compareTo(other){if(this.seconds===other.seconds){return primitiveComparator(this.nanoseconds,other.nanoseconds);}return primitiveComparator(this.seconds,other.seconds);}/**
     * Returns true if this `Timestamp` is equal to the provided one.
     *
     * @param other The `Timestamp` to compare against.
     * @return true if this `Timestamp` is equal to the provided one.
     */},{key:"isEqual",value:function isEqual(other){return other.seconds===this.seconds&&other.nanoseconds===this.nanoseconds;}},{key:"toString",value:function toString(){return'Timestamp(seconds='+this.seconds+', nanoseconds='+this.nanoseconds+')';}},{key:"toJSON",value:function toJSON(){return{seconds:this.seconds,nanoseconds:this.nanoseconds};}/**
     * Converts this object to a primitive string, which allows Timestamp objects to be compared
     * using the `>`, `<=`, `>=` and `>` operators.
     */},{key:"valueOf",value:function valueOf(){// This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is
// translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded
// with zeroes to be a consistent length. Strings with this format then have a lexiographical
// ordering that matches the expected ordering. The <seconds> translation is done to avoid
// having a leading negative sign (i.e. a leading '-' character) in its string representation,
// which would affect its lexiographical ordering.
var adjustedSeconds=this.seconds-MIN_SECONDS;// Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.
var formattedSeconds=String(adjustedSeconds).padStart(12,'0');var formattedNanoseconds=String(this.nanoseconds).padStart(9,'0');return formattedSeconds+'.'+formattedNanoseconds;}}],[{key:"now",value:function now(){return Timestamp.fromMillis(Date.now());}/**
     * Creates a new timestamp from the given date.
     *
     * @param date The date to initialize the `Timestamp` from.
     * @return A new `Timestamp` representing the same point in time as the given
     *     date.
     */},{key:"fromDate",value:function fromDate(date){return Timestamp.fromMillis(date.getTime());}/**
     * Creates a new timestamp from the given number of milliseconds.
     *
     * @param milliseconds Number of milliseconds since Unix epoch
     *     1970-01-01T00:00:00Z.
     * @return A new `Timestamp` representing the same point in time as the given
     *     number of milliseconds.
     */},{key:"fromMillis",value:function fromMillis(milliseconds){var seconds=Math.floor(milliseconds/1000);var nanos=(milliseconds-seconds*1000)*1e6;return new Timestamp(seconds,nanos);}}]);return Timestamp;}();/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Represents a locally-applied ServerTimestamp.
 *
 * Server Timestamps are backed by MapValues that contain an internal field
 * `__type__` with a value of `server_timestamp`. The previous value and local
 * write time are stored in its `__previous_value__` and `__local_write_time__`
 * fields respectively.
 *
 * Notes:
 * - ServerTimestampValue instances are created as the result of applying a
 *   TransformMutation (see TransformMutation.applyTo()). They can only exist in
 *   the local view of a document. Therefore they do not need to be parsed or
 *   serialized.
 * - When evaluated locally (e.g. for snapshot.data()), they by default
 *   evaluate to `null`. This behavior can be configured by passing custom
 *   FieldValueOptions to value().
 * - With respect to other ServerTimestampValues, they sort by their
 *   localWriteTime.
 */var SERVER_TIMESTAMP_SENTINEL='server_timestamp';var TYPE_KEY='__type__';var PREVIOUS_VALUE_KEY='__previous_value__';var LOCAL_WRITE_TIME_KEY='__local_write_time__';function isServerTimestamp(value){var _a,_b;var type=(_b=(((_a=value===null||value===void 0?void 0:value.mapValue)===null||_a===void 0?void 0:_a.fields)||{})[TYPE_KEY])===null||_b===void 0?void 0:_b.stringValue;return type===SERVER_TIMESTAMP_SENTINEL;}/**
 * Creates a new ServerTimestamp proto value (using the internal format).
 */function serverTimestamp(localWriteTime,previousValue){var _fields;var mapValue={fields:(_fields={},_defineProperty(_fields,TYPE_KEY,{stringValue:SERVER_TIMESTAMP_SENTINEL}),_defineProperty(_fields,LOCAL_WRITE_TIME_KEY,{timestampValue:{seconds:localWriteTime.seconds,nanos:localWriteTime.nanoseconds}}),_fields)};if(previousValue){mapValue.fields[PREVIOUS_VALUE_KEY]=previousValue;}return{mapValue:mapValue};}/**
 * Returns the value of the field before this ServerTimestamp was set.
 *
 * Preserving the previous values allows the user to display the last resoled
 * value until the backend responds with the timestamp.
 */function getPreviousValue(value){var previousValue=value.mapValue.fields[PREVIOUS_VALUE_KEY];if(isServerTimestamp(previousValue)){return getPreviousValue(previousValue);}return previousValue;}/**
 * Returns the local time at which this timestamp was first set.
 */function getLocalWriteTime(value){var localWriteTime=normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);return new Timestamp(localWriteTime.seconds,localWriteTime.nanos);}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // A RegExp matching ISO 8601 UTC timestamps with optional fraction.
var ISO_TIMESTAMP_REG_EXP=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);/** Extracts the backend's type order for the provided value. */function typeOrder(value){if('nullValue'in value){return 0/* NullValue */;}else if('booleanValue'in value){return 1/* BooleanValue */;}else if('integerValue'in value||'doubleValue'in value){return 2/* NumberValue */;}else if('timestampValue'in value){return 3/* TimestampValue */;}else if('stringValue'in value){return 5/* StringValue */;}else if('bytesValue'in value){return 6/* BlobValue */;}else if('referenceValue'in value){return 7/* RefValue */;}else if('geoPointValue'in value){return 8/* GeoPointValue */;}else if('arrayValue'in value){return 9/* ArrayValue */;}else if('mapValue'in value){if(isServerTimestamp(value)){return 4/* ServerTimestampValue */;}return 10/* ObjectValue */;}else{return fail();}}/** Tests `left` and `right` for equality based on the backend semantics. */function valueEquals(left,right){var leftType=typeOrder(left);var rightType=typeOrder(right);if(leftType!==rightType){return false;}switch(leftType){case 0/* NullValue */:return true;case 1/* BooleanValue */:return left.booleanValue===right.booleanValue;case 4/* ServerTimestampValue */:return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));case 3/* TimestampValue */:return timestampEquals(left,right);case 5/* StringValue */:return left.stringValue===right.stringValue;case 6/* BlobValue */:return blobEquals(left,right);case 7/* RefValue */:return left.referenceValue===right.referenceValue;case 8/* GeoPointValue */:return geoPointEquals(left,right);case 2/* NumberValue */:return numberEquals(left,right);case 9/* ArrayValue */:return arrayEquals(left.arrayValue.values||[],right.arrayValue.values||[],valueEquals);case 10/* ObjectValue */:return objectEquals(left,right);default:return fail();}}function timestampEquals(left,right){if(typeof left.timestampValue==='string'&&typeof right.timestampValue==='string'&&left.timestampValue.length===right.timestampValue.length){// Use string equality for ISO 8601 timestamps
return left.timestampValue===right.timestampValue;}var leftTimestamp=normalizeTimestamp(left.timestampValue);var rightTimestamp=normalizeTimestamp(right.timestampValue);return leftTimestamp.seconds===rightTimestamp.seconds&&leftTimestamp.nanos===rightTimestamp.nanos;}function geoPointEquals(left,right){return normalizeNumber(left.geoPointValue.latitude)===normalizeNumber(right.geoPointValue.latitude)&&normalizeNumber(left.geoPointValue.longitude)===normalizeNumber(right.geoPointValue.longitude);}function blobEquals(left,right){return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));}function numberEquals(left,right){if('integerValue'in left&&'integerValue'in right){return normalizeNumber(left.integerValue)===normalizeNumber(right.integerValue);}else if('doubleValue'in left&&'doubleValue'in right){var n1=normalizeNumber(left.doubleValue);var n2=normalizeNumber(right.doubleValue);if(n1===n2){return isNegativeZero(n1)===isNegativeZero(n2);}else{return isNaN(n1)&&isNaN(n2);}}return false;}function objectEquals(left,right){var leftMap=left.mapValue.fields||{};var rightMap=right.mapValue.fields||{};if(objectSize(leftMap)!==objectSize(rightMap)){return false;}for(var key in leftMap){if(leftMap.hasOwnProperty(key)){if(rightMap[key]===undefined||!valueEquals(leftMap[key],rightMap[key])){return false;}}}return true;}/** Returns true if the ArrayValue contains the specified element. */function arrayValueContains(haystack,needle){return(haystack.values||[]).find(function(v){return valueEquals(v,needle);})!==undefined;}function valueCompare(left,right){var leftType=typeOrder(left);var rightType=typeOrder(right);if(leftType!==rightType){return primitiveComparator(leftType,rightType);}switch(leftType){case 0/* NullValue */:return 0;case 1/* BooleanValue */:return primitiveComparator(left.booleanValue,right.booleanValue);case 2/* NumberValue */:return compareNumbers(left,right);case 3/* TimestampValue */:return compareTimestamps(left.timestampValue,right.timestampValue);case 4/* ServerTimestampValue */:return compareTimestamps(getLocalWriteTime(left),getLocalWriteTime(right));case 5/* StringValue */:return primitiveComparator(left.stringValue,right.stringValue);case 6/* BlobValue */:return compareBlobs(left.bytesValue,right.bytesValue);case 7/* RefValue */:return compareReferences(left.referenceValue,right.referenceValue);case 8/* GeoPointValue */:return compareGeoPoints(left.geoPointValue,right.geoPointValue);case 9/* ArrayValue */:return compareArrays(left.arrayValue,right.arrayValue);case 10/* ObjectValue */:return compareMaps(left.mapValue,right.mapValue);default:throw fail();}}function compareNumbers(left,right){var leftNumber=normalizeNumber(left.integerValue||left.doubleValue);var rightNumber=normalizeNumber(right.integerValue||right.doubleValue);if(leftNumber<rightNumber){return-1;}else if(leftNumber>rightNumber){return 1;}else if(leftNumber===rightNumber){return 0;}else{// one or both are NaN.
if(isNaN(leftNumber)){return isNaN(rightNumber)?0:-1;}else{return 1;}}}function compareTimestamps(left,right){if(typeof left==='string'&&typeof right==='string'&&left.length===right.length){return primitiveComparator(left,right);}var leftTimestamp=normalizeTimestamp(left);var rightTimestamp=normalizeTimestamp(right);var comparison=primitiveComparator(leftTimestamp.seconds,rightTimestamp.seconds);if(comparison!==0){return comparison;}return primitiveComparator(leftTimestamp.nanos,rightTimestamp.nanos);}function compareReferences(leftPath,rightPath){var leftSegments=leftPath.split('/');var rightSegments=rightPath.split('/');for(var i=0;i<leftSegments.length&&i<rightSegments.length;i++){var comparison=primitiveComparator(leftSegments[i],rightSegments[i]);if(comparison!==0){return comparison;}}return primitiveComparator(leftSegments.length,rightSegments.length);}function compareGeoPoints(left,right){var comparison=primitiveComparator(normalizeNumber(left.latitude),normalizeNumber(right.latitude));if(comparison!==0){return comparison;}return primitiveComparator(normalizeNumber(left.longitude),normalizeNumber(right.longitude));}function compareBlobs(left,right){var leftBytes=normalizeByteString(left);var rightBytes=normalizeByteString(right);return leftBytes.compareTo(rightBytes);}function compareArrays(left,right){var leftArray=left.values||[];var rightArray=right.values||[];for(var i=0;i<leftArray.length&&i<rightArray.length;++i){var compare=valueCompare(leftArray[i],rightArray[i]);if(compare){return compare;}}return primitiveComparator(leftArray.length,rightArray.length);}function compareMaps(left,right){var leftMap=left.fields||{};var leftKeys=Object.keys(leftMap);var rightMap=right.fields||{};var rightKeys=Object.keys(rightMap);// Even though MapValues are likely sorted correctly based on their insertion
// order (e.g. when received from the backend), local modifications can bring
// elements out of order. We need to re-sort the elements to ensure that
// canonical IDs are independent of insertion order.
leftKeys.sort();rightKeys.sort();for(var i=0;i<leftKeys.length&&i<rightKeys.length;++i){var keyCompare=primitiveComparator(leftKeys[i],rightKeys[i]);if(keyCompare!==0){return keyCompare;}var compare=valueCompare(leftMap[leftKeys[i]],rightMap[rightKeys[i]]);if(compare!==0){return compare;}}return primitiveComparator(leftKeys.length,rightKeys.length);}/**
 * Generates the canonical ID for the provided field value (as used in Target
 * serialization).
 */function canonicalId(value){return canonifyValue(value);}function canonifyValue(value){if('nullValue'in value){return'null';}else if('booleanValue'in value){return''+value.booleanValue;}else if('integerValue'in value){return''+value.integerValue;}else if('doubleValue'in value){return''+value.doubleValue;}else if('timestampValue'in value){return canonifyTimestamp(value.timestampValue);}else if('stringValue'in value){return value.stringValue;}else if('bytesValue'in value){return canonifyByteString(value.bytesValue);}else if('referenceValue'in value){return canonifyReference(value.referenceValue);}else if('geoPointValue'in value){return canonifyGeoPoint(value.geoPointValue);}else if('arrayValue'in value){return canonifyArray(value.arrayValue);}else if('mapValue'in value){return canonifyMap(value.mapValue);}else{return fail();}}function canonifyByteString(byteString){return normalizeByteString(byteString).toBase64();}function canonifyTimestamp(timestamp){var normalizedTimestamp=normalizeTimestamp(timestamp);return"time(".concat(normalizedTimestamp.seconds,",").concat(normalizedTimestamp.nanos,")");}function canonifyGeoPoint(geoPoint){return"geo(".concat(geoPoint.latitude,",").concat(geoPoint.longitude,")");}function canonifyReference(referenceValue){return DocumentKey.fromName(referenceValue).toString();}function canonifyMap(mapValue){// Iteration order in JavaScript is not guaranteed. To ensure that we generate
// matching canonical IDs for identical maps, we need to sort the keys.
var sortedKeys=Object.keys(mapValue.fields||{}).sort();var result='{';var first=true;var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=sortedKeys[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var key=_step2.value;if(!first){result+=',';}else{first=false;}result+="".concat(key,":").concat(canonifyValue(mapValue.fields[key]));}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2["return"]!=null){_iterator2["return"]();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}return result+'}';}function canonifyArray(arrayValue){var result='[';var first=true;var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=(arrayValue.values||[])[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var value=_step3.value;if(!first){result+=',';}else{first=false;}result+=canonifyValue(value);}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally{try{if(!_iteratorNormalCompletion3&&_iterator3["return"]!=null){_iterator3["return"]();}}finally{if(_didIteratorError3){throw _iteratorError3;}}}return result+']';}/**
 * Converts the possible Proto values for a timestamp value into a "seconds and
 * nanos" representation.
 */function normalizeTimestamp(date){hardAssert(!!date);// The json interface (for the browser) will return an iso timestamp string,
// while the proto js library (for node) will return a
// google.protobuf.Timestamp instance.
if(typeof date==='string'){// The date string can have higher precision (nanos) than the Date class
// (millis), so we do some custom parsing here.
// Parse the nanos right out of the string.
var nanos=0;var fraction=ISO_TIMESTAMP_REG_EXP.exec(date);hardAssert(!!fraction);if(fraction[1]){// Pad the fraction out to 9 digits (nanos).
var nanoStr=fraction[1];nanoStr=(nanoStr+'000000000').substr(0,9);nanos=Number(nanoStr);}// Parse the date to get the seconds.
var parsedDate=new Date(date);var seconds=Math.floor(parsedDate.getTime()/1000);return{seconds:seconds,nanos:nanos};}else{// TODO(b/37282237): Use strings for Proto3 timestamps
// assert(!this.options.useProto3Json,
//   'The timestamp instance format requires Proto JS.');
var _seconds=normalizeNumber(date.seconds);var _nanos=normalizeNumber(date.nanos);return{seconds:_seconds,nanos:_nanos};}}/**
 * Converts the possible Proto types for numbers into a JavaScript number.
 * Returns 0 if the value is not numeric.
 */function normalizeNumber(value){// TODO(bjornick): Handle int64 greater than 53 bits.
if(typeof value==='number'){return value;}else if(typeof value==='string'){return Number(value);}else{return 0;}}/** Converts the possible Proto types for Blobs into a ByteString. */function normalizeByteString(blob){if(typeof blob==='string'){return ByteString.fromBase64String(blob);}else{return ByteString.fromUint8Array(blob);}}/** Returns a reference value for the provided database and key. */function refValue(databaseId,key){return{referenceValue:"projects/".concat(databaseId.projectId,"/databases/").concat(databaseId.database,"/documents/").concat(key.path.canonicalString())};}/** Returns true if `value` is an IntegerValue . */function isInteger(value){return!!value&&'integerValue'in value;}/** Returns true if `value` is a DoubleValue. */function isDouble(value){return!!value&&'doubleValue'in value;}/** Returns true if `value` is either an IntegerValue or a DoubleValue. */function isNumber(value){return isInteger(value)||isDouble(value);}/** Returns true if `value` is an ArrayValue. */function isArray(value){return!!value&&'arrayValue'in value;}/** Returns true if `value` is a NullValue. */function isNullValue(value){return!!value&&'nullValue'in value;}/** Returns true if `value` is NaN. */function isNanValue(value){return!!value&&'doubleValue'in value&&isNaN(Number(value.doubleValue));}/** Returns true if `value` is a MapValue. */function isMapValue(value){return!!value&&'mapValue'in value;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The result of a lookup for a given path may be an existing document or a
 * marker that this document does not exist at a given version.
 */var MaybeDocument=function MaybeDocument(key,version){_classCallCheck(this,MaybeDocument);this.key=key;this.version=version;};/**
 * Represents a document in Firestore with a key, version, data and whether the
 * data has local mutations applied to it.
 */var Document=/*#__PURE__*/function(_MaybeDocument){_inherits(Document,_MaybeDocument);function Document(key,version,objectValue,options){var _this3;_classCallCheck(this,Document);_this3=_possibleConstructorReturn(this,_getPrototypeOf(Document).call(this,key,version));_this3.objectValue=objectValue;_this3.hasLocalMutations=!!options.hasLocalMutations;_this3.hasCommittedMutations=!!options.hasCommittedMutations;return _this3;}_createClass(Document,[{key:"field",value:function field(path){return this.objectValue.field(path);}},{key:"data",value:function data(){return this.objectValue;}},{key:"toProto",value:function toProto(){return this.objectValue.proto;}},{key:"isEqual",value:function isEqual(other){return other instanceof Document&&this.key.isEqual(other.key)&&this.version.isEqual(other.version)&&this.hasLocalMutations===other.hasLocalMutations&&this.hasCommittedMutations===other.hasCommittedMutations&&this.objectValue.isEqual(other.objectValue);}},{key:"toString",value:function toString(){return"Document(".concat(this.key,", ").concat(this.version,", ").concat(this.objectValue.toString(),", ")+"{hasLocalMutations: ".concat(this.hasLocalMutations,"}), ")+"{hasCommittedMutations: ".concat(this.hasCommittedMutations,"})");}},{key:"hasPendingWrites",get:function get(){return this.hasLocalMutations||this.hasCommittedMutations;}}]);return Document;}(MaybeDocument);/**
 * Compares the value for field `field` in the provided documents. Throws if
 * the field does not exist in both documents.
 */function compareDocumentsByField(field,d1,d2){var v1=d1.field(field);var v2=d2.field(field);if(v1!==null&&v2!==null){return valueCompare(v1,v2);}else{return fail();}}/**
 * A class representing a deleted document.
 * Version is set to 0 if we don't point to any specific time, otherwise it
 * denotes time we know it didn't exist at.
 */var NoDocument=/*#__PURE__*/function(_MaybeDocument2){_inherits(NoDocument,_MaybeDocument2);function NoDocument(key,version,options){var _this4;_classCallCheck(this,NoDocument);_this4=_possibleConstructorReturn(this,_getPrototypeOf(NoDocument).call(this,key,version));_this4.hasCommittedMutations=!!(options&&options.hasCommittedMutations);return _this4;}_createClass(NoDocument,[{key:"toString",value:function toString(){return"NoDocument(".concat(this.key,", ").concat(this.version,")");}},{key:"isEqual",value:function isEqual(other){return other instanceof NoDocument&&other.hasCommittedMutations===this.hasCommittedMutations&&other.version.isEqual(this.version)&&other.key.isEqual(this.key);}},{key:"hasPendingWrites",get:function get(){return this.hasCommittedMutations;}}]);return NoDocument;}(MaybeDocument);/**
 * A class representing an existing document whose data is unknown (e.g. a
 * document that was updated without a known base document).
 */var UnknownDocument=/*#__PURE__*/function(_MaybeDocument3){_inherits(UnknownDocument,_MaybeDocument3);function UnknownDocument(){_classCallCheck(this,UnknownDocument);return _possibleConstructorReturn(this,_getPrototypeOf(UnknownDocument).apply(this,arguments));}_createClass(UnknownDocument,[{key:"toString",value:function toString(){return"UnknownDocument(".concat(this.key,", ").concat(this.version,")");}},{key:"isEqual",value:function isEqual(other){return other instanceof UnknownDocument&&other.version.isEqual(this.version)&&other.key.isEqual(this.key);}},{key:"hasPendingWrites",get:function get(){return true;}}]);return UnknownDocument;}(MaybeDocument);/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // Visible for testing
var TargetImpl=function TargetImpl(path){var collectionGroup=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var orderBy=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var filters=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var limit=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var startAt=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;var endAt=arguments.length>6&&arguments[6]!==undefined?arguments[6]:null;_classCallCheck(this,TargetImpl);this.path=path;this.collectionGroup=collectionGroup;this.orderBy=orderBy;this.filters=filters;this.limit=limit;this.startAt=startAt;this.endAt=endAt;this.memoizedCanonicalId=null;};/**
 * Initializes a Target with a path and optional additional query constraints.
 * Path must currently be empty if this is a collection group query.
 *
 * NOTE: you should always construct `Target` from `Query.toTarget` instead of
 * using this factory method, because `Query` provides an implicit `orderBy`
 * property.
 */function newTarget(path){var collectionGroup=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var orderBy=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var filters=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var limit=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var startAt=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;var endAt=arguments.length>6&&arguments[6]!==undefined?arguments[6]:null;return new TargetImpl(path,collectionGroup,orderBy,filters,limit,startAt,endAt);}function canonifyTarget(target){var targetImpl=debugCast(target);if(targetImpl.memoizedCanonicalId===null){var _canonicalId=targetImpl.path.canonicalString();if(targetImpl.collectionGroup!==null){_canonicalId+='|cg:'+targetImpl.collectionGroup;}_canonicalId+='|f:';_canonicalId+=targetImpl.filters.map(function(f){return canonifyFilter(f);}).join(',');_canonicalId+='|ob:';_canonicalId+=targetImpl.orderBy.map(function(o){return canonifyOrderBy(o);}).join(',');if(!isNullOrUndefined(targetImpl.limit)){_canonicalId+='|l:';_canonicalId+=targetImpl.limit;}if(targetImpl.startAt){_canonicalId+='|lb:';_canonicalId+=canonifyBound(targetImpl.startAt);}if(targetImpl.endAt){_canonicalId+='|ub:';_canonicalId+=canonifyBound(targetImpl.endAt);}targetImpl.memoizedCanonicalId=_canonicalId;}return targetImpl.memoizedCanonicalId;}function stringifyTarget(target){var str=target.path.canonicalString();if(target.collectionGroup!==null){str+=' collectionGroup='+target.collectionGroup;}if(target.filters.length>0){str+=", filters: [".concat(target.filters.map(function(f){return stringifyFilter(f);}).join(', '),"]");}if(!isNullOrUndefined(target.limit)){str+=', limit: '+target.limit;}if(target.orderBy.length>0){str+=", orderBy: [".concat(target.orderBy.map(function(o){return stringifyOrderBy(o);}).join(', '),"]");}if(target.startAt){str+=', startAt: '+canonifyBound(target.startAt);}if(target.endAt){str+=', endAt: '+canonifyBound(target.endAt);}return"Target(".concat(str,")");}function targetEquals(left,right){if(left.limit!==right.limit){return false;}if(left.orderBy.length!==right.orderBy.length){return false;}for(var i=0;i<left.orderBy.length;i++){if(!orderByEquals(left.orderBy[i],right.orderBy[i])){return false;}}if(left.filters.length!==right.filters.length){return false;}for(var _i3=0;_i3<left.filters.length;_i3++){if(!filterEquals(left.filters[_i3],right.filters[_i3])){return false;}}if(left.collectionGroup!==right.collectionGroup){return false;}if(!left.path.isEqual(right.path)){return false;}if(!boundEquals(left.startAt,right.startAt)){return false;}return boundEquals(left.endAt,right.endAt);}function isDocumentTarget(target){return DocumentKey.isDocumentKey(target.path)&&target.collectionGroup===null&&target.filters.length===0;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Query encapsulates all the query attributes we support in the SDK. It can
 * be run against the LocalStore, as well as be converted to a `Target` to
 * query the RemoteStore results.
 *
 * Visible for testing.
 */var QueryImpl=/**
     * Initializes a Query with a path and optional additional query constraints.
     * Path must currently be empty if this is a collection group query.
     */function QueryImpl(path){var collectionGroup=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var explicitOrderBy=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var filters=arguments.length>3&&arguments[3]!==undefined?arguments[3]:[];var limit=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var limitType=arguments.length>5&&arguments[5]!==undefined?arguments[5]:"F";var startAt=arguments.length>6&&arguments[6]!==undefined?arguments[6]:null;var endAt=arguments.length>7&&arguments[7]!==undefined?arguments[7]:null;_classCallCheck(this,QueryImpl);this.path=path;this.collectionGroup=collectionGroup;this.explicitOrderBy=explicitOrderBy;this.filters=filters;this.limit=limit;this.limitType=limitType;this.startAt=startAt;this.endAt=endAt;this.memoizedOrderBy=null;// The corresponding `Target` of this `Query` instance.
this.memoizedTarget=null;if(this.startAt);if(this.endAt);};/** Creates a new Query for a query that matches all documents at `path` */function newQueryForPath(path){return new QueryImpl(path);}/**
 * Helper to convert a collection group query into a collection query at a
 * specific path. This is used when executing collection group queries, since
 * we have to split the query into a set of collection queries at multiple
 * paths.
 */function asCollectionQueryAtPath(query,path){return new QueryImpl(path,/*collectionGroup=*/null,query.explicitOrderBy.slice(),query.filters.slice(),query.limit,query.limitType,query.startAt,query.endAt);}/**
 * Returns true if this query does not specify any query constraints that
 * could remove results.
 */function matchesAllDocuments(query){return query.filters.length===0&&query.limit===null&&query.startAt==null&&query.endAt==null&&(query.explicitOrderBy.length===0||query.explicitOrderBy.length===1&&query.explicitOrderBy[0].field.isKeyField());}function hasLimitToFirst(query){return!isNullOrUndefined(query.limit)&&query.limitType==="F"/* First */;}function hasLimitToLast(query){return!isNullOrUndefined(query.limit)&&query.limitType==="L"/* Last */;}function getFirstOrderByField(query){return query.explicitOrderBy.length>0?query.explicitOrderBy[0].field:null;}function getInequalityFilterField(query){var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=query.filters[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var filter=_step4.value;if(filter.isInequality()){return filter.field;}}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally{try{if(!_iteratorNormalCompletion4&&_iterator4["return"]!=null){_iterator4["return"]();}}finally{if(_didIteratorError4){throw _iteratorError4;}}}return null;}/**
 * Checks if any of the provided Operators are included in the query and
 * returns the first one that is, or null if none are.
 */function findFilterOperator(query,operators){var _iteratorNormalCompletion5=true;var _didIteratorError5=false;var _iteratorError5=undefined;try{for(var _iterator5=query.filters[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){var filter=_step5.value;if(operators.indexOf(filter.op)>=0){return filter.op;}}}catch(err){_didIteratorError5=true;_iteratorError5=err;}finally{try{if(!_iteratorNormalCompletion5&&_iterator5["return"]!=null){_iterator5["return"]();}}finally{if(_didIteratorError5){throw _iteratorError5;}}}return null;}/**
 * Creates a new Query for a collection group query that matches all documents
 * within the provided collection group.
 */function newQueryForCollectionGroup(collectionId){return new QueryImpl(ResourcePath.emptyPath(),collectionId);}/**
 * Returns whether the query matches a single document by path (rather than a
 * collection).
 */function isDocumentQuery(query){return DocumentKey.isDocumentKey(query.path)&&query.collectionGroup===null&&query.filters.length===0;}/**
 * Returns whether the query matches a collection group rather than a specific
 * collection.
 */function isCollectionGroupQuery(query){return query.collectionGroup!==null;}/**
 * Returns the implicit order by constraint that is used to execute the Query,
 * which can be different from the order by constraints the user provided (e.g.
 * the SDK and backend always orders by `__name__`).
 */function queryOrderBy(query){var queryImpl=debugCast(query);if(queryImpl.memoizedOrderBy===null){queryImpl.memoizedOrderBy=[];var inequalityField=getInequalityFilterField(queryImpl);var firstOrderByField=getFirstOrderByField(queryImpl);if(inequalityField!==null&&firstOrderByField===null){// In order to implicitly add key ordering, we must also add the
// inequality filter field for it to be a valid query.
// Note that the default inequality field and key ordering is ascending.
if(!inequalityField.isKeyField()){queryImpl.memoizedOrderBy.push(new OrderBy(inequalityField));}queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath.keyField(),"asc"/* ASCENDING */));}else{var foundKeyOrdering=false;var _iteratorNormalCompletion6=true;var _didIteratorError6=false;var _iteratorError6=undefined;try{for(var _iterator6=queryImpl.explicitOrderBy[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){var orderBy=_step6.value;queryImpl.memoizedOrderBy.push(orderBy);if(orderBy.field.isKeyField()){foundKeyOrdering=true;}}}catch(err){_didIteratorError6=true;_iteratorError6=err;}finally{try{if(!_iteratorNormalCompletion6&&_iterator6["return"]!=null){_iterator6["return"]();}}finally{if(_didIteratorError6){throw _iteratorError6;}}}if(!foundKeyOrdering){// The order of the implicit key ordering always matches the last
// explicit order by
var lastDirection=queryImpl.explicitOrderBy.length>0?queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length-1].dir:"asc"/* ASCENDING */;queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath.keyField(),lastDirection));}}}return queryImpl.memoizedOrderBy;}/**
 * Converts this `Query` instance to it's corresponding `Target` representation.
 */function queryToTarget(query){var queryImpl=debugCast(query);if(!queryImpl.memoizedTarget){if(queryImpl.limitType==="F"/* First */){queryImpl.memoizedTarget=newTarget(queryImpl.path,queryImpl.collectionGroup,queryOrderBy(queryImpl),queryImpl.filters,queryImpl.limit,queryImpl.startAt,queryImpl.endAt);}else{// Flip the orderBy directions since we want the last results
var orderBys=[];var _iteratorNormalCompletion7=true;var _didIteratorError7=false;var _iteratorError7=undefined;try{for(var _iterator7=queryOrderBy(queryImpl)[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){var orderBy=_step7.value;var dir=orderBy.dir==="desc"/* DESCENDING */?"asc"/* ASCENDING */:"desc"/* DESCENDING */;orderBys.push(new OrderBy(orderBy.field,dir));}// We need to swap the cursors to match the now-flipped query ordering.
}catch(err){_didIteratorError7=true;_iteratorError7=err;}finally{try{if(!_iteratorNormalCompletion7&&_iterator7["return"]!=null){_iterator7["return"]();}}finally{if(_didIteratorError7){throw _iteratorError7;}}}var startAt=queryImpl.endAt?new Bound(queryImpl.endAt.position,!queryImpl.endAt.before):null;var endAt=queryImpl.startAt?new Bound(queryImpl.startAt.position,!queryImpl.startAt.before):null;// Now return as a LimitType.First query.
queryImpl.memoizedTarget=newTarget(queryImpl.path,queryImpl.collectionGroup,orderBys,queryImpl.filters,queryImpl.limit,startAt,endAt);}}return queryImpl.memoizedTarget;}function queryWithAddedFilter(query,filter){var newFilters=query.filters.concat([filter]);return new QueryImpl(query.path,query.collectionGroup,query.explicitOrderBy.slice(),newFilters,query.limit,query.limitType,query.startAt,query.endAt);}function queryWithAddedOrderBy(query,orderBy){// TODO(dimond): validate that orderBy does not list the same key twice.
var newOrderBy=query.explicitOrderBy.concat([orderBy]);return new QueryImpl(query.path,query.collectionGroup,newOrderBy,query.filters.slice(),query.limit,query.limitType,query.startAt,query.endAt);}function queryWithLimit(query,limit,limitType){return new QueryImpl(query.path,query.collectionGroup,query.explicitOrderBy.slice(),query.filters.slice(),limit,limitType,query.startAt,query.endAt);}function queryWithStartAt(query,bound){return new QueryImpl(query.path,query.collectionGroup,query.explicitOrderBy.slice(),query.filters.slice(),query.limit,query.limitType,bound,query.endAt);}function queryWithEndAt(query,bound){return new QueryImpl(query.path,query.collectionGroup,query.explicitOrderBy.slice(),query.filters.slice(),query.limit,query.limitType,query.startAt,bound);}function queryEquals(left,right){return targetEquals(queryToTarget(left),queryToTarget(right))&&left.limitType===right.limitType;}// TODO(b/29183165): This is used to get a unique string from a query to, for
// example, use as a dictionary key, but the implementation is subject to
// collisions. Make it collision-free.
function canonifyQuery(query){return"".concat(canonifyTarget(queryToTarget(query)),"|lt:").concat(query.limitType);}function stringifyQuery(query){return"Query(target=".concat(stringifyTarget(queryToTarget(query)),"; limitType=").concat(query.limitType,")");}/** Returns whether `doc` matches the constraints of `query`. */function queryMatches(query,doc){return queryMatchesPathAndCollectionGroup(query,doc)&&queryMatchesOrderBy(query,doc)&&queryMatchesFilters(query,doc)&&queryMatchesBounds(query,doc);}function queryMatchesPathAndCollectionGroup(query,doc){var docPath=doc.key.path;if(query.collectionGroup!==null){// NOTE: this.path is currently always empty since we don't expose Collection
// Group queries rooted at a document path yet.
return doc.key.hasCollectionId(query.collectionGroup)&&query.path.isPrefixOf(docPath);}else if(DocumentKey.isDocumentKey(query.path)){// exact match for document queries
return query.path.isEqual(docPath);}else{// shallow ancestor queries by default
return query.path.isImmediateParentOf(docPath);}}/**
 * A document must have a value for every ordering clause in order to show up
 * in the results.
 */function queryMatchesOrderBy(query,doc){var _iteratorNormalCompletion8=true;var _didIteratorError8=false;var _iteratorError8=undefined;try{for(var _iterator8=query.explicitOrderBy[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){var orderBy=_step8.value;// order by key always matches
if(!orderBy.field.isKeyField()&&doc.field(orderBy.field)===null){return false;}}}catch(err){_didIteratorError8=true;_iteratorError8=err;}finally{try{if(!_iteratorNormalCompletion8&&_iterator8["return"]!=null){_iterator8["return"]();}}finally{if(_didIteratorError8){throw _iteratorError8;}}}return true;}function queryMatchesFilters(query,doc){var _iteratorNormalCompletion9=true;var _didIteratorError9=false;var _iteratorError9=undefined;try{for(var _iterator9=query.filters[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){var filter=_step9.value;if(!filter.matches(doc)){return false;}}}catch(err){_didIteratorError9=true;_iteratorError9=err;}finally{try{if(!_iteratorNormalCompletion9&&_iterator9["return"]!=null){_iterator9["return"]();}}finally{if(_didIteratorError9){throw _iteratorError9;}}}return true;}/** Makes sure a document is within the bounds, if provided. */function queryMatchesBounds(query,doc){if(query.startAt&&!sortsBeforeDocument(query.startAt,queryOrderBy(query),doc)){return false;}if(query.endAt&&sortsBeforeDocument(query.endAt,queryOrderBy(query),doc)){return false;}return true;}/**
 * Returns a new comparator function that can be used to compare two documents
 * based on the Query's ordering constraint.
 */function newQueryComparator(query){return function(d1,d2){var comparedOnKeyField=false;var _iteratorNormalCompletion10=true;var _didIteratorError10=false;var _iteratorError10=undefined;try{for(var _iterator10=queryOrderBy(query)[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){var orderBy=_step10.value;var comp=compareDocs(orderBy,d1,d2);if(comp!==0){return comp;}comparedOnKeyField=comparedOnKeyField||orderBy.field.isKeyField();}}catch(err){_didIteratorError10=true;_iteratorError10=err;}finally{try{if(!_iteratorNormalCompletion10&&_iterator10["return"]!=null){_iterator10["return"]();}}finally{if(_didIteratorError10){throw _iteratorError10;}}}return 0;};}var Filter=function Filter(){_classCallCheck(this,Filter);};var FieldFilter=/*#__PURE__*/function(_Filter){_inherits(FieldFilter,_Filter);function FieldFilter(field,op,value){var _this5;_classCallCheck(this,FieldFilter);_this5=_possibleConstructorReturn(this,_getPrototypeOf(FieldFilter).call(this));_this5.field=field;_this5.op=op;_this5.value=value;return _this5;}/**
     * Creates a filter based on the provided arguments.
     */_createClass(FieldFilter,[{key:"matches",value:function matches(doc){var other=doc.field(this.field);// Types do not have to match in NOT_EQUAL filters.
if(this.op==="!="/* NOT_EQUAL */){return other!==null&&this.matchesComparison(valueCompare(other,this.value));}// Only compare types with matching backend order (such as double and int).
return other!==null&&typeOrder(this.value)===typeOrder(other)&&this.matchesComparison(valueCompare(other,this.value));}},{key:"matchesComparison",value:function matchesComparison(comparison){switch(this.op){case"<"/* LESS_THAN */:return comparison<0;case"<="/* LESS_THAN_OR_EQUAL */:return comparison<=0;case"=="/* EQUAL */:return comparison===0;case"!="/* NOT_EQUAL */:return comparison!==0;case">"/* GREATER_THAN */:return comparison>0;case">="/* GREATER_THAN_OR_EQUAL */:return comparison>=0;default:return fail();}}},{key:"isInequality",value:function isInequality(){return["<"/* LESS_THAN */,"<="/* LESS_THAN_OR_EQUAL */,">"/* GREATER_THAN */,">="/* GREATER_THAN_OR_EQUAL */,"!="/* NOT_EQUAL */,"not-in"/* NOT_IN */].indexOf(this.op)>=0;}}],[{key:"create",value:function create(field,op,value){if(field.isKeyField()){if(op==="in"/* IN */||op==="not-in"/* NOT_IN */){return this.createKeyFieldInFilter(field,op,value);}else{return new KeyFieldFilter(field,op,value);}}else if(isNullValue(value)){if(op!=="=="/* EQUAL */&&op!=="!="/* NOT_EQUAL */){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. Null only supports '==' and '!=' comparisons.");}return new FieldFilter(field,op,value);}else if(isNanValue(value)){if(op!=="=="/* EQUAL */&&op!=="!="/* NOT_EQUAL */){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. NaN only supports '==' and '!=' comparisons.");}return new FieldFilter(field,op,value);}else if(op==="array-contains"/* ARRAY_CONTAINS */){return new ArrayContainsFilter(field,value);}else if(op==="in"/* IN */){return new InFilter(field,value);}else if(op==="not-in"/* NOT_IN */){return new NotInFilter(field,value);}else if(op==="array-contains-any"/* ARRAY_CONTAINS_ANY */){return new ArrayContainsAnyFilter(field,value);}else{return new FieldFilter(field,op,value);}}},{key:"createKeyFieldInFilter",value:function createKeyFieldInFilter(field,op,value){return op==="in"/* IN */?new KeyFieldInFilter(field,value):new KeyFieldNotInFilter(field,value);}}]);return FieldFilter;}(Filter);function canonifyFilter(filter){// TODO(b/29183165): Technically, this won't be unique if two values have
// the same description, such as the int 3 and the string "3". So we should
// add the types in here somehow, too.
return filter.field.canonicalString()+filter.op.toString()+canonicalId(filter.value);}function filterEquals(f1,f2){return f1.op===f2.op&&f1.field.isEqual(f2.field)&&valueEquals(f1.value,f2.value);}/** Returns a debug description for `filter`. */function stringifyFilter(filter){return"".concat(filter.field.canonicalString()," ").concat(filter.op," ").concat(canonicalId(filter.value));}/** Filter that matches on key fields (i.e. '__name__'). */var KeyFieldFilter=/*#__PURE__*/function(_FieldFilter){_inherits(KeyFieldFilter,_FieldFilter);function KeyFieldFilter(field,op,value){var _this6;_classCallCheck(this,KeyFieldFilter);_this6=_possibleConstructorReturn(this,_getPrototypeOf(KeyFieldFilter).call(this,field,op,value));_this6.key=DocumentKey.fromName(value.referenceValue);return _this6;}_createClass(KeyFieldFilter,[{key:"matches",value:function matches(doc){var comparison=DocumentKey.comparator(doc.key,this.key);return this.matchesComparison(comparison);}}]);return KeyFieldFilter;}(FieldFilter);/** Filter that matches on key fields within an array. */var KeyFieldInFilter=/*#__PURE__*/function(_FieldFilter2){_inherits(KeyFieldInFilter,_FieldFilter2);function KeyFieldInFilter(field,value){var _this7;_classCallCheck(this,KeyFieldInFilter);_this7=_possibleConstructorReturn(this,_getPrototypeOf(KeyFieldInFilter).call(this,field,"in"/* IN */,value));_this7.keys=extractDocumentKeysFromArrayValue("in"/* IN */,value);return _this7;}_createClass(KeyFieldInFilter,[{key:"matches",value:function matches(doc){return this.keys.some(function(key){return key.isEqual(doc.key);});}}]);return KeyFieldInFilter;}(FieldFilter);/** Filter that matches on key fields not present within an array. */var KeyFieldNotInFilter=/*#__PURE__*/function(_FieldFilter3){_inherits(KeyFieldNotInFilter,_FieldFilter3);function KeyFieldNotInFilter(field,value){var _this8;_classCallCheck(this,KeyFieldNotInFilter);_this8=_possibleConstructorReturn(this,_getPrototypeOf(KeyFieldNotInFilter).call(this,field,"not-in"/* NOT_IN */,value));_this8.keys=extractDocumentKeysFromArrayValue("not-in"/* NOT_IN */,value);return _this8;}_createClass(KeyFieldNotInFilter,[{key:"matches",value:function matches(doc){return!this.keys.some(function(key){return key.isEqual(doc.key);});}}]);return KeyFieldNotInFilter;}(FieldFilter);function extractDocumentKeysFromArrayValue(op,value){var _a;return(((_a=value.arrayValue)===null||_a===void 0?void 0:_a.values)||[]).map(function(v){return DocumentKey.fromName(v.referenceValue);});}/** A Filter that implements the array-contains operator. */var ArrayContainsFilter=/*#__PURE__*/function(_FieldFilter4){_inherits(ArrayContainsFilter,_FieldFilter4);function ArrayContainsFilter(field,value){_classCallCheck(this,ArrayContainsFilter);return _possibleConstructorReturn(this,_getPrototypeOf(ArrayContainsFilter).call(this,field,"array-contains"/* ARRAY_CONTAINS */,value));}_createClass(ArrayContainsFilter,[{key:"matches",value:function matches(doc){var other=doc.field(this.field);return isArray(other)&&arrayValueContains(other.arrayValue,this.value);}}]);return ArrayContainsFilter;}(FieldFilter);/** A Filter that implements the IN operator. */var InFilter=/*#__PURE__*/function(_FieldFilter5){_inherits(InFilter,_FieldFilter5);function InFilter(field,value){_classCallCheck(this,InFilter);return _possibleConstructorReturn(this,_getPrototypeOf(InFilter).call(this,field,"in"/* IN */,value));}_createClass(InFilter,[{key:"matches",value:function matches(doc){var other=doc.field(this.field);return other!==null&&arrayValueContains(this.value.arrayValue,other);}}]);return InFilter;}(FieldFilter);/** A Filter that implements the not-in operator. */var NotInFilter=/*#__PURE__*/function(_FieldFilter6){_inherits(NotInFilter,_FieldFilter6);function NotInFilter(field,value){_classCallCheck(this,NotInFilter);return _possibleConstructorReturn(this,_getPrototypeOf(NotInFilter).call(this,field,"not-in"/* NOT_IN */,value));}_createClass(NotInFilter,[{key:"matches",value:function matches(doc){if(arrayValueContains(this.value.arrayValue,{nullValue:'NULL_VALUE'})){return false;}var other=doc.field(this.field);return other!==null&&!arrayValueContains(this.value.arrayValue,other);}}]);return NotInFilter;}(FieldFilter);/** A Filter that implements the array-contains-any operator. */var ArrayContainsAnyFilter=/*#__PURE__*/function(_FieldFilter7){_inherits(ArrayContainsAnyFilter,_FieldFilter7);function ArrayContainsAnyFilter(field,value){_classCallCheck(this,ArrayContainsAnyFilter);return _possibleConstructorReturn(this,_getPrototypeOf(ArrayContainsAnyFilter).call(this,field,"array-contains-any"/* ARRAY_CONTAINS_ANY */,value));}_createClass(ArrayContainsAnyFilter,[{key:"matches",value:function matches(doc){var _this9=this;var other=doc.field(this.field);if(!isArray(other)||!other.arrayValue.values){return false;}return other.arrayValue.values.some(function(val){return arrayValueContains(_this9.value.arrayValue,val);});}}]);return ArrayContainsAnyFilter;}(FieldFilter);/**
 * Represents a bound of a query.
 *
 * The bound is specified with the given components representing a position and
 * whether it's just before or just after the position (relative to whatever the
 * query order is).
 *
 * The position represents a logical index position for a query. It's a prefix
 * of values for the (potentially implicit) order by clauses of a query.
 *
 * Bound provides a function to determine whether a document comes before or
 * after a bound. This is influenced by whether the position is just before or
 * just after the provided values.
 */var Bound=function Bound(position,before){_classCallCheck(this,Bound);this.position=position;this.before=before;};function canonifyBound(bound){// TODO(b/29183165): Make this collision robust.
return"".concat(bound.before?'b':'a',":").concat(bound.position.map(function(p){return canonicalId(p);}).join(','));}/**
 * Returns true if a document sorts before a bound using the provided sort
 * order.
 */function sortsBeforeDocument(bound,orderBy,doc){var comparison=0;for(var i=0;i<bound.position.length;i++){var orderByComponent=orderBy[i];var component=bound.position[i];if(orderByComponent.field.isKeyField()){comparison=DocumentKey.comparator(DocumentKey.fromName(component.referenceValue),doc.key);}else{var docValue=doc.field(orderByComponent.field);comparison=valueCompare(component,docValue);}if(orderByComponent.dir==="desc"/* DESCENDING */){comparison=comparison*-1;}if(comparison!==0){break;}}return bound.before?comparison<=0:comparison<0;}function boundEquals(left,right){if(left===null){return right===null;}else if(right===null){return false;}if(left.before!==right.before||left.position.length!==right.position.length){return false;}for(var i=0;i<left.position.length;i++){var leftPosition=left.position[i];var rightPosition=right.position[i];if(!valueEquals(leftPosition,rightPosition)){return false;}}return true;}/**
 * An ordering on a field, in some Direction. Direction defaults to ASCENDING.
 */var OrderBy=function OrderBy(field)/* ASCENDING */{var dir=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"asc";_classCallCheck(this,OrderBy);this.field=field;this.dir=dir;};function compareDocs(orderBy,d1,d2){var comparison=orderBy.field.isKeyField()?DocumentKey.comparator(d1.key,d2.key):compareDocumentsByField(orderBy.field,d1,d2);switch(orderBy.dir){case"asc"/* ASCENDING */:return comparison;case"desc"/* DESCENDING */:return-1*comparison;default:return fail();}}function canonifyOrderBy(orderBy){// TODO(b/29183165): Make this collision robust.
return orderBy.field.canonicalString()+orderBy.dir;}function stringifyOrderBy(orderBy){return"".concat(orderBy.field.canonicalString()," (").concat(orderBy.dir,")");}function orderByEquals(left,right){return left.dir===right.dir&&left.field.isEqual(right.field);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A version of a document in Firestore. This corresponds to the version
 * timestamp, such as update_time or read_time.
 */var SnapshotVersion=/*#__PURE__*/function(){function SnapshotVersion(timestamp){_classCallCheck(this,SnapshotVersion);this.timestamp=timestamp;}_createClass(SnapshotVersion,[{key:"compareTo",value:function compareTo(other){return this.timestamp._compareTo(other.timestamp);}},{key:"isEqual",value:function isEqual(other){return this.timestamp.isEqual(other.timestamp);}/** Returns a number representation of the version for use in spec tests. */},{key:"toMicroseconds",value:function toMicroseconds(){// Convert to microseconds.
return this.timestamp.seconds*1e6+this.timestamp.nanoseconds/1000;}},{key:"toString",value:function toString(){return'SnapshotVersion('+this.timestamp.toString()+')';}},{key:"toTimestamp",value:function toTimestamp(){return this.timestamp;}}],[{key:"fromTimestamp",value:function fromTimestamp(value){return new SnapshotVersion(value);}},{key:"min",value:function min(){return new SnapshotVersion(new Timestamp(0,0));}}]);return SnapshotVersion;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An ObjectValue represents a MapValue in the Firestore Proto and offers the
 * ability to add and remove fields (via the ObjectValueBuilder).
 */var ObjectValue=/*#__PURE__*/function(){function ObjectValue(proto){_classCallCheck(this,ObjectValue);this.proto=proto;}_createClass(ObjectValue,[{key:"field",/**
     * Returns the value at the given path or null.
     *
     * @param path the path to search
     * @return The value at the path or if there it doesn't exist.
     */value:function field(path){if(path.isEmpty()){return this.proto;}else{var value=this.proto;for(var i=0;i<path.length-1;++i){if(!value.mapValue.fields){return null;}value=value.mapValue.fields[path.get(i)];if(!isMapValue(value)){return null;}}value=(value.mapValue.fields||{})[path.lastSegment()];return value||null;}}},{key:"isEqual",value:function isEqual(other){return valueEquals(this.proto,other.proto);}}],[{key:"empty",value:function empty(){return new ObjectValue({mapValue:{}});}}]);return ObjectValue;}();/**
 * An ObjectValueBuilder provides APIs to set and delete fields from an
 * ObjectValue.
 */var ObjectValueBuilder=/*#__PURE__*/function(){/**
     * @param baseObject The object to mutate.
     */function ObjectValueBuilder(){var baseObject=arguments.length>0&&arguments[0]!==undefined?arguments[0]:ObjectValue.empty();_classCallCheck(this,ObjectValueBuilder);this.baseObject=baseObject;/** A map that contains the accumulated changes in this builder. */this.overlayMap=new Map();}/**
     * Sets the field to the provided value.
     *
     * @param path The field path to set.
     * @param value The value to set.
     * @return The current Builder instance.
     */_createClass(ObjectValueBuilder,[{key:"set",value:function set(path,value){this.setOverlay(path,value);return this;}/**
     * Removes the field at the specified path. If there is no field at the
     * specified path, nothing is changed.
     *
     * @param path The field path to remove.
     * @return The current Builder instance.
     */},{key:"delete",value:function _delete(path){this.setOverlay(path,null);return this;}/**
     * Adds `value` to the overlay map at `path`. Creates nested map entries if
     * needed.
     */},{key:"setOverlay",value:function setOverlay(path,value){var currentLevel=this.overlayMap;for(var i=0;i<path.length-1;++i){var currentSegment=path.get(i);var currentValue=currentLevel.get(currentSegment);if(currentValue instanceof Map){// Re-use a previously created map
currentLevel=currentValue;}else if(currentValue&&typeOrder(currentValue)===10/* ObjectValue */){// Convert the existing Protobuf MapValue into a map
currentValue=new Map(Object.entries(currentValue.mapValue.fields||{}));currentLevel.set(currentSegment,currentValue);currentLevel=currentValue;}else{// Create an empty map to represent the current nesting level
currentValue=new Map();currentLevel.set(currentSegment,currentValue);currentLevel=currentValue;}}currentLevel.set(path.lastSegment(),value);}/** Returns an ObjectValue with all mutations applied. */},{key:"build",value:function build(){var mergedResult=this.applyOverlay(FieldPath.emptyPath(),this.overlayMap);if(mergedResult!=null){return new ObjectValue(mergedResult);}else{return this.baseObject;}}/**
     * Applies any overlays from `currentOverlays` that exist at `currentPath`
     * and returns the merged data at `currentPath` (or null if there were no
     * changes).
     *
     * @param currentPath The path at the current nesting level. Can be set to
     * FieldValue.emptyPath() to represent the root.
     * @param currentOverlays The overlays at the current nesting level in the
     * same format as `overlayMap`.
     * @return The merged data at `currentPath` or null if no modifications
     * were applied.
     */},{key:"applyOverlay",value:function applyOverlay(currentPath,currentOverlays){var _this10=this;var modified=false;var existingValue=this.baseObject.field(currentPath);var resultAtPath=isMapValue(existingValue)?// If there is already data at the current path, base our
Object.assign({},existingValue.mapValue.fields):{};currentOverlays.forEach(function(value,pathSegment){if(value instanceof Map){var nested=_this10.applyOverlay(currentPath.child(pathSegment),value);if(nested!=null){resultAtPath[pathSegment]=nested;modified=true;}}else if(value!==null){resultAtPath[pathSegment]=value;modified=true;}else if(resultAtPath.hasOwnProperty(pathSegment)){delete resultAtPath[pathSegment];modified=true;}});return modified?{mapValue:{fields:resultAtPath}}:null;}}]);return ObjectValueBuilder;}();/**
 * Returns a FieldMask built from all fields in a MapValue.
 */function extractFieldMask(value){var fields=[];_forEach(value.fields||{},function(key,value){var currentPath=new FieldPath([key]);if(isMapValue(value)){var nestedMask=extractFieldMask(value.mapValue);var nestedFields=nestedMask.fields;if(nestedFields.length===0){// Preserve the empty map by adding it to the FieldMask.
fields.push(currentPath);}else{// For nested and non-empty ObjectValues, add the FieldPath of the
// leaf nodes.
var _iteratorNormalCompletion11=true;var _didIteratorError11=false;var _iteratorError11=undefined;try{for(var _iterator11=nestedFields[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){var nestedPath=_step11.value;fields.push(currentPath.child(nestedPath));}}catch(err){_didIteratorError11=true;_iteratorError11=err;}finally{try{if(!_iteratorNormalCompletion11&&_iterator11["return"]!=null){_iterator11["return"]();}}finally{if(_didIteratorError11){throw _iteratorError11;}}}}}else{// For nested and non-empty ObjectValues, add the FieldPath of the leaf
// nodes.
fields.push(currentPath);}});return new FieldMask(fields);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var ExistenceFilter=// TODO(b/33078163): just use simplest form of existence filter for now
function ExistenceFilter(count){_classCallCheck(this,ExistenceFilter);this.count=count;};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Error Codes describing the different ways GRPC can fail. These are copied
 * directly from GRPC's sources here:
 *
 * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
 *
 * Important! The names of these identifiers matter because the string forms
 * are used for reverse lookups from the webchannel stream. Do NOT change the
 * names of these identifiers or change this into a const enum.
 */var RpcCode;(function(RpcCode){RpcCode[RpcCode["OK"]=0]="OK";RpcCode[RpcCode["CANCELLED"]=1]="CANCELLED";RpcCode[RpcCode["UNKNOWN"]=2]="UNKNOWN";RpcCode[RpcCode["INVALID_ARGUMENT"]=3]="INVALID_ARGUMENT";RpcCode[RpcCode["DEADLINE_EXCEEDED"]=4]="DEADLINE_EXCEEDED";RpcCode[RpcCode["NOT_FOUND"]=5]="NOT_FOUND";RpcCode[RpcCode["ALREADY_EXISTS"]=6]="ALREADY_EXISTS";RpcCode[RpcCode["PERMISSION_DENIED"]=7]="PERMISSION_DENIED";RpcCode[RpcCode["UNAUTHENTICATED"]=16]="UNAUTHENTICATED";RpcCode[RpcCode["RESOURCE_EXHAUSTED"]=8]="RESOURCE_EXHAUSTED";RpcCode[RpcCode["FAILED_PRECONDITION"]=9]="FAILED_PRECONDITION";RpcCode[RpcCode["ABORTED"]=10]="ABORTED";RpcCode[RpcCode["OUT_OF_RANGE"]=11]="OUT_OF_RANGE";RpcCode[RpcCode["UNIMPLEMENTED"]=12]="UNIMPLEMENTED";RpcCode[RpcCode["INTERNAL"]=13]="INTERNAL";RpcCode[RpcCode["UNAVAILABLE"]=14]="UNAVAILABLE";RpcCode[RpcCode["DATA_LOSS"]=15]="DATA_LOSS";})(RpcCode||(RpcCode={}));/**
 * Determines whether an error code represents a permanent error when received
 * in response to a non-write operation.
 *
 * See isPermanentWriteError for classifying write errors.
 */function isPermanentError(code){switch(code){case Code.OK:return fail();case Code.CANCELLED:case Code.UNKNOWN:case Code.DEADLINE_EXCEEDED:case Code.RESOURCE_EXHAUSTED:case Code.INTERNAL:case Code.UNAVAILABLE:// Unauthenticated means something went wrong with our token and we need
// to retry with new credentials which will happen automatically.
case Code.UNAUTHENTICATED:return false;case Code.INVALID_ARGUMENT:case Code.NOT_FOUND:case Code.ALREADY_EXISTS:case Code.PERMISSION_DENIED:case Code.FAILED_PRECONDITION:// Aborted might be retried in some scenarios, but that is dependant on
// the context and should handled individually by the calling code.
// See https://cloud.google.com/apis/design/errors.
case Code.ABORTED:case Code.OUT_OF_RANGE:case Code.UNIMPLEMENTED:case Code.DATA_LOSS:return true;default:return fail();}}/**
 * Determines whether an error code represents a permanent error when received
 * in response to a write operation.
 *
 * Write operations must be handled specially because as of b/119437764, ABORTED
 * errors on the write stream should be retried too (even though ABORTED errors
 * are not generally retryable).
 *
 * Note that during the initial handshake on the write stream an ABORTED error
 * signals that we should discard our stream token (i.e. it is permanent). This
 * means a handshake error should be classified with isPermanentError, above.
 */function isPermanentWriteError(code){return isPermanentError(code)&&code!==Code.ABORTED;}/**
 * Maps an error Code from GRPC status code number, like 0, 1, or 14. These
 * are not the same as HTTP status codes.
 *
 * @returns The Code equivalent to the given GRPC status code. Fails if there
 *     is no match.
 */function mapCodeFromRpcCode(code){if(code===undefined){// This shouldn't normally happen, but in certain error cases (like trying
// to send invalid proto messages) we may get an error with no GRPC code.
logError('GRPC error has no .code');return Code.UNKNOWN;}switch(code){case RpcCode.OK:return Code.OK;case RpcCode.CANCELLED:return Code.CANCELLED;case RpcCode.UNKNOWN:return Code.UNKNOWN;case RpcCode.DEADLINE_EXCEEDED:return Code.DEADLINE_EXCEEDED;case RpcCode.RESOURCE_EXHAUSTED:return Code.RESOURCE_EXHAUSTED;case RpcCode.INTERNAL:return Code.INTERNAL;case RpcCode.UNAVAILABLE:return Code.UNAVAILABLE;case RpcCode.UNAUTHENTICATED:return Code.UNAUTHENTICATED;case RpcCode.INVALID_ARGUMENT:return Code.INVALID_ARGUMENT;case RpcCode.NOT_FOUND:return Code.NOT_FOUND;case RpcCode.ALREADY_EXISTS:return Code.ALREADY_EXISTS;case RpcCode.PERMISSION_DENIED:return Code.PERMISSION_DENIED;case RpcCode.FAILED_PRECONDITION:return Code.FAILED_PRECONDITION;case RpcCode.ABORTED:return Code.ABORTED;case RpcCode.OUT_OF_RANGE:return Code.OUT_OF_RANGE;case RpcCode.UNIMPLEMENTED:return Code.UNIMPLEMENTED;case RpcCode.DATA_LOSS:return Code.DATA_LOSS;default:return fail();}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An event from the RemoteStore. It is split into targetChanges (changes to the
 * state or the set of documents in our watched targets) and documentUpdates
 * (changes to the actual documents).
 */var RemoteEvent=/*#__PURE__*/function(){function RemoteEvent(/**
     * The snapshot version this event brings us up to, or MIN if not set.
     */snapshotVersion,/**
     * A map from target to changes to the target. See TargetChange.
     */targetChanges,/**
     * A set of targets that is known to be inconsistent. Listens for these
     * targets should be re-established without resume tokens.
     */targetMismatches,/**
     * A set of which documents have changed or been deleted, along with the
     * doc's new values (if not deleted).
     */documentUpdates,/**
     * A set of which document updates are due only to limbo resolution targets.
     */resolvedLimboDocuments){_classCallCheck(this,RemoteEvent);this.snapshotVersion=snapshotVersion;this.targetChanges=targetChanges;this.targetMismatches=targetMismatches;this.documentUpdates=documentUpdates;this.resolvedLimboDocuments=resolvedLimboDocuments;}/**
     * HACK: Views require RemoteEvents in order to determine whether the view is
     * CURRENT, but secondary tabs don't receive remote events. So this method is
     * used to create a synthesized RemoteEvent that can be used to apply a
     * CURRENT status change to a View, for queries executed in a different tab.
     */ // PORTING NOTE: Multi-tab only
_createClass(RemoteEvent,null,[{key:"createSynthesizedRemoteEventForCurrentChange",value:function createSynthesizedRemoteEventForCurrentChange(targetId,current){var targetChanges=new Map();targetChanges.set(targetId,TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId,current));return new RemoteEvent(SnapshotVersion.min(),targetChanges,targetIdSet(),maybeDocumentMap(),documentKeySet());}}]);return RemoteEvent;}();/**
 * A TargetChange specifies the set of changes for a specific target as part of
 * a RemoteEvent. These changes track which documents are added, modified or
 * removed, as well as the target's resume token and whether the target is
 * marked CURRENT.
 * The actual changes *to* documents are not part of the TargetChange since
 * documents may be part of multiple targets.
 */var TargetChange=/*#__PURE__*/function(){function TargetChange(/**
     * An opaque, server-assigned token that allows watching a query to be resumed
     * after disconnecting without retransmitting all the data that matches the
     * query. The resume token essentially identifies a point in time from which
     * the server should resume sending results.
     */resumeToken,/**
     * The "current" (synced) status of this target. Note that "current"
     * has special meaning in the RPC protocol that implies that a target is
     * both up-to-date and consistent with the rest of the watch stream.
     */current,/**
     * The set of documents that were newly assigned to this target as part of
     * this remote event.
     */addedDocuments,/**
     * The set of documents that were already assigned to this target but received
     * an update during this remote event.
     */modifiedDocuments,/**
     * The set of documents that were removed from this target as part of this
     * remote event.
     */removedDocuments){_classCallCheck(this,TargetChange);this.resumeToken=resumeToken;this.current=current;this.addedDocuments=addedDocuments;this.modifiedDocuments=modifiedDocuments;this.removedDocuments=removedDocuments;}/**
     * This method is used to create a synthesized TargetChanges that can be used to
     * apply a CURRENT status change to a View (for queries executed in a different
     * tab) or for new queries (to raise snapshots with correct CURRENT status).
     */_createClass(TargetChange,null,[{key:"createSynthesizedTargetChangeForCurrentChange",value:function createSynthesizedTargetChangeForCurrentChange(targetId,current){return new TargetChange(ByteString.EMPTY_BYTE_STRING,current,documentKeySet(),documentKeySet(),documentKeySet());}}]);return TargetChange;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Represents a changed document and a list of target ids to which this change
 * applies.
 *
 * If document has been deleted NoDocument will be provided.
 */var DocumentWatchChange=function DocumentWatchChange(/** The new document applies to all of these targets. */updatedTargetIds,/** The new document is removed from all of these targets. */removedTargetIds,/** The key of the document for this change. */key,/**
     * The new document or NoDocument if it was deleted. Is null if the
     * document went out of view without the server sending a new document.
     */newDoc){_classCallCheck(this,DocumentWatchChange);this.updatedTargetIds=updatedTargetIds;this.removedTargetIds=removedTargetIds;this.key=key;this.newDoc=newDoc;};var ExistenceFilterChange=function ExistenceFilterChange(targetId,existenceFilter){_classCallCheck(this,ExistenceFilterChange);this.targetId=targetId;this.existenceFilter=existenceFilter;};var WatchTargetChange=function WatchTargetChange(/** What kind of change occurred to the watch target. */state,/** The target IDs that were added/removed/set. */targetIds){var resumeToken=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ByteString.EMPTY_BYTE_STRING;var cause=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;_classCallCheck(this,WatchTargetChange);this.state=state;this.targetIds=targetIds;this.resumeToken=resumeToken;this.cause=cause;};/** Tracks the internal state of a Watch target. */var TargetState=/*#__PURE__*/function(){function TargetState(){_classCallCheck(this,TargetState);/**
         * The number of pending responses (adds or removes) that we are waiting on.
         * We only consider targets active that have no pending responses.
         */this.pendingResponses=0;/**
         * Keeps track of the document changes since the last raised snapshot.
         *
         * These changes are continuously updated as we receive document updates and
         * always reflect the current set of changes against the last issued snapshot.
         */this.documentChanges=snapshotChangesMap();/** See public getters for explanations of these fields. */this._resumeToken=ByteString.EMPTY_BYTE_STRING;this._current=false;/**
         * Whether this target state should be included in the next snapshot. We
         * initialize to true so that newly-added targets are included in the next
         * RemoteEvent.
         */this._hasPendingChanges=true;}/**
     * Whether this target has been marked 'current'.
     *
     * 'Current' has special meaning in the RPC protocol: It implies that the
     * Watch backend has sent us all changes up to the point at which the target
     * was added and that the target is consistent with the rest of the watch
     * stream.
     */_createClass(TargetState,[{key:"updateResumeToken",/**
     * Applies the resume token to the TargetChange, but only when it has a new
     * value. Empty resumeTokens are discarded.
     */value:function updateResumeToken(resumeToken){if(resumeToken.approximateByteSize()>0){this._hasPendingChanges=true;this._resumeToken=resumeToken;}}/**
     * Creates a target change from the current set of changes.
     *
     * To reset the document changes after raising this snapshot, call
     * `clearPendingChanges()`.
     */},{key:"toTargetChange",value:function toTargetChange(){var addedDocuments=documentKeySet();var modifiedDocuments=documentKeySet();var removedDocuments=documentKeySet();this.documentChanges.forEach(function(key,changeType){switch(changeType){case 0/* Added */:addedDocuments=addedDocuments.add(key);break;case 2/* Modified */:modifiedDocuments=modifiedDocuments.add(key);break;case 1/* Removed */:removedDocuments=removedDocuments.add(key);break;default:fail();}});return new TargetChange(this._resumeToken,this._current,addedDocuments,modifiedDocuments,removedDocuments);}/**
     * Resets the document changes and sets `hasPendingChanges` to false.
     */},{key:"clearPendingChanges",value:function clearPendingChanges(){this._hasPendingChanges=false;this.documentChanges=snapshotChangesMap();}},{key:"addDocumentChange",value:function addDocumentChange(key,changeType){this._hasPendingChanges=true;this.documentChanges=this.documentChanges.insert(key,changeType);}},{key:"removeDocumentChange",value:function removeDocumentChange(key){this._hasPendingChanges=true;this.documentChanges=this.documentChanges.remove(key);}},{key:"recordPendingTargetRequest",value:function recordPendingTargetRequest(){this.pendingResponses+=1;}},{key:"recordTargetResponse",value:function recordTargetResponse(){this.pendingResponses-=1;}},{key:"markCurrent",value:function markCurrent(){this._hasPendingChanges=true;this._current=true;}},{key:"current",get:function get(){return this._current;}/** The last resume token sent to us for this target. */},{key:"resumeToken",get:function get(){return this._resumeToken;}/** Whether this target has pending target adds or target removes. */},{key:"isPending",get:function get(){return this.pendingResponses!==0;}/** Whether we have modified any state that should trigger a snapshot. */},{key:"hasPendingChanges",get:function get(){return this._hasPendingChanges;}}]);return TargetState;}();var LOG_TAG='WatchChangeAggregator';/**
 * A helper class to accumulate watch changes into a RemoteEvent.
 */var WatchChangeAggregator=/*#__PURE__*/function(){function WatchChangeAggregator(metadataProvider){_classCallCheck(this,WatchChangeAggregator);this.metadataProvider=metadataProvider;/** The internal state of all tracked targets. */this.targetStates=new Map();/** Keeps track of the documents to update since the last raised snapshot. */this.pendingDocumentUpdates=maybeDocumentMap();/** A mapping of document keys to their set of target IDs. */this.pendingDocumentTargetMapping=documentTargetMap();/**
         * A list of targets with existence filter mismatches. These targets are
         * known to be inconsistent and their listens needs to be re-established by
         * RemoteStore.
         */this.pendingTargetResets=new SortedSet(primitiveComparator);}/**
     * Processes and adds the DocumentWatchChange to the current set of changes.
     */_createClass(WatchChangeAggregator,[{key:"handleDocumentChange",value:function handleDocumentChange(docChange){var _iteratorNormalCompletion12=true;var _didIteratorError12=false;var _iteratorError12=undefined;try{for(var _iterator12=docChange.updatedTargetIds[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){var targetId=_step12.value;if(docChange.newDoc instanceof Document){this.addDocumentToTarget(targetId,docChange.newDoc);}else if(docChange.newDoc instanceof NoDocument){this.removeDocumentFromTarget(targetId,docChange.key,docChange.newDoc);}}}catch(err){_didIteratorError12=true;_iteratorError12=err;}finally{try{if(!_iteratorNormalCompletion12&&_iterator12["return"]!=null){_iterator12["return"]();}}finally{if(_didIteratorError12){throw _iteratorError12;}}}var _iteratorNormalCompletion13=true;var _didIteratorError13=false;var _iteratorError13=undefined;try{for(var _iterator13=docChange.removedTargetIds[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){var _targetId=_step13.value;this.removeDocumentFromTarget(_targetId,docChange.key,docChange.newDoc);}}catch(err){_didIteratorError13=true;_iteratorError13=err;}finally{try{if(!_iteratorNormalCompletion13&&_iterator13["return"]!=null){_iterator13["return"]();}}finally{if(_didIteratorError13){throw _iteratorError13;}}}}/** Processes and adds the WatchTargetChange to the current set of changes. */},{key:"handleTargetChange",value:function handleTargetChange(targetChange){var _this11=this;this.forEachTarget(targetChange,function(targetId){var targetState=_this11.ensureTargetState(targetId);switch(targetChange.state){case 0/* NoChange */:if(_this11.isActiveTarget(targetId)){targetState.updateResumeToken(targetChange.resumeToken);}break;case 1/* Added */:// We need to decrement the number of pending acks needed from watch
// for this targetId.
targetState.recordTargetResponse();if(!targetState.isPending){// We have a freshly added target, so we need to reset any state
// that we had previously. This can happen e.g. when remove and add
// back a target for existence filter mismatches.
targetState.clearPendingChanges();}targetState.updateResumeToken(targetChange.resumeToken);break;case 2/* Removed */:// We need to keep track of removed targets to we can post-filter and
// remove any target changes.
// We need to decrement the number of pending acks needed from watch
// for this targetId.
targetState.recordTargetResponse();if(!targetState.isPending){_this11.removeTarget(targetId);}break;case 3/* Current */:if(_this11.isActiveTarget(targetId)){targetState.markCurrent();targetState.updateResumeToken(targetChange.resumeToken);}break;case 4/* Reset */:if(_this11.isActiveTarget(targetId)){// Reset the target and synthesizes removes for all existing
// documents. The backend will re-add any documents that still
// match the target before it sends the next global snapshot.
_this11.resetTarget(targetId);targetState.updateResumeToken(targetChange.resumeToken);}break;default:fail();}});}/**
     * Iterates over all targetIds that the watch change applies to: either the
     * targetIds explicitly listed in the change or the targetIds of all currently
     * active targets.
     */},{key:"forEachTarget",value:function forEachTarget(targetChange,fn){var _this12=this;if(targetChange.targetIds.length>0){targetChange.targetIds.forEach(fn);}else{this.targetStates.forEach(function(_,targetId){if(_this12.isActiveTarget(targetId)){fn(targetId);}});}}/**
     * Handles existence filters and synthesizes deletes for filter mismatches.
     * Targets that are invalidated by filter mismatches are added to
     * `pendingTargetResets`.
     */},{key:"handleExistenceFilter",value:function handleExistenceFilter(watchChange){var targetId=watchChange.targetId;var expectedCount=watchChange.existenceFilter.count;var targetData=this.targetDataForActiveTarget(targetId);if(targetData){var target=targetData.target;if(isDocumentTarget(target)){if(expectedCount===0){// The existence filter told us the document does not exist. We deduce
// that this document does not exist and apply a deleted document to
// our updates. Without applying this deleted document there might be
// another query that will raise this document as part of a snapshot
// until it is resolved, essentially exposing inconsistency between
// queries.
var key=new DocumentKey(target.path);this.removeDocumentFromTarget(targetId,key,new NoDocument(key,SnapshotVersion.min()));}else{hardAssert(expectedCount===1);}}else{var currentSize=this.getCurrentDocumentCountForTarget(targetId);if(currentSize!==expectedCount){// Existence filter mismatch: We reset the mapping and raise a new
// snapshot with `isFromCache:true`.
this.resetTarget(targetId);this.pendingTargetResets=this.pendingTargetResets.add(targetId);}}}}/**
     * Converts the currently accumulated state into a remote event at the
     * provided snapshot version. Resets the accumulated changes before returning.
     */},{key:"createRemoteEvent",value:function createRemoteEvent(snapshotVersion){var _this13=this;var targetChanges=new Map();this.targetStates.forEach(function(targetState,targetId){var targetData=_this13.targetDataForActiveTarget(targetId);if(targetData){if(targetState.current&&isDocumentTarget(targetData.target)){// Document queries for document that don't exist can produce an empty
// result set. To update our local cache, we synthesize a document
// delete if we have not previously received the document. This
// resolves the limbo state of the document, removing it from
// limboDocumentRefs.
//
// TODO(dimond): Ideally we would have an explicit lookup target
// instead resulting in an explicit delete message and we could
// remove this special logic.
var key=new DocumentKey(targetData.target.path);if(_this13.pendingDocumentUpdates.get(key)===null&&!_this13.targetContainsDocument(targetId,key)){_this13.removeDocumentFromTarget(targetId,key,new NoDocument(key,snapshotVersion));}}if(targetState.hasPendingChanges){targetChanges.set(targetId,targetState.toTargetChange());targetState.clearPendingChanges();}}});var resolvedLimboDocuments=documentKeySet();// We extract the set of limbo-only document updates as the GC logic
// special-cases documents that do not appear in the target cache.
//
// TODO(gsoltis): Expand on this comment once GC is available in the JS
// client.
this.pendingDocumentTargetMapping.forEach(function(key,targets){var isOnlyLimboTarget=true;targets.forEachWhile(function(targetId){var targetData=_this13.targetDataForActiveTarget(targetId);if(targetData&&targetData.purpose!==2/* LimboResolution */){isOnlyLimboTarget=false;return false;}return true;});if(isOnlyLimboTarget){resolvedLimboDocuments=resolvedLimboDocuments.add(key);}});var remoteEvent=new RemoteEvent(snapshotVersion,targetChanges,this.pendingTargetResets,this.pendingDocumentUpdates,resolvedLimboDocuments);this.pendingDocumentUpdates=maybeDocumentMap();this.pendingDocumentTargetMapping=documentTargetMap();this.pendingTargetResets=new SortedSet(primitiveComparator);return remoteEvent;}/**
     * Adds the provided document to the internal list of document updates and
     * its document key to the given target's mapping.
     */ // Visible for testing.
},{key:"addDocumentToTarget",value:function addDocumentToTarget(targetId,document){if(!this.isActiveTarget(targetId)){return;}var changeType=this.targetContainsDocument(targetId,document.key)?2/* Modified */:0/* Added */;var targetState=this.ensureTargetState(targetId);targetState.addDocumentChange(document.key,changeType);this.pendingDocumentUpdates=this.pendingDocumentUpdates.insert(document.key,document);this.pendingDocumentTargetMapping=this.pendingDocumentTargetMapping.insert(document.key,this.ensureDocumentTargetMapping(document.key).add(targetId));}/**
     * Removes the provided document from the target mapping. If the
     * document no longer matches the target, but the document's state is still
     * known (e.g. we know that the document was deleted or we received the change
     * that caused the filter mismatch), the new document can be provided
     * to update the remote document cache.
     */ // Visible for testing.
},{key:"removeDocumentFromTarget",value:function removeDocumentFromTarget(targetId,key,updatedDocument){if(!this.isActiveTarget(targetId)){return;}var targetState=this.ensureTargetState(targetId);if(this.targetContainsDocument(targetId,key)){targetState.addDocumentChange(key,1/* Removed */);}else{// The document may have entered and left the target before we raised a
// snapshot, so we can just ignore the change.
targetState.removeDocumentChange(key);}this.pendingDocumentTargetMapping=this.pendingDocumentTargetMapping.insert(key,this.ensureDocumentTargetMapping(key)["delete"](targetId));if(updatedDocument){this.pendingDocumentUpdates=this.pendingDocumentUpdates.insert(key,updatedDocument);}}},{key:"removeTarget",value:function removeTarget(targetId){this.targetStates["delete"](targetId);}/**
     * Returns the current count of documents in the target. This includes both
     * the number of documents that the LocalStore considers to be part of the
     * target as well as any accumulated changes.
     */},{key:"getCurrentDocumentCountForTarget",value:function getCurrentDocumentCountForTarget(targetId){var targetState=this.ensureTargetState(targetId);var targetChange=targetState.toTargetChange();return this.metadataProvider.getRemoteKeysForTarget(targetId).size+targetChange.addedDocuments.size-targetChange.removedDocuments.size;}/**
     * Increment the number of acks needed from watch before we can consider the
     * server to be 'in-sync' with the client's active targets.
     */},{key:"recordPendingTargetRequest",value:function recordPendingTargetRequest(targetId){// For each request we get we need to record we need a response for it.
var targetState=this.ensureTargetState(targetId);targetState.recordPendingTargetRequest();}},{key:"ensureTargetState",value:function ensureTargetState(targetId){var result=this.targetStates.get(targetId);if(!result){result=new TargetState();this.targetStates.set(targetId,result);}return result;}},{key:"ensureDocumentTargetMapping",value:function ensureDocumentTargetMapping(key){var targetMapping=this.pendingDocumentTargetMapping.get(key);if(!targetMapping){targetMapping=new SortedSet(primitiveComparator);this.pendingDocumentTargetMapping=this.pendingDocumentTargetMapping.insert(key,targetMapping);}return targetMapping;}/**
     * Verifies that the user is still interested in this target (by calling
     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs
     * from watch.
     */},{key:"isActiveTarget",value:function isActiveTarget(targetId){var targetActive=this.targetDataForActiveTarget(targetId)!==null;if(!targetActive){logDebug(LOG_TAG,'Detected inactive target',targetId);}return targetActive;}/**
     * Returns the TargetData for an active target (i.e. a target that the user
     * is still interested in that has no outstanding target change requests).
     */},{key:"targetDataForActiveTarget",value:function targetDataForActiveTarget(targetId){var targetState=this.targetStates.get(targetId);return targetState&&targetState.isPending?null:this.metadataProvider.getTargetDataForTarget(targetId);}/**
     * Resets the state of a Watch target to its initial state (e.g. sets
     * 'current' to false, clears the resume token and removes its target mapping
     * from all documents).
     */},{key:"resetTarget",value:function resetTarget(targetId){var _this14=this;this.targetStates.set(targetId,new TargetState());// Trigger removal for any documents currently mapped to this target.
// These removals will be part of the initial snapshot if Watch does not
// resend these documents.
var existingKeys=this.metadataProvider.getRemoteKeysForTarget(targetId);existingKeys.forEach(function(key){_this14.removeDocumentFromTarget(targetId,key,/*updatedDocument=*/null);});}/**
     * Returns whether the LocalStore considers the document to be part of the
     * specified target.
     */},{key:"targetContainsDocument",value:function targetContainsDocument(targetId,key){var existingKeys=this.metadataProvider.getRemoteKeysForTarget(targetId);return existingKeys.has(key);}}]);return WatchChangeAggregator;}();function documentTargetMap(){return new SortedMap(DocumentKey.comparator);}function snapshotChangesMap(){return new SortedMap(DocumentKey.comparator);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DIRECTIONS=function(){var dirs={};dirs["asc"/* ASCENDING */]='ASCENDING';dirs["desc"/* DESCENDING */]='DESCENDING';return dirs;}();var OPERATORS=function(){var ops={};ops["<"/* LESS_THAN */]='LESS_THAN';ops["<="/* LESS_THAN_OR_EQUAL */]='LESS_THAN_OR_EQUAL';ops[">"/* GREATER_THAN */]='GREATER_THAN';ops[">="/* GREATER_THAN_OR_EQUAL */]='GREATER_THAN_OR_EQUAL';ops["=="/* EQUAL */]='EQUAL';ops["!="/* NOT_EQUAL */]='NOT_EQUAL';ops["array-contains"/* ARRAY_CONTAINS */]='ARRAY_CONTAINS';ops["in"/* IN */]='IN';ops["not-in"/* NOT_IN */]='NOT_IN';ops["array-contains-any"/* ARRAY_CONTAINS_ANY */]='ARRAY_CONTAINS_ANY';return ops;}();function assertPresent(value,description){}/**
 * This class generates JsonObject values for the Datastore API suitable for
 * sending to either GRPC stub methods or via the JSON/HTTP REST API.
 *
 * The serializer supports both Protobuf.js and Proto3 JSON formats. By
 * setting `useProto3Json` to true, the serializer will use the Proto3 JSON
 * format.
 *
 * For a description of the Proto3 JSON format check
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 *
 * TODO(klimt): We can remove the databaseId argument if we keep the full
 * resource name in documents.
 */var JsonProtoSerializer=function JsonProtoSerializer(databaseId,useProto3Json){_classCallCheck(this,JsonProtoSerializer);this.databaseId=databaseId;this.useProto3Json=useProto3Json;};function fromRpcStatus(status){var code=status.code===undefined?Code.UNKNOWN:mapCodeFromRpcCode(status.code);return new FirestoreError(code,status.message||'');}/**
 * Returns a value for a number (or null) that's appropriate to put into
 * a google.protobuf.Int32Value proto.
 * DO NOT USE THIS FOR ANYTHING ELSE.
 * This method cheats. It's typed as returning "number" because that's what
 * our generated proto interfaces say Int32Value must be. But GRPC actually
 * expects a { value: <number> } struct.
 */function toInt32Proto(serializer,val){if(serializer.useProto3Json||isNullOrUndefined(val)){return val;}else{return{value:val};}}/**
 * Returns an IntegerValue for `value`.
 */function toInteger(value){return{integerValue:''+value};}/**
 * Returns an DoubleValue for `value` that is encoded based the serializer's
 * `useProto3Json` setting.
 */function toDouble(serializer,value){if(serializer.useProto3Json){if(isNaN(value)){return{doubleValue:'NaN'};}else if(value===Infinity){return{doubleValue:'Infinity'};}else if(value===-Infinity){return{doubleValue:'-Infinity'};}}return{doubleValue:isNegativeZero(value)?'-0':value};}/**
 * Returns a value for a number that's appropriate to put into a proto.
 * The return value is an IntegerValue if it can safely represent the value,
 * otherwise a DoubleValue is returned.
 */function toNumber(serializer,value){return isSafeInteger(value)?toInteger(value):toDouble(serializer,value);}/**
 * Returns a value for a Date that's appropriate to put into a proto.
 */function toTimestamp(serializer,timestamp){if(serializer.useProto3Json){// Serialize to ISO-8601 date format, but with full nano resolution.
// Since JS Date has only millis, let's only use it for the seconds and
// then manually add the fractions to the end.
var jsDateStr=new Date(timestamp.seconds*1000).toISOString();// Remove .xxx frac part and Z in the end.
var strUntilSeconds=jsDateStr.replace(/\.\d*/,'').replace('Z','');// Pad the fraction out to 9 digits (nanos).
var nanoStr=('000000000'+timestamp.nanoseconds).slice(-9);return"".concat(strUntilSeconds,".").concat(nanoStr,"Z");}else{return{seconds:''+timestamp.seconds,nanos:timestamp.nanoseconds// eslint-disable-next-line @typescript-eslint/no-explicit-any
};}}function fromTimestamp(date){var timestamp=normalizeTimestamp(date);return new Timestamp(timestamp.seconds,timestamp.nanos);}/**
 * Returns a value for bytes that's appropriate to put in a proto.
 *
 * Visible for testing.
 */function toBytes(serializer,bytes){if(serializer.useProto3Json){return bytes.toBase64();}else{return bytes.toUint8Array();}}/**
 * Returns a ByteString based on the proto string value.
 */function fromBytes(serializer,value){if(serializer.useProto3Json){hardAssert(value===undefined||typeof value==='string');return ByteString.fromBase64String(value?value:'');}else{hardAssert(value===undefined||value instanceof Uint8Array);return ByteString.fromUint8Array(value?value:new Uint8Array());}}function toVersion(serializer,version){return toTimestamp(serializer,version.toTimestamp());}function fromVersion(version){hardAssert(!!version);return SnapshotVersion.fromTimestamp(fromTimestamp(version));}function toResourceName(databaseId,path){return fullyQualifiedPrefixPath(databaseId).child('documents').child(path).canonicalString();}function fromResourceName(name){var resource=ResourcePath.fromString(name);hardAssert(isValidResourceName(resource));return resource;}function toName(serializer,key){return toResourceName(serializer.databaseId,key.path);}function fromName(serializer,name){var resource=fromResourceName(name);hardAssert(resource.get(1)===serializer.databaseId.projectId);hardAssert(!resource.get(3)&&!serializer.databaseId.database||resource.get(3)===serializer.databaseId.database);return new DocumentKey(extractLocalPathFromResourceName(resource));}function toQueryPath(serializer,path){return toResourceName(serializer.databaseId,path);}function getEncodedDatabaseId(serializer){var path=new ResourcePath(['projects',serializer.databaseId.projectId,'databases',serializer.databaseId.database]);return path.canonicalString();}function fullyQualifiedPrefixPath(databaseId){return new ResourcePath(['projects',databaseId.projectId,'databases',databaseId.database]);}function extractLocalPathFromResourceName(resourceName){hardAssert(resourceName.length>4&&resourceName.get(4)==='documents');return resourceName.popFirst(5);}/** Creates a Document proto from key and fields (but no create/update time) */function toMutationDocument(serializer,key,fields){return{name:toName(serializer,key),fields:fields.proto.mapValue.fields};}function fromFound(serializer,doc){hardAssert(!!doc.found);assertPresent(doc.found.name);assertPresent(doc.found.updateTime);var key=fromName(serializer,doc.found.name);var version=fromVersion(doc.found.updateTime);var data=new ObjectValue({mapValue:{fields:doc.found.fields}});return new Document(key,version,data,{});}function fromMissing(serializer,result){hardAssert(!!result.missing);hardAssert(!!result.readTime);var key=fromName(serializer,result.missing);var version=fromVersion(result.readTime);return new NoDocument(key,version);}function fromMaybeDocument(serializer,result){if('found'in result){return fromFound(serializer,result);}else if('missing'in result){return fromMissing(serializer,result);}return fail();}function fromWatchChange(serializer,change){var watchChange;if('targetChange'in change){assertPresent(change.targetChange);// proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'
// if unset
var state=fromWatchTargetChangeState(change.targetChange.targetChangeType||'NO_CHANGE');var targetIds=change.targetChange.targetIds||[];var resumeToken=fromBytes(serializer,change.targetChange.resumeToken);var causeProto=change.targetChange.cause;var cause=causeProto&&fromRpcStatus(causeProto);watchChange=new WatchTargetChange(state,targetIds,resumeToken,cause||null);}else if('documentChange'in change){assertPresent(change.documentChange);var entityChange=change.documentChange;assertPresent(entityChange.document);assertPresent(entityChange.document.name);assertPresent(entityChange.document.updateTime);var key=fromName(serializer,entityChange.document.name);var _version=fromVersion(entityChange.document.updateTime);var data=new ObjectValue({mapValue:{fields:entityChange.document.fields}});var doc=new Document(key,_version,data,{});var updatedTargetIds=entityChange.targetIds||[];var removedTargetIds=entityChange.removedTargetIds||[];watchChange=new DocumentWatchChange(updatedTargetIds,removedTargetIds,doc.key,doc);}else if('documentDelete'in change){assertPresent(change.documentDelete);var docDelete=change.documentDelete;assertPresent(docDelete.document);var _key7=fromName(serializer,docDelete.document);var _version2=docDelete.readTime?fromVersion(docDelete.readTime):SnapshotVersion.min();var _doc=new NoDocument(_key7,_version2);var _removedTargetIds=docDelete.removedTargetIds||[];watchChange=new DocumentWatchChange([],_removedTargetIds,_doc.key,_doc);}else if('documentRemove'in change){assertPresent(change.documentRemove);var docRemove=change.documentRemove;assertPresent(docRemove.document);var _key8=fromName(serializer,docRemove.document);var _removedTargetIds2=docRemove.removedTargetIds||[];watchChange=new DocumentWatchChange([],_removedTargetIds2,_key8,null);}else if('filter'in change){// TODO(dimond): implement existence filter parsing with strategy.
assertPresent(change.filter);var filter=change.filter;assertPresent(filter.targetId);var count=filter.count||0;var existenceFilter=new ExistenceFilter(count);var targetId=filter.targetId;watchChange=new ExistenceFilterChange(targetId,existenceFilter);}else{return fail();}return watchChange;}function fromWatchTargetChangeState(state){if(state==='NO_CHANGE'){return 0/* NoChange */;}else if(state==='ADD'){return 1/* Added */;}else if(state==='REMOVE'){return 2/* Removed */;}else if(state==='CURRENT'){return 3/* Current */;}else if(state==='RESET'){return 4/* Reset */;}else{return fail();}}function versionFromListenResponse(change){// We have only reached a consistent snapshot for the entire stream if there
// is a read_time set and it applies to all targets (i.e. the list of
// targets is empty). The backend is guaranteed to send such responses.
if(!('targetChange'in change)){return SnapshotVersion.min();}var targetChange=change.targetChange;if(targetChange.targetIds&&targetChange.targetIds.length){return SnapshotVersion.min();}if(!targetChange.readTime){return SnapshotVersion.min();}return fromVersion(targetChange.readTime);}function toMutation(serializer,mutation){var result;if(mutation instanceof SetMutation){result={update:toMutationDocument(serializer,mutation.key,mutation.value)};}else if(mutation instanceof DeleteMutation){result={"delete":toName(serializer,mutation.key)};}else if(mutation instanceof PatchMutation){result={update:toMutationDocument(serializer,mutation.key,mutation.data),updateMask:toDocumentMask(mutation.fieldMask)};}else if(mutation instanceof TransformMutation){result={transform:{document:toName(serializer,mutation.key),fieldTransforms:mutation.fieldTransforms.map(function(transform){return toFieldTransform(serializer,transform);})}};}else if(mutation instanceof VerifyMutation){result={verify:toName(serializer,mutation.key)};}else{return fail();}if(!mutation.precondition.isNone){result.currentDocument=toPrecondition(serializer,mutation.precondition);}return result;}function toPrecondition(serializer,precondition){if(precondition.updateTime!==undefined){return{updateTime:toVersion(serializer,precondition.updateTime)};}else if(precondition.exists!==undefined){return{exists:precondition.exists};}else{return fail();}}function fromWriteResult(proto,commitTime){// NOTE: Deletes don't have an updateTime.
var version=proto.updateTime?fromVersion(proto.updateTime):fromVersion(commitTime);if(version.isEqual(SnapshotVersion.min())){// The Firestore Emulator currently returns an update time of 0 for
// deletes of non-existing documents (rather than null). This breaks the
// test "get deleted doc while offline with source=cache" as NoDocuments
// with version 0 are filtered by IndexedDb's RemoteDocumentCache.
// TODO(#2149): Remove this when Emulator is fixed
version=fromVersion(commitTime);}var transformResults=null;if(proto.transformResults&&proto.transformResults.length>0){transformResults=proto.transformResults;}return new MutationResult(version,transformResults);}function fromWriteResults(protos,commitTime){if(protos&&protos.length>0){hardAssert(commitTime!==undefined);return protos.map(function(proto){return fromWriteResult(proto,commitTime);});}else{return[];}}function toFieldTransform(serializer,fieldTransform){var transform=fieldTransform.transform;if(transform instanceof ServerTimestampTransform){return{fieldPath:fieldTransform.field.canonicalString(),setToServerValue:'REQUEST_TIME'};}else if(transform instanceof ArrayUnionTransformOperation){return{fieldPath:fieldTransform.field.canonicalString(),appendMissingElements:{values:transform.elements}};}else if(transform instanceof ArrayRemoveTransformOperation){return{fieldPath:fieldTransform.field.canonicalString(),removeAllFromArray:{values:transform.elements}};}else if(transform instanceof NumericIncrementTransformOperation){return{fieldPath:fieldTransform.field.canonicalString(),increment:transform.operand};}else{throw fail();}}function toDocumentsTarget(serializer,target){return{documents:[toQueryPath(serializer,target.path)]};}function toQueryTarget(serializer,target){// Dissect the path into parent, collectionId, and optional key filter.
var result={structuredQuery:{}};var path=target.path;if(target.collectionGroup!==null){result.parent=toQueryPath(serializer,path);result.structuredQuery.from=[{collectionId:target.collectionGroup,allDescendants:true}];}else{result.parent=toQueryPath(serializer,path.popLast());result.structuredQuery.from=[{collectionId:path.lastSegment()}];}var where=toFilter(target.filters);if(where){result.structuredQuery.where=where;}var orderBy=toOrder(target.orderBy);if(orderBy){result.structuredQuery.orderBy=orderBy;}var limit=toInt32Proto(serializer,target.limit);if(limit!==null){result.structuredQuery.limit=limit;}if(target.startAt){result.structuredQuery.startAt=toCursor(target.startAt);}if(target.endAt){result.structuredQuery.endAt=toCursor(target.endAt);}return result;}function toListenRequestLabels(serializer,targetData){var value=toLabel(serializer,targetData.purpose);if(value==null){return null;}else{return{'goog-listen-tags':value};}}function toLabel(serializer,purpose){switch(purpose){case 0/* Listen */:return null;case 1/* ExistenceFilterMismatch */:return'existence-filter-mismatch';case 2/* LimboResolution */:return'limbo-document';default:return fail();}}function toTarget(serializer,targetData){var result;var target=targetData.target;if(isDocumentTarget(target)){result={documents:toDocumentsTarget(serializer,target)};}else{result={query:toQueryTarget(serializer,target)};}result.targetId=targetData.targetId;if(targetData.resumeToken.approximateByteSize()>0){result.resumeToken=toBytes(serializer,targetData.resumeToken);}return result;}function toFilter(filters){if(filters.length===0){return;}var protos=filters.map(function(filter){return toUnaryOrFieldFilter(filter);});if(protos.length===1){return protos[0];}return{compositeFilter:{op:'AND',filters:protos}};}function toOrder(orderBys){if(orderBys.length===0){return;}return orderBys.map(function(order){return toPropertyOrder(order);});}function toCursor(cursor){return{before:cursor.before,values:cursor.position};}// visible for testing
function toDirection(dir){return DIRECTIONS[dir];}// visible for testing
function toOperatorName(op){return OPERATORS[op];}function toFieldPathReference(path){return{fieldPath:path.canonicalString()};}// visible for testing
function toPropertyOrder(orderBy){return{field:toFieldPathReference(orderBy.field),direction:toDirection(orderBy.dir)};}// visible for testing
function toUnaryOrFieldFilter(filter){if(filter.op==="=="/* EQUAL */){if(isNanValue(filter.value)){return{unaryFilter:{field:toFieldPathReference(filter.field),op:'IS_NAN'}};}else if(isNullValue(filter.value)){return{unaryFilter:{field:toFieldPathReference(filter.field),op:'IS_NULL'}};}}else if(filter.op==="!="/* NOT_EQUAL */){if(isNanValue(filter.value)){return{unaryFilter:{field:toFieldPathReference(filter.field),op:'IS_NOT_NAN'}};}else if(isNullValue(filter.value)){return{unaryFilter:{field:toFieldPathReference(filter.field),op:'IS_NOT_NULL'}};}}return{fieldFilter:{field:toFieldPathReference(filter.field),op:toOperatorName(filter.op),value:filter.value}};}function toDocumentMask(fieldMask){var canonicalFields=[];fieldMask.fields.forEach(function(field){return canonicalFields.push(field.canonicalString());});return{fieldPaths:canonicalFields};}function isValidResourceName(path){// Resource names have at least 4 components (project ID, database ID)
return path.length>=4&&path.get(0)==='projects'&&path.get(2)==='databases';}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Represents a transform within a TransformMutation. */var TransformOperation=function TransformOperation(){_classCallCheck(this,TransformOperation);// Make sure that the structural type of `TransformOperation` is unique.
// See https://github.com/microsoft/TypeScript/issues/5451
this._=undefined;};/**
 * Computes the local transform result against the provided `previousValue`,
 * optionally using the provided localWriteTime.
 */function applyTransformOperationToLocalView(transform,previousValue,localWriteTime){if(transform instanceof ServerTimestampTransform){return serverTimestamp(localWriteTime,previousValue);}else if(transform instanceof ArrayUnionTransformOperation){return applyArrayUnionTransformOperation(transform,previousValue);}else if(transform instanceof ArrayRemoveTransformOperation){return applyArrayRemoveTransformOperation(transform,previousValue);}else{return applyNumericIncrementTransformOperationToLocalView(transform,previousValue);}}/**
 * Computes a final transform result after the transform has been acknowledged
 * by the server, potentially using the server-provided transformResult.
 */function applyTransformOperationToRemoteDocument(transform,previousValue,transformResult){// The server just sends null as the transform result for array operations,
// so we have to calculate a result the same as we do for local
// applications.
if(transform instanceof ArrayUnionTransformOperation){return applyArrayUnionTransformOperation(transform,previousValue);}else if(transform instanceof ArrayRemoveTransformOperation){return applyArrayRemoveTransformOperation(transform,previousValue);}return transformResult;}/**
 * If this transform operation is not idempotent, returns the base value to
 * persist for this transform. If a base value is returned, the transform
 * operation is always applied to this base value, even if document has
 * already been updated.
 *
 * Base values provide consistent behavior for non-idempotent transforms and
 * allow us to return the same latency-compensated value even if the backend
 * has already applied the transform operation. The base value is null for
 * idempotent transforms, as they can be re-played even if the backend has
 * already applied them.
 *
 * @return a base value to store along with the mutation, or null for
 * idempotent transforms.
 */function computeTransformOperationBaseValue(transform,previousValue){if(transform instanceof NumericIncrementTransformOperation){return isNumber(previousValue)?previousValue:{integerValue:0};}return null;}function transformOperationEquals(left,right){if(left instanceof ArrayUnionTransformOperation&&right instanceof ArrayUnionTransformOperation){return arrayEquals(left.elements,right.elements,valueEquals);}else if(left instanceof ArrayRemoveTransformOperation&&right instanceof ArrayRemoveTransformOperation){return arrayEquals(left.elements,right.elements,valueEquals);}else if(left instanceof NumericIncrementTransformOperation&&right instanceof NumericIncrementTransformOperation){return valueEquals(left.operand,right.operand);}return left instanceof ServerTimestampTransform&&right instanceof ServerTimestampTransform;}/** Transforms a value into a server-generated timestamp. */var ServerTimestampTransform=/*#__PURE__*/function(_TransformOperation){_inherits(ServerTimestampTransform,_TransformOperation);function ServerTimestampTransform(){_classCallCheck(this,ServerTimestampTransform);return _possibleConstructorReturn(this,_getPrototypeOf(ServerTimestampTransform).apply(this,arguments));}return ServerTimestampTransform;}(TransformOperation);/** Transforms an array value via a union operation. */var ArrayUnionTransformOperation=/*#__PURE__*/function(_TransformOperation2){_inherits(ArrayUnionTransformOperation,_TransformOperation2);function ArrayUnionTransformOperation(elements){var _this15;_classCallCheck(this,ArrayUnionTransformOperation);_this15=_possibleConstructorReturn(this,_getPrototypeOf(ArrayUnionTransformOperation).call(this));_this15.elements=elements;return _this15;}return ArrayUnionTransformOperation;}(TransformOperation);function applyArrayUnionTransformOperation(transform,previousValue){var values=coercedFieldValuesArray(previousValue);var _iteratorNormalCompletion14=true;var _didIteratorError14=false;var _iteratorError14=undefined;try{var _loop=function _loop(){var toUnion=_step14.value;if(!values.some(function(element){return valueEquals(element,toUnion);})){values.push(toUnion);}};for(var _iterator14=transform.elements[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){_loop();}}catch(err){_didIteratorError14=true;_iteratorError14=err;}finally{try{if(!_iteratorNormalCompletion14&&_iterator14["return"]!=null){_iterator14["return"]();}}finally{if(_didIteratorError14){throw _iteratorError14;}}}return{arrayValue:{values:values}};}/** Transforms an array value via a remove operation. */var ArrayRemoveTransformOperation=/*#__PURE__*/function(_TransformOperation3){_inherits(ArrayRemoveTransformOperation,_TransformOperation3);function ArrayRemoveTransformOperation(elements){var _this16;_classCallCheck(this,ArrayRemoveTransformOperation);_this16=_possibleConstructorReturn(this,_getPrototypeOf(ArrayRemoveTransformOperation).call(this));_this16.elements=elements;return _this16;}return ArrayRemoveTransformOperation;}(TransformOperation);function applyArrayRemoveTransformOperation(transform,previousValue){var values=coercedFieldValuesArray(previousValue);var _iteratorNormalCompletion15=true;var _didIteratorError15=false;var _iteratorError15=undefined;try{var _loop2=function _loop2(){var toRemove=_step15.value;values=values.filter(function(element){return!valueEquals(element,toRemove);});};for(var _iterator15=transform.elements[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){_loop2();}}catch(err){_didIteratorError15=true;_iteratorError15=err;}finally{try{if(!_iteratorNormalCompletion15&&_iterator15["return"]!=null){_iterator15["return"]();}}finally{if(_didIteratorError15){throw _iteratorError15;}}}return{arrayValue:{values:values}};}/**
 * Implements the backend semantics for locally computed NUMERIC_ADD (increment)
 * transforms. Converts all field values to integers or doubles, but unlike the
 * backend does not cap integer values at 2^63. Instead, JavaScript number
 * arithmetic is used and precision loss can occur for values greater than 2^53.
 */var NumericIncrementTransformOperation=/*#__PURE__*/function(_TransformOperation4){_inherits(NumericIncrementTransformOperation,_TransformOperation4);function NumericIncrementTransformOperation(serializer,operand){var _this17;_classCallCheck(this,NumericIncrementTransformOperation);_this17=_possibleConstructorReturn(this,_getPrototypeOf(NumericIncrementTransformOperation).call(this));_this17.serializer=serializer;_this17.operand=operand;return _this17;}return NumericIncrementTransformOperation;}(TransformOperation);function applyNumericIncrementTransformOperationToLocalView(transform,previousValue){// PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit
// precision and resolves overflows by reducing precision, we do not
// manually cap overflows at 2^63.
var baseValue=computeTransformOperationBaseValue(transform,previousValue);var sum=asNumber(baseValue)+asNumber(transform.operand);if(isInteger(baseValue)&&isInteger(transform.operand)){return toInteger(sum);}else{return toDouble(transform.serializer,sum);}}function asNumber(value){return normalizeNumber(value.integerValue||value.doubleValue);}function coercedFieldValuesArray(value){return isArray(value)&&value.arrayValue.values?value.arrayValue.values.slice():[];}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Provides a set of fields that can be used to partially patch a document.
 * FieldMask is used in conjunction with ObjectValue.
 * Examples:
 *   foo - Overwrites foo entirely with the provided value. If foo is not
 *         present in the companion ObjectValue, the field is deleted.
 *   foo.bar - Overwrites only the field bar of the object foo.
 *             If foo is not an object, foo is replaced with an object
 *             containing foo
 */var FieldMask=/*#__PURE__*/function(){function FieldMask(fields){_classCallCheck(this,FieldMask);this.fields=fields;// TODO(dimond): validation of FieldMask
// Sort the field mask to support `FieldMask.isEqual()` and assert below.
fields.sort(FieldPath.comparator);}/**
     * Verifies that `fieldPath` is included by at least one field in this field
     * mask.
     *
     * This is an O(n) operation, where `n` is the size of the field mask.
     */_createClass(FieldMask,[{key:"covers",value:function covers(fieldPath){var _iteratorNormalCompletion16=true;var _didIteratorError16=false;var _iteratorError16=undefined;try{for(var _iterator16=this.fields[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){var fieldMaskPath=_step16.value;if(fieldMaskPath.isPrefixOf(fieldPath)){return true;}}}catch(err){_didIteratorError16=true;_iteratorError16=err;}finally{try{if(!_iteratorNormalCompletion16&&_iterator16["return"]!=null){_iterator16["return"]();}}finally{if(_didIteratorError16){throw _iteratorError16;}}}return false;}},{key:"isEqual",value:function isEqual(other){return arrayEquals(this.fields,other.fields,function(l,r){return l.isEqual(r);});}}]);return FieldMask;}();/** A field path and the TransformOperation to perform upon it. */var FieldTransform=function FieldTransform(field,transform){_classCallCheck(this,FieldTransform);this.field=field;this.transform=transform;};function fieldTransformEquals(left,right){return left.field.isEqual(right.field)&&transformOperationEquals(left.transform,right.transform);}/** The result of successfully applying a mutation to the backend. */var MutationResult=function MutationResult(/**
     * The version at which the mutation was committed:
     *
     * - For most operations, this is the updateTime in the WriteResult.
     * - For deletes, the commitTime of the WriteResponse (because deletes are
     *   not stored and have no updateTime).
     *
     * Note that these versions can be different: No-op writes will not change
     * the updateTime even though the commitTime advances.
     */version,/**
     * The resulting fields returned from the backend after a
     * TransformMutation has been committed. Contains one FieldValue for each
     * FieldTransform that was in the mutation.
     *
     * Will be null if the mutation was not a TransformMutation.
     */transformResults){_classCallCheck(this,MutationResult);this.version=version;this.transformResults=transformResults;};/**
 * Encodes a precondition for a mutation. This follows the model that the
 * backend accepts with the special case of an explicit "empty" precondition
 * (meaning no precondition).
 */var Precondition=/*#__PURE__*/function(){function Precondition(updateTime,exists){_classCallCheck(this,Precondition);this.updateTime=updateTime;this.exists=exists;}/** Creates a new empty Precondition. */_createClass(Precondition,[{key:"isEqual",value:function isEqual(other){return this.exists===other.exists&&(this.updateTime?!!other.updateTime&&this.updateTime.isEqual(other.updateTime):!other.updateTime);}},{key:"isNone",/** Returns whether this Precondition is empty. */get:function get(){return this.updateTime===undefined&&this.exists===undefined;}}],[{key:"none",value:function none(){return new Precondition();}/** Creates a new Precondition with an exists flag. */},{key:"exists",value:function exists(_exists){return new Precondition(undefined,_exists);}/** Creates a new Precondition based on a version a document exists at. */},{key:"updateTime",value:function updateTime(version){return new Precondition(version);}}]);return Precondition;}();/**
 * Returns true if the preconditions is valid for the given document
 * (or null if no document is available).
 */function preconditionIsValidForDocument(precondition,maybeDoc){if(precondition.updateTime!==undefined){return maybeDoc instanceof Document&&maybeDoc.version.isEqual(precondition.updateTime);}else if(precondition.exists!==undefined){return precondition.exists===maybeDoc instanceof Document;}else{return true;}}/**
 * A mutation describes a self-contained change to a document. Mutations can
 * create, replace, delete, and update subsets of documents.
 *
 * Mutations not only act on the value of the document but also its version.
 *
 * For local mutations (mutations that haven't been committed yet), we preserve
 * the existing version for Set, Patch, and Transform mutations. For Delete
 * mutations, we reset the version to 0.
 *
 * Here's the expected transition table.
 *
 * MUTATION           APPLIED TO            RESULTS IN
 *
 * SetMutation        Document(v3)          Document(v3)
 * SetMutation        NoDocument(v3)        Document(v0)
 * SetMutation        null                  Document(v0)
 * PatchMutation      Document(v3)          Document(v3)
 * PatchMutation      NoDocument(v3)        NoDocument(v3)
 * PatchMutation      null                  null
 * TransformMutation  Document(v3)          Document(v3)
 * TransformMutation  NoDocument(v3)        NoDocument(v3)
 * TransformMutation  null                  null
 * DeleteMutation     Document(v3)          NoDocument(v0)
 * DeleteMutation     NoDocument(v3)        NoDocument(v0)
 * DeleteMutation     null                  NoDocument(v0)
 *
 * For acknowledged mutations, we use the updateTime of the WriteResponse as
 * the resulting version for Set, Patch, and Transform mutations. As deletes
 * have no explicit update time, we use the commitTime of the WriteResponse for
 * Delete mutations.
 *
 * If a mutation is acknowledged by the backend but fails the precondition check
 * locally, we return an `UnknownDocument` and rely on Watch to send us the
 * updated version.
 *
 * Note that TransformMutations don't create Documents (in the case of being
 * applied to a NoDocument), even though they would on the backend. This is
 * because the client always combines the TransformMutation with a SetMutation
 * or PatchMutation and we only want to apply the transform if the prior
 * mutation resulted in a Document (always true for a SetMutation, but not
 * necessarily for a PatchMutation).
 *
 * ## Subclassing Notes
 *
 * Subclasses of Mutation need to implement applyToRemoteDocument() and
 * applyToLocalView() to implement the actual behavior of applying the mutation
 * to some source document.
 */var Mutation=function Mutation(){_classCallCheck(this,Mutation);};/**
 * Applies this mutation to the given MaybeDocument or null for the purposes
 * of computing a new remote document. If the input document doesn't match the
 * expected state (e.g. it is null or outdated), an `UnknownDocument` can be
 * returned.
 *
 * @param mutation The mutation to apply.
 * @param maybeDoc The document to mutate. The input document can be null if
 *     the client has no knowledge of the pre-mutation state of the document.
 * @param mutationResult The result of applying the mutation from the backend.
 * @return The mutated document. The returned document may be an
 *     UnknownDocument if the mutation could not be applied to the locally
 *     cached base document.
 */function applyMutationToRemoteDocument(mutation,maybeDoc,mutationResult){if(mutation instanceof SetMutation){return applySetMutationToRemoteDocument(mutation,maybeDoc,mutationResult);}else if(mutation instanceof PatchMutation){return applyPatchMutationToRemoteDocument(mutation,maybeDoc,mutationResult);}else if(mutation instanceof TransformMutation){return applyTransformMutationToRemoteDocument(mutation,maybeDoc,mutationResult);}else{return applyDeleteMutationToRemoteDocument(mutation,maybeDoc,mutationResult);}}/**
 * Applies this mutation to the given MaybeDocument or null for the purposes
 * of computing the new local view of a document. Both the input and returned
 * documents can be null.
 *
 * @param mutation The mutation to apply.
 * @param maybeDoc The document to mutate. The input document can be null if
 *     the client has no knowledge of the pre-mutation state of the document.
 * @param baseDoc The state of the document prior to this mutation batch. The
 *     input document can be null if the client has no knowledge of the
 *     pre-mutation state of the document.
 * @param localWriteTime A timestamp indicating the local write time of the
 *     batch this mutation is a part of.
 * @return The mutated document. The returned document may be null, but only
 *     if maybeDoc was null and the mutation would not create a new document.
 */function applyMutationToLocalView(mutation,maybeDoc,baseDoc,localWriteTime){if(mutation instanceof SetMutation){return applySetMutationToLocalView(mutation,maybeDoc);}else if(mutation instanceof PatchMutation){return applyPatchMutationToLocalView(mutation,maybeDoc);}else if(mutation instanceof TransformMutation){return applyTransformMutationToLocalView(mutation,maybeDoc,localWriteTime,baseDoc);}else{return applyDeleteMutationToLocalView(mutation,maybeDoc);}}/**
 * If this mutation is not idempotent, returns the base value to persist with
 * this mutation. If a base value is returned, the mutation is always applied
 * to this base value, even if document has already been updated.
 *
 * The base value is a sparse object that consists of only the document
 * fields for which this mutation contains a non-idempotent transformation
 * (e.g. a numeric increment). The provided value guarantees consistent
 * behavior for non-idempotent transforms and allow us to return the same
 * latency-compensated value even if the backend has already applied the
 * mutation. The base value is null for idempotent mutations, as they can be
 * re-played even if the backend has already applied them.
 *
 * @return a base value to store along with the mutation, or null for
 * idempotent mutations.
 */function extractMutationBaseValue(mutation,maybeDoc){if(mutation instanceof TransformMutation){return extractTransformMutationBaseValue(mutation,maybeDoc);}return null;}function mutationEquals(left,right){if(left.type!==right.type){return false;}if(!left.key.isEqual(right.key)){return false;}if(!left.precondition.isEqual(right.precondition)){return false;}if(left.type===0/* Set */){return left.value.isEqual(right.value);}if(left.type===1/* Patch */){return left.data.isEqual(right.data)&&left.fieldMask.isEqual(right.fieldMask);}if(left.type===2/* Transform */){return arrayEquals(left.fieldTransforms,left.fieldTransforms,function(l,r){return fieldTransformEquals(l,r);});}return true;}/**
 * Returns the version from the given document for use as the result of a
 * mutation. Mutations are defined to return the version of the base document
 * only if it is an existing document. Deleted and unknown documents have a
 * post-mutation version of SnapshotVersion.min().
 */function getPostMutationVersion(maybeDoc){if(maybeDoc instanceof Document){return maybeDoc.version;}else{return SnapshotVersion.min();}}/**
 * A mutation that creates or replaces the document at the given key with the
 * object value contents.
 */var SetMutation=/*#__PURE__*/function(_Mutation){_inherits(SetMutation,_Mutation);function SetMutation(key,value,precondition){var _this18;_classCallCheck(this,SetMutation);_this18=_possibleConstructorReturn(this,_getPrototypeOf(SetMutation).call(this));_this18.key=key;_this18.value=value;_this18.precondition=precondition;_this18.type=0/* Set */;return _this18;}return SetMutation;}(Mutation);function applySetMutationToRemoteDocument(mutation,maybeDoc,mutationResult){// Unlike applySetMutationToLocalView, if we're applying a mutation to a
// remote document the server has accepted the mutation so the precondition
// must have held.
return new Document(mutation.key,mutationResult.version,mutation.value,{hasCommittedMutations:true});}function applySetMutationToLocalView(mutation,maybeDoc){if(!preconditionIsValidForDocument(mutation.precondition,maybeDoc)){return maybeDoc;}var version=getPostMutationVersion(maybeDoc);return new Document(mutation.key,version,mutation.value,{hasLocalMutations:true});}/**
 * A mutation that modifies fields of the document at the given key with the
 * given values. The values are applied through a field mask:
 *
 *  * When a field is in both the mask and the values, the corresponding field
 *    is updated.
 *  * When a field is in neither the mask nor the values, the corresponding
 *    field is unmodified.
 *  * When a field is in the mask but not in the values, the corresponding field
 *    is deleted.
 *  * When a field is not in the mask but is in the values, the values map is
 *    ignored.
 */var PatchMutation=/*#__PURE__*/function(_Mutation2){_inherits(PatchMutation,_Mutation2);function PatchMutation(key,data,fieldMask,precondition){var _this19;_classCallCheck(this,PatchMutation);_this19=_possibleConstructorReturn(this,_getPrototypeOf(PatchMutation).call(this));_this19.key=key;_this19.data=data;_this19.fieldMask=fieldMask;_this19.precondition=precondition;_this19.type=1/* Patch */;return _this19;}return PatchMutation;}(Mutation);function applyPatchMutationToRemoteDocument(mutation,maybeDoc,mutationResult){if(!preconditionIsValidForDocument(mutation.precondition,maybeDoc)){// Since the mutation was not rejected, we know that the  precondition
// matched on the backend. We therefore must not have the expected version
// of the document in our cache and return an UnknownDocument with the
// known updateTime.
return new UnknownDocument(mutation.key,mutationResult.version);}var newData=patchDocument(mutation,maybeDoc);return new Document(mutation.key,mutationResult.version,newData,{hasCommittedMutations:true});}function applyPatchMutationToLocalView(mutation,maybeDoc){if(!preconditionIsValidForDocument(mutation.precondition,maybeDoc)){return maybeDoc;}var version=getPostMutationVersion(maybeDoc);var newData=patchDocument(mutation,maybeDoc);return new Document(mutation.key,version,newData,{hasLocalMutations:true});}/**
 * Patches the data of document if available or creates a new document. Note
 * that this does not check whether or not the precondition of this patch
 * holds.
 */function patchDocument(mutation,maybeDoc){var data;if(maybeDoc instanceof Document){data=maybeDoc.data();}else{data=ObjectValue.empty();}return patchObject(mutation,data);}function patchObject(mutation,data){var builder=new ObjectValueBuilder(data);mutation.fieldMask.fields.forEach(function(fieldPath){if(!fieldPath.isEmpty()){var newValue=mutation.data.field(fieldPath);if(newValue!==null){builder.set(fieldPath,newValue);}else{builder["delete"](fieldPath);}}});return builder.build();}/**
 * A mutation that modifies specific fields of the document with transform
 * operations. Currently the only supported transform is a server timestamp, but
 * IP Address, increment(n), etc. could be supported in the future.
 *
 * It is somewhat similar to a PatchMutation in that it patches specific fields
 * and has no effect when applied to a null or NoDocument (see comment on
 * Mutation for rationale).
 */var TransformMutation=/*#__PURE__*/function(_Mutation3){_inherits(TransformMutation,_Mutation3);function TransformMutation(key,fieldTransforms){var _this20;_classCallCheck(this,TransformMutation);_this20=_possibleConstructorReturn(this,_getPrototypeOf(TransformMutation).call(this));_this20.key=key;_this20.fieldTransforms=fieldTransforms;_this20.type=2/* Transform */;// NOTE: We set a precondition of exists: true as a safety-check, since we
// always combine TransformMutations with a SetMutation or PatchMutation which
// (if successful) should end up with an existing document.
_this20.precondition=Precondition.exists(true);return _this20;}return TransformMutation;}(Mutation);function applyTransformMutationToRemoteDocument(mutation,maybeDoc,mutationResult){hardAssert(mutationResult.transformResults!=null);if(!preconditionIsValidForDocument(mutation.precondition,maybeDoc)){// Since the mutation was not rejected, we know that the  precondition
// matched on the backend. We therefore must not have the expected version
// of the document in our cache and return an UnknownDocument with the
// known updateTime.
return new UnknownDocument(mutation.key,mutationResult.version);}var doc=requireDocument(mutation,maybeDoc);var transformResults=serverTransformResults(mutation.fieldTransforms,maybeDoc,mutationResult.transformResults);var version=mutationResult.version;var newData=transformObject(mutation,doc.data(),transformResults);return new Document(mutation.key,version,newData,{hasCommittedMutations:true});}function applyTransformMutationToLocalView(mutation,maybeDoc,localWriteTime,baseDoc){if(!preconditionIsValidForDocument(mutation.precondition,maybeDoc)){return maybeDoc;}var doc=requireDocument(mutation,maybeDoc);var transformResults=localTransformResults(mutation.fieldTransforms,localWriteTime,maybeDoc,baseDoc);var newData=transformObject(mutation,doc.data(),transformResults);return new Document(mutation.key,doc.version,newData,{hasLocalMutations:true});}function extractTransformMutationBaseValue(mutation,maybeDoc){var baseObject=null;var _iteratorNormalCompletion17=true;var _didIteratorError17=false;var _iteratorError17=undefined;try{for(var _iterator17=mutation.fieldTransforms[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){var fieldTransform=_step17.value;var existingValue=maybeDoc instanceof Document?maybeDoc.field(fieldTransform.field):undefined;var coercedValue=computeTransformOperationBaseValue(fieldTransform.transform,existingValue||null);if(coercedValue!=null){if(baseObject==null){baseObject=new ObjectValueBuilder().set(fieldTransform.field,coercedValue);}else{baseObject=baseObject.set(fieldTransform.field,coercedValue);}}}}catch(err){_didIteratorError17=true;_iteratorError17=err;}finally{try{if(!_iteratorNormalCompletion17&&_iterator17["return"]!=null){_iterator17["return"]();}}finally{if(_didIteratorError17){throw _iteratorError17;}}}return baseObject?baseObject.build():null;}/**
 * Asserts that the given MaybeDocument is actually a Document and verifies
 * that it matches the key for this mutation. Since we only support
 * transformations with precondition exists this method is guaranteed to be
 * safe.
 */function requireDocument(mutation,maybeDoc){return maybeDoc;}/**
 * Creates a list of "transform results" (a transform result is a field value
 * representing the result of applying a transform) for use after a
 * TransformMutation has been acknowledged by the server.
 *
 * @param fieldTransforms The field transforms to apply the result to.
 * @param baseDoc The document prior to applying this mutation batch.
 * @param serverTransformResults The transform results received by the server.
 * @return The transform results list.
 */function serverTransformResults(fieldTransforms,baseDoc,serverTransformResults){var transformResults=[];hardAssert(fieldTransforms.length===serverTransformResults.length);for(var i=0;i<serverTransformResults.length;i++){var fieldTransform=fieldTransforms[i];var transform=fieldTransform.transform;var previousValue=null;if(baseDoc instanceof Document){previousValue=baseDoc.field(fieldTransform.field);}transformResults.push(applyTransformOperationToRemoteDocument(transform,previousValue,serverTransformResults[i]));}return transformResults;}/**
 * Creates a list of "transform results" (a transform result is a field value
 * representing the result of applying a transform) for use when applying a
 * TransformMutation locally.
 *
 * @param fieldTransforms The field transforms to apply the result to.
 * @param localWriteTime The local time of the transform mutation (used to
 *     generate ServerTimestampValues).
 * @param maybeDoc The current state of the document after applying all
 *     previous mutations.
 * @param baseDoc The document prior to applying this mutation batch.
 * @return The transform results list.
 */function localTransformResults(fieldTransforms,localWriteTime,maybeDoc,baseDoc){var transformResults=[];var _iteratorNormalCompletion18=true;var _didIteratorError18=false;var _iteratorError18=undefined;try{for(var _iterator18=fieldTransforms[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){var fieldTransform=_step18.value;var transform=fieldTransform.transform;var previousValue=null;if(maybeDoc instanceof Document){previousValue=maybeDoc.field(fieldTransform.field);}if(previousValue===null&&baseDoc instanceof Document){// If the current document does not contain a value for the mutated
// field, use the value that existed before applying this mutation
// batch. This solves an edge case where a PatchMutation clears the
// values in a nested map before the TransformMutation is applied.
previousValue=baseDoc.field(fieldTransform.field);}transformResults.push(applyTransformOperationToLocalView(transform,previousValue,localWriteTime));}}catch(err){_didIteratorError18=true;_iteratorError18=err;}finally{try{if(!_iteratorNormalCompletion18&&_iterator18["return"]!=null){_iterator18["return"]();}}finally{if(_didIteratorError18){throw _iteratorError18;}}}return transformResults;}function transformObject(mutation,data,transformResults){var builder=new ObjectValueBuilder(data);for(var i=0;i<mutation.fieldTransforms.length;i++){var fieldTransform=mutation.fieldTransforms[i];builder.set(fieldTransform.field,transformResults[i]);}return builder.build();}/** A mutation that deletes the document at the given key. */var DeleteMutation=/*#__PURE__*/function(_Mutation4){_inherits(DeleteMutation,_Mutation4);function DeleteMutation(key,precondition){var _this21;_classCallCheck(this,DeleteMutation);_this21=_possibleConstructorReturn(this,_getPrototypeOf(DeleteMutation).call(this));_this21.key=key;_this21.precondition=precondition;_this21.type=3/* Delete */;return _this21;}return DeleteMutation;}(Mutation);function applyDeleteMutationToRemoteDocument(mutation,maybeDoc,mutationResult){// Unlike applyToLocalView, if we're applying a mutation to a remote
// document the server has accepted the mutation so the precondition must
// have held.
return new NoDocument(mutation.key,mutationResult.version,{hasCommittedMutations:true});}function applyDeleteMutationToLocalView(mutation,maybeDoc){if(!preconditionIsValidForDocument(mutation.precondition,maybeDoc)){return maybeDoc;}return new NoDocument(mutation.key,SnapshotVersion.min());}/**
 * A mutation that verifies the existence of the document at the given key with
 * the provided precondition.
 *
 * The `verify` operation is only used in Transactions, and this class serves
 * primarily to facilitate serialization into protos.
 */var VerifyMutation=/*#__PURE__*/function(_Mutation5){_inherits(VerifyMutation,_Mutation5);function VerifyMutation(key,precondition){var _this22;_classCallCheck(this,VerifyMutation);_this22=_possibleConstructorReturn(this,_getPrototypeOf(VerifyMutation).call(this));_this22.key=key;_this22.precondition=precondition;_this22.type=4/* Verify */;return _this22;}return VerifyMutation;}(Mutation);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var BATCHID_UNKNOWN=-1;/**
 * A batch of mutations that will be sent as one unit to the backend.
 */var MutationBatch=/*#__PURE__*/function(){/**
     * @param batchId The unique ID of this mutation batch.
     * @param localWriteTime The original write time of this mutation.
     * @param baseMutations Mutations that are used to populate the base
     * values when this mutation is applied locally. This can be used to locally
     * overwrite values that are persisted in the remote document cache. Base
     * mutations are never sent to the backend.
     * @param mutations The user-provided mutations in this mutation batch.
     * User-provided mutations are applied both locally and remotely on the
     * backend.
     */function MutationBatch(batchId,localWriteTime,baseMutations,mutations){_classCallCheck(this,MutationBatch);this.batchId=batchId;this.localWriteTime=localWriteTime;this.baseMutations=baseMutations;this.mutations=mutations;}/**
     * Applies all the mutations in this MutationBatch to the specified document
     * to create a new remote document
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     * @param batchResult The result of applying the MutationBatch to the
     * backend.
     */_createClass(MutationBatch,[{key:"applyToRemoteDocument",value:function applyToRemoteDocument(docKey,maybeDoc,batchResult){var mutationResults=batchResult.mutationResults;for(var i=0;i<this.mutations.length;i++){var mutation=this.mutations[i];if(mutation.key.isEqual(docKey)){var mutationResult=mutationResults[i];maybeDoc=applyMutationToRemoteDocument(mutation,maybeDoc,mutationResult);}}return maybeDoc;}/**
     * Computes the local view of a document given all the mutations in this
     * batch.
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     */},{key:"applyToLocalView",value:function applyToLocalView(docKey,maybeDoc){// First, apply the base state. This allows us to apply non-idempotent
// transform against a consistent set of values.
var _iteratorNormalCompletion19=true;var _didIteratorError19=false;var _iteratorError19=undefined;try{for(var _iterator19=this.baseMutations[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){var mutation=_step19.value;if(mutation.key.isEqual(docKey)){maybeDoc=applyMutationToLocalView(mutation,maybeDoc,maybeDoc,this.localWriteTime);}}}catch(err){_didIteratorError19=true;_iteratorError19=err;}finally{try{if(!_iteratorNormalCompletion19&&_iterator19["return"]!=null){_iterator19["return"]();}}finally{if(_didIteratorError19){throw _iteratorError19;}}}var baseDoc=maybeDoc;// Second, apply all user-provided mutations.
var _iteratorNormalCompletion20=true;var _didIteratorError20=false;var _iteratorError20=undefined;try{for(var _iterator20=this.mutations[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){var _mutation=_step20.value;if(_mutation.key.isEqual(docKey)){maybeDoc=applyMutationToLocalView(_mutation,maybeDoc,baseDoc,this.localWriteTime);}}}catch(err){_didIteratorError20=true;_iteratorError20=err;}finally{try{if(!_iteratorNormalCompletion20&&_iterator20["return"]!=null){_iterator20["return"]();}}finally{if(_didIteratorError20){throw _iteratorError20;}}}return maybeDoc;}/**
     * Computes the local view for all provided documents given the mutations in
     * this batch.
     */},{key:"applyToLocalDocumentSet",value:function applyToLocalDocumentSet(maybeDocs){var _this23=this;// TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations
// directly (as done in `applyToLocalView()`), we can reduce the complexity
// to O(n).
var mutatedDocuments=maybeDocs;this.mutations.forEach(function(m){var mutatedDocument=_this23.applyToLocalView(m.key,maybeDocs.get(m.key));if(mutatedDocument){mutatedDocuments=mutatedDocuments.insert(m.key,mutatedDocument);}});return mutatedDocuments;}},{key:"keys",value:function keys(){return this.mutations.reduce(function(keys,m){return keys.add(m.key);},documentKeySet());}},{key:"isEqual",value:function isEqual(other){return this.batchId===other.batchId&&arrayEquals(this.mutations,other.mutations,function(l,r){return mutationEquals(l,r);})&&arrayEquals(this.baseMutations,other.baseMutations,function(l,r){return mutationEquals(l,r);});}}]);return MutationBatch;}();/** The result of applying a mutation batch to the backend. */var MutationBatchResult=/*#__PURE__*/function(){function MutationBatchResult(batch,commitVersion,mutationResults,/**
     * A pre-computed mapping from each mutated document to the resulting
     * version.
     */docVersions){_classCallCheck(this,MutationBatchResult);this.batch=batch;this.commitVersion=commitVersion;this.mutationResults=mutationResults;this.docVersions=docVersions;}/**
     * Creates a new MutationBatchResult for the given batch and results. There
     * must be one result for each mutation in the batch. This static factory
     * caches a document=>version mapping (docVersions).
     */_createClass(MutationBatchResult,null,[{key:"from",value:function from(batch,commitVersion,results){hardAssert(batch.mutations.length===results.length);var versionMap=documentVersionMap();var mutations=batch.mutations;for(var i=0;i<mutations.length;i++){versionMap=versionMap.insert(mutations[i].key,results[i].version);}return new MutationBatchResult(batch,commitVersion,results,versionMap);}}]);return MutationBatchResult;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A map implementation that uses objects as keys. Objects must have an
 * associated equals function and must be immutable. Entries in the map are
 * stored together with the key being produced from the mapKeyFn. This map
 * automatically handles collisions of keys.
 */var ObjectMap=/*#__PURE__*/function(){function ObjectMap(mapKeyFn,equalsFn){_classCallCheck(this,ObjectMap);this.mapKeyFn=mapKeyFn;this.equalsFn=equalsFn;/**
         * The inner map for a key -> value pair. Due to the possibility of
         * collisions we keep a list of entries that we do a linear search through
         * to find an actual match. Note that collisions should be rare, so we still
         * expect near constant time lookups in practice.
         */this.inner={};}/** Get a value for this key, or undefined if it does not exist. */_createClass(ObjectMap,[{key:"get",value:function get(key){var id=this.mapKeyFn(key);var matches=this.inner[id];if(matches===undefined){return undefined;}var _iteratorNormalCompletion21=true;var _didIteratorError21=false;var _iteratorError21=undefined;try{for(var _iterator21=matches[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){var _step21$value=_slicedToArray(_step21.value,2),otherKey=_step21$value[0],value=_step21$value[1];if(this.equalsFn(otherKey,key)){return value;}}}catch(err){_didIteratorError21=true;_iteratorError21=err;}finally{try{if(!_iteratorNormalCompletion21&&_iterator21["return"]!=null){_iterator21["return"]();}}finally{if(_didIteratorError21){throw _iteratorError21;}}}return undefined;}},{key:"has",value:function has(key){return this.get(key)!==undefined;}/** Put this key and value in the map. */},{key:"set",value:function set(key,value){var id=this.mapKeyFn(key);var matches=this.inner[id];if(matches===undefined){this.inner[id]=[[key,value]];return;}for(var i=0;i<matches.length;i++){if(this.equalsFn(matches[i][0],key)){matches[i]=[key,value];return;}}matches.push([key,value]);}/**
     * Remove this key from the map. Returns a boolean if anything was deleted.
     */},{key:"delete",value:function _delete(key){var id=this.mapKeyFn(key);var matches=this.inner[id];if(matches===undefined){return false;}for(var i=0;i<matches.length;i++){if(this.equalsFn(matches[i][0],key)){if(matches.length===1){delete this.inner[id];}else{matches.splice(i,1);}return true;}}return false;}},{key:"forEach",value:function forEach(fn){_forEach(this.inner,function(_,entries){var _iteratorNormalCompletion22=true;var _didIteratorError22=false;var _iteratorError22=undefined;try{for(var _iterator22=entries[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){var _step22$value=_slicedToArray(_step22.value,2),k=_step22$value[0],v=_step22$value[1];fn(k,v);}}catch(err){_didIteratorError22=true;_iteratorError22=err;}finally{try{if(!_iteratorNormalCompletion22&&_iterator22["return"]!=null){_iterator22["return"]();}}finally{if(_didIteratorError22){throw _iteratorError22;}}}});}},{key:"isEmpty",value:function isEmpty(){return _isEmpty(this.inner);}}]);return ObjectMap;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * PersistencePromise<> is essentially a re-implementation of Promise<> except
 * it has a .next() method instead of .then() and .next() and .catch() callbacks
 * are executed synchronously when a PersistencePromise resolves rather than
 * asynchronously (Promise<> implementations use setImmediate() or similar).
 *
 * This is necessary to interoperate with IndexedDB which will automatically
 * commit transactions if control is returned to the event loop without
 * synchronously initiating another operation on the transaction.
 *
 * NOTE: .then() and .catch() only allow a single consumer, unlike normal
 * Promises.
 */var PersistencePromise=/*#__PURE__*/function(){function PersistencePromise(callback){var _this24=this;_classCallCheck(this,PersistencePromise);// NOTE: next/catchCallback will always point to our own wrapper functions,
// not the user's raw next() or catch() callbacks.
this.nextCallback=null;this.catchCallback=null;// When the operation resolves, we'll set result or error and mark isDone.
this.result=undefined;this.error=undefined;this.isDone=false;// Set to true when .then() or .catch() are called and prevents additional
// chaining.
this.callbackAttached=false;callback(function(value){_this24.isDone=true;_this24.result=value;if(_this24.nextCallback){// value should be defined unless T is Void, but we can't express
// that in the type system.
_this24.nextCallback(value);}},function(error){_this24.isDone=true;_this24.error=error;if(_this24.catchCallback){_this24.catchCallback(error);}});}_createClass(PersistencePromise,[{key:"catch",value:function _catch(fn){return this.next(undefined,fn);}},{key:"next",value:function next(nextFn,catchFn){var _this25=this;if(this.callbackAttached){fail();}this.callbackAttached=true;if(this.isDone){if(!this.error){return this.wrapSuccess(nextFn,this.result);}else{return this.wrapFailure(catchFn,this.error);}}else{return new PersistencePromise(function(resolve,reject){_this25.nextCallback=function(value){_this25.wrapSuccess(nextFn,value).next(resolve,reject);};_this25.catchCallback=function(error){_this25.wrapFailure(catchFn,error).next(resolve,reject);};});}}},{key:"toPromise",value:function toPromise(){var _this26=this;return new Promise(function(resolve,reject){_this26.next(resolve,reject);});}},{key:"wrapUserFunction",value:function wrapUserFunction(fn){try{var result=fn();if(result instanceof PersistencePromise){return result;}else{return PersistencePromise.resolve(result);}}catch(e){return PersistencePromise.reject(e);}}},{key:"wrapSuccess",value:function wrapSuccess(nextFn,value){if(nextFn){return this.wrapUserFunction(function(){return nextFn(value);});}else{// If there's no nextFn, then R must be the same as T
return PersistencePromise.resolve(value);}}},{key:"wrapFailure",value:function wrapFailure(catchFn,error){if(catchFn){return this.wrapUserFunction(function(){return catchFn(error);});}else{return PersistencePromise.reject(error);}}}],[{key:"resolve",value:function resolve(result){return new PersistencePromise(function(resolve,reject){resolve(result);});}},{key:"reject",value:function reject(error){return new PersistencePromise(function(resolve,reject){reject(error);});}},{key:"waitFor",value:function waitFor(// Accept all Promise types in waitFor().
// eslint-disable-next-line @typescript-eslint/no-explicit-any
all){return new PersistencePromise(function(resolve,reject){var expectedCount=0;var resolvedCount=0;var done=false;all.forEach(function(element){++expectedCount;element.next(function(){++resolvedCount;if(done&&resolvedCount===expectedCount){resolve();}},function(err){return reject(err);});});done=true;if(resolvedCount===expectedCount){resolve();}});}/**
     * Given an array of predicate functions that asynchronously evaluate to a
     * boolean, implements a short-circuiting `or` between the results. Predicates
     * will be evaluated until one of them returns `true`, then stop. The final
     * result will be whether any of them returned `true`.
     */},{key:"or",value:function or(predicates){var p=PersistencePromise.resolve(false);var _iteratorNormalCompletion23=true;var _didIteratorError23=false;var _iteratorError23=undefined;try{var _loop3=function _loop3(){var predicate=_step23.value;p=p.next(function(isTrue){if(isTrue){return PersistencePromise.resolve(isTrue);}else{return predicate();}});};for(var _iterator23=predicates[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){_loop3();}}catch(err){_didIteratorError23=true;_iteratorError23=err;}finally{try{if(!_iteratorNormalCompletion23&&_iterator23["return"]!=null){_iterator23["return"]();}}finally{if(_didIteratorError23){throw _iteratorError23;}}}return p;}},{key:"forEach",value:function forEach(collection,f){var _this27=this;var promises=[];collection.forEach(function(r,s){promises.push(f.call(_this27,r,s));});return this.waitFor(promises);}}]);return PersistencePromise;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A readonly view of the local state of all documents we're tracking (i.e. we
 * have a cached version in remoteDocumentCache or local mutations for the
 * document). The view is computed by applying the mutations in the
 * MutationQueue to the RemoteDocumentCache.
 */var LocalDocumentsView=/*#__PURE__*/function(){function LocalDocumentsView(remoteDocumentCache,mutationQueue,indexManager){_classCallCheck(this,LocalDocumentsView);this.remoteDocumentCache=remoteDocumentCache;this.mutationQueue=mutationQueue;this.indexManager=indexManager;}/**
     * Get the local view of the document identified by `key`.
     *
     * @return Local view of the document or null if we don't have any cached
     * state for it.
     */_createClass(LocalDocumentsView,[{key:"getDocument",value:function getDocument(transaction,key){var _this28=this;return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction,key).next(function(batches){return _this28.getDocumentInternal(transaction,key,batches);});}/** Internal version of `getDocument` that allows reusing batches. */},{key:"getDocumentInternal",value:function getDocumentInternal(transaction,key,inBatches){return this.remoteDocumentCache.getEntry(transaction,key).next(function(doc){var _iteratorNormalCompletion24=true;var _didIteratorError24=false;var _iteratorError24=undefined;try{for(var _iterator24=inBatches[Symbol.iterator](),_step24;!(_iteratorNormalCompletion24=(_step24=_iterator24.next()).done);_iteratorNormalCompletion24=true){var batch=_step24.value;doc=batch.applyToLocalView(key,doc);}}catch(err){_didIteratorError24=true;_iteratorError24=err;}finally{try{if(!_iteratorNormalCompletion24&&_iterator24["return"]!=null){_iterator24["return"]();}}finally{if(_didIteratorError24){throw _iteratorError24;}}}return doc;});}// Returns the view of the given `docs` as they would appear after applying
// all mutations in the given `batches`.
},{key:"applyLocalMutationsToDocuments",value:function applyLocalMutationsToDocuments(transaction,docs,batches){var results=nullableMaybeDocumentMap();docs.forEach(function(key,localView){var _iteratorNormalCompletion25=true;var _didIteratorError25=false;var _iteratorError25=undefined;try{for(var _iterator25=batches[Symbol.iterator](),_step25;!(_iteratorNormalCompletion25=(_step25=_iterator25.next()).done);_iteratorNormalCompletion25=true){var batch=_step25.value;localView=batch.applyToLocalView(key,localView);}}catch(err){_didIteratorError25=true;_iteratorError25=err;}finally{try{if(!_iteratorNormalCompletion25&&_iterator25["return"]!=null){_iterator25["return"]();}}finally{if(_didIteratorError25){throw _iteratorError25;}}}results=results.insert(key,localView);});return results;}/**
     * Gets the local view of the documents identified by `keys`.
     *
     * If we don't have cached state for a document in `keys`, a NoDocument will
     * be stored for that key in the resulting set.
     */},{key:"getDocuments",value:function getDocuments(transaction,keys){var _this29=this;return this.remoteDocumentCache.getEntries(transaction,keys).next(function(docs){return _this29.getLocalViewOfDocuments(transaction,docs);});}/**
     * Similar to `getDocuments`, but creates the local view from the given
     * `baseDocs` without retrieving documents from the local store.
     */},{key:"getLocalViewOfDocuments",value:function getLocalViewOfDocuments(transaction,baseDocs){var _this30=this;return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction,baseDocs).next(function(batches){var docs=_this30.applyLocalMutationsToDocuments(transaction,baseDocs,batches);var results=maybeDocumentMap();docs.forEach(function(key,maybeDoc){// TODO(http://b/32275378): Don't conflate missing / deleted.
if(!maybeDoc){maybeDoc=new NoDocument(key,SnapshotVersion.min());}results=results.insert(key,maybeDoc);});return results;});}/**
     * Performs a query against the local view of all documents.
     *
     * @param transaction The persistence transaction.
     * @param query The query to match documents against.
     * @param sinceReadTime If not set to SnapshotVersion.min(), return only
     *     documents that have been read since this snapshot version (exclusive).
     */},{key:"getDocumentsMatchingQuery",value:function getDocumentsMatchingQuery(transaction,query,sinceReadTime){if(isDocumentQuery(query)){return this.getDocumentsMatchingDocumentQuery(transaction,query.path);}else if(isCollectionGroupQuery(query)){return this.getDocumentsMatchingCollectionGroupQuery(transaction,query,sinceReadTime);}else{return this.getDocumentsMatchingCollectionQuery(transaction,query,sinceReadTime);}}},{key:"getDocumentsMatchingDocumentQuery",value:function getDocumentsMatchingDocumentQuery(transaction,docPath){// Just do a simple document lookup.
return this.getDocument(transaction,new DocumentKey(docPath)).next(function(maybeDoc){var result=documentMap();if(maybeDoc instanceof Document){result=result.insert(maybeDoc.key,maybeDoc);}return result;});}},{key:"getDocumentsMatchingCollectionGroupQuery",value:function getDocumentsMatchingCollectionGroupQuery(transaction,query,sinceReadTime){var _this31=this;var collectionId=query.collectionGroup;var results=documentMap();return this.indexManager.getCollectionParents(transaction,collectionId).next(function(parents){// Perform a collection query against each parent that contains the
// collectionId and aggregate the results.
return PersistencePromise.forEach(parents,function(parent){var collectionQuery=asCollectionQueryAtPath(query,parent.child(collectionId));return _this31.getDocumentsMatchingCollectionQuery(transaction,collectionQuery,sinceReadTime).next(function(r){r.forEach(function(key,doc){results=results.insert(key,doc);});});}).next(function(){return results;});});}},{key:"getDocumentsMatchingCollectionQuery",value:function getDocumentsMatchingCollectionQuery(transaction,query,sinceReadTime){var _this32=this;// Query the remote documents and overlay mutations.
var results;var mutationBatches;return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction,query,sinceReadTime).next(function(queryResults){results=queryResults;return _this32.mutationQueue.getAllMutationBatchesAffectingQuery(transaction,query);}).next(function(matchingMutationBatches){mutationBatches=matchingMutationBatches;// It is possible that a PatchMutation can make a document match a query, even if
// the version in the RemoteDocumentCache is not a match yet (waiting for server
// to ack). To handle this, we find all document keys affected by the PatchMutations
// that are not in `result` yet, and back fill them via `remoteDocumentCache.getEntries`,
// otherwise those `PatchMutations` will be ignored because no base document can be found,
// and lead to missing result for the query.
return _this32.addMissingBaseDocuments(transaction,mutationBatches,results).next(function(mergedDocuments){results=mergedDocuments;var _iteratorNormalCompletion26=true;var _didIteratorError26=false;var _iteratorError26=undefined;try{for(var _iterator26=mutationBatches[Symbol.iterator](),_step26;!(_iteratorNormalCompletion26=(_step26=_iterator26.next()).done);_iteratorNormalCompletion26=true){var batch=_step26.value;var _iteratorNormalCompletion27=true;var _didIteratorError27=false;var _iteratorError27=undefined;try{for(var _iterator27=batch.mutations[Symbol.iterator](),_step27;!(_iteratorNormalCompletion27=(_step27=_iterator27.next()).done);_iteratorNormalCompletion27=true){var mutation=_step27.value;var key=mutation.key;var baseDoc=results.get(key);var mutatedDoc=applyMutationToLocalView(mutation,baseDoc,baseDoc,batch.localWriteTime);if(mutatedDoc instanceof Document){results=results.insert(key,mutatedDoc);}else{results=results.remove(key);}}}catch(err){_didIteratorError27=true;_iteratorError27=err;}finally{try{if(!_iteratorNormalCompletion27&&_iterator27["return"]!=null){_iterator27["return"]();}}finally{if(_didIteratorError27){throw _iteratorError27;}}}}}catch(err){_didIteratorError26=true;_iteratorError26=err;}finally{try{if(!_iteratorNormalCompletion26&&_iterator26["return"]!=null){_iterator26["return"]();}}finally{if(_didIteratorError26){throw _iteratorError26;}}}});}).next(function(){// Finally, filter out any documents that don't actually match
// the query.
results.forEach(function(key,doc){if(!queryMatches(query,doc)){results=results.remove(key);}});return results;});}},{key:"addMissingBaseDocuments",value:function addMissingBaseDocuments(transaction,matchingMutationBatches,existingDocuments){var missingBaseDocEntriesForPatching=documentKeySet();var _iteratorNormalCompletion28=true;var _didIteratorError28=false;var _iteratorError28=undefined;try{for(var _iterator28=matchingMutationBatches[Symbol.iterator](),_step28;!(_iteratorNormalCompletion28=(_step28=_iterator28.next()).done);_iteratorNormalCompletion28=true){var batch=_step28.value;var _iteratorNormalCompletion29=true;var _didIteratorError29=false;var _iteratorError29=undefined;try{for(var _iterator29=batch.mutations[Symbol.iterator](),_step29;!(_iteratorNormalCompletion29=(_step29=_iterator29.next()).done);_iteratorNormalCompletion29=true){var mutation=_step29.value;if(mutation instanceof PatchMutation&&existingDocuments.get(mutation.key)===null){missingBaseDocEntriesForPatching=missingBaseDocEntriesForPatching.add(mutation.key);}}}catch(err){_didIteratorError29=true;_iteratorError29=err;}finally{try{if(!_iteratorNormalCompletion29&&_iterator29["return"]!=null){_iterator29["return"]();}}finally{if(_didIteratorError29){throw _iteratorError29;}}}}}catch(err){_didIteratorError28=true;_iteratorError28=err;}finally{try{if(!_iteratorNormalCompletion28&&_iterator28["return"]!=null){_iterator28["return"]();}}finally{if(_didIteratorError28){throw _iteratorError28;}}}var mergedDocuments=existingDocuments;return this.remoteDocumentCache.getEntries(transaction,missingBaseDocEntriesForPatching).next(function(missingBaseDocs){missingBaseDocs.forEach(function(key,doc){if(doc!==null&&doc instanceof Document){mergedDocuments=mergedDocuments.insert(key,doc);}});return mergedDocuments;});}}]);return LocalDocumentsView;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var PRIMARY_LEASE_LOST_ERROR_MSG='The current tab is not in the required state to perform this operation. '+'It might be necessary to refresh the browser tab.';/**
 * A base class representing a persistence transaction, encapsulating both the
 * transaction's sequence numbers as well as a list of onCommitted listeners.
 *
 * When you call Persistence.runTransaction(), it will create a transaction and
 * pass it to your callback. You then pass it to any method that operates
 * on persistence.
 */var PersistenceTransaction=/*#__PURE__*/function(){function PersistenceTransaction(){_classCallCheck(this,PersistenceTransaction);this.onCommittedListeners=[];}_createClass(PersistenceTransaction,[{key:"addOnCommittedListener",value:function addOnCommittedListener(listener){this.onCommittedListeners.push(listener);}},{key:"raiseOnCommittedEvent",value:function raiseOnCommittedEvent(){this.onCommittedListeners.forEach(function(listener){return listener();});}}]);return PersistenceTransaction;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An immutable set of metadata that the local store tracks for each target.
 */var TargetData=/*#__PURE__*/function(){function TargetData(/** The target being listened to. */target,/**
     * The target ID to which the target corresponds; Assigned by the
     * LocalStore for user listens and by the SyncEngine for limbo watches.
     */targetId,/** The purpose of the target. */purpose,/**
     * The sequence number of the last transaction during which this target data
     * was modified.
     */sequenceNumber){var snapshotVersion=arguments.length>4&&arguments[4]!==undefined?arguments[4]:SnapshotVersion.min();var lastLimboFreeSnapshotVersion=arguments.length>5&&arguments[5]!==undefined?arguments[5]:SnapshotVersion.min();var resumeToken=arguments.length>6&&arguments[6]!==undefined?arguments[6]:ByteString.EMPTY_BYTE_STRING;_classCallCheck(this,TargetData);this.target=target;this.targetId=targetId;this.purpose=purpose;this.sequenceNumber=sequenceNumber;this.snapshotVersion=snapshotVersion;this.lastLimboFreeSnapshotVersion=lastLimboFreeSnapshotVersion;this.resumeToken=resumeToken;}/** Creates a new target data instance with an updated sequence number. */_createClass(TargetData,[{key:"withSequenceNumber",value:function withSequenceNumber(sequenceNumber){return new TargetData(this.target,this.targetId,this.purpose,sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken);}/**
     * Creates a new target data instance with an updated resume token and
     * snapshot version.
     */},{key:"withResumeToken",value:function withResumeToken(resumeToken,snapshotVersion){return new TargetData(this.target,this.targetId,this.purpose,this.sequenceNumber,snapshotVersion,this.lastLimboFreeSnapshotVersion,resumeToken);}/**
     * Creates a new target data instance with an updated last limbo free
     * snapshot version number.
     */},{key:"withLastLimboFreeSnapshotVersion",value:function withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion){return new TargetData(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,lastLimboFreeSnapshotVersion,this.resumeToken);}}]);return TargetData;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An in-memory buffer of entries to be written to a RemoteDocumentCache.
 * It can be used to batch up a set of changes to be written to the cache, but
 * additionally supports reading entries back with the `getEntry()` method,
 * falling back to the underlying RemoteDocumentCache if no entry is
 * buffered.
 *
 * Entries added to the cache *must* be read first. This is to facilitate
 * calculating the size delta of the pending changes.
 *
 * PORTING NOTE: This class was implemented then removed from other platforms.
 * If byte-counting ends up being needed on the other platforms, consider
 * porting this class as part of that implementation work.
 */var RemoteDocumentChangeBuffer=/*#__PURE__*/function(){function RemoteDocumentChangeBuffer(){_classCallCheck(this,RemoteDocumentChangeBuffer);// A mapping of document key to the new cache entry that should be written (or null if any
// existing cache entry should be removed).
this.changes=new ObjectMap(function(key){return key.toString();},function(l,r){return l.isEqual(r);});this.changesApplied=false;}_createClass(RemoteDocumentChangeBuffer,[{key:"addEntry",/**
     * Buffers a `RemoteDocumentCache.addEntry()` call.
     *
     * You can only modify documents that have already been retrieved via
     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
     */value:function addEntry(maybeDocument,readTime){this.assertNotApplied();this.readTime=readTime;this.changes.set(maybeDocument.key,maybeDocument);}/**
     * Buffers a `RemoteDocumentCache.removeEntry()` call.
     *
     * You can only remove documents that have already been retrieved via
     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).
     */},{key:"removeEntry",value:function removeEntry(key,readTime){this.assertNotApplied();if(readTime){this.readTime=readTime;}this.changes.set(key,null);}/**
     * Looks up an entry in the cache. The buffered changes will first be checked,
     * and if no buffered change applies, this will forward to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKey The key of the entry to look up.
     * @return The cached Document or NoDocument entry, or null if we have nothing
     * cached.
     */},{key:"getEntry",value:function getEntry(transaction,documentKey){this.assertNotApplied();var bufferedEntry=this.changes.get(documentKey);if(bufferedEntry!==undefined){return PersistencePromise.resolve(bufferedEntry);}else{return this.getFromCache(transaction,documentKey);}}/**
     * Looks up several entries in the cache, forwarding to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKeys The keys of the entries to look up.
     * @return A map of cached `Document`s or `NoDocument`s, indexed by key. If an
     *     entry cannot be found, the corresponding key will be mapped to a null
     *     value.
     */},{key:"getEntries",value:function getEntries(transaction,documentKeys){return this.getAllFromCache(transaction,documentKeys);}/**
     * Applies buffered changes to the underlying RemoteDocumentCache, using
     * the provided transaction.
     */},{key:"apply",value:function apply(transaction){this.assertNotApplied();this.changesApplied=true;return this.applyChanges(transaction);}/** Helper to assert this.changes is not null  */},{key:"assertNotApplied",value:function assertNotApplied(){}},{key:"readTime",set:function set(value){this._readTime=value;},get:function get(){return this._readTime;}}]);return RemoteDocumentChangeBuffer;}();/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An in-memory implementation of IndexManager.
 */var MemoryIndexManager=/*#__PURE__*/function(){function MemoryIndexManager(){_classCallCheck(this,MemoryIndexManager);this.collectionParentIndex=new MemoryCollectionParentIndex();}_createClass(MemoryIndexManager,[{key:"addToCollectionParentIndex",value:function addToCollectionParentIndex(transaction,collectionPath){this.collectionParentIndex.add(collectionPath);return PersistencePromise.resolve();}},{key:"getCollectionParents",value:function getCollectionParents(transaction,collectionId){return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));}}]);return MemoryIndexManager;}();/**
 * Internal implementation of the collection-parent index exposed by MemoryIndexManager.
 * Also used for in-memory caching by IndexedDbIndexManager and initial index population
 * in indexeddb_schema.ts
 */var MemoryCollectionParentIndex=/*#__PURE__*/function(){function MemoryCollectionParentIndex(){_classCallCheck(this,MemoryCollectionParentIndex);this.index={};}// Returns false if the entry already existed.
_createClass(MemoryCollectionParentIndex,[{key:"add",value:function add(collectionPath){var collectionId=collectionPath.lastSegment();var parentPath=collectionPath.popLast();var existingParents=this.index[collectionId]||new SortedSet(ResourcePath.comparator);var added=!existingParents.has(parentPath);this.index[collectionId]=existingParents.add(parentPath);return added;}},{key:"has",value:function has(collectionPath){var collectionId=collectionPath.lastSegment();var parentPath=collectionPath.popLast();var existingParents=this.index[collectionId];return existingParents&&existingParents.has(parentPath);}},{key:"getEntries",value:function getEntries(collectionId){var parentPaths=this.index[collectionId]||new SortedSet(ResourcePath.comparator);return parentPaths.toArray();}}]);return MemoryCollectionParentIndex;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var Deferred=function Deferred(){var _this33=this;_classCallCheck(this,Deferred);this.promise=new Promise(function(resolve,reject){_this33.resolve=resolve;_this33.reject=reject;});};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Verifies whether `e` is an IndexedDbTransactionError. */function isIndexedDbTransactionError(e){// Use name equality, as instanceof checks on errors don't work with errors
// that wrap other errors.
return e.name==='IndexedDbTransactionError';}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Offset to ensure non-overlapping target ids. */var OFFSET=2;/**
 * Generates monotonically increasing target IDs for sending targets to the
 * watch stream.
 *
 * The client constructs two generators, one for the target cache, and one for
 * for the sync engine (to generate limbo documents targets). These
 * generators produce non-overlapping IDs (by using even and odd IDs
 * respectively).
 *
 * By separating the target ID space, the query cache can generate target IDs
 * that persist across client restarts, while sync engine can independently
 * generate in-memory target IDs that are transient and can be reused after a
 * restart.
 */var TargetIdGenerator=/*#__PURE__*/function(){function TargetIdGenerator(lastId){_classCallCheck(this,TargetIdGenerator);this.lastId=lastId;}_createClass(TargetIdGenerator,[{key:"next",value:function next(){this.lastId+=OFFSET;return this.lastId;}}],[{key:"forTargetCache",value:function forTargetCache(){// The target cache generator must return '2' in its first call to `next()`
// as there is no differentiation in the protocol layer between an unset
// number and the number '0'. If we were to sent a target with target ID
// '0', the backend would consider it unset and replace it with its own ID.
return new TargetIdGenerator(2-OFFSET);}},{key:"forSyncEngine",value:function forSyncEngine(){// Sync engine assigns target IDs for limbo document detection.
return new TargetIdGenerator(1-OFFSET);}}]);return TargetIdGenerator;}();/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LruParams=/*#__PURE__*/function(){function LruParams(// When we attempt to collect, we will only do so if the cache size is greater than this
// threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.
cacheSizeCollectionThreshold,// The percentage of sequence numbers that we will attempt to collect
percentileToCollect,// A cap on the total number of sequence numbers that will be collected. This prevents
// us from collecting a huge number of sequence numbers if the cache has grown very large.
maximumSequenceNumbersToCollect){_classCallCheck(this,LruParams);this.cacheSizeCollectionThreshold=cacheSizeCollectionThreshold;this.percentileToCollect=percentileToCollect;this.maximumSequenceNumbersToCollect=maximumSequenceNumbersToCollect;}_createClass(LruParams,null,[{key:"withCacheSize",value:function withCacheSize(cacheSize){return new LruParams(cacheSize,LruParams.DEFAULT_COLLECTION_PERCENTILE,LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);}}]);return LruParams;}();LruParams.COLLECTION_DISABLED=-1;LruParams.MINIMUM_CACHE_SIZE_BYTES=1*1024*1024;LruParams.DEFAULT_CACHE_SIZE_BYTES=40*1024*1024;LruParams.DEFAULT_COLLECTION_PERCENTILE=10;LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1000;LruParams.DEFAULT=new LruParams(LruParams.DEFAULT_CACHE_SIZE_BYTES,LruParams.DEFAULT_COLLECTION_PERCENTILE,LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);LruParams.DISABLED=new LruParams(LruParams.COLLECTION_DISABLED,0,0);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$1='LocalStore';/**
 * The maximum time to leave a resume token buffered without writing it out.
 * This value is arbitrary: it's long enough to avoid several writes
 * (possibly indefinitely if updates come more frequently than this) but
 * short enough that restarting after crashing will still have a pretty
 * recent resume token.
 */var RESUME_TOKEN_MAX_AGE_MICROS=5*60*1e6;/**
 * Implements `LocalStore` interface.
 *
 * Note: some field defined in this class might have public access level, but
 * the class is not exported so they are only accessible from this module.
 * This is useful to implement optional features (like bundles) in free
 * functions, such that they are tree-shakeable.
 */var LocalStoreImpl=/*#__PURE__*/function(){function LocalStoreImpl(/** Manages our in-memory or durable persistence. */persistence,queryEngine,initialUser){_classCallCheck(this,LocalStoreImpl);this.persistence=persistence;this.queryEngine=queryEngine;/**
         * Maps a targetID to data about its target.
         *
         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs
         * of `applyRemoteEvent()` idempotent.
         */this.targetDataByTarget=new SortedMap(primitiveComparator);/** Maps a target to its targetID. */ // TODO(wuandy): Evaluate if TargetId can be part of Target.
this.targetIdByTarget=new ObjectMap(function(t){return canonifyTarget(t);},targetEquals);/**
         * The read time of the last entry processed by `getNewDocumentChanges()`.
         *
         * PORTING NOTE: This is only used for multi-tab synchronization.
         */this.lastDocumentChangeReadTime=SnapshotVersion.min();this.mutationQueue=persistence.getMutationQueue(initialUser);this.remoteDocuments=persistence.getRemoteDocumentCache();this.targetCache=persistence.getTargetCache();this.localDocuments=new LocalDocumentsView(this.remoteDocuments,this.mutationQueue,this.persistence.getIndexManager());this.queryEngine.setLocalDocumentsView(this.localDocuments);}_createClass(LocalStoreImpl,[{key:"collectGarbage",value:function collectGarbage(garbageCollector){var _this34=this;return this.persistence.runTransaction('Collect garbage','readwrite-primary',function(txn){return garbageCollector.collect(txn,_this34.targetDataByTarget);});}}]);return LocalStoreImpl;}();function newLocalStore(/** Manages our in-memory or durable persistence. */persistence,queryEngine,initialUser){return new LocalStoreImpl(persistence,queryEngine,initialUser);}/**
 * Tells the LocalStore that the currently authenticated user has changed.
 *
 * In response the local store switches the mutation queue to the new user and
 * returns any resulting document changes.
 */ // PORTING NOTE: Android and iOS only return the documents affected by the
// change.
function handleUserChange(localStore,user){var localStoreImpl,newMutationQueue,newLocalDocuments,result;return regeneratorRuntime.async(function handleUserChange$(_context){while(1){switch(_context.prev=_context.next){case 0:localStoreImpl=debugCast(localStore);newMutationQueue=localStoreImpl.mutationQueue;newLocalDocuments=localStoreImpl.localDocuments;_context.next=5;return regeneratorRuntime.awrap(localStoreImpl.persistence.runTransaction('Handle user change','readonly',function(txn){// Swap out the mutation queue, grabbing the pending mutation batches
// before and after.
var oldBatches;return localStoreImpl.mutationQueue.getAllMutationBatches(txn).next(function(promisedOldBatches){oldBatches=promisedOldBatches;newMutationQueue=localStoreImpl.persistence.getMutationQueue(user);// Recreate our LocalDocumentsView using the new
// MutationQueue.
newLocalDocuments=new LocalDocumentsView(localStoreImpl.remoteDocuments,newMutationQueue,localStoreImpl.persistence.getIndexManager());return newMutationQueue.getAllMutationBatches(txn);}).next(function(newBatches){var removedBatchIds=[];var addedBatchIds=[];// Union the old/new changed keys.
var changedKeys=documentKeySet();var _iteratorNormalCompletion30=true;var _didIteratorError30=false;var _iteratorError30=undefined;try{for(var _iterator30=oldBatches[Symbol.iterator](),_step30;!(_iteratorNormalCompletion30=(_step30=_iterator30.next()).done);_iteratorNormalCompletion30=true){var batch=_step30.value;removedBatchIds.push(batch.batchId);var _iteratorNormalCompletion32=true;var _didIteratorError32=false;var _iteratorError32=undefined;try{for(var _iterator32=batch.mutations[Symbol.iterator](),_step32;!(_iteratorNormalCompletion32=(_step32=_iterator32.next()).done);_iteratorNormalCompletion32=true){var mutation=_step32.value;changedKeys=changedKeys.add(mutation.key);}}catch(err){_didIteratorError32=true;_iteratorError32=err;}finally{try{if(!_iteratorNormalCompletion32&&_iterator32["return"]!=null){_iterator32["return"]();}}finally{if(_didIteratorError32){throw _iteratorError32;}}}}}catch(err){_didIteratorError30=true;_iteratorError30=err;}finally{try{if(!_iteratorNormalCompletion30&&_iterator30["return"]!=null){_iterator30["return"]();}}finally{if(_didIteratorError30){throw _iteratorError30;}}}var _iteratorNormalCompletion31=true;var _didIteratorError31=false;var _iteratorError31=undefined;try{for(var _iterator31=newBatches[Symbol.iterator](),_step31;!(_iteratorNormalCompletion31=(_step31=_iterator31.next()).done);_iteratorNormalCompletion31=true){var _batch=_step31.value;addedBatchIds.push(_batch.batchId);var _iteratorNormalCompletion33=true;var _didIteratorError33=false;var _iteratorError33=undefined;try{for(var _iterator33=_batch.mutations[Symbol.iterator](),_step33;!(_iteratorNormalCompletion33=(_step33=_iterator33.next()).done);_iteratorNormalCompletion33=true){var _mutation2=_step33.value;changedKeys=changedKeys.add(_mutation2.key);}}catch(err){_didIteratorError33=true;_iteratorError33=err;}finally{try{if(!_iteratorNormalCompletion33&&_iterator33["return"]!=null){_iterator33["return"]();}}finally{if(_didIteratorError33){throw _iteratorError33;}}}}// Return the set of all (potentially) changed documents and the list
// of mutation batch IDs that were affected by change.
}catch(err){_didIteratorError31=true;_iteratorError31=err;}finally{try{if(!_iteratorNormalCompletion31&&_iterator31["return"]!=null){_iterator31["return"]();}}finally{if(_didIteratorError31){throw _iteratorError31;}}}return newLocalDocuments.getDocuments(txn,changedKeys).next(function(affectedDocuments){return{affectedDocuments:affectedDocuments,removedBatchIds:removedBatchIds,addedBatchIds:addedBatchIds};});});}));case 5:result=_context.sent;localStoreImpl.mutationQueue=newMutationQueue;localStoreImpl.localDocuments=newLocalDocuments;localStoreImpl.queryEngine.setLocalDocumentsView(localStoreImpl.localDocuments);return _context.abrupt("return",result);case 10:case"end":return _context.stop();}}});}/* Accepts locally generated Mutations and commit them to storage. */function localWrite(localStore,mutations){var localStoreImpl=debugCast(localStore);var localWriteTime=Timestamp.now();var keys=mutations.reduce(function(keys,m){return keys.add(m.key);},documentKeySet());var existingDocs;return localStoreImpl.persistence.runTransaction('Locally write mutations','readwrite',function(txn){// Load and apply all existing mutations. This lets us compute the
// current base state for all non-idempotent transforms before applying
// any additional user-provided writes.
return localStoreImpl.localDocuments.getDocuments(txn,keys).next(function(docs){existingDocs=docs;// For non-idempotent mutations (such as `FieldValue.increment()`),
// we record the base state in a separate patch mutation. This is
// later used to guarantee consistent values and prevents flicker
// even if the backend sends us an update that already includes our
// transform.
var baseMutations=[];var _iteratorNormalCompletion34=true;var _didIteratorError34=false;var _iteratorError34=undefined;try{for(var _iterator34=mutations[Symbol.iterator](),_step34;!(_iteratorNormalCompletion34=(_step34=_iterator34.next()).done);_iteratorNormalCompletion34=true){var mutation=_step34.value;var baseValue=extractMutationBaseValue(mutation,existingDocs.get(mutation.key));if(baseValue!=null){// NOTE: The base state should only be applied if there's some
// existing document to override, so use a Precondition of
// exists=true
baseMutations.push(new PatchMutation(mutation.key,baseValue,extractFieldMask(baseValue.proto.mapValue),Precondition.exists(true)));}}}catch(err){_didIteratorError34=true;_iteratorError34=err;}finally{try{if(!_iteratorNormalCompletion34&&_iterator34["return"]!=null){_iterator34["return"]();}}finally{if(_didIteratorError34){throw _iteratorError34;}}}return localStoreImpl.mutationQueue.addMutationBatch(txn,localWriteTime,baseMutations,mutations);});}).then(function(batch){var changes=batch.applyToLocalDocumentSet(existingDocs);return{batchId:batch.batchId,changes:changes};});}/**
 * Acknowledges the given batch.
 *
 * On the happy path when a batch is acknowledged, the local store will
 *
 *  + remove the batch from the mutation queue;
 *  + apply the changes to the remote document cache;
 *  + recalculate the latency compensated view implied by those changes (there
 *    may be mutations in the queue that affect the documents but haven't been
 *    acknowledged yet); and
 *  + give the changed documents back the sync engine
 *
 * @returns The resulting (modified) documents.
 */function acknowledgeBatch(localStore,batchResult){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('Acknowledge batch','readwrite-primary',function(txn){var affected=batchResult.batch.keys();var documentBuffer=localStoreImpl.remoteDocuments.newChangeBuffer({trackRemovals:true// Make sure document removals show up in `getNewDocumentChanges()`
});return applyWriteToRemoteDocuments(localStoreImpl,txn,batchResult,documentBuffer).next(function(){return documentBuffer.apply(txn);}).next(function(){return localStoreImpl.mutationQueue.performConsistencyCheck(txn);}).next(function(){return localStoreImpl.localDocuments.getDocuments(txn,affected);});});}/**
 * Removes mutations from the MutationQueue for the specified batch;
 * LocalDocuments will be recalculated.
 *
 * @returns The resulting modified documents.
 */function rejectBatch(localStore,batchId){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('Reject batch','readwrite-primary',function(txn){var affectedKeys;return localStoreImpl.mutationQueue.lookupMutationBatch(txn,batchId).next(function(batch){hardAssert(batch!==null);affectedKeys=batch.keys();return localStoreImpl.mutationQueue.removeMutationBatch(txn,batch);}).next(function(){return localStoreImpl.mutationQueue.performConsistencyCheck(txn);}).next(function(){return localStoreImpl.localDocuments.getDocuments(txn,affectedKeys);});});}/**
 * Returns the largest (latest) batch id in mutation queue that is pending
 * server response.
 *
 * Returns `BATCHID_UNKNOWN` if the queue is empty.
 */function getHighestUnacknowledgedBatchId(localStore){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id','readonly',function(txn){return localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn);});}/**
 * Returns the last consistent snapshot processed (used by the RemoteStore to
 * determine whether to buffer incoming snapshots from the backend).
 */function getLastRemoteSnapshotVersion(localStore){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('Get last remote snapshot version','readonly',function(txn){return localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn);});}/**
 * Updates the "ground-state" (remote) documents. We assume that the remote
 * event reflects any write batches that have been acknowledged or rejected
 * (i.e. we do not re-apply local mutations to updates from this event).
 *
 * LocalDocuments are re-calculated if there are remaining mutations in the
 * queue.
 */function applyRemoteEventToLocalCache(localStore,remoteEvent){var localStoreImpl=debugCast(localStore);var remoteVersion=remoteEvent.snapshotVersion;var newTargetDataByTargetMap=localStoreImpl.targetDataByTarget;return localStoreImpl.persistence.runTransaction('Apply remote event','readwrite-primary',function(txn){var documentBuffer=localStoreImpl.remoteDocuments.newChangeBuffer({trackRemovals:true// Make sure document removals show up in `getNewDocumentChanges()`
});// Reset newTargetDataByTargetMap in case this transaction gets re-run.
newTargetDataByTargetMap=localStoreImpl.targetDataByTarget;var promises=[];remoteEvent.targetChanges.forEach(function(change,targetId){var oldTargetData=newTargetDataByTargetMap.get(targetId);if(!oldTargetData){return;}// Only update the remote keys if the target is still active. This
// ensures that we can persist the updated target data along with
// the updated assignment.
promises.push(localStoreImpl.targetCache.removeMatchingKeys(txn,change.removedDocuments,targetId).next(function(){return localStoreImpl.targetCache.addMatchingKeys(txn,change.addedDocuments,targetId);}));var resumeToken=change.resumeToken;// Update the resume token if the change includes one.
if(resumeToken.approximateByteSize()>0){var newTargetData=oldTargetData.withResumeToken(resumeToken,remoteVersion).withSequenceNumber(txn.currentSequenceNumber);newTargetDataByTargetMap=newTargetDataByTargetMap.insert(targetId,newTargetData);// Update the target data if there are target changes (or if
// sufficient time has passed since the last update).
if(shouldPersistTargetData(oldTargetData,newTargetData,change)){promises.push(localStoreImpl.targetCache.updateTargetData(txn,newTargetData));}}});var changedDocs=maybeDocumentMap();var updatedKeys=documentKeySet();remoteEvent.documentUpdates.forEach(function(key,doc){updatedKeys=updatedKeys.add(key);});// Each loop iteration only affects its "own" doc, so it's safe to get all the remote
// documents in advance in a single call.
promises.push(documentBuffer.getEntries(txn,updatedKeys).next(function(existingDocs){remoteEvent.documentUpdates.forEach(function(key,doc){var existingDoc=existingDocs.get(key);// Note: The order of the steps below is important, since we want
// to ensure that rejected limbo resolutions (which fabricate
// NoDocuments with SnapshotVersion.min()) never add documents to
// cache.
if(doc instanceof NoDocument&&doc.version.isEqual(SnapshotVersion.min())){// NoDocuments with SnapshotVersion.min() are used in manufactured
// events. We remove these documents from cache since we lost
// access.
documentBuffer.removeEntry(key,remoteVersion);changedDocs=changedDocs.insert(key,doc);}else if(existingDoc==null||doc.version.compareTo(existingDoc.version)>0||doc.version.compareTo(existingDoc.version)===0&&existingDoc.hasPendingWrites){documentBuffer.addEntry(doc,remoteVersion);changedDocs=changedDocs.insert(key,doc);}else{logDebug(LOG_TAG$1,'Ignoring outdated watch update for ',key,'. Current version:',existingDoc.version,' Watch version:',doc.version);}if(remoteEvent.resolvedLimboDocuments.has(key)){promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn,key));}});}));// HACK: The only reason we allow a null snapshot version is so that we
// can synthesize remote events when we get permission denied errors while
// trying to resolve the state of a locally cached document that is in
// limbo.
if(!remoteVersion.isEqual(SnapshotVersion.min())){var updateRemoteVersion=localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn).next(function(lastRemoteSnapshotVersion){return localStoreImpl.targetCache.setTargetsMetadata(txn,txn.currentSequenceNumber,remoteVersion);});promises.push(updateRemoteVersion);}return PersistencePromise.waitFor(promises).next(function(){return documentBuffer.apply(txn);}).next(function(){return localStoreImpl.localDocuments.getLocalViewOfDocuments(txn,changedDocs);});}).then(function(changedDocs){localStoreImpl.targetDataByTarget=newTargetDataByTargetMap;return changedDocs;});}/**
 * Returns true if the newTargetData should be persisted during an update of
 * an active target. TargetData should always be persisted when a target is
 * being released and should not call this function.
 *
 * While the target is active, TargetData updates can be omitted when nothing
 * about the target has changed except metadata like the resume token or
 * snapshot version. Occasionally it's worth the extra write to prevent these
 * values from getting too stale after a crash, but this doesn't have to be
 * too frequent.
 */function shouldPersistTargetData(oldTargetData,newTargetData,change){hardAssert(newTargetData.resumeToken.approximateByteSize()>0);// Always persist target data if we don't already have a resume token.
if(oldTargetData.resumeToken.approximateByteSize()===0){return true;}// Don't allow resume token changes to be buffered indefinitely. This
// allows us to be reasonably up-to-date after a crash and avoids needing
// to loop over all active queries on shutdown. Especially in the browser
// we may not get time to do anything interesting while the current tab is
// closing.
var timeDelta=newTargetData.snapshotVersion.toMicroseconds()-oldTargetData.snapshotVersion.toMicroseconds();if(timeDelta>=RESUME_TOKEN_MAX_AGE_MICROS){return true;}// Otherwise if the only thing that has changed about a target is its resume
// token it's not worth persisting. Note that the RemoteStore keeps an
// in-memory view of the currently active targets which includes the current
// resume token, so stream failure or user changes will still use an
// up-to-date resume token regardless of what we do here.
var changes=change.addedDocuments.size+change.modifiedDocuments.size+change.removedDocuments.size;return changes>0;}/**
 * Notifies local store of the changed views to locally pin documents.
 */function notifyLocalViewChanges(localStore,viewChanges){var localStoreImpl,_iteratorNormalCompletion35,_didIteratorError35,_iteratorError35,_iterator35,_step35,viewChange,targetId,targetData,lastLimboFreeSnapshotVersion,updatedTargetData;return regeneratorRuntime.async(function notifyLocalViewChanges$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:localStoreImpl=debugCast(localStore);_context2.prev=1;_context2.next=4;return regeneratorRuntime.awrap(localStoreImpl.persistence.runTransaction('notifyLocalViewChanges','readwrite',function(txn){return PersistencePromise.forEach(viewChanges,function(viewChange){return PersistencePromise.forEach(viewChange.addedKeys,function(key){return localStoreImpl.persistence.referenceDelegate.addReference(txn,viewChange.targetId,key);}).next(function(){return PersistencePromise.forEach(viewChange.removedKeys,function(key){return localStoreImpl.persistence.referenceDelegate.removeReference(txn,viewChange.targetId,key);});});});}));case 4:_context2.next=13;break;case 6:_context2.prev=6;_context2.t0=_context2["catch"](1);if(!isIndexedDbTransactionError(_context2.t0)){_context2.next=12;break;}// If `notifyLocalViewChanges` fails, we did not advance the sequence
// number for the documents that were included in this transaction.
// This might trigger them to be deleted earlier than they otherwise
// would have, but it should not invalidate the integrity of the data.
logDebug(LOG_TAG$1,'Failed to update sequence numbers: '+_context2.t0);_context2.next=13;break;case 12:throw _context2.t0;case 13:_iteratorNormalCompletion35=true;_didIteratorError35=false;_iteratorError35=undefined;_context2.prev=16;for(_iterator35=viewChanges[Symbol.iterator]();!(_iteratorNormalCompletion35=(_step35=_iterator35.next()).done);_iteratorNormalCompletion35=true){viewChange=_step35.value;targetId=viewChange.targetId;if(!viewChange.fromCache){targetData=localStoreImpl.targetDataByTarget.get(targetId);// Advance the last limbo free snapshot version
lastLimboFreeSnapshotVersion=targetData.snapshotVersion;updatedTargetData=targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);localStoreImpl.targetDataByTarget=localStoreImpl.targetDataByTarget.insert(targetId,updatedTargetData);}}_context2.next=24;break;case 20:_context2.prev=20;_context2.t1=_context2["catch"](16);_didIteratorError35=true;_iteratorError35=_context2.t1;case 24:_context2.prev=24;_context2.prev=25;if(!_iteratorNormalCompletion35&&_iterator35["return"]!=null){_iterator35["return"]();}case 27:_context2.prev=27;if(!_didIteratorError35){_context2.next=30;break;}throw _iteratorError35;case 30:return _context2.finish(27);case 31:return _context2.finish(24);case 32:case"end":return _context2.stop();}}},null,null,[[1,6],[16,20,24,32],[25,,27,31]]);}/**
 * Gets the mutation batch after the passed in batchId in the mutation queue
 * or null if empty.
 * @param afterBatchId If provided, the batch to search after.
 * @returns The next mutation or null if there wasn't one.
 */function nextMutationBatch(localStore,afterBatchId){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('Get next mutation batch','readonly',function(txn){if(afterBatchId===undefined){afterBatchId=BATCHID_UNKNOWN;}return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn,afterBatchId);});}/**
 * Reads the current value of a Document with a given key or null if not
 * found - used for testing.
 */function readLocalDocument(localStore,key){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('read document','readonly',function(txn){return localStoreImpl.localDocuments.getDocument(txn,key);});}/**
 * Assigns the given target an internal ID so that its results can be pinned so
 * they don't get GC'd. A target must be allocated in the local store before
 * the store can be used to manage its view.
 *
 * Allocating an already allocated `Target` will return the existing `TargetData`
 * for that `Target`.
 */function allocateTarget(localStore,target){var localStoreImpl=debugCast(localStore);return localStoreImpl.persistence.runTransaction('Allocate target','readwrite',function(txn){var targetData;return localStoreImpl.targetCache.getTargetData(txn,target).next(function(cached){if(cached){// This target has been listened to previously, so reuse the
// previous targetID.
// TODO(mcg): freshen last accessed date?
targetData=cached;return PersistencePromise.resolve(targetData);}else{return localStoreImpl.targetCache.allocateTargetId(txn).next(function(targetId){targetData=new TargetData(target,targetId,0/* Listen */,txn.currentSequenceNumber);return localStoreImpl.targetCache.addTargetData(txn,targetData).next(function(){return targetData;});});}});}).then(function(targetData){// If Multi-Tab is enabled, the existing target data may be newer than
// the in-memory data
var cachedTargetData=localStoreImpl.targetDataByTarget.get(targetData.targetId);if(cachedTargetData===null||targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion)>0){localStoreImpl.targetDataByTarget=localStoreImpl.targetDataByTarget.insert(targetData.targetId,targetData);localStoreImpl.targetIdByTarget.set(target,targetData.targetId);}return targetData;});}/**
 * Returns the TargetData as seen by the LocalStore, including updates that may
 * have not yet been persisted to the TargetCache.
 */ // Visible for testing.
function getLocalTargetData(localStore,transaction,target){var localStoreImpl=debugCast(localStore);var targetId=localStoreImpl.targetIdByTarget.get(target);if(targetId!==undefined){return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));}else{return localStoreImpl.targetCache.getTargetData(transaction,target);}}/**
 * Unpins all the documents associated with the given target. If
 * `keepPersistedTargetData` is set to false and Eager GC enabled, the method
 * directly removes the associated target data from the target cache.
 *
 * Releasing a non-existing `Target` is a no-op.
 */ // PORTING NOTE: `keepPersistedTargetData` is multi-tab only.
function releaseTarget(localStore,targetId,keepPersistedTargetData){var localStoreImpl,targetData,mode;return regeneratorRuntime.async(function releaseTarget$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:localStoreImpl=debugCast(localStore);targetData=localStoreImpl.targetDataByTarget.get(targetId);mode=keepPersistedTargetData?'readwrite':'readwrite-primary';_context3.prev=3;if(keepPersistedTargetData){_context3.next=7;break;}_context3.next=7;return regeneratorRuntime.awrap(localStoreImpl.persistence.runTransaction('Release target',mode,function(txn){return localStoreImpl.persistence.referenceDelegate.removeTarget(txn,targetData);}));case 7:_context3.next=16;break;case 9:_context3.prev=9;_context3.t0=_context3["catch"](3);if(!isIndexedDbTransactionError(_context3.t0)){_context3.next=15;break;}// All `releaseTarget` does is record the final metadata state for the
// target, but we've been recording this periodically during target
// activity. If we lose this write this could cause a very slight
// difference in the order of target deletion during GC, but we
// don't define exact LRU semantics so this is acceptable.
logDebug(LOG_TAG$1,"Failed to update sequence numbers for target ".concat(targetId,": ").concat(_context3.t0));_context3.next=16;break;case 15:throw _context3.t0;case 16:localStoreImpl.targetDataByTarget=localStoreImpl.targetDataByTarget.remove(targetId);localStoreImpl.targetIdByTarget["delete"](targetData.target);case 18:case"end":return _context3.stop();}}},null,null,[[3,9]]);}/**
 * Runs the specified query against the local store and returns the results,
 * potentially taking advantage of query data from previous executions (such
 * as the set of remote keys).
 *
 * @param usePreviousResults Whether results from previous executions can
 * be used to optimize this query execution.
 */function executeQuery(localStore,query,usePreviousResults){var localStoreImpl=debugCast(localStore);var lastLimboFreeSnapshotVersion=SnapshotVersion.min();var remoteKeys=documentKeySet();return localStoreImpl.persistence.runTransaction('Execute query','readonly',function(txn){return getLocalTargetData(localStoreImpl,txn,queryToTarget(query)).next(function(targetData){if(targetData){lastLimboFreeSnapshotVersion=targetData.lastLimboFreeSnapshotVersion;return localStoreImpl.targetCache.getMatchingKeysForTargetId(txn,targetData.targetId).next(function(result){remoteKeys=result;});}}).next(function(){return localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn,query,usePreviousResults?lastLimboFreeSnapshotVersion:SnapshotVersion.min(),usePreviousResults?remoteKeys:documentKeySet());}).next(function(documents){return{documents:documents,remoteKeys:remoteKeys};});});}function applyWriteToRemoteDocuments(localStoreImpl,txn,batchResult,documentBuffer){var batch=batchResult.batch;var docKeys=batch.keys();var promiseChain=PersistencePromise.resolve();docKeys.forEach(function(docKey){promiseChain=promiseChain.next(function(){return documentBuffer.getEntry(txn,docKey);}).next(function(remoteDoc){var doc=remoteDoc;var ackVersion=batchResult.docVersions.get(docKey);hardAssert(ackVersion!==null);if(!doc||doc.version.compareTo(ackVersion)<0){doc=batch.applyToRemoteDocument(docKey,doc,batchResult);if(!doc);else{// We use the commitVersion as the readTime rather than the
// document's updateTime since the updateTime is not advanced
// for updates that do not modify the underlying document.
documentBuffer.addEntry(doc,batchResult.commitVersion);}}});});return promiseChain.next(function(){return localStoreImpl.mutationQueue.removeMutationBatch(txn,batch);});}/**
 * Verifies the error thrown by a LocalStore operation. If a LocalStore
 * operation fails because the primary lease has been taken by another client,
 * we ignore the error (the persistence layer will immediately call
 * `applyPrimaryLease` to propagate the primary state change). All other errors
 * are re-thrown.
 *
 * @param err An error returned by a LocalStore operation.
 * @return A Promise that resolves after we recovered, or the original error.
 */function ignoreIfPrimaryLeaseLoss(err){return regeneratorRuntime.async(function ignoreIfPrimaryLeaseLoss$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(err.code===Code.FAILED_PRECONDITION&&err.message===PRIMARY_LEASE_LOST_ERROR_MSG)){_context4.next=4;break;}logDebug(LOG_TAG$1,'Unexpectedly lost primary lease');_context4.next=5;break;case 4:throw err;case 5:case"end":return _context4.stop();}}});}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A set of changes to what documents are currently in view and out of view for
 * a given query. These changes are sent to the LocalStore by the View (via
 * the SyncEngine) and are used to pin / unpin documents as appropriate.
 */var LocalViewChanges=/*#__PURE__*/function(){function LocalViewChanges(targetId,fromCache,addedKeys,removedKeys){_classCallCheck(this,LocalViewChanges);this.targetId=targetId;this.fromCache=fromCache;this.addedKeys=addedKeys;this.removedKeys=removedKeys;}_createClass(LocalViewChanges,null,[{key:"fromSnapshot",value:function fromSnapshot(targetId,viewSnapshot){var addedKeys=documentKeySet();var removedKeys=documentKeySet();var _iteratorNormalCompletion36=true;var _didIteratorError36=false;var _iteratorError36=undefined;try{for(var _iterator36=viewSnapshot.docChanges[Symbol.iterator](),_step36;!(_iteratorNormalCompletion36=(_step36=_iterator36.next()).done);_iteratorNormalCompletion36=true){var docChange=_step36.value;switch(docChange.type){case 0/* Added */:addedKeys=addedKeys.add(docChange.doc.key);break;case 1/* Removed */:removedKeys=removedKeys.add(docChange.doc.key);break;// do nothing
}}}catch(err){_didIteratorError36=true;_iteratorError36=err;}finally{try{if(!_iteratorNormalCompletion36&&_iterator36["return"]!=null){_iterator36["return"]();}}finally{if(_didIteratorError36){throw _iteratorError36;}}}return new LocalViewChanges(targetId,viewSnapshot.fromCache,addedKeys,removedKeys);}}]);return LocalViewChanges;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A collection of references to a document from some kind of numbered entity
 * (either a target ID or batch ID). As references are added to or removed from
 * the set corresponding events are emitted to a registered garbage collector.
 *
 * Each reference is represented by a DocumentReference object. Each of them
 * contains enough information to uniquely identify the reference. They are all
 * stored primarily in a set sorted by key. A document is considered garbage if
 * there's no references in that set (this can be efficiently checked thanks to
 * sorting by key).
 *
 * ReferenceSet also keeps a secondary set that contains references sorted by
 * IDs. This one is used to efficiently implement removal of all references by
 * some target ID.
 */var ReferenceSet=/*#__PURE__*/function(){function ReferenceSet(){_classCallCheck(this,ReferenceSet);// A set of outstanding references to a document sorted by key.
this.refsByKey=new SortedSet(DocReference.compareByKey);// A set of outstanding references to a document sorted by target id.
this.refsByTarget=new SortedSet(DocReference.compareByTargetId);}/** Returns true if the reference set contains no references. */_createClass(ReferenceSet,[{key:"isEmpty",value:function isEmpty(){return this.refsByKey.isEmpty();}/** Adds a reference to the given document key for the given ID. */},{key:"addReference",value:function addReference(key,id){var ref=new DocReference(key,id);this.refsByKey=this.refsByKey.add(ref);this.refsByTarget=this.refsByTarget.add(ref);}/** Add references to the given document keys for the given ID. */},{key:"addReferences",value:function addReferences(keys,id){var _this35=this;keys.forEach(function(key){return _this35.addReference(key,id);});}/**
     * Removes a reference to the given document key for the given
     * ID.
     */},{key:"removeReference",value:function removeReference(key,id){this.removeRef(new DocReference(key,id));}},{key:"removeReferences",value:function removeReferences(keys,id){var _this36=this;keys.forEach(function(key){return _this36.removeReference(key,id);});}/**
     * Clears all references with a given ID. Calls removeRef() for each key
     * removed.
     */},{key:"removeReferencesForId",value:function removeReferencesForId(id){var _this37=this;var emptyKey=new DocumentKey(new ResourcePath([]));var startRef=new DocReference(emptyKey,id);var endRef=new DocReference(emptyKey,id+1);var keys=[];this.refsByTarget.forEachInRange([startRef,endRef],function(ref){_this37.removeRef(ref);keys.push(ref.key);});return keys;}},{key:"removeAllReferences",value:function removeAllReferences(){var _this38=this;this.refsByKey.forEach(function(ref){return _this38.removeRef(ref);});}},{key:"removeRef",value:function removeRef(ref){this.refsByKey=this.refsByKey["delete"](ref);this.refsByTarget=this.refsByTarget["delete"](ref);}},{key:"referencesForId",value:function referencesForId(id){var emptyKey=new DocumentKey(new ResourcePath([]));var startRef=new DocReference(emptyKey,id);var endRef=new DocReference(emptyKey,id+1);var keys=documentKeySet();this.refsByTarget.forEachInRange([startRef,endRef],function(ref){keys=keys.add(ref.key);});return keys;}},{key:"containsKey",value:function containsKey(key){var ref=new DocReference(key,0);var firstRef=this.refsByKey.firstAfterOrEqual(ref);return firstRef!==null&&key.isEqual(firstRef.key);}}]);return ReferenceSet;}();var DocReference=/*#__PURE__*/function(){function DocReference(key,targetOrBatchId){_classCallCheck(this,DocReference);this.key=key;this.targetOrBatchId=targetOrBatchId;}/** Compare by key then by ID */_createClass(DocReference,null,[{key:"compareByKey",value:function compareByKey(left,right){return DocumentKey.comparator(left.key,right.key)||primitiveComparator(left.targetOrBatchId,right.targetOrBatchId);}/** Compare by ID then by key */},{key:"compareByTargetId",value:function compareByTargetId(left,right){return primitiveComparator(left.targetOrBatchId,right.targetOrBatchId)||DocumentKey.comparator(left.key,right.key);}}]);return DocReference;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$2='ExponentialBackoff';/**
 * Initial backoff time in milliseconds after an error.
 * Set to 1s according to https://cloud.google.com/apis/design/errors.
 */var DEFAULT_BACKOFF_INITIAL_DELAY_MS=1000;var DEFAULT_BACKOFF_FACTOR=1.5;/** Maximum backoff time in milliseconds */var DEFAULT_BACKOFF_MAX_DELAY_MS=60*1000;/**
 * A helper for running delayed tasks following an exponential backoff curve
 * between attempts.
 *
 * Each delay is made up of a "base" delay which follows the exponential
 * backoff curve, and a +/- 50% "jitter" that is calculated and added to the
 * base delay. This prevents clients from accidentally synchronizing their
 * delays causing spikes of load to the backend.
 */var ExponentialBackoff=/*#__PURE__*/function(){function ExponentialBackoff(/**
     * The AsyncQueue to run backoff operations on.
     */queue,/**
     * The ID to use when scheduling backoff operations on the AsyncQueue.
     */timerId){var initialDelayMs=arguments.length>2&&arguments[2]!==undefined?arguments[2]:DEFAULT_BACKOFF_INITIAL_DELAY_MS;var backoffFactor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:DEFAULT_BACKOFF_FACTOR;var maxDelayMs=arguments.length>4&&arguments[4]!==undefined?arguments[4]:DEFAULT_BACKOFF_MAX_DELAY_MS;_classCallCheck(this,ExponentialBackoff);this.queue=queue;this.timerId=timerId;this.initialDelayMs=initialDelayMs;this.backoffFactor=backoffFactor;this.maxDelayMs=maxDelayMs;this.currentBaseMs=0;this.timerPromise=null;/** The last backoff attempt, as epoch milliseconds. */this.lastAttemptTime=Date.now();this.reset();}/**
     * Resets the backoff delay.
     *
     * The very next backoffAndWait() will have no delay. If it is called again
     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
     * subsequent ones will increase according to the backoffFactor.
     */_createClass(ExponentialBackoff,[{key:"reset",value:function reset(){this.currentBaseMs=0;}/**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     */},{key:"resetToMax",value:function resetToMax(){this.currentBaseMs=this.maxDelayMs;}/**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts. If there was a pending backoff operation
     * already, it will be canceled.
     */},{key:"backoffAndRun",value:function backoffAndRun(op){var _this39=this;// Cancel any pending backoff operation.
this.cancel();// First schedule using the current base (which may be 0 and should be
// honored as such).
var desiredDelayWithJitterMs=Math.floor(this.currentBaseMs+this.jitterDelayMs());// Guard against lastAttemptTime being in the future due to a clock change.
var delaySoFarMs=Math.max(0,Date.now()-this.lastAttemptTime);// Guard against the backoff delay already being past.
var remainingDelayMs=Math.max(0,desiredDelayWithJitterMs-delaySoFarMs);if(remainingDelayMs>0){logDebug(LOG_TAG$2,"Backing off for ".concat(remainingDelayMs," ms ")+"(base delay: ".concat(this.currentBaseMs," ms, ")+"delay with jitter: ".concat(desiredDelayWithJitterMs," ms, ")+"last attempt: ".concat(delaySoFarMs," ms ago)"));}this.timerPromise=this.queue.enqueueAfterDelay(this.timerId,remainingDelayMs,function(){_this39.lastAttemptTime=Date.now();return op();});// Apply backoff factor to determine next delay and ensure it is within
// bounds.
this.currentBaseMs*=this.backoffFactor;if(this.currentBaseMs<this.initialDelayMs){this.currentBaseMs=this.initialDelayMs;}if(this.currentBaseMs>this.maxDelayMs){this.currentBaseMs=this.maxDelayMs;}}},{key:"skipBackoff",value:function skipBackoff(){if(this.timerPromise!==null){this.timerPromise.skipDelay();this.timerPromise=null;}}},{key:"cancel",value:function cancel(){if(this.timerPromise!==null){this.timerPromise.cancel();this.timerPromise=null;}}/** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */},{key:"jitterDelayMs",value:function jitterDelayMs(){return(Math.random()-0.5)*this.currentBaseMs;}}]);return ExponentialBackoff;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$3='PersistentStream';/** The time a stream stays open after it is marked idle. */var IDLE_TIMEOUT_MS=60*1000;/**
 * A PersistentStream is an abstract base class that represents a streaming RPC
 * to the Firestore backend. It's built on top of the connections own support
 * for streaming RPCs, and adds several critical features for our clients:
 *
 *   - Exponential backoff on failure
 *   - Authentication via CredentialsProvider
 *   - Dispatching all callbacks into the shared worker queue
 *   - Closing idle streams after 60 seconds of inactivity
 *
 * Subclasses of PersistentStream implement serialization of models to and
 * from the JSON representation of the protocol buffers for a specific
 * streaming RPC.
 *
 * ## Starting and Stopping
 *
 * Streaming RPCs are stateful and need to be start()ed before messages can
 * be sent and received. The PersistentStream will call the onOpen() function
 * of the listener once the stream is ready to accept requests.
 *
 * Should a start() fail, PersistentStream will call the registered onClose()
 * listener with a FirestoreError indicating what went wrong.
 *
 * A PersistentStream can be started and stopped repeatedly.
 *
 * Generic types:
 *  SendType: The type of the outgoing message of the underlying
 *    connection stream
 *  ReceiveType: The type of the incoming message of the underlying
 *    connection stream
 *  ListenerType: The type of the listener that will be used for callbacks
 */var PersistentStream=/*#__PURE__*/function(){function PersistentStream(queue,connectionTimerId,idleTimerId,connection,credentialsProvider,listener){_classCallCheck(this,PersistentStream);this.queue=queue;this.idleTimerId=idleTimerId;this.connection=connection;this.credentialsProvider=credentialsProvider;this.listener=listener;this.state=0/* Initial */;/**
         * A close count that's incremented every time the stream is closed; used by
         * getCloseGuardedDispatcher() to invalidate callbacks that happen after
         * close.
         */this.closeCount=0;this.idleTimer=null;this.stream=null;this.backoff=new ExponentialBackoff(queue,connectionTimerId);}/**
     * Returns true if start() has been called and no error has occurred. True
     * indicates the stream is open or in the process of opening (which
     * encompasses respecting backoff, getting auth tokens, and starting the
     * actual RPC). Use isOpen() to determine if the stream is open and ready for
     * outbound requests.
     */_createClass(PersistentStream,[{key:"isStarted",value:function isStarted(){return this.state===1/* Starting */||this.state===2/* Open */||this.state===4/* Backoff */;}/**
     * Returns true if the underlying RPC is open (the onOpen() listener has been
     * called) and the stream is ready for outbound requests.
     */},{key:"isOpen",value:function isOpen(){return this.state===2/* Open */;}/**
     * Starts the RPC. Only allowed if isStarted() returns false. The stream is
     * not immediately ready for use: onOpen() will be invoked when the RPC is
     * ready for outbound requests, at which point isOpen() will return true.
     *
     * When start returns, isStarted() will return true.
     */},{key:"start",value:function start(){if(this.state===3/* Error */){this.performBackoff();return;}this.auth();}/**
     * Stops the RPC. This call is idempotent and allowed regardless of the
     * current isStarted() state.
     *
     * When stop returns, isStarted() and isOpen() will both return false.
     */},{key:"stop",value:function stop(){return regeneratorRuntime.async(function stop$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:if(!this.isStarted()){_context5.next=3;break;}_context5.next=3;return regeneratorRuntime.awrap(this.close(0/* Initial */));case 3:case"end":return _context5.stop();}}},null,this);}/**
     * After an error the stream will usually back off on the next attempt to
     * start it. If the error warrants an immediate restart of the stream, the
     * sender can use this to indicate that the receiver should not back off.
     *
     * Each error will call the onClose() listener. That function can decide to
     * inhibit backoff if required.
     */},{key:"inhibitBackoff",value:function inhibitBackoff(){this.state=0/* Initial */;this.backoff.reset();}/**
     * Marks this stream as idle. If no further actions are performed on the
     * stream for one minute, the stream will automatically close itself and
     * notify the stream's onClose() handler with Status.OK. The stream will then
     * be in a !isStarted() state, requiring the caller to start the stream again
     * before further use.
     *
     * Only streams that are in state 'Open' can be marked idle, as all other
     * states imply pending network operations.
     */},{key:"markIdle",value:function markIdle(){var _this40=this;// Starts the idle time if we are in state 'Open' and are not yet already
// running a timer (in which case the previous idle timeout still applies).
if(this.isOpen()&&this.idleTimer===null){this.idleTimer=this.queue.enqueueAfterDelay(this.idleTimerId,IDLE_TIMEOUT_MS,function(){return _this40.handleIdleCloseTimer();});}}/** Sends a message to the underlying stream. */},{key:"sendRequest",value:function sendRequest(msg){this.cancelIdleCheck();this.stream.send(msg);}/** Called by the idle timer when the stream should close due to inactivity. */},{key:"handleIdleCloseTimer",value:function handleIdleCloseTimer(){return regeneratorRuntime.async(function handleIdleCloseTimer$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:if(!this.isOpen()){_context6.next=2;break;}return _context6.abrupt("return",this.close(0/* Initial */));case 2:case"end":return _context6.stop();}}},null,this);}/** Marks the stream as active again. */},{key:"cancelIdleCheck",value:function cancelIdleCheck(){if(this.idleTimer){this.idleTimer.cancel();this.idleTimer=null;}}/**
     * Closes the stream and cleans up as necessary:
     *
     * * closes the underlying GRPC stream;
     * * calls the onClose handler with the given 'error';
     * * sets internal stream state to 'finalState';
     * * adjusts the backoff timer based on the error
     *
     * A new stream can be opened by calling start().
     *
     * @param finalState the intended state of the stream after closing.
     * @param error the error the connection was closed with.
     */},{key:"close",value:function close(finalState,error){return regeneratorRuntime.async(function close$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:// Cancel any outstanding timers (they're guaranteed not to execute).
this.cancelIdleCheck();this.backoff.cancel();// Invalidates any stream-related callbacks (e.g. from auth or the
// underlying stream), guaranteeing they won't execute.
this.closeCount++;if(finalState!==3/* Error */){// If this is an intentional close ensure we don't delay our next connection attempt.
this.backoff.reset();}else if(error&&error.code===Code.RESOURCE_EXHAUSTED){// Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)
logError(error.toString());logError('Using maximum backoff delay to prevent overloading the backend.');this.backoff.resetToMax();}else if(error&&error.code===Code.UNAUTHENTICATED){// "unauthenticated" error means the token was rejected. Try force refreshing it in case it
// just expired.
this.credentialsProvider.invalidateToken();}// Clean up the underlying stream because we are no longer interested in events.
if(this.stream!==null){this.tearDown();this.stream.close();this.stream=null;}// This state must be assigned before calling onClose() to allow the callback to
// inhibit backoff or otherwise manipulate the state in its non-started state.
this.state=finalState;// Notify the listener that the stream closed.
_context7.next=8;return regeneratorRuntime.awrap(this.listener.onClose(error));case 8:case"end":return _context7.stop();}}},null,this);}/**
     * Can be overridden to perform additional cleanup before the stream is closed.
     * Calling super.tearDown() is not required.
     */},{key:"tearDown",value:function tearDown(){}},{key:"auth",value:function auth(){var _this41=this;this.state=1/* Starting */;var dispatchIfNotClosed=this.getCloseGuardedDispatcher(this.closeCount);// TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.
var closeCount=this.closeCount;this.credentialsProvider.getToken().then(function(token){// Stream can be stopped while waiting for authentication.
// TODO(mikelehen): We really should just use dispatchIfNotClosed
// and let this dispatch onto the queue, but that opened a spec test can
// of worms that I don't want to deal with in this PR.
if(_this41.closeCount===closeCount){// Normally we'd have to schedule the callback on the AsyncQueue.
// However, the following calls are safe to be called outside the
// AsyncQueue since they don't chain asynchronous calls
_this41.startStream(token);}},function(error){dispatchIfNotClosed(function(){var rpcError=new FirestoreError(Code.UNKNOWN,'Fetching auth token failed: '+error.message);return _this41.handleStreamClose(rpcError);});});}},{key:"startStream",value:function startStream(token){var _this42=this;var dispatchIfNotClosed=this.getCloseGuardedDispatcher(this.closeCount);this.stream=this.startRpc(token);this.stream.onOpen(function(){dispatchIfNotClosed(function(){_this42.state=2/* Open */;return _this42.listener.onOpen();});});this.stream.onClose(function(error){dispatchIfNotClosed(function(){return _this42.handleStreamClose(error);});});this.stream.onMessage(function(msg){dispatchIfNotClosed(function(){return _this42.onMessage(msg);});});}},{key:"performBackoff",value:function performBackoff(){var _this43=this;this.state=4/* Backoff */;this.backoff.backoffAndRun(function _callee(){return regeneratorRuntime.async(function _callee$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:_this43.state=0/* Initial */;_this43.start();case 2:case"end":return _context8.stop();}}});});}// Visible for tests
},{key:"handleStreamClose",value:function handleStreamClose(error){logDebug(LOG_TAG$3,"close with error: ".concat(error));this.stream=null;// In theory the stream could close cleanly, however, in our current model
// we never expect this to happen because if we stop a stream ourselves,
// this callback will never be called. To prevent cases where we retry
// without a backoff accidentally, we set the stream to error in all cases.
return this.close(3/* Error */,error);}/**
     * Returns a "dispatcher" function that dispatches operations onto the
     * AsyncQueue but only runs them if closeCount remains unchanged. This allows
     * us to turn auth / stream callbacks into no-ops if the stream is closed /
     * re-opened, etc.
     */},{key:"getCloseGuardedDispatcher",value:function getCloseGuardedDispatcher(startCloseCount){var _this44=this;return function(fn){_this44.queue.enqueueAndForget(function(){if(_this44.closeCount===startCloseCount){return fn();}else{logDebug(LOG_TAG$3,'stream callback skipped by getCloseGuardedDispatcher.');return Promise.resolve();}});};}}]);return PersistentStream;}();/**
 * A PersistentStream that implements the Listen RPC.
 *
 * Once the Listen stream has called the onOpen() listener, any number of
 * listen() and unlisten() calls can be made to control what changes will be
 * sent from the server for ListenResponses.
 */var PersistentListenStream=/*#__PURE__*/function(_PersistentStream){_inherits(PersistentListenStream,_PersistentStream);function PersistentListenStream(queue,connection,credentials,serializer,listener){var _this45;_classCallCheck(this,PersistentListenStream);_this45=_possibleConstructorReturn(this,_getPrototypeOf(PersistentListenStream).call(this,queue,"listen_stream_connection_backoff"/* ListenStreamConnectionBackoff */,"listen_stream_idle"/* ListenStreamIdle */,connection,credentials,listener));_this45.serializer=serializer;return _this45;}_createClass(PersistentListenStream,[{key:"startRpc",value:function startRpc(token){return this.connection.openStream('Listen',token);}},{key:"onMessage",value:function onMessage(watchChangeProto){// A successful response means the stream is healthy
this.backoff.reset();var watchChange=fromWatchChange(this.serializer,watchChangeProto);var snapshot=versionFromListenResponse(watchChangeProto);return this.listener.onWatchChange(watchChange,snapshot);}/**
     * Registers interest in the results of the given target. If the target
     * includes a resumeToken it will be included in the request. Results that
     * affect the target will be streamed back as WatchChange messages that
     * reference the targetId.
     */},{key:"watch",value:function watch(targetData){var request={};request.database=getEncodedDatabaseId(this.serializer);request.addTarget=toTarget(this.serializer,targetData);var labels=toListenRequestLabels(this.serializer,targetData);if(labels){request.labels=labels;}this.sendRequest(request);}/**
     * Unregisters interest in the results of the target associated with the
     * given targetId.
     */},{key:"unwatch",value:function unwatch(targetId){var request={};request.database=getEncodedDatabaseId(this.serializer);request.removeTarget=targetId;this.sendRequest(request);}}]);return PersistentListenStream;}(PersistentStream);/**
 * A Stream that implements the Write RPC.
 *
 * The Write RPC requires the caller to maintain special streamToken
 * state in between calls, to help the server understand which responses the
 * client has processed by the time the next request is made. Every response
 * will contain a streamToken; this value must be passed to the next
 * request.
 *
 * After calling start() on this stream, the next request must be a handshake,
 * containing whatever streamToken is on hand. Once a response to this
 * request is received, all pending mutations may be submitted. When
 * submitting multiple batches of mutations at the same time, it's
 * okay to use the same streamToken for the calls to writeMutations.
 *
 * TODO(b/33271235): Use proto types
 */var PersistentWriteStream=/*#__PURE__*/function(_PersistentStream2){_inherits(PersistentWriteStream,_PersistentStream2);function PersistentWriteStream(queue,connection,credentials,serializer,listener){var _this46;_classCallCheck(this,PersistentWriteStream);_this46=_possibleConstructorReturn(this,_getPrototypeOf(PersistentWriteStream).call(this,queue,"write_stream_connection_backoff"/* WriteStreamConnectionBackoff */,"write_stream_idle"/* WriteStreamIdle */,connection,credentials,listener));_this46.serializer=serializer;_this46.handshakeComplete_=false;return _this46;}/**
     * Tracks whether or not a handshake has been successfully exchanged and
     * the stream is ready to accept mutations.
     */_createClass(PersistentWriteStream,[{key:"start",// Override of PersistentStream.start
value:function start(){this.handshakeComplete_=false;this.lastStreamToken=undefined;_get(_getPrototypeOf(PersistentWriteStream.prototype),"start",this).call(this);}},{key:"tearDown",value:function tearDown(){if(this.handshakeComplete_){this.writeMutations([]);}}},{key:"startRpc",value:function startRpc(token){return this.connection.openStream('Write',token);}},{key:"onMessage",value:function onMessage(responseProto){// Always capture the last stream token.
hardAssert(!!responseProto.streamToken);this.lastStreamToken=responseProto.streamToken;if(!this.handshakeComplete_){// The first response is always the handshake response
hardAssert(!responseProto.writeResults||responseProto.writeResults.length===0);this.handshakeComplete_=true;return this.listener.onHandshakeComplete();}else{// A successful first write response means the stream is healthy,
// Note, that we could consider a successful handshake healthy, however,
// the write itself might be causing an error we want to back off from.
this.backoff.reset();var results=fromWriteResults(responseProto.writeResults,responseProto.commitTime);var commitVersion=fromVersion(responseProto.commitTime);return this.listener.onMutationResult(commitVersion,results);}}/**
     * Sends an initial streamToken to the server, performing the handshake
     * required to make the StreamingWrite RPC work. Subsequent
     * calls should wait until onHandshakeComplete was called.
     */},{key:"writeHandshake",value:function writeHandshake(){// TODO(dimond): Support stream resumption. We intentionally do not set the
// stream token on the handshake, ignoring any stream token we might have.
var request={};request.database=getEncodedDatabaseId(this.serializer);this.sendRequest(request);}/** Sends a group of mutations to the Firestore backend to apply. */},{key:"writeMutations",value:function writeMutations(mutations){var _this47=this;var request={streamToken:this.lastStreamToken,writes:mutations.map(function(mutation){return toMutation(_this47.serializer,mutation);})};this.sendRequest(request);}},{key:"handshakeComplete",get:function get(){return this.handshakeComplete_;}}]);return PersistentWriteStream;}(PersistentStream);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Datastore and its related methods are a wrapper around the external Google
 * Cloud Datastore grpc API, which provides an interface that is more convenient
 * for the rest of the client SDK architecture to consume.
 */var Datastore=function Datastore(){_classCallCheck(this,Datastore);};/**
 * An implementation of Datastore that exposes additional state for internal
 * consumption.
 */var DatastoreImpl=/*#__PURE__*/function(_Datastore){_inherits(DatastoreImpl,_Datastore);function DatastoreImpl(credentials,connection,serializer){var _this48;_classCallCheck(this,DatastoreImpl);_this48=_possibleConstructorReturn(this,_getPrototypeOf(DatastoreImpl).call(this));_this48.credentials=credentials;_this48.connection=connection;_this48.serializer=serializer;_this48.terminated=false;return _this48;}_createClass(DatastoreImpl,[{key:"verifyInitialized",value:function verifyInitialized(){if(this.terminated){throw new FirestoreError(Code.FAILED_PRECONDITION,'The client has already been terminated.');}}/** Gets an auth token and invokes the provided RPC. */},{key:"invokeRPC",value:function invokeRPC(rpcName,path,request){var _this49=this;this.verifyInitialized();return this.credentials.getToken().then(function(token){return _this49.connection.invokeRPC(rpcName,path,request,token);})["catch"](function(error){if(error.code===Code.UNAUTHENTICATED){_this49.credentials.invalidateToken();}throw error;});}/** Gets an auth token and invokes the provided RPC with streamed results. */},{key:"invokeStreamingRPC",value:function invokeStreamingRPC(rpcName,path,request){var _this50=this;this.verifyInitialized();return this.credentials.getToken().then(function(token){return _this50.connection.invokeStreamingRPC(rpcName,path,request,token);})["catch"](function(error){if(error.code===Code.UNAUTHENTICATED){_this50.credentials.invalidateToken();}throw error;});}},{key:"terminate",value:function terminate(){this.terminated=false;}}]);return DatastoreImpl;}(Datastore);// TODO(firestorexp): Make sure there is only one Datastore instance per
// firestore-exp client.
function newDatastore(credentials,connection,serializer){return new DatastoreImpl(credentials,connection,serializer);}function invokeCommitRpc(datastore,mutations){var datastoreImpl,path,request;return regeneratorRuntime.async(function invokeCommitRpc$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:datastoreImpl=debugCast(datastore);path=getEncodedDatabaseId(datastoreImpl.serializer)+'/documents';request={writes:mutations.map(function(m){return toMutation(datastoreImpl.serializer,m);})};_context9.next=5;return regeneratorRuntime.awrap(datastoreImpl.invokeRPC('Commit',path,request));case 5:case"end":return _context9.stop();}}});}function invokeBatchGetDocumentsRpc(datastore,keys){var datastoreImpl,path,request,response,docs,result;return regeneratorRuntime.async(function invokeBatchGetDocumentsRpc$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:datastoreImpl=debugCast(datastore);path=getEncodedDatabaseId(datastoreImpl.serializer)+'/documents';request={documents:keys.map(function(k){return toName(datastoreImpl.serializer,k);})};_context10.next=5;return regeneratorRuntime.awrap(datastoreImpl.invokeStreamingRPC('BatchGetDocuments',path,request));case 5:response=_context10.sent;docs=new Map();response.forEach(function(proto){var doc=fromMaybeDocument(datastoreImpl.serializer,proto);docs.set(doc.key.toString(),doc);});result=[];keys.forEach(function(key){var doc=docs.get(key.toString());hardAssert(!!doc);result.push(doc);});return _context10.abrupt("return",result);case 11:case"end":return _context10.stop();}}});}function newPersistentWriteStream(datastore,queue,listener){var datastoreImpl=debugCast(datastore);datastoreImpl.verifyInitialized();return new PersistentWriteStream(queue,datastoreImpl.connection,datastoreImpl.credentials,datastoreImpl.serializer,listener);}function newPersistentWatchStream(datastore,queue,listener){var datastoreImpl=debugCast(datastore);datastoreImpl.verifyInitialized();return new PersistentListenStream(queue,datastoreImpl.connection,datastoreImpl.credentials,datastoreImpl.serializer,listener);}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$4='OnlineStateTracker';// To deal with transient failures, we allow multiple stream attempts before
// giving up and transitioning from OnlineState.Unknown to Offline.
// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.
// @jdimond thinks that bug is sufficiently fixed so that we can set this back
// to 1. If that works okay, we could potentially remove this logic entirely.
var MAX_WATCH_STREAM_FAILURES=1;// To deal with stream attempts that don't succeed or fail in a timely manner,
// we have a timeout for OnlineState to reach Online or Offline.
// If the timeout is reached, we transition to Offline rather than waiting
// indefinitely.
var ONLINE_STATE_TIMEOUT_MS=10*1000;/**
 * A component used by the RemoteStore to track the OnlineState (that is,
 * whether or not the client as a whole should be considered to be online or
 * offline), implementing the appropriate heuristics.
 *
 * In particular, when the client is trying to connect to the backend, we
 * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for
 * a connection to succeed. If we have too many failures or the timeout elapses,
 * then we set the OnlineState to Offline, and the client will behave as if
 * it is offline (get()s will return cached data, etc.).
 */var OnlineStateTracker=/*#__PURE__*/function(){function OnlineStateTracker(asyncQueue,onlineStateHandler){_classCallCheck(this,OnlineStateTracker);this.asyncQueue=asyncQueue;this.onlineStateHandler=onlineStateHandler;/** The current OnlineState. */this.state="Unknown"/* Unknown */;/**
         * A count of consecutive failures to open the stream. If it reaches the
         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to
         * Offline.
         */this.watchStreamFailures=0;/**
         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we
         * transition from OnlineState.Unknown to OnlineState.Offline without waiting
         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).
         */this.onlineStateTimer=null;/**
         * Whether the client should log a warning message if it fails to connect to
         * the backend (initially true, cleared after a successful stream, or if we've
         * logged the message already).
         */this.shouldWarnClientIsOffline=true;}/**
     * Called by RemoteStore when a watch stream is started (including on each
     * backoff attempt).
     *
     * If this is the first attempt, it sets the OnlineState to Unknown and starts
     * the onlineStateTimer.
     */_createClass(OnlineStateTracker,[{key:"handleWatchStreamStart",value:function handleWatchStreamStart(){var _this51=this;if(this.watchStreamFailures===0){this.setAndBroadcast("Unknown"/* Unknown */);this.onlineStateTimer=this.asyncQueue.enqueueAfterDelay("online_state_timeout"/* OnlineStateTimeout */,ONLINE_STATE_TIMEOUT_MS,function(){_this51.onlineStateTimer=null;_this51.logClientOfflineWarningIfNecessary("Backend didn't respond within ".concat(ONLINE_STATE_TIMEOUT_MS/1000," ")+"seconds.");_this51.setAndBroadcast("Offline"/* Offline */);// NOTE: handleWatchStreamFailure() will continue to increment
// watchStreamFailures even though we are already marked Offline,
// but this is non-harmful.
return Promise.resolve();});}}/**
     * Updates our OnlineState as appropriate after the watch stream reports a
     * failure. The first failure moves us to the 'Unknown' state. We then may
     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we
     * actually transition to the 'Offline' state.
     */},{key:"handleWatchStreamFailure",value:function handleWatchStreamFailure(error){if(this.state==="Online"/* Online */){this.setAndBroadcast("Unknown"/* Unknown */);}else{this.watchStreamFailures++;if(this.watchStreamFailures>=MAX_WATCH_STREAM_FAILURES){this.clearOnlineStateTimer();this.logClientOfflineWarningIfNecessary("Connection failed ".concat(MAX_WATCH_STREAM_FAILURES," ")+"times. Most recent error: ".concat(error.toString()));this.setAndBroadcast("Offline"/* Offline */);}}}/**
     * Explicitly sets the OnlineState to the specified state.
     *
     * Note that this resets our timers / failure counters, etc. used by our
     * Offline heuristics, so must not be used in place of
     * handleWatchStreamStart() and handleWatchStreamFailure().
     */},{key:"set",value:function set(newState){this.clearOnlineStateTimer();this.watchStreamFailures=0;if(newState==="Online"/* Online */){// We've connected to watch at least once. Don't warn the developer
// about being offline going forward.
this.shouldWarnClientIsOffline=false;}this.setAndBroadcast(newState);}},{key:"setAndBroadcast",value:function setAndBroadcast(newState){if(newState!==this.state){this.state=newState;this.onlineStateHandler(newState);}}},{key:"logClientOfflineWarningIfNecessary",value:function logClientOfflineWarningIfNecessary(details){var message="Could not reach Cloud Firestore backend. ".concat(details,"\n")+"This typically indicates that your device does not have a healthy "+"Internet connection at the moment. The client will operate in offline "+"mode until it is able to successfully connect to the backend.";if(this.shouldWarnClientIsOffline){logError(message);this.shouldWarnClientIsOffline=false;}else{logDebug(LOG_TAG$4,message);}}},{key:"clearOnlineStateTimer",value:function clearOnlineStateTimer(){if(this.onlineStateTimer!==null){this.onlineStateTimer.cancel();this.onlineStateTimer=null;}}}]);return OnlineStateTracker;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$5='RemoteStore';// TODO(b/35853402): Negotiate this with the stream.
var MAX_PENDING_WRITES=10;var RemoteStoreImpl=function RemoteStoreImpl(/**
     * The local store, used to fill the write pipeline with outbound mutations.
     */localStore,/** The client-side proxy for interacting with the backend. */datastore,asyncQueue,onlineStateHandler,connectivityMonitor){var _this52=this;_classCallCheck(this,RemoteStoreImpl);this.localStore=localStore;this.datastore=datastore;this.asyncQueue=asyncQueue;this.remoteSyncer={};/**
         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the
         * LocalStore via fillWritePipeline() and have or will send to the write
         * stream.
         *
         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or
         * restart the write stream. When the stream is established the writes in the
         * pipeline will be sent in order.
         *
         * Writes remain in writePipeline until they are acknowledged by the backend
         * and thus will automatically be re-sent if the stream is interrupted /
         * restarted before they're acknowledged.
         *
         * Write responses from the backend are linked to their originating request
         * purely based on order, and so we can just shift() writes from the front of
         * the writePipeline as we receive responses.
         */this.writePipeline=[];/**
         * A mapping of watched targets that the client cares about tracking and the
         * user has explicitly called a 'listen' for this target.
         *
         * These targets may or may not have been sent to or acknowledged by the
         * server. On re-establishing the listen stream, these targets should be sent
         * to the server. The targets removed with unlistens are removed eagerly
         * without waiting for confirmation from the listen stream.
         */this.listenTargets=new Map();/**
         * A set of reasons for why the RemoteStore may be offline. If empty, the
         * RemoteStore may start its network connections.
         */this.offlineCauses=new Set();/**
         * Event handlers that get called when the network is disabled or enabled.
         *
         * PORTING NOTE: These functions are used on the Web client to create the
         * underlying streams (to support tree-shakeable streams). On Android and iOS,
         * the streams are created during construction of RemoteStore.
         */this.onNetworkStatusChange=[];this.connectivityMonitor=connectivityMonitor;this.connectivityMonitor.addCallback(function(_){asyncQueue.enqueueAndForget(function _callee2(){return regeneratorRuntime.async(function _callee2$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:if(!canUseNetwork(_this52)){_context11.next=4;break;}logDebug(LOG_TAG$5,'Restarting streams for network reachability change.');_context11.next=4;return regeneratorRuntime.awrap(restartNetwork(_this52));case 4:case"end":return _context11.stop();}}});});});this.onlineStateTracker=new OnlineStateTracker(asyncQueue,onlineStateHandler);};function newRemoteStore(localStore,datastore,asyncQueue,onlineStateHandler,connectivityMonitor){return new RemoteStoreImpl(localStore,datastore,asyncQueue,onlineStateHandler,connectivityMonitor);}/** Re-enables the network. Idempotent. */function remoteStoreEnableNetwork(remoteStore){var remoteStoreImpl=debugCast(remoteStore);remoteStoreImpl.offlineCauses["delete"](0/* UserDisabled */);return enableNetworkInternal(remoteStoreImpl);}function enableNetworkInternal(remoteStoreImpl){var _iteratorNormalCompletion37,_didIteratorError37,_iteratorError37,_iterator37,_step37,networkStatusHandler;return regeneratorRuntime.async(function enableNetworkInternal$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:if(!canUseNetwork(remoteStoreImpl)){_context12.next=27;break;}_iteratorNormalCompletion37=true;_didIteratorError37=false;_iteratorError37=undefined;_context12.prev=4;_iterator37=remoteStoreImpl.onNetworkStatusChange[Symbol.iterator]();case 6:if(_iteratorNormalCompletion37=(_step37=_iterator37.next()).done){_context12.next=13;break;}networkStatusHandler=_step37.value;_context12.next=10;return regeneratorRuntime.awrap(networkStatusHandler(/* enabled= */true));case 10:_iteratorNormalCompletion37=true;_context12.next=6;break;case 13:_context12.next=19;break;case 15:_context12.prev=15;_context12.t0=_context12["catch"](4);_didIteratorError37=true;_iteratorError37=_context12.t0;case 19:_context12.prev=19;_context12.prev=20;if(!_iteratorNormalCompletion37&&_iterator37["return"]!=null){_iterator37["return"]();}case 22:_context12.prev=22;if(!_didIteratorError37){_context12.next=25;break;}throw _iteratorError37;case 25:return _context12.finish(22);case 26:return _context12.finish(19);case 27:case"end":return _context12.stop();}}},null,null,[[4,15,19,27],[20,,22,26]]);}/**
 * Temporarily disables the network. The network can be re-enabled using
 * enableNetwork().
 */function remoteStoreDisableNetwork(remoteStore){var remoteStoreImpl;return regeneratorRuntime.async(function remoteStoreDisableNetwork$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:remoteStoreImpl=debugCast(remoteStore);remoteStoreImpl.offlineCauses.add(0/* UserDisabled */);_context13.next=4;return regeneratorRuntime.awrap(disableNetworkInternal(remoteStoreImpl));case 4:// Set the OnlineState to Offline so get()s return from cache, etc.
remoteStoreImpl.onlineStateTracker.set("Offline"/* Offline */);case 5:case"end":return _context13.stop();}}});}function disableNetworkInternal(remoteStoreImpl){var _iteratorNormalCompletion38,_didIteratorError38,_iteratorError38,_iterator38,_step38,networkStatusHandler;return regeneratorRuntime.async(function disableNetworkInternal$(_context14){while(1){switch(_context14.prev=_context14.next){case 0:_iteratorNormalCompletion38=true;_didIteratorError38=false;_iteratorError38=undefined;_context14.prev=3;_iterator38=remoteStoreImpl.onNetworkStatusChange[Symbol.iterator]();case 5:if(_iteratorNormalCompletion38=(_step38=_iterator38.next()).done){_context14.next=12;break;}networkStatusHandler=_step38.value;_context14.next=9;return regeneratorRuntime.awrap(networkStatusHandler(/* enabled= */false));case 9:_iteratorNormalCompletion38=true;_context14.next=5;break;case 12:_context14.next=18;break;case 14:_context14.prev=14;_context14.t0=_context14["catch"](3);_didIteratorError38=true;_iteratorError38=_context14.t0;case 18:_context14.prev=18;_context14.prev=19;if(!_iteratorNormalCompletion38&&_iterator38["return"]!=null){_iterator38["return"]();}case 21:_context14.prev=21;if(!_didIteratorError38){_context14.next=24;break;}throw _iteratorError38;case 24:return _context14.finish(21);case 25:return _context14.finish(18);case 26:case"end":return _context14.stop();}}},null,null,[[3,14,18,26],[19,,21,25]]);}function remoteStoreShutdown(remoteStore){var remoteStoreImpl;return regeneratorRuntime.async(function remoteStoreShutdown$(_context15){while(1){switch(_context15.prev=_context15.next){case 0:remoteStoreImpl=debugCast(remoteStore);logDebug(LOG_TAG$5,'RemoteStore shutting down.');remoteStoreImpl.offlineCauses.add(5/* Shutdown */);_context15.next=5;return regeneratorRuntime.awrap(disableNetworkInternal(remoteStoreImpl));case 5:remoteStoreImpl.connectivityMonitor.shutdown();// Set the OnlineState to Unknown (rather than Offline) to avoid potentially
// triggering spurious listener events with cached data, etc.
remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);case 7:case"end":return _context15.stop();}}});}/**
 * Starts new listen for the given target. Uses resume token if provided. It
 * is a no-op if the target of given `TargetData` is already being listened to.
 */function remoteStoreListen(remoteStore,targetData){var remoteStoreImpl=debugCast(remoteStore);if(remoteStoreImpl.listenTargets.has(targetData.targetId)){return;}// Mark this as something the client is currently listening for.
remoteStoreImpl.listenTargets.set(targetData.targetId,targetData);if(shouldStartWatchStream(remoteStoreImpl)){// The listen will be sent in onWatchStreamOpen
startWatchStream(remoteStoreImpl);}else if(ensureWatchStream(remoteStoreImpl).isOpen()){sendWatchRequest(remoteStoreImpl,targetData);}}/**
 * Removes the listen from server. It is a no-op if the given target id is
 * not being listened to.
 */function remoteStoreUnlisten(remoteStore,targetId){var remoteStoreImpl=debugCast(remoteStore);var watchStream=ensureWatchStream(remoteStoreImpl);remoteStoreImpl.listenTargets["delete"](targetId);if(watchStream.isOpen()){sendUnwatchRequest(remoteStoreImpl,targetId);}if(remoteStoreImpl.listenTargets.size===0){if(watchStream.isOpen()){watchStream.markIdle();}else if(canUseNetwork(remoteStoreImpl)){// Revert to OnlineState.Unknown if the watch stream is not open and we
// have no listeners, since without any listens to send we cannot
// confirm if the stream is healthy and upgrade to OnlineState.Online.
remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);}}}/**
 * We need to increment the the expected number of pending responses we're due
 * from watch so we wait for the ack to process any messages from this target.
 */function sendWatchRequest(remoteStoreImpl,targetData){remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);ensureWatchStream(remoteStoreImpl).watch(targetData);}/**
 * We need to increment the expected number of pending responses we're due
 * from watch so we wait for the removal on the server before we process any
 * messages from this target.
 */function sendUnwatchRequest(remoteStoreImpl,targetId){remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);ensureWatchStream(remoteStoreImpl).unwatch(targetId);}function startWatchStream(remoteStoreImpl){remoteStoreImpl.watchChangeAggregator=new WatchChangeAggregator({getRemoteKeysForTarget:function getRemoteKeysForTarget(targetId){return remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId);},getTargetDataForTarget:function getTargetDataForTarget(targetId){return remoteStoreImpl.listenTargets.get(targetId)||null;}});ensureWatchStream(remoteStoreImpl).start();remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();}/**
 * Returns whether the watch stream should be started because it's necessary
 * and has not yet been started.
 */function shouldStartWatchStream(remoteStoreImpl){return canUseNetwork(remoteStoreImpl)&&!ensureWatchStream(remoteStoreImpl).isStarted()&&remoteStoreImpl.listenTargets.size>0;}function canUseNetwork(remoteStore){var remoteStoreImpl=debugCast(remoteStore);return remoteStoreImpl.offlineCauses.size===0;}function cleanUpWatchStreamState(remoteStoreImpl){remoteStoreImpl.watchChangeAggregator=undefined;}function onWatchStreamOpen(remoteStoreImpl){return regeneratorRuntime.async(function onWatchStreamOpen$(_context16){while(1){switch(_context16.prev=_context16.next){case 0:remoteStoreImpl.listenTargets.forEach(function(targetData,targetId){sendWatchRequest(remoteStoreImpl,targetData);});case 1:case"end":return _context16.stop();}}});}function onWatchStreamClose(remoteStoreImpl,error){return regeneratorRuntime.async(function onWatchStreamClose$(_context17){while(1){switch(_context17.prev=_context17.next){case 0:cleanUpWatchStreamState(remoteStoreImpl);// If we still need the watch stream, retry the connection.
if(shouldStartWatchStream(remoteStoreImpl)){remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);startWatchStream(remoteStoreImpl);}else{// No need to restart watch stream because there are no active targets.
// The online state is set to unknown because there is no active attempt
// at establishing a connection
remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);}case 2:case"end":return _context17.stop();}}});}function onWatchStreamChange(remoteStoreImpl,watchChange,snapshotVersion){var lastRemoteSnapshotVersion;return regeneratorRuntime.async(function onWatchStreamChange$(_context18){while(1){switch(_context18.prev=_context18.next){case 0:// Mark the client as online since we got a message from the server
remoteStoreImpl.onlineStateTracker.set("Online"/* Online */);if(!(watchChange instanceof WatchTargetChange&&watchChange.state===2/* Removed */&&watchChange.cause)){_context18.next=13;break;}_context18.prev=2;_context18.next=5;return regeneratorRuntime.awrap(handleTargetError(remoteStoreImpl,watchChange));case 5:_context18.next=12;break;case 7:_context18.prev=7;_context18.t0=_context18["catch"](2);logDebug(LOG_TAG$5,'Failed to remove targets %s: %s ',watchChange.targetIds.join(','),_context18.t0);_context18.next=12;return regeneratorRuntime.awrap(disableNetworkUntilRecovery(remoteStoreImpl,_context18.t0));case 12:return _context18.abrupt("return");case 13:if(watchChange instanceof DocumentWatchChange){remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);}else if(watchChange instanceof ExistenceFilterChange){remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);}else{remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);}if(snapshotVersion.isEqual(SnapshotVersion.min())){_context18.next=29;break;}_context18.prev=15;_context18.next=18;return regeneratorRuntime.awrap(getLastRemoteSnapshotVersion(remoteStoreImpl.localStore));case 18:lastRemoteSnapshotVersion=_context18.sent;if(!(snapshotVersion.compareTo(lastRemoteSnapshotVersion)>=0)){_context18.next=22;break;}_context18.next=22;return regeneratorRuntime.awrap(raiseWatchSnapshot(remoteStoreImpl,snapshotVersion));case 22:_context18.next=29;break;case 24:_context18.prev=24;_context18.t1=_context18["catch"](15);logDebug(LOG_TAG$5,'Failed to raise snapshot:',_context18.t1);_context18.next=29;return regeneratorRuntime.awrap(disableNetworkUntilRecovery(remoteStoreImpl,_context18.t1));case 29:case"end":return _context18.stop();}}},null,null,[[2,7],[15,24]]);}/**
 * Recovery logic for IndexedDB errors that takes the network offline until
 * `op` succeeds. Retries are scheduled with backoff using
 * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is
 * validated via a generic operation.
 *
 * The returned Promise is resolved once the network is disabled and before
 * any retry attempt.
 */function disableNetworkUntilRecovery(remoteStoreImpl,e,op){return regeneratorRuntime.async(function disableNetworkUntilRecovery$(_context20){while(1){switch(_context20.prev=_context20.next){case 0:if(!isIndexedDbTransactionError(e)){_context20.next=9;break;}remoteStoreImpl.offlineCauses.add(1/* IndexedDbFailed */);// Disable network and raise offline snapshots
_context20.next=4;return regeneratorRuntime.awrap(disableNetworkInternal(remoteStoreImpl));case 4:remoteStoreImpl.onlineStateTracker.set("Offline"/* Offline */);if(!op){// Use a simple read operation to determine if IndexedDB recovered.
// Ideally, we would expose a health check directly on SimpleDb, but
// RemoteStore only has access to persistence through LocalStore.
op=function op(){return getLastRemoteSnapshotVersion(remoteStoreImpl.localStore);};}// Probe IndexedDB periodically and re-enable network
remoteStoreImpl.asyncQueue.enqueueRetryable(function _callee3(){return regeneratorRuntime.async(function _callee3$(_context19){while(1){switch(_context19.prev=_context19.next){case 0:logDebug(LOG_TAG$5,'Retrying IndexedDB access');_context19.next=3;return regeneratorRuntime.awrap(op());case 3:remoteStoreImpl.offlineCauses["delete"](1/* IndexedDbFailed */);_context19.next=6;return regeneratorRuntime.awrap(enableNetworkInternal(remoteStoreImpl));case 6:case"end":return _context19.stop();}}});});_context20.next=10;break;case 9:throw e;case 10:case"end":return _context20.stop();}}});}/**
 * Executes `op`. If `op` fails, takes the network offline until `op`
 * succeeds. Returns after the first attempt.
 */function executeWithRecovery(remoteStoreImpl,op){return op()["catch"](function(e){return disableNetworkUntilRecovery(remoteStoreImpl,e,op);});}/**
 * Takes a batch of changes from the Datastore, repackages them as a
 * RemoteEvent, and passes that on to the listener, which is typically the
 * SyncEngine.
 */function raiseWatchSnapshot(remoteStoreImpl,snapshotVersion){var remoteEvent=remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);// Update in-memory resume tokens. LocalStore will update the
// persistent view of these when applying the completed RemoteEvent.
remoteEvent.targetChanges.forEach(function(change,targetId){if(change.resumeToken.approximateByteSize()>0){var targetData=remoteStoreImpl.listenTargets.get(targetId);// A watched target might have been removed already.
if(targetData){remoteStoreImpl.listenTargets.set(targetId,targetData.withResumeToken(change.resumeToken,snapshotVersion));}}});// Re-establish listens for the targets that have been invalidated by
// existence filter mismatches.
remoteEvent.targetMismatches.forEach(function(targetId){var targetData=remoteStoreImpl.listenTargets.get(targetId);if(!targetData){// A watched target might have been removed already.
return;}// Clear the resume token for the target, since we're in a known mismatch
// state.
remoteStoreImpl.listenTargets.set(targetId,targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING,targetData.snapshotVersion));// Cause a hard reset by unwatching and rewatching immediately, but
// deliberately don't send a resume token so that we get a full update.
sendUnwatchRequest(remoteStoreImpl,targetId);// Mark the target we send as being on behalf of an existence filter
// mismatch, but don't actually retain that in listenTargets. This ensures
// that we flag the first re-listen this way without impacting future
// listens of this target (that might happen e.g. on reconnect).
var requestTargetData=new TargetData(targetData.target,targetId,1/* ExistenceFilterMismatch */,targetData.sequenceNumber);sendWatchRequest(remoteStoreImpl,requestTargetData);});return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);}/** Handles an error on a target */function handleTargetError(remoteStoreImpl,watchChange){var error,_iteratorNormalCompletion39,_didIteratorError39,_iteratorError39,_iterator39,_step39,targetId;return regeneratorRuntime.async(function handleTargetError$(_context21){while(1){switch(_context21.prev=_context21.next){case 0:error=watchChange.cause;_iteratorNormalCompletion39=true;_didIteratorError39=false;_iteratorError39=undefined;_context21.prev=4;_iterator39=watchChange.targetIds[Symbol.iterator]();case 6:if(_iteratorNormalCompletion39=(_step39=_iterator39.next()).done){_context21.next=16;break;}targetId=_step39.value;if(!remoteStoreImpl.listenTargets.has(targetId)){_context21.next=13;break;}_context21.next=11;return regeneratorRuntime.awrap(remoteStoreImpl.remoteSyncer.rejectListen(targetId,error));case 11:remoteStoreImpl.listenTargets["delete"](targetId);remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);case 13:_iteratorNormalCompletion39=true;_context21.next=6;break;case 16:_context21.next=22;break;case 18:_context21.prev=18;_context21.t0=_context21["catch"](4);_didIteratorError39=true;_iteratorError39=_context21.t0;case 22:_context21.prev=22;_context21.prev=23;if(!_iteratorNormalCompletion39&&_iterator39["return"]!=null){_iterator39["return"]();}case 25:_context21.prev=25;if(!_didIteratorError39){_context21.next=28;break;}throw _iteratorError39;case 28:return _context21.finish(25);case 29:return _context21.finish(22);case 30:case"end":return _context21.stop();}}},null,null,[[4,18,22,30],[23,,25,29]]);}/**
 * Attempts to fill our write pipeline with writes from the LocalStore.
 *
 * Called internally to bootstrap or refill the write pipeline and by
 * SyncEngine whenever there are new mutations to process.
 *
 * Starts the write stream if necessary.
 */function fillWritePipeline(remoteStore){var remoteStoreImpl,writeStream,lastBatchIdRetrieved,batch;return regeneratorRuntime.async(function fillWritePipeline$(_context22){while(1){switch(_context22.prev=_context22.next){case 0:remoteStoreImpl=debugCast(remoteStore);writeStream=ensureWriteStream(remoteStoreImpl);lastBatchIdRetrieved=remoteStoreImpl.writePipeline.length>0?remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length-1].batchId:BATCHID_UNKNOWN;case 3:if(!canAddToWritePipeline(remoteStoreImpl)){_context22.next=23;break;}_context22.prev=4;_context22.next=7;return regeneratorRuntime.awrap(nextMutationBatch(remoteStoreImpl.localStore,lastBatchIdRetrieved));case 7:batch=_context22.sent;if(!(batch===null)){_context22.next=13;break;}if(remoteStoreImpl.writePipeline.length===0){writeStream.markIdle();}return _context22.abrupt("break",23);case 13:lastBatchIdRetrieved=batch.batchId;addToWritePipeline(remoteStoreImpl,batch);case 15:_context22.next=21;break;case 17:_context22.prev=17;_context22.t0=_context22["catch"](4);_context22.next=21;return regeneratorRuntime.awrap(disableNetworkUntilRecovery(remoteStoreImpl,_context22.t0));case 21:_context22.next=3;break;case 23:if(shouldStartWriteStream(remoteStoreImpl)){startWriteStream(remoteStoreImpl);}case 24:case"end":return _context22.stop();}}},null,null,[[4,17]]);}/**
 * Returns true if we can add to the write pipeline (i.e. the network is
 * enabled and the write pipeline is not full).
 */function canAddToWritePipeline(remoteStoreImpl){return canUseNetwork(remoteStoreImpl)&&remoteStoreImpl.writePipeline.length<MAX_PENDING_WRITES;}/**
 * Queues additional writes to be sent to the write stream, sending them
 * immediately if the write stream is established.
 */function addToWritePipeline(remoteStoreImpl,batch){remoteStoreImpl.writePipeline.push(batch);var writeStream=ensureWriteStream(remoteStoreImpl);if(writeStream.isOpen()&&writeStream.handshakeComplete){writeStream.writeMutations(batch.mutations);}}function shouldStartWriteStream(remoteStoreImpl){return canUseNetwork(remoteStoreImpl)&&!ensureWriteStream(remoteStoreImpl).isStarted()&&remoteStoreImpl.writePipeline.length>0;}function startWriteStream(remoteStoreImpl){ensureWriteStream(remoteStoreImpl).start();}function onWriteStreamOpen(remoteStoreImpl){return regeneratorRuntime.async(function onWriteStreamOpen$(_context23){while(1){switch(_context23.prev=_context23.next){case 0:ensureWriteStream(remoteStoreImpl).writeHandshake();case 1:case"end":return _context23.stop();}}});}function onWriteHandshakeComplete(remoteStoreImpl){var writeStream,_iteratorNormalCompletion40,_didIteratorError40,_iteratorError40,_iterator40,_step40,batch;return regeneratorRuntime.async(function onWriteHandshakeComplete$(_context24){while(1){switch(_context24.prev=_context24.next){case 0:writeStream=ensureWriteStream(remoteStoreImpl);// Send the write pipeline now that the stream is established.
_iteratorNormalCompletion40=true;_didIteratorError40=false;_iteratorError40=undefined;_context24.prev=4;for(_iterator40=remoteStoreImpl.writePipeline[Symbol.iterator]();!(_iteratorNormalCompletion40=(_step40=_iterator40.next()).done);_iteratorNormalCompletion40=true){batch=_step40.value;writeStream.writeMutations(batch.mutations);}_context24.next=12;break;case 8:_context24.prev=8;_context24.t0=_context24["catch"](4);_didIteratorError40=true;_iteratorError40=_context24.t0;case 12:_context24.prev=12;_context24.prev=13;if(!_iteratorNormalCompletion40&&_iterator40["return"]!=null){_iterator40["return"]();}case 15:_context24.prev=15;if(!_didIteratorError40){_context24.next=18;break;}throw _iteratorError40;case 18:return _context24.finish(15);case 19:return _context24.finish(12);case 20:case"end":return _context24.stop();}}},null,null,[[4,8,12,20],[13,,15,19]]);}function onMutationResult(remoteStoreImpl,commitVersion,results){var batch,success;return regeneratorRuntime.async(function onMutationResult$(_context25){while(1){switch(_context25.prev=_context25.next){case 0:batch=remoteStoreImpl.writePipeline.shift();success=MutationBatchResult.from(batch,commitVersion,results);_context25.next=4;return regeneratorRuntime.awrap(executeWithRecovery(remoteStoreImpl,function(){return remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success);}));case 4:_context25.next=6;return regeneratorRuntime.awrap(fillWritePipeline(remoteStoreImpl));case 6:case"end":return _context25.stop();}}});}function onWriteStreamClose(remoteStoreImpl,error){return regeneratorRuntime.async(function onWriteStreamClose$(_context26){while(1){switch(_context26.prev=_context26.next){case 0:if(!(error&&ensureWriteStream(remoteStoreImpl).handshakeComplete)){_context26.next=3;break;}_context26.next=3;return regeneratorRuntime.awrap(handleWriteError(remoteStoreImpl,error));case 3:// The write stream might have been started by refilling the write
// pipeline for failed writes
if(shouldStartWriteStream(remoteStoreImpl)){startWriteStream(remoteStoreImpl);}case 4:case"end":return _context26.stop();}}});}function handleWriteError(remoteStoreImpl,error){var batch;return regeneratorRuntime.async(function handleWriteError$(_context27){while(1){switch(_context27.prev=_context27.next){case 0:if(!isPermanentWriteError(error.code)){_context27.next=7;break;}// This was a permanent error, the request itself was the problem
// so it's not going to succeed if we resend it.
batch=remoteStoreImpl.writePipeline.shift();// In this case it's also unlikely that the server itself is melting
// down -- this was just a bad request so inhibit backoff on the next
// restart.
ensureWriteStream(remoteStoreImpl).inhibitBackoff();_context27.next=5;return regeneratorRuntime.awrap(executeWithRecovery(remoteStoreImpl,function(){return remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId,error);}));case 5:_context27.next=7;return regeneratorRuntime.awrap(fillWritePipeline(remoteStoreImpl));case 7:case"end":return _context27.stop();}}});}function restartNetwork(remoteStore){var remoteStoreImpl;return regeneratorRuntime.async(function restartNetwork$(_context28){while(1){switch(_context28.prev=_context28.next){case 0:remoteStoreImpl=debugCast(remoteStore);remoteStoreImpl.offlineCauses.add(4/* ConnectivityChange */);_context28.next=4;return regeneratorRuntime.awrap(disableNetworkInternal(remoteStoreImpl));case 4:remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);remoteStoreImpl.offlineCauses["delete"](4/* ConnectivityChange */);_context28.next=8;return regeneratorRuntime.awrap(enableNetworkInternal(remoteStoreImpl));case 8:case"end":return _context28.stop();}}});}function remoteStoreHandleCredentialChange(remoteStore,user){var remoteStoreImpl,usesNetwork;return regeneratorRuntime.async(function remoteStoreHandleCredentialChange$(_context29){while(1){switch(_context29.prev=_context29.next){case 0:remoteStoreImpl=debugCast(remoteStore);remoteStoreImpl.asyncQueue.verifyOperationInProgress();logDebug(LOG_TAG$5,'RemoteStore received new credentials');usesNetwork=canUseNetwork(remoteStoreImpl);// Tear down and re-create our network streams. This will ensure we get a
// fresh auth token for the new user and re-fill the write pipeline with
// new mutations from the LocalStore (since mutations are per-user).
remoteStoreImpl.offlineCauses.add(3/* CredentialChange */);_context29.next=7;return regeneratorRuntime.awrap(disableNetworkInternal(remoteStoreImpl));case 7:if(usesNetwork){// Don't set the network status to Unknown if we are offline.
remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);}_context29.next=10;return regeneratorRuntime.awrap(remoteStoreImpl.remoteSyncer.handleCredentialChange(user));case 10:remoteStoreImpl.offlineCauses["delete"](3/* CredentialChange */);_context29.next=13;return regeneratorRuntime.awrap(enableNetworkInternal(remoteStoreImpl));case 13:case"end":return _context29.stop();}}});}/**
 * Toggles the network state when the client gains or loses its primary lease.
 */function remoteStoreApplyPrimaryState(remoteStore,isPrimary){var remoteStoreImpl;return regeneratorRuntime.async(function remoteStoreApplyPrimaryState$(_context30){while(1){switch(_context30.prev=_context30.next){case 0:remoteStoreImpl=debugCast(remoteStore);if(!isPrimary){_context30.next=7;break;}remoteStoreImpl.offlineCauses["delete"](2/* IsSecondary */);_context30.next=5;return regeneratorRuntime.awrap(enableNetworkInternal(remoteStoreImpl));case 5:_context30.next=12;break;case 7:if(isPrimary){_context30.next=12;break;}remoteStoreImpl.offlineCauses.add(2/* IsSecondary */);_context30.next=11;return regeneratorRuntime.awrap(disableNetworkInternal(remoteStoreImpl));case 11:remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);case 12:case"end":return _context30.stop();}}});}/**
 * If not yet initialized, registers the WatchStream and its network state
 * callback with `remoteStoreImpl`. Returns the existing stream if one is
 * already available.
 *
 * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.
 * This is not done on Web to allow it to be tree-shaken.
 */function ensureWatchStream(remoteStoreImpl){if(!remoteStoreImpl.watchStream){// Create stream (but note that it is not started yet).
remoteStoreImpl.watchStream=newPersistentWatchStream(remoteStoreImpl.datastore,remoteStoreImpl.asyncQueue,{onOpen:onWatchStreamOpen.bind(null,remoteStoreImpl),onClose:onWatchStreamClose.bind(null,remoteStoreImpl),onWatchChange:onWatchStreamChange.bind(null,remoteStoreImpl)});remoteStoreImpl.onNetworkStatusChange.push(function _callee4(enabled){return regeneratorRuntime.async(function _callee4$(_context31){while(1){switch(_context31.prev=_context31.next){case 0:if(!enabled){_context31.next=5;break;}remoteStoreImpl.watchStream.inhibitBackoff();if(shouldStartWatchStream(remoteStoreImpl)){startWatchStream(remoteStoreImpl);}else{remoteStoreImpl.onlineStateTracker.set("Unknown"/* Unknown */);}_context31.next=8;break;case 5:_context31.next=7;return regeneratorRuntime.awrap(remoteStoreImpl.watchStream.stop());case 7:cleanUpWatchStreamState(remoteStoreImpl);case 8:case"end":return _context31.stop();}}});});}return remoteStoreImpl.watchStream;}/**
 * If not yet initialized, registers the WriteStream and its network state
 * callback with `remoteStoreImpl`. Returns the existing stream if one is
 * already available.
 *
 * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.
 * This is not done on Web to allow it to be tree-shaken.
 */function ensureWriteStream(remoteStoreImpl){if(!remoteStoreImpl.writeStream){// Create stream (but note that it is not started yet).
remoteStoreImpl.writeStream=newPersistentWriteStream(remoteStoreImpl.datastore,remoteStoreImpl.asyncQueue,{onOpen:onWriteStreamOpen.bind(null,remoteStoreImpl),onClose:onWriteStreamClose.bind(null,remoteStoreImpl),onHandshakeComplete:onWriteHandshakeComplete.bind(null,remoteStoreImpl),onMutationResult:onMutationResult.bind(null,remoteStoreImpl)});remoteStoreImpl.onNetworkStatusChange.push(function _callee5(enabled){return regeneratorRuntime.async(function _callee5$(_context32){while(1){switch(_context32.prev=_context32.next){case 0:if(!enabled){_context32.next=6;break;}remoteStoreImpl.writeStream.inhibitBackoff();// This will start the write stream if necessary.
_context32.next=4;return regeneratorRuntime.awrap(fillWritePipeline(remoteStoreImpl));case 4:_context32.next=9;break;case 6:_context32.next=8;return regeneratorRuntime.awrap(remoteStoreImpl.writeStream.stop());case 8:if(remoteStoreImpl.writePipeline.length>0){logDebug(LOG_TAG$5,"Stopping write stream with ".concat(remoteStoreImpl.writePipeline.length," pending writes"));remoteStoreImpl.writePipeline=[];}case 9:case"end":return _context32.stop();}}});});}return remoteStoreImpl.writeStream;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * DocumentSet is an immutable (copy-on-write) collection that holds documents
 * in order specified by the provided comparator. We always add a document key
 * comparator on top of what is provided to guarantee document equality based on
 * the key.
 */var DocumentSet=/*#__PURE__*/function(){/** The default ordering is by key if the comparator is omitted */function DocumentSet(comp){_classCallCheck(this,DocumentSet);// We are adding document key comparator to the end as it's the only
// guaranteed unique property of a document.
if(comp){this.comparator=function(d1,d2){return comp(d1,d2)||DocumentKey.comparator(d1.key,d2.key);};}else{this.comparator=function(d1,d2){return DocumentKey.comparator(d1.key,d2.key);};}this.keyedMap=documentMap();this.sortedSet=new SortedMap(this.comparator);}/**
     * Returns an empty copy of the existing DocumentSet, using the same
     * comparator.
     */_createClass(DocumentSet,[{key:"has",value:function has(key){return this.keyedMap.get(key)!=null;}},{key:"get",value:function get(key){return this.keyedMap.get(key);}},{key:"first",value:function first(){return this.sortedSet.minKey();}},{key:"last",value:function last(){return this.sortedSet.maxKey();}},{key:"isEmpty",value:function isEmpty(){return this.sortedSet.isEmpty();}/**
     * Returns the index of the provided key in the document set, or -1 if the
     * document key is not present in the set;
     */},{key:"indexOf",value:function indexOf(key){var doc=this.keyedMap.get(key);return doc?this.sortedSet.indexOf(doc):-1;}},{key:"forEach",/** Iterates documents in order defined by "comparator" */value:function forEach(cb){this.sortedSet.inorderTraversal(function(k,v){cb(k);return false;});}/** Inserts or updates a document with the same key */},{key:"add",value:function add(doc){// First remove the element if we have it.
var set=this["delete"](doc.key);return set.copy(set.keyedMap.insert(doc.key,doc),set.sortedSet.insert(doc,null));}/** Deletes a document with a given key */},{key:"delete",value:function _delete(key){var doc=this.get(key);if(!doc){return this;}return this.copy(this.keyedMap.remove(key),this.sortedSet.remove(doc));}},{key:"isEqual",value:function isEqual(other){if(!(other instanceof DocumentSet)){return false;}if(this.size!==other.size){return false;}var thisIt=this.sortedSet.getIterator();var otherIt=other.sortedSet.getIterator();while(thisIt.hasNext()){var thisDoc=thisIt.getNext().key;var otherDoc=otherIt.getNext().key;if(!thisDoc.isEqual(otherDoc)){return false;}}return true;}},{key:"toString",value:function toString(){var docStrings=[];this.forEach(function(doc){docStrings.push(doc.toString());});if(docStrings.length===0){return'DocumentSet ()';}else{return'DocumentSet (\n  '+docStrings.join('  \n')+'\n)';}}},{key:"copy",value:function copy(keyedMap,sortedSet){var newSet=new DocumentSet();newSet.comparator=this.comparator;newSet.keyedMap=keyedMap;newSet.sortedSet=sortedSet;return newSet;}},{key:"size",get:function get(){return this.sortedSet.size;}}],[{key:"emptySet",value:function emptySet(oldSet){return new DocumentSet(oldSet.comparator);}}]);return DocumentSet;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * DocumentChangeSet keeps track of a set of changes to docs in a query, merging
 * duplicate events for the same doc.
 */var DocumentChangeSet=/*#__PURE__*/function(){function DocumentChangeSet(){_classCallCheck(this,DocumentChangeSet);this.changeMap=new SortedMap(DocumentKey.comparator);}_createClass(DocumentChangeSet,[{key:"track",value:function track(change){var key=change.doc.key;var oldChange=this.changeMap.get(key);if(!oldChange){this.changeMap=this.changeMap.insert(key,change);return;}// Merge the new change with the existing change.
if(change.type!==0/* Added */&&oldChange.type===3/* Metadata */){this.changeMap=this.changeMap.insert(key,change);}else if(change.type===3/* Metadata */&&oldChange.type!==1/* Removed */){this.changeMap=this.changeMap.insert(key,{type:oldChange.type,doc:change.doc});}else if(change.type===2/* Modified */&&oldChange.type===2/* Modified */){this.changeMap=this.changeMap.insert(key,{type:2/* Modified */,doc:change.doc});}else if(change.type===2/* Modified */&&oldChange.type===0/* Added */){this.changeMap=this.changeMap.insert(key,{type:0/* Added */,doc:change.doc});}else if(change.type===1/* Removed */&&oldChange.type===0/* Added */){this.changeMap=this.changeMap.remove(key);}else if(change.type===1/* Removed */&&oldChange.type===2/* Modified */){this.changeMap=this.changeMap.insert(key,{type:1/* Removed */,doc:oldChange.doc});}else if(change.type===0/* Added */&&oldChange.type===1/* Removed */){this.changeMap=this.changeMap.insert(key,{type:2/* Modified */,doc:change.doc});}else{// This includes these cases, which don't make sense:
// Added->Added
// Removed->Removed
// Modified->Added
// Removed->Modified
// Metadata->Added
// Removed->Metadata
fail();}}},{key:"getChanges",value:function getChanges(){var changes=[];this.changeMap.inorderTraversal(function(key,change){changes.push(change);});return changes;}}]);return DocumentChangeSet;}();var ViewSnapshot=/*#__PURE__*/function(){function ViewSnapshot(query,docs,oldDocs,docChanges,mutatedKeys,fromCache,syncStateChanged,excludesMetadataChanges){_classCallCheck(this,ViewSnapshot);this.query=query;this.docs=docs;this.oldDocs=oldDocs;this.docChanges=docChanges;this.mutatedKeys=mutatedKeys;this.fromCache=fromCache;this.syncStateChanged=syncStateChanged;this.excludesMetadataChanges=excludesMetadataChanges;}/** Returns a view snapshot as if all documents in the snapshot were added. */_createClass(ViewSnapshot,[{key:"isEqual",value:function isEqual(other){if(this.fromCache!==other.fromCache||this.syncStateChanged!==other.syncStateChanged||!this.mutatedKeys.isEqual(other.mutatedKeys)||!queryEquals(this.query,other.query)||!this.docs.isEqual(other.docs)||!this.oldDocs.isEqual(other.oldDocs)){return false;}var changes=this.docChanges;var otherChanges=other.docChanges;if(changes.length!==otherChanges.length){return false;}for(var i=0;i<changes.length;i++){if(changes[i].type!==otherChanges[i].type||!changes[i].doc.isEqual(otherChanges[i].doc)){return false;}}return true;}},{key:"hasPendingWrites",get:function get(){return!this.mutatedKeys.isEmpty();}}],[{key:"fromInitialDocuments",value:function fromInitialDocuments(query,documents,mutatedKeys,fromCache){var changes=[];documents.forEach(function(doc){changes.push({type:0/* Added */,doc:doc});});return new ViewSnapshot(query,documents,DocumentSet.emptySet(documents),changes,mutatedKeys,fromCache,/* syncStateChanged= */true,/* excludesMetadataChanges= */false);}}]);return ViewSnapshot;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var AddedLimboDocument=function AddedLimboDocument(key){_classCallCheck(this,AddedLimboDocument);this.key=key;};var RemovedLimboDocument=function RemovedLimboDocument(key){_classCallCheck(this,RemovedLimboDocument);this.key=key;};/**
 * View is responsible for computing the final merged truth of what docs are in
 * a query. It gets notified of local and remote changes to docs, and applies
 * the query filters and limits to determine the most correct possible results.
 */var View=/*#__PURE__*/function(){function View(query,/** Documents included in the remote target */_syncedDocuments){_classCallCheck(this,View);this.query=query;this._syncedDocuments=_syncedDocuments;this.syncState=null;/**
         * A flag whether the view is current with the backend. A view is considered
         * current after it has seen the current flag from the backend and did not
         * lose consistency within the watch stream (e.g. because of an existence
         * filter mismatch).
         */this.current=false;/** Documents in the view but not in the remote target */this.limboDocuments=documentKeySet();/** Document Keys that have local changes */this.mutatedKeys=documentKeySet();this.docComparator=newQueryComparator(query);this.documentSet=new DocumentSet(this.docComparator);}/**
     * The set of remote documents that the server has told us belongs to the target associated with
     * this view.
     */_createClass(View,[{key:"computeDocChanges",/**
     * Iterates over a set of doc changes, applies the query limit, and computes
     * what the new results should be, what the changes were, and whether we may
     * need to go back to the local cache for more results. Does not make any
     * changes to the view.
     * @param docChanges The doc changes to apply to this view.
     * @param previousChanges If this is being called with a refill, then start
     *        with this set of docs and changes instead of the current view.
     * @return a new set of docs, changes, and refill flag.
     */value:function computeDocChanges(docChanges,previousChanges){var _this53=this;var changeSet=previousChanges?previousChanges.changeSet:new DocumentChangeSet();var oldDocumentSet=previousChanges?previousChanges.documentSet:this.documentSet;var newMutatedKeys=previousChanges?previousChanges.mutatedKeys:this.mutatedKeys;var newDocumentSet=oldDocumentSet;var needsRefill=false;// Track the last doc in a (full) limit. This is necessary, because some
// update (a delete, or an update moving a doc past the old limit) might
// mean there is some other document in the local cache that either should
// come (1) between the old last limit doc and the new last document, in the
// case of updates, or (2) after the new last document, in the case of
// deletes. So we keep this doc at the old limit to compare the updates to.
//
// Note that this should never get used in a refill (when previousChanges is
// set), because there will only be adds -- no deletes or updates.
var lastDocInLimit=hasLimitToFirst(this.query)&&oldDocumentSet.size===this.query.limit?oldDocumentSet.last():null;var firstDocInLimit=hasLimitToLast(this.query)&&oldDocumentSet.size===this.query.limit?oldDocumentSet.first():null;docChanges.inorderTraversal(function(key,newMaybeDoc){var oldDoc=oldDocumentSet.get(key);var newDoc=newMaybeDoc instanceof Document?newMaybeDoc:null;if(newDoc){newDoc=queryMatches(_this53.query,newDoc)?newDoc:null;}var oldDocHadPendingMutations=oldDoc?_this53.mutatedKeys.has(oldDoc.key):false;var newDocHasPendingMutations=newDoc?newDoc.hasLocalMutations||// We only consider committed mutations for documents that were
// mutated during the lifetime of the view.
_this53.mutatedKeys.has(newDoc.key)&&newDoc.hasCommittedMutations:false;var changeApplied=false;// Calculate change
if(oldDoc&&newDoc){var docsEqual=oldDoc.data().isEqual(newDoc.data());if(!docsEqual){if(!_this53.shouldWaitForSyncedDocument(oldDoc,newDoc)){changeSet.track({type:2/* Modified */,doc:newDoc});changeApplied=true;if(lastDocInLimit&&_this53.docComparator(newDoc,lastDocInLimit)>0||firstDocInLimit&&_this53.docComparator(newDoc,firstDocInLimit)<0){// This doc moved from inside the limit to outside the limit.
// That means there may be some other doc in the local cache
// that should be included instead.
needsRefill=true;}}}else if(oldDocHadPendingMutations!==newDocHasPendingMutations){changeSet.track({type:3/* Metadata */,doc:newDoc});changeApplied=true;}}else if(!oldDoc&&newDoc){changeSet.track({type:0/* Added */,doc:newDoc});changeApplied=true;}else if(oldDoc&&!newDoc){changeSet.track({type:1/* Removed */,doc:oldDoc});changeApplied=true;if(lastDocInLimit||firstDocInLimit){// A doc was removed from a full limit query. We'll need to
// requery from the local cache to see if we know about some other
// doc that should be in the results.
needsRefill=true;}}if(changeApplied){if(newDoc){newDocumentSet=newDocumentSet.add(newDoc);if(newDocHasPendingMutations){newMutatedKeys=newMutatedKeys.add(key);}else{newMutatedKeys=newMutatedKeys["delete"](key);}}else{newDocumentSet=newDocumentSet["delete"](key);newMutatedKeys=newMutatedKeys["delete"](key);}}});// Drop documents out to meet limit/limitToLast requirement.
if(hasLimitToFirst(this.query)||hasLimitToLast(this.query)){while(newDocumentSet.size>this.query.limit){var oldDoc=hasLimitToFirst(this.query)?newDocumentSet.last():newDocumentSet.first();newDocumentSet=newDocumentSet["delete"](oldDoc.key);newMutatedKeys=newMutatedKeys["delete"](oldDoc.key);changeSet.track({type:1/* Removed */,doc:oldDoc});}}return{documentSet:newDocumentSet,changeSet:changeSet,needsRefill:needsRefill,mutatedKeys:newMutatedKeys};}},{key:"shouldWaitForSyncedDocument",value:function shouldWaitForSyncedDocument(oldDoc,newDoc){// We suppress the initial change event for documents that were modified as
// part of a write acknowledgment (e.g. when the value of a server transform
// is applied) as Watch will send us the same document again.
// By suppressing the event, we only raise two user visible events (one with
// `hasPendingWrites` and the final state of the document) instead of three
// (one with `hasPendingWrites`, the modified document with
// `hasPendingWrites` and the final state of the document).
return oldDoc.hasLocalMutations&&newDoc.hasCommittedMutations&&!newDoc.hasLocalMutations;}/**
     * Updates the view with the given ViewDocumentChanges and optionally updates
     * limbo docs and sync state from the provided target change.
     * @param docChanges The set of changes to make to the view's docs.
     * @param updateLimboDocuments Whether to update limbo documents based on this
     *        change.
     * @param targetChange A target change to apply for computing limbo docs and
     *        sync state.
     * @return A new ViewChange with the given docs, changes, and sync state.
     */ // PORTING NOTE: The iOS/Android clients always compute limbo document changes.
},{key:"applyChanges",value:function applyChanges(docChanges,updateLimboDocuments,targetChange){var _this54=this;var oldDocs=this.documentSet;this.documentSet=docChanges.documentSet;this.mutatedKeys=docChanges.mutatedKeys;// Sort changes based on type and query comparator
var changes=docChanges.changeSet.getChanges();changes.sort(function(c1,c2){return compareChangeType(c1.type,c2.type)||_this54.docComparator(c1.doc,c2.doc);});this.applyTargetChange(targetChange);var limboChanges=updateLimboDocuments?this.updateLimboDocuments():[];var synced=this.limboDocuments.size===0&&this.current;var newSyncState=synced?1/* Synced */:0/* Local */;var syncStateChanged=newSyncState!==this.syncState;this.syncState=newSyncState;if(changes.length===0&&!syncStateChanged){// no changes
return{limboChanges:limboChanges};}else{var snap=new ViewSnapshot(this.query,docChanges.documentSet,oldDocs,changes,docChanges.mutatedKeys,newSyncState===0/* Local */,syncStateChanged,/* excludesMetadataChanges= */false);return{snapshot:snap,limboChanges:limboChanges};}}/**
     * Applies an OnlineState change to the view, potentially generating a
     * ViewChange if the view's syncState changes as a result.
     */},{key:"applyOnlineStateChange",value:function applyOnlineStateChange(onlineState){if(this.current&&onlineState==="Offline"/* Offline */){// If we're offline, set `current` to false and then call applyChanges()
// to refresh our syncState and generate a ViewChange as appropriate. We
// are guaranteed to get a new TargetChange that sets `current` back to
// true once the client is back online.
this.current=false;return this.applyChanges({documentSet:this.documentSet,changeSet:new DocumentChangeSet(),mutatedKeys:this.mutatedKeys,needsRefill:false},/* updateLimboDocuments= */false);}else{// No effect, just return a no-op ViewChange.
return{limboChanges:[]};}}/**
     * Returns whether the doc for the given key should be in limbo.
     */},{key:"shouldBeInLimbo",value:function shouldBeInLimbo(key){// If the remote end says it's part of this query, it's not in limbo.
if(this._syncedDocuments.has(key)){return false;}// The local store doesn't think it's a result, so it shouldn't be in limbo.
if(!this.documentSet.has(key)){return false;}// If there are local changes to the doc, they might explain why the server
// doesn't know that it's part of the query. So don't put it in limbo.
// TODO(klimt): Ideally, we would only consider changes that might actually
// affect this specific query.
if(this.documentSet.get(key).hasLocalMutations){return false;}// Everything else is in limbo.
return true;}/**
     * Updates syncedDocuments, current, and limbo docs based on the given change.
     * Returns the list of changes to which docs are in limbo.
     */},{key:"applyTargetChange",value:function applyTargetChange(targetChange){var _this55=this;if(targetChange){targetChange.addedDocuments.forEach(function(key){return _this55._syncedDocuments=_this55._syncedDocuments.add(key);});targetChange.modifiedDocuments.forEach(function(key){});targetChange.removedDocuments.forEach(function(key){return _this55._syncedDocuments=_this55._syncedDocuments["delete"](key);});this.current=targetChange.current;}}},{key:"updateLimboDocuments",value:function updateLimboDocuments(){var _this56=this;// We can only determine limbo documents when we're in-sync with the server.
if(!this.current){return[];}// TODO(klimt): Do this incrementally so that it's not quadratic when
// updating many documents.
var oldLimboDocuments=this.limboDocuments;this.limboDocuments=documentKeySet();this.documentSet.forEach(function(doc){if(_this56.shouldBeInLimbo(doc.key)){_this56.limboDocuments=_this56.limboDocuments.add(doc.key);}});// Diff the new limbo docs with the old limbo docs.
var changes=[];oldLimboDocuments.forEach(function(key){if(!_this56.limboDocuments.has(key)){changes.push(new RemovedLimboDocument(key));}});this.limboDocuments.forEach(function(key){if(!oldLimboDocuments.has(key)){changes.push(new AddedLimboDocument(key));}});return changes;}/**
     * Update the in-memory state of the current view with the state read from
     * persistence.
     *
     * We update the query view whenever a client's primary status changes:
     * - When a client transitions from primary to secondary, it can miss
     *   LocalStorage updates and its query views may temporarily not be
     *   synchronized with the state on disk.
     * - For secondary to primary transitions, the client needs to update the list
     *   of `syncedDocuments` since secondary clients update their query views
     *   based purely on synthesized RemoteEvents.
     *
     * @param queryResult.documents - The documents that match the query according
     * to the LocalStore.
     * @param queryResult.remoteKeys - The keys of the documents that match the
     * query according to the backend.
     *
     * @return The ViewChange that resulted from this synchronization.
     */ // PORTING NOTE: Multi-tab only.
},{key:"synchronizeWithPersistedState",value:function synchronizeWithPersistedState(queryResult){this._syncedDocuments=queryResult.remoteKeys;this.limboDocuments=documentKeySet();var docChanges=this.computeDocChanges(queryResult.documents);return this.applyChanges(docChanges,/*updateLimboDocuments=*/true);}/**
     * Returns a view snapshot as if this query was just listened to. Contains
     * a document add for every existing document and the `fromCache` and
     * `hasPendingWrites` status of the already established view.
     */ // PORTING NOTE: Multi-tab only.
},{key:"computeInitialSnapshot",value:function computeInitialSnapshot(){return ViewSnapshot.fromInitialDocuments(this.query,this.documentSet,this.mutatedKeys,this.syncState===0/* Local */);}},{key:"syncedDocuments",get:function get(){return this._syncedDocuments;}}]);return View;}();function compareChangeType(c1,c2){var order=function order(change){switch(change){case 0/* Added */:return 1;case 2/* Modified */:return 2;case 3/* Metadata */:// A metadata change is converted to a modified change at the public
// api layer.  Since we sort by document key and then change type,
// metadata and modified changes must be sorted equivalently.
return 2;case 1/* Removed */:return 0;default:return fail();}};return order(c1)-order(c2);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$6='AsyncQueue';/**
 * Represents an operation scheduled to be run in the future on an AsyncQueue.
 *
 * It is created via DelayedOperation.createAndSchedule().
 *
 * Supports cancellation (via cancel()) and early execution (via skipDelay()).
 *
 * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type
 * in newer versions of TypeScript defines `finally`, which is not available in
 * IE.
 */var DelayedOperation=/*#__PURE__*/function(){function DelayedOperation(asyncQueue,timerId,targetTimeMs,op,removalCallback){_classCallCheck(this,DelayedOperation);this.asyncQueue=asyncQueue;this.timerId=timerId;this.targetTimeMs=targetTimeMs;this.op=op;this.removalCallback=removalCallback;this.deferred=new Deferred();this.then=this.deferred.promise.then.bind(this.deferred.promise);// It's normal for the deferred promise to be canceled (due to cancellation)
// and so we attach a dummy catch callback to avoid
// 'UnhandledPromiseRejectionWarning' log spam.
this.deferred.promise["catch"](function(err){});}/**
     * Creates and returns a DelayedOperation that has been scheduled to be
     * executed on the provided asyncQueue after the provided delayMs.
     *
     * @param asyncQueue The queue to schedule the operation on.
     * @param id A Timer ID identifying the type of operation this is.
     * @param delayMs The delay (ms) before the operation should be scheduled.
     * @param op The operation to run.
     * @param removalCallback A callback to be called synchronously once the
     *   operation is executed or canceled, notifying the AsyncQueue to remove it
     *   from its delayedOperations list.
     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
     *   the DelayedOperation class public.
     */_createClass(DelayedOperation,[{key:"start",/**
     * Starts the timer. This is called immediately after construction by
     * createAndSchedule().
     */value:function start(delayMs){var _this57=this;this.timerHandle=setTimeout(function(){return _this57.handleDelayElapsed();},delayMs);}/**
     * Queues the operation to run immediately (if it hasn't already been run or
     * canceled).
     */},{key:"skipDelay",value:function skipDelay(){return this.handleDelayElapsed();}/**
     * Cancels the operation if it hasn't already been executed or canceled. The
     * promise will be rejected.
     *
     * As long as the operation has not yet been run, calling cancel() provides a
     * guarantee that the operation will not be run.
     */},{key:"cancel",value:function cancel(reason){if(this.timerHandle!==null){this.clearTimeout();this.deferred.reject(new FirestoreError(Code.CANCELLED,'Operation cancelled'+(reason?': '+reason:'')));}}},{key:"handleDelayElapsed",value:function handleDelayElapsed(){var _this58=this;this.asyncQueue.enqueueAndForget(function(){if(_this58.timerHandle!==null){_this58.clearTimeout();return _this58.op().then(function(result){return _this58.deferred.resolve(result);});}else{return Promise.resolve();}});}},{key:"clearTimeout",value:function(_clearTimeout){function clearTimeout(){return _clearTimeout.apply(this,arguments);}clearTimeout.toString=function(){return _clearTimeout.toString();};return clearTimeout;}(function(){if(this.timerHandle!==null){this.removalCallback(this);clearTimeout(this.timerHandle);this.timerHandle=null;}})}],[{key:"createAndSchedule",value:function createAndSchedule(asyncQueue,timerId,delayMs,op,removalCallback){var targetTime=Date.now()+delayMs;var delayedOp=new DelayedOperation(asyncQueue,timerId,targetTime,op,removalCallback);delayedOp.start(delayMs);return delayedOp;}}]);return DelayedOperation;}();var AsyncQueue=/*#__PURE__*/function(){function AsyncQueue(){var _this59=this;_classCallCheck(this,AsyncQueue);// The last promise in the queue.
this.tail=Promise.resolve();// A list of retryable operations. Retryable operations are run in order and
// retried with backoff.
this.retryableOps=[];// Is this AsyncQueue being shut down? Once it is set to true, it will not
// be changed again.
this._isShuttingDown=false;// Operations scheduled to be queued in the future. Operations are
// automatically removed after they are run or canceled.
this.delayedOperations=[];// visible for testing
this.failure=null;// Flag set while there's an outstanding AsyncQueue operation, used for
// assertion sanity-checks.
this.operationInProgress=false;// List of TimerIds to fast-forward delays for.
this.timerIdsToSkip=[];// Backoff timer used to schedule retries for retryable operations
this.backoff=new ExponentialBackoff(this,"async_queue_retry"/* AsyncQueueRetry */);// Visibility handler that triggers an immediate retry of all retryable
// operations. Meant to speed up recovery when we regain file system access
// after page comes into foreground.
this.visibilityHandler=function(){_this59.backoff.skipBackoff();};}// Is this AsyncQueue being shut down? If true, this instance will not enqueue
// any new operations, Promises from enqueue requests will not resolve.
_createClass(AsyncQueue,[{key:"enqueueAndForget",/**
     * Adds a new operation to the queue without waiting for it to complete (i.e.
     * we ignore the Promise result).
     */value:function enqueueAndForget(op){// eslint-disable-next-line @typescript-eslint/no-floating-promises
this.enqueue(op);}/**
     * Regardless if the queue has initialized shutdown, adds a new operation to the
     * queue without waiting for it to complete (i.e. we ignore the Promise result).
     */},{key:"enqueueAndForgetEvenWhileRestricted",value:function enqueueAndForgetEvenWhileRestricted(op){this.verifyNotFailed();// eslint-disable-next-line @typescript-eslint/no-floating-promises
this.enqueueInternal(op);}/**
     * Initialize the shutdown of this queue. Once this method is called, the
     * only possible way to request running an operation is through
     * `enqueueEvenWhileRestricted()`.
     */},{key:"enterRestrictedMode",value:function enterRestrictedMode(){if(!this._isShuttingDown){this._isShuttingDown=true;}}/**
     * Adds a new operation to the queue. Returns a promise that will be resolved
     * when the promise returned by the new operation is (with its value).
     */},{key:"enqueue",value:function enqueue(op){this.verifyNotFailed();if(this._isShuttingDown){// Return a Promise which never resolves.
return new Promise(function(resolve){});}return this.enqueueInternal(op);}/**
     * Enqueue a retryable operation.
     *
     * A retryable operation is rescheduled with backoff if it fails with a
     * IndexedDbTransactionError (the error type used by SimpleDb). All
     * retryable operations are executed in order and only run if all prior
     * operations were retried successfully.
     */},{key:"enqueueRetryable",value:function enqueueRetryable(op){var _this60=this;this.retryableOps.push(op);this.enqueueAndForget(function(){return _this60.retryNextOp();});}/**
     * Runs the next operation from the retryable queue. If the operation fails,
     * reschedules with backoff.
     */},{key:"retryNextOp",value:function retryNextOp(){var _this61=this;return regeneratorRuntime.async(function retryNextOp$(_context33){while(1){switch(_context33.prev=_context33.next){case 0:if(!(this.retryableOps.length===0)){_context33.next=2;break;}return _context33.abrupt("return");case 2:_context33.prev=2;_context33.next=5;return regeneratorRuntime.awrap(this.retryableOps[0]());case 5:this.retryableOps.shift();this.backoff.reset();_context33.next=16;break;case 9:_context33.prev=9;_context33.t0=_context33["catch"](2);if(!isIndexedDbTransactionError(_context33.t0)){_context33.next=15;break;}logDebug(LOG_TAG$6,'Operation failed with retryable error: '+_context33.t0);_context33.next=16;break;case 15:throw _context33.t0;case 16:if(this.retryableOps.length>0){// If there are additional operations, we re-schedule `retryNextOp()`.
// This is necessary to run retryable operations that failed during
// their initial attempt since we don't know whether they are already
// enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
// needs to  be re-run, we will run `op1`, `op1`, `op2` using the
// already enqueued calls to `retryNextOp()`. `op3()` will then run in the
// call scheduled here.
// Since `backoffAndRun()` cancels an existing backoff and schedules a
// new backoff on every call, there is only ever a single additional
// operation in the queue.
this.backoff.backoffAndRun(function(){return _this61.retryNextOp();});}case 17:case"end":return _context33.stop();}}},null,this,[[2,9]]);}},{key:"enqueueInternal",value:function enqueueInternal(op){var _this62=this;var newTail=this.tail.then(function(){_this62.operationInProgress=true;return op()["catch"](function(error){_this62.failure=error;_this62.operationInProgress=false;var message=getMessageOrStack(error);logError('INTERNAL UNHANDLED ERROR: ',message);// Re-throw the error so that this.tail becomes a rejected Promise and
// all further attempts to chain (via .then) will just short-circuit
// and return the rejected Promise.
throw error;}).then(function(result){_this62.operationInProgress=false;return result;});});this.tail=newTail;return newTail;}/**
     * Schedules an operation to be queued on the AsyncQueue once the specified
     * `delayMs` has elapsed. The returned DelayedOperation can be used to cancel
     * or fast-forward the operation prior to its running.
     */},{key:"enqueueAfterDelay",value:function enqueueAfterDelay(timerId,delayMs,op){var _this63=this;this.verifyNotFailed();// Fast-forward delays for timerIds that have been overriden.
if(this.timerIdsToSkip.indexOf(timerId)>-1){delayMs=0;}var delayedOp=DelayedOperation.createAndSchedule(this,timerId,delayMs,op,function(removedOp){return _this63.removeDelayedOperation(removedOp);});this.delayedOperations.push(delayedOp);return delayedOp;}},{key:"verifyNotFailed",value:function verifyNotFailed(){if(this.failure){fail();}}/**
     * Verifies there's an operation currently in-progress on the AsyncQueue.
     * Unfortunately we can't verify that the running code is in the promise chain
     * of that operation, so this isn't a foolproof check, but it should be enough
     * to catch some bugs.
     */},{key:"verifyOperationInProgress",value:function verifyOperationInProgress(){}/**
     * Waits until all currently queued tasks are finished executing. Delayed
     * operations are not run.
     */},{key:"drain",value:function drain(){var currentTail;return regeneratorRuntime.async(function drain$(_context34){while(1){switch(_context34.prev=_context34.next){case 0:currentTail=this.tail;_context34.next=3;return regeneratorRuntime.awrap(currentTail);case 3:if(currentTail!==this.tail){_context34.next=0;break;}case 4:case"end":return _context34.stop();}}},null,this);}/**
     * For Tests: Determine if a delayed operation with a particular TimerId
     * exists.
     */},{key:"containsDelayedOperation",value:function containsDelayedOperation(timerId){var _iteratorNormalCompletion41=true;var _didIteratorError41=false;var _iteratorError41=undefined;try{for(var _iterator41=this.delayedOperations[Symbol.iterator](),_step41;!(_iteratorNormalCompletion41=(_step41=_iterator41.next()).done);_iteratorNormalCompletion41=true){var op=_step41.value;if(op.timerId===timerId){return true;}}}catch(err){_didIteratorError41=true;_iteratorError41=err;}finally{try{if(!_iteratorNormalCompletion41&&_iterator41["return"]!=null){_iterator41["return"]();}}finally{if(_didIteratorError41){throw _iteratorError41;}}}return false;}/**
     * For Tests: Runs some or all delayed operations early.
     *
     * @param lastTimerId Delayed operations up to and including this TimerId will
     *  be drained. Pass TimerId.All to run all delayed operations.
     * @returns a Promise that resolves once all operations have been run.
     */},{key:"runAllDelayedOperationsUntil",value:function runAllDelayedOperationsUntil(lastTimerId){var _this64=this;// Note that draining may generate more delayed ops, so we do that first.
return this.drain().then(function(){// Run ops in the same order they'd run if they ran naturally.
_this64.delayedOperations.sort(function(a,b){return a.targetTimeMs-b.targetTimeMs;});var _iteratorNormalCompletion42=true;var _didIteratorError42=false;var _iteratorError42=undefined;try{for(var _iterator42=_this64.delayedOperations[Symbol.iterator](),_step42;!(_iteratorNormalCompletion42=(_step42=_iterator42.next()).done);_iteratorNormalCompletion42=true){var op=_step42.value;op.skipDelay();if(lastTimerId!=="all"/* All */&&op.timerId===lastTimerId){break;}}}catch(err){_didIteratorError42=true;_iteratorError42=err;}finally{try{if(!_iteratorNormalCompletion42&&_iterator42["return"]!=null){_iterator42["return"]();}}finally{if(_didIteratorError42){throw _iteratorError42;}}}return _this64.drain();});}/**
     * For Tests: Skip all subsequent delays for a timer id.
     */},{key:"skipDelaysForTimerId",value:function skipDelaysForTimerId(timerId){this.timerIdsToSkip.push(timerId);}/** Called once a DelayedOperation is run or canceled. */},{key:"removeDelayedOperation",value:function removeDelayedOperation(op){// NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.
var index=this.delayedOperations.indexOf(op);this.delayedOperations.splice(index,1);}},{key:"isShuttingDown",get:function get(){return this._isShuttingDown;}}]);return AsyncQueue;}();/**
 * Returns a FirestoreError that can be surfaced to the user if the provided
 * error is an IndexedDbTransactionError. Re-throws the error otherwise.
 */function wrapInUserErrorIfRecoverable(e,msg){logError(LOG_TAG$6,"".concat(msg,": ").concat(e));if(isIndexedDbTransactionError(e)){return new FirestoreError(Code.UNAVAILABLE,"".concat(msg,": ").concat(e));}else{throw e;}}/**
 * Chrome includes Error.message in Error.stack. Other browsers do not.
 * This returns expected output of message + stack when available.
 * @param error Error or FirestoreError
 */function getMessageOrStack(error){var message=error.message||'';if(error.stack){if(error.stack.includes(error.message)){message=error.stack;}else{message=error.message+'\n'+error.stack;}}return message;}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Holds the listeners and the last received ViewSnapshot for a query being
 * tracked by EventManager.
 */var QueryListenersInfo=function QueryListenersInfo(){_classCallCheck(this,QueryListenersInfo);this.viewSnap=undefined;this.listeners=[];};function newEventManager(){return new EventManagerImpl();}var EventManagerImpl=function EventManagerImpl(){_classCallCheck(this,EventManagerImpl);this.queries=new ObjectMap(function(q){return canonifyQuery(q);},queryEquals);this.onlineState="Unknown"/* Unknown */;this.snapshotsInSyncListeners=new Set();};function eventManagerListen(eventManager,listener){var eventManagerImpl,query,firstListen,queryInfo,firestoreError,raisedEvent,_raisedEvent;return regeneratorRuntime.async(function eventManagerListen$(_context35){while(1){switch(_context35.prev=_context35.next){case 0:eventManagerImpl=debugCast(eventManager);query=listener.query;firstListen=false;queryInfo=eventManagerImpl.queries.get(query);if(!queryInfo){firstListen=true;queryInfo=new QueryListenersInfo();}if(!firstListen){_context35.next=17;break;}_context35.prev=6;_context35.next=9;return regeneratorRuntime.awrap(eventManagerImpl.onListen(query));case 9:queryInfo.viewSnap=_context35.sent;_context35.next=17;break;case 12:_context35.prev=12;_context35.t0=_context35["catch"](6);firestoreError=wrapInUserErrorIfRecoverable(_context35.t0,"Initialization of query '".concat(stringifyQuery(listener.query),"' failed"));listener.onError(firestoreError);return _context35.abrupt("return");case 17:eventManagerImpl.queries.set(query,queryInfo);queryInfo.listeners.push(listener);// Run global snapshot listeners if a consistent snapshot has been emitted.
raisedEvent=listener.applyOnlineStateChange(eventManagerImpl.onlineState);if(queryInfo.viewSnap){_raisedEvent=listener.onViewSnapshot(queryInfo.viewSnap);if(_raisedEvent){raiseSnapshotsInSyncEvent(eventManagerImpl);}}case 21:case"end":return _context35.stop();}}},null,null,[[6,12]]);}function eventManagerUnlisten(eventManager,listener){var eventManagerImpl,query,lastListen,queryInfo,i;return regeneratorRuntime.async(function eventManagerUnlisten$(_context36){while(1){switch(_context36.prev=_context36.next){case 0:eventManagerImpl=debugCast(eventManager);query=listener.query;lastListen=false;queryInfo=eventManagerImpl.queries.get(query);if(queryInfo){i=queryInfo.listeners.indexOf(listener);if(i>=0){queryInfo.listeners.splice(i,1);lastListen=queryInfo.listeners.length===0;}}if(!lastListen){_context36.next=8;break;}eventManagerImpl.queries["delete"](query);return _context36.abrupt("return",eventManagerImpl.onUnlisten(query));case 8:case"end":return _context36.stop();}}});}function eventManagerOnWatchChange(eventManager,viewSnaps){var eventManagerImpl=debugCast(eventManager);var raisedEvent=false;var _iteratorNormalCompletion43=true;var _didIteratorError43=false;var _iteratorError43=undefined;try{for(var _iterator43=viewSnaps[Symbol.iterator](),_step43;!(_iteratorNormalCompletion43=(_step43=_iterator43.next()).done);_iteratorNormalCompletion43=true){var viewSnap=_step43.value;var query=viewSnap.query;var queryInfo=eventManagerImpl.queries.get(query);if(queryInfo){var _iteratorNormalCompletion44=true;var _didIteratorError44=false;var _iteratorError44=undefined;try{for(var _iterator44=queryInfo.listeners[Symbol.iterator](),_step44;!(_iteratorNormalCompletion44=(_step44=_iterator44.next()).done);_iteratorNormalCompletion44=true){var listener=_step44.value;if(listener.onViewSnapshot(viewSnap)){raisedEvent=true;}}}catch(err){_didIteratorError44=true;_iteratorError44=err;}finally{try{if(!_iteratorNormalCompletion44&&_iterator44["return"]!=null){_iterator44["return"]();}}finally{if(_didIteratorError44){throw _iteratorError44;}}}queryInfo.viewSnap=viewSnap;}}}catch(err){_didIteratorError43=true;_iteratorError43=err;}finally{try{if(!_iteratorNormalCompletion43&&_iterator43["return"]!=null){_iterator43["return"]();}}finally{if(_didIteratorError43){throw _iteratorError43;}}}if(raisedEvent){raiseSnapshotsInSyncEvent(eventManagerImpl);}}function eventManagerOnWatchError(eventManager,query,error){var eventManagerImpl=debugCast(eventManager);var queryInfo=eventManagerImpl.queries.get(query);if(queryInfo){var _iteratorNormalCompletion45=true;var _didIteratorError45=false;var _iteratorError45=undefined;try{for(var _iterator45=queryInfo.listeners[Symbol.iterator](),_step45;!(_iteratorNormalCompletion45=(_step45=_iterator45.next()).done);_iteratorNormalCompletion45=true){var listener=_step45.value;listener.onError(error);}}catch(err){_didIteratorError45=true;_iteratorError45=err;}finally{try{if(!_iteratorNormalCompletion45&&_iterator45["return"]!=null){_iterator45["return"]();}}finally{if(_didIteratorError45){throw _iteratorError45;}}}}// Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()
// after an error.
eventManagerImpl.queries["delete"](query);}function eventManagerOnOnlineStateChange(eventManager,onlineState){var eventManagerImpl=debugCast(eventManager);eventManagerImpl.onlineState=onlineState;var raisedEvent=false;eventManagerImpl.queries.forEach(function(_,queryInfo){var _iteratorNormalCompletion46=true;var _didIteratorError46=false;var _iteratorError46=undefined;try{for(var _iterator46=queryInfo.listeners[Symbol.iterator](),_step46;!(_iteratorNormalCompletion46=(_step46=_iterator46.next()).done);_iteratorNormalCompletion46=true){var listener=_step46.value;// Run global snapshot listeners if a consistent snapshot has been emitted.
if(listener.applyOnlineStateChange(onlineState)){raisedEvent=true;}}}catch(err){_didIteratorError46=true;_iteratorError46=err;}finally{try{if(!_iteratorNormalCompletion46&&_iterator46["return"]!=null){_iterator46["return"]();}}finally{if(_didIteratorError46){throw _iteratorError46;}}}});if(raisedEvent){raiseSnapshotsInSyncEvent(eventManagerImpl);}}function _addSnapshotsInSyncListener(eventManager,observer){var eventManagerImpl=debugCast(eventManager);eventManagerImpl.snapshotsInSyncListeners.add(observer);// Immediately fire an initial event, indicating all existing listeners
// are in-sync.
observer.next();}function removeSnapshotsInSyncListener(eventManager,observer){var eventManagerImpl=debugCast(eventManager);eventManagerImpl.snapshotsInSyncListeners["delete"](observer);}// Call all global snapshot listeners that have been set.
function raiseSnapshotsInSyncEvent(eventManagerImpl){eventManagerImpl.snapshotsInSyncListeners.forEach(function(observer){observer.next();});}/**
 * QueryListener takes a series of internal view snapshots and determines
 * when to raise the event.
 *
 * It uses an Observer to dispatch events.
 */var QueryListener=/*#__PURE__*/function(){function QueryListener(query,queryObserver,options){_classCallCheck(this,QueryListener);this.query=query;this.queryObserver=queryObserver;/**
         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
         * observer. This flag is set to true once we've actually raised an event.
         */this.raisedInitialEvent=false;this.snap=null;this.onlineState="Unknown"/* Unknown */;this.options=options||{};}/**
     * Applies the new ViewSnapshot to this listener, raising a user-facing event
     * if applicable (depending on what changed, whether the user has opted into
     * metadata-only changes, etc.). Returns true if a user-facing event was
     * indeed raised.
     */_createClass(QueryListener,[{key:"onViewSnapshot",value:function onViewSnapshot(snap){if(!this.options.includeMetadataChanges){// Remove the metadata only changes.
var docChanges=[];var _iteratorNormalCompletion47=true;var _didIteratorError47=false;var _iteratorError47=undefined;try{for(var _iterator47=snap.docChanges[Symbol.iterator](),_step47;!(_iteratorNormalCompletion47=(_step47=_iterator47.next()).done);_iteratorNormalCompletion47=true){var docChange=_step47.value;if(docChange.type!==3/* Metadata */){docChanges.push(docChange);}}}catch(err){_didIteratorError47=true;_iteratorError47=err;}finally{try{if(!_iteratorNormalCompletion47&&_iterator47["return"]!=null){_iterator47["return"]();}}finally{if(_didIteratorError47){throw _iteratorError47;}}}snap=new ViewSnapshot(snap.query,snap.docs,snap.oldDocs,docChanges,snap.mutatedKeys,snap.fromCache,snap.syncStateChanged,/* excludesMetadataChanges= */true);}var raisedEvent=false;if(!this.raisedInitialEvent){if(this.shouldRaiseInitialEvent(snap,this.onlineState)){this.raiseInitialEvent(snap);raisedEvent=true;}}else if(this.shouldRaiseEvent(snap)){this.queryObserver.next(snap);raisedEvent=true;}this.snap=snap;return raisedEvent;}},{key:"onError",value:function onError(error){this.queryObserver.error(error);}/** Returns whether a snapshot was raised. */},{key:"applyOnlineStateChange",value:function applyOnlineStateChange(onlineState){this.onlineState=onlineState;var raisedEvent=false;if(this.snap&&!this.raisedInitialEvent&&this.shouldRaiseInitialEvent(this.snap,onlineState)){this.raiseInitialEvent(this.snap);raisedEvent=true;}return raisedEvent;}},{key:"shouldRaiseInitialEvent",value:function shouldRaiseInitialEvent(snap,onlineState){// Always raise the first event when we're synced
if(!snap.fromCache){return true;}// NOTE: We consider OnlineState.Unknown as online (it should become Offline
// or Online if we wait long enough).
var maybeOnline=onlineState!=="Offline"/* Offline */;// Don't raise the event if we're online, aren't synced yet (checked
// above) and are waiting for a sync.
if(this.options.waitForSyncWhenOnline&&maybeOnline){return false;}// Raise data from cache if we have any documents or we are offline
return!snap.docs.isEmpty()||onlineState==="Offline"/* Offline */;}},{key:"shouldRaiseEvent",value:function shouldRaiseEvent(snap){// We don't need to handle includeDocumentMetadataChanges here because
// the Metadata only changes have already been stripped out if needed.
// At this point the only changes we will see are the ones we should
// propagate.
if(snap.docChanges.length>0){return true;}var hasPendingWritesChanged=this.snap&&this.snap.hasPendingWrites!==snap.hasPendingWrites;if(snap.syncStateChanged||hasPendingWritesChanged){return this.options.includeMetadataChanges===true;}// Generally we should have hit one of the cases above, but it's possible
// to get here if there were only metadata docChanges and they got
// stripped out.
return false;}},{key:"raiseInitialEvent",value:function raiseInitialEvent(snap){snap=ViewSnapshot.fromInitialDocuments(snap.query,snap.docs,snap.mutatedKeys,snap.fromCache);this.raisedInitialEvent=true;this.queryObserver.next(snap);}}]);return QueryListener;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$7='SyncEngine';/**
 * QueryView contains all of the data that SyncEngine needs to keep track of for
 * a particular query.
 */var QueryView=function QueryView(/**
     * The query itself.
     */query,/**
     * The target number created by the client that is used in the watch
     * stream to identify this query.
     */targetId,/**
     * The view is responsible for computing the final merged truth of what
     * docs are in the query. It gets notified of local and remote changes,
     * and applies the query filters and limits to determine the most correct
     * possible results.
     */view){_classCallCheck(this,QueryView);this.query=query;this.targetId=targetId;this.view=view;};/** Tracks a limbo resolution. */var LimboResolution=function LimboResolution(key){_classCallCheck(this,LimboResolution);this.key=key;/**
         * Set to true once we've received a document. This is used in
         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to
         * decide whether it needs to manufacture a delete event for the target once
         * the target is CURRENT.
         */this.receivedDocument=false;};/**
 * An implementation of `SyncEngine` coordinating with other parts of SDK.
 *
 * The parts of SyncEngine that act as a callback to RemoteStore need to be
 * registered individually. This is done in `syncEngineWrite()` and
 * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods
 * serve as entry points to RemoteStore's functionality.
 *
 * Note: some field defined in this class might have public access level, but
 * the class is not exported so they are only accessible from this module.
 * This is useful to implement optional features (like bundles) in free
 * functions, such that they are tree-shakeable.
 */var SyncEngineImpl=/*#__PURE__*/function(){function SyncEngineImpl(localStore,remoteStore,eventManager,// PORTING NOTE: Manages state synchronization in multi-tab environments.
sharedClientState,currentUser,maxConcurrentLimboResolutions){_classCallCheck(this,SyncEngineImpl);this.localStore=localStore;this.remoteStore=remoteStore;this.eventManager=eventManager;this.sharedClientState=sharedClientState;this.currentUser=currentUser;this.maxConcurrentLimboResolutions=maxConcurrentLimboResolutions;this.syncEngineListener={};this.queryViewsByQuery=new ObjectMap(function(q){return canonifyQuery(q);},queryEquals);this.queriesByTarget=new Map();/**
         * The keys of documents that are in limbo for which we haven't yet started a
         * limbo resolution query.
         */this.enqueuedLimboResolutions=[];/**
         * Keeps track of the target ID for each document that is in limbo with an
         * active target.
         */this.activeLimboTargetsByKey=new SortedMap(DocumentKey.comparator);/**
         * Keeps track of the information about an active limbo resolution for each
         * active target ID that was started for the purpose of limbo resolution.
         */this.activeLimboResolutionsByTarget=new Map();this.limboDocumentRefs=new ReferenceSet();/** Stores user completion handlers, indexed by User and BatchId. */this.mutationUserCallbacks={};/** Stores user callbacks waiting for all pending writes to be acknowledged. */this.pendingWritesCallbacks=new Map();this.limboTargetIdGenerator=TargetIdGenerator.forSyncEngine();this.onlineState="Unknown"/* Unknown */;// The primary state is set to `true` or `false` immediately after Firestore
// startup. In the interim, a client should only be considered primary if
// `isPrimary` is true.
this._isPrimaryClient=undefined;}_createClass(SyncEngineImpl,[{key:"isPrimaryClient",get:function get(){return this._isPrimaryClient===true;}}]);return SyncEngineImpl;}();function newSyncEngine(localStore,remoteStore,eventManager,// PORTING NOTE: Manages state synchronization in multi-tab environments.
sharedClientState,currentUser,maxConcurrentLimboResolutions,isPrimary){var syncEngine=new SyncEngineImpl(localStore,remoteStore,eventManager,sharedClientState,currentUser,maxConcurrentLimboResolutions);if(isPrimary){syncEngine._isPrimaryClient=true;}return syncEngine;}/**
 * Initiates the new listen, resolves promise when listen enqueued to the
 * server. All the subsequent view snapshots or errors are sent to the
 * subscribed handlers. Returns the initial snapshot.
 */function syncEngineListen(syncEngine,query){var syncEngineImpl,targetId,viewSnapshot,queryView,targetData,status;return regeneratorRuntime.async(function syncEngineListen$(_context37){while(1){switch(_context37.prev=_context37.next){case 0:syncEngineImpl=ensureWatchCallbacks(syncEngine);queryView=syncEngineImpl.queryViewsByQuery.get(query);if(!queryView){_context37.next=8;break;}// PORTING NOTE: With Multi-Tab Web, it is possible that a query view
// already exists when EventManager calls us for the first time. This
// happens when the primary tab is already listening to this query on
// behalf of another tab and the user of the primary also starts listening
// to the query. EventManager will not have an assigned target ID in this
// case and calls `listen` to obtain this ID.
targetId=queryView.targetId;syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId);viewSnapshot=queryView.view.computeInitialSnapshot();_context37.next=17;break;case 8:_context37.next=10;return regeneratorRuntime.awrap(allocateTarget(syncEngineImpl.localStore,queryToTarget(query)));case 10:targetData=_context37.sent;status=syncEngineImpl.sharedClientState.addLocalQueryTarget(targetData.targetId);targetId=targetData.targetId;_context37.next=15;return regeneratorRuntime.awrap(initializeViewAndComputeSnapshot(syncEngineImpl,query,targetId,status==='current'));case 15:viewSnapshot=_context37.sent;if(syncEngineImpl.isPrimaryClient){remoteStoreListen(syncEngineImpl.remoteStore,targetData);}case 17:return _context37.abrupt("return",viewSnapshot);case 18:case"end":return _context37.stop();}}});}/**
 * Registers a view for a previously unknown query and computes its initial
 * snapshot.
 */function initializeViewAndComputeSnapshot(syncEngineImpl,query,targetId,current){var queryResult,view,viewDocChanges,synthesizedTargetChange,viewChange,data;return regeneratorRuntime.async(function initializeViewAndComputeSnapshot$(_context38){while(1){switch(_context38.prev=_context38.next){case 0:// PORTING NOTE: On Web only, we inject the code that registers new Limbo
// targets based on view changes. This allows us to only depend on Limbo
// changes when user code includes queries.
syncEngineImpl.applyDocChanges=function(queryView,changes,remoteEvent){return applyDocChanges(syncEngineImpl,queryView,changes,remoteEvent);};_context38.next=3;return regeneratorRuntime.awrap(executeQuery(syncEngineImpl.localStore,query,/* usePreviousResults= */true));case 3:queryResult=_context38.sent;view=new View(query,queryResult.remoteKeys);viewDocChanges=view.computeDocChanges(queryResult.documents);synthesizedTargetChange=TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId,current&&syncEngineImpl.onlineState!=="Offline"/* Offline */);viewChange=view.applyChanges(viewDocChanges,/* updateLimboDocuments= */syncEngineImpl.isPrimaryClient,synthesizedTargetChange);updateTrackedLimbos(syncEngineImpl,targetId,viewChange.limboChanges);data=new QueryView(query,targetId,view);syncEngineImpl.queryViewsByQuery.set(query,data);if(syncEngineImpl.queriesByTarget.has(targetId)){syncEngineImpl.queriesByTarget.get(targetId).push(query);}else{syncEngineImpl.queriesByTarget.set(targetId,[query]);}return _context38.abrupt("return",viewChange.snapshot);case 13:case"end":return _context38.stop();}}});}/** Stops listening to the query. */function syncEngineUnlisten(syncEngine,query){var syncEngineImpl,queryView,queries,targetRemainsActive;return regeneratorRuntime.async(function syncEngineUnlisten$(_context39){while(1){switch(_context39.prev=_context39.next){case 0:syncEngineImpl=debugCast(syncEngine);queryView=syncEngineImpl.queryViewsByQuery.get(query);// Only clean up the query view and target if this is the only query mapped
// to the target.
queries=syncEngineImpl.queriesByTarget.get(queryView.targetId);if(!(queries.length>1)){_context39.next=7;break;}syncEngineImpl.queriesByTarget.set(queryView.targetId,queries.filter(function(q){return!queryEquals(q,query);}));syncEngineImpl.queryViewsByQuery["delete"](query);return _context39.abrupt("return");case 7:if(!syncEngineImpl.isPrimaryClient){_context39.next=15;break;}// We need to remove the local query target first to allow us to verify
// whether any other client is still interested in this target.
syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);targetRemainsActive=syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);if(targetRemainsActive){_context39.next=13;break;}_context39.next=13;return regeneratorRuntime.awrap(releaseTarget(syncEngineImpl.localStore,queryView.targetId,/*keepPersistedTargetData=*/false).then(function(){syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);remoteStoreUnlisten(syncEngineImpl.remoteStore,queryView.targetId);removeAndCleanupTarget(syncEngineImpl,queryView.targetId);})["catch"](ignoreIfPrimaryLeaseLoss));case 13:_context39.next=18;break;case 15:removeAndCleanupTarget(syncEngineImpl,queryView.targetId);_context39.next=18;return regeneratorRuntime.awrap(releaseTarget(syncEngineImpl.localStore,queryView.targetId,/*keepPersistedTargetData=*/true));case 18:case"end":return _context39.stop();}}});}/**
 * Initiates the write of local mutation batch which involves adding the
 * writes to the mutation queue, notifying the remote store about new
 * mutations and raising events for any changes this write caused.
 *
 * The promise returned by this call is resolved when the above steps
 * have completed, *not* when the write was acked by the backend. The
 * userCallback is resolved once the write was acked/rejected by the
 * backend (or failed locally for any other reason).
 */function syncEngineWrite(syncEngine,batch,userCallback){var syncEngineImpl,result,error;return regeneratorRuntime.async(function syncEngineWrite$(_context40){while(1){switch(_context40.prev=_context40.next){case 0:syncEngineImpl=ensureWriteCallbacks(syncEngine);_context40.prev=1;_context40.next=4;return regeneratorRuntime.awrap(localWrite(syncEngineImpl.localStore,batch));case 4:result=_context40.sent;syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);addMutationCallback(syncEngineImpl,result.batchId,userCallback);_context40.next=9;return regeneratorRuntime.awrap(emitNewSnapsAndNotifyLocalStore(syncEngineImpl,result.changes));case 9:_context40.next=11;return regeneratorRuntime.awrap(fillWritePipeline(syncEngineImpl.remoteStore));case 11:_context40.next=17;break;case 13:_context40.prev=13;_context40.t0=_context40["catch"](1);// If we can't persist the mutation, we reject the user callback and
// don't send the mutation. The user can then retry the write.
error=wrapInUserErrorIfRecoverable(_context40.t0,"Failed to persist write");userCallback.reject(error);case 17:case"end":return _context40.stop();}}},null,null,[[1,13]]);}/**
 * Applies one remote event to the sync engine, notifying any views of the
 * changes, and releasing any pending mutation batches that would become
 * visible because of the snapshot version the remote event contains.
 */function applyRemoteEvent(syncEngine,remoteEvent){var syncEngineImpl,changes;return regeneratorRuntime.async(function applyRemoteEvent$(_context41){while(1){switch(_context41.prev=_context41.next){case 0:syncEngineImpl=debugCast(syncEngine);_context41.prev=1;_context41.next=4;return regeneratorRuntime.awrap(applyRemoteEventToLocalCache(syncEngineImpl.localStore,remoteEvent));case 4:changes=_context41.sent;// Update `receivedDocument` as appropriate for any limbo targets.
remoteEvent.targetChanges.forEach(function(targetChange,targetId){var limboResolution=syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);if(limboResolution){// Since this is a limbo resolution lookup, it's for a single document
// and it could be added, modified, or removed, but not a combination.
hardAssert(targetChange.addedDocuments.size+targetChange.modifiedDocuments.size+targetChange.removedDocuments.size<=1);if(targetChange.addedDocuments.size>0){limboResolution.receivedDocument=true;}else if(targetChange.modifiedDocuments.size>0){hardAssert(limboResolution.receivedDocument);}else if(targetChange.removedDocuments.size>0){hardAssert(limboResolution.receivedDocument);limboResolution.receivedDocument=false;}else{// This was probably just a CURRENT targetChange or similar.
}}});_context41.next=8;return regeneratorRuntime.awrap(emitNewSnapsAndNotifyLocalStore(syncEngineImpl,changes,remoteEvent));case 8:_context41.next=14;break;case 10:_context41.prev=10;_context41.t0=_context41["catch"](1);_context41.next=14;return regeneratorRuntime.awrap(ignoreIfPrimaryLeaseLoss(_context41.t0));case 14:case"end":return _context41.stop();}}},null,null,[[1,10]]);}/**
 * Applies an OnlineState change to the sync engine and notifies any views of
 * the change.
 */function applyOnlineStateChange(syncEngine,onlineState,source){var syncEngineImpl=debugCast(syncEngine);// If we are the secondary client, we explicitly ignore the remote store's
// online state (the local client may go offline, even though the primary
// tab remains online) and only apply the primary tab's online state from
// SharedClientState.
if(syncEngineImpl.isPrimaryClient&&source===0/* RemoteStore */||!syncEngineImpl.isPrimaryClient&&source===1/* SharedClientState */){var newViewSnapshots=[];syncEngineImpl.queryViewsByQuery.forEach(function(query,queryView){var viewChange=queryView.view.applyOnlineStateChange(onlineState);if(viewChange.snapshot){newViewSnapshots.push(viewChange.snapshot);}});eventManagerOnOnlineStateChange(syncEngineImpl.eventManager,onlineState);if(newViewSnapshots.length){syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);}syncEngineImpl.onlineState=onlineState;if(syncEngineImpl.isPrimaryClient){syncEngineImpl.sharedClientState.setOnlineState(onlineState);}}}/**
 * Rejects the listen for the given targetID. This can be triggered by the
 * backend for any active target.
 *
 * @param syncEngine The sync engine implementation.
 * @param targetId The targetID corresponds to one previously initiated by the
 * user as part of TargetData passed to listen() on RemoteStore.
 * @param err A description of the condition that has forced the rejection.
 * Nearly always this will be an indication that the user is no longer
 * authorized to see the data matching the target.
 */function rejectListen(syncEngine,targetId,err){var syncEngineImpl,limboResolution,limboKey,documentUpdates,resolvedLimboDocuments,event;return regeneratorRuntime.async(function rejectListen$(_context42){while(1){switch(_context42.prev=_context42.next){case 0:syncEngineImpl=debugCast(syncEngine);// PORTING NOTE: Multi-tab only.
syncEngineImpl.sharedClientState.updateQueryState(targetId,'rejected',err);limboResolution=syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);limboKey=limboResolution&&limboResolution.key;if(!limboKey){_context42.next=16;break;}// TODO(klimt): We really only should do the following on permission
// denied errors, but we don't have the cause code here.
// It's a limbo doc. Create a synthetic event saying it was deleted.
// This is kind of a hack. Ideally, we would have a method in the local
// store to purge a document. However, it would be tricky to keep all of
// the local store's invariants with another method.
documentUpdates=new SortedMap(DocumentKey.comparator);documentUpdates=documentUpdates.insert(limboKey,new NoDocument(limboKey,SnapshotVersion.min()));resolvedLimboDocuments=documentKeySet().add(limboKey);event=new RemoteEvent(SnapshotVersion.min(),/* targetChanges= */new Map(),/* targetMismatches= */new SortedSet(primitiveComparator),documentUpdates,resolvedLimboDocuments);_context42.next=11;return regeneratorRuntime.awrap(applyRemoteEvent(syncEngineImpl,event));case 11:// Since this query failed, we won't want to manually unlisten to it.
// We only remove it from bookkeeping after we successfully applied the
// RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to
// this query when the RemoteStore restarts the Watch stream, which should
// re-trigger the target failure.
syncEngineImpl.activeLimboTargetsByKey=syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);syncEngineImpl.activeLimboResolutionsByTarget["delete"](targetId);pumpEnqueuedLimboResolutions(syncEngineImpl);_context42.next=18;break;case 16:_context42.next=18;return regeneratorRuntime.awrap(releaseTarget(syncEngineImpl.localStore,targetId,/* keepPersistedTargetData */false).then(function(){return removeAndCleanupTarget(syncEngineImpl,targetId,err);})["catch"](ignoreIfPrimaryLeaseLoss));case 18:case"end":return _context42.stop();}}});}function applySuccessfulWrite(syncEngine,mutationBatchResult){var syncEngineImpl,batchId,changes;return regeneratorRuntime.async(function applySuccessfulWrite$(_context43){while(1){switch(_context43.prev=_context43.next){case 0:syncEngineImpl=debugCast(syncEngine);batchId=mutationBatchResult.batch.batchId;_context43.prev=2;_context43.next=5;return regeneratorRuntime.awrap(acknowledgeBatch(syncEngineImpl.localStore,mutationBatchResult));case 5:changes=_context43.sent;// The local store may or may not be able to apply the write result and
// raise events immediately (depending on whether the watcher is caught
// up), so we raise user callbacks first so that they consistently happen
// before listen events.
processUserCallback(syncEngineImpl,batchId,/*error=*/null);triggerPendingWritesCallbacks(syncEngineImpl,batchId);syncEngineImpl.sharedClientState.updateMutationState(batchId,'acknowledged');_context43.next=11;return regeneratorRuntime.awrap(emitNewSnapsAndNotifyLocalStore(syncEngineImpl,changes));case 11:_context43.next=17;break;case 13:_context43.prev=13;_context43.t0=_context43["catch"](2);_context43.next=17;return regeneratorRuntime.awrap(ignoreIfPrimaryLeaseLoss(_context43.t0));case 17:case"end":return _context43.stop();}}},null,null,[[2,13]]);}function rejectFailedWrite(syncEngine,batchId,error){var syncEngineImpl,changes;return regeneratorRuntime.async(function rejectFailedWrite$(_context44){while(1){switch(_context44.prev=_context44.next){case 0:syncEngineImpl=debugCast(syncEngine);_context44.prev=1;_context44.next=4;return regeneratorRuntime.awrap(rejectBatch(syncEngineImpl.localStore,batchId));case 4:changes=_context44.sent;// The local store may or may not be able to apply the write result and
// raise events immediately (depending on whether the watcher is caught up),
// so we raise user callbacks first so that they consistently happen before
// listen events.
processUserCallback(syncEngineImpl,batchId,error);triggerPendingWritesCallbacks(syncEngineImpl,batchId);syncEngineImpl.sharedClientState.updateMutationState(batchId,'rejected',error);_context44.next=10;return regeneratorRuntime.awrap(emitNewSnapsAndNotifyLocalStore(syncEngineImpl,changes));case 10:_context44.next=16;break;case 12:_context44.prev=12;_context44.t0=_context44["catch"](1);_context44.next=16;return regeneratorRuntime.awrap(ignoreIfPrimaryLeaseLoss(_context44.t0));case 16:case"end":return _context44.stop();}}},null,null,[[1,12]]);}/**
 * Registers a user callback that resolves when all pending mutations at the moment of calling
 * are acknowledged .
 */function registerPendingWritesCallback(syncEngine,callback){var syncEngineImpl,highestBatchId,callbacks,firestoreError;return regeneratorRuntime.async(function registerPendingWritesCallback$(_context45){while(1){switch(_context45.prev=_context45.next){case 0:syncEngineImpl=debugCast(syncEngine);if(!canUseNetwork(syncEngineImpl.remoteStore)){logDebug(LOG_TAG$7,'The network is disabled. The task returned by '+"'awaitPendingWrites()' will not complete until the network is enabled.");}_context45.prev=2;_context45.next=5;return regeneratorRuntime.awrap(getHighestUnacknowledgedBatchId(syncEngineImpl.localStore));case 5:highestBatchId=_context45.sent;if(!(highestBatchId===BATCHID_UNKNOWN)){_context45.next=9;break;}// Trigger the callback right away if there is no pending writes at the moment.
callback.resolve();return _context45.abrupt("return");case 9:callbacks=syncEngineImpl.pendingWritesCallbacks.get(highestBatchId)||[];callbacks.push(callback);syncEngineImpl.pendingWritesCallbacks.set(highestBatchId,callbacks);_context45.next=18;break;case 14:_context45.prev=14;_context45.t0=_context45["catch"](2);firestoreError=wrapInUserErrorIfRecoverable(_context45.t0,'Initialization of waitForPendingWrites() operation failed');callback.reject(firestoreError);case 18:case"end":return _context45.stop();}}},null,null,[[2,14]]);}/**
 * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,
 * if there are any.
 */function triggerPendingWritesCallbacks(syncEngineImpl,batchId){(syncEngineImpl.pendingWritesCallbacks.get(batchId)||[]).forEach(function(callback){callback.resolve();});syncEngineImpl.pendingWritesCallbacks["delete"](batchId);}/** Reject all outstanding callbacks waiting for pending writes to complete. */function rejectOutstandingPendingWritesCallbacks(syncEngineImpl,errorMessage){syncEngineImpl.pendingWritesCallbacks.forEach(function(callbacks){callbacks.forEach(function(callback){callback.reject(new FirestoreError(Code.CANCELLED,errorMessage));});});syncEngineImpl.pendingWritesCallbacks.clear();}function addMutationCallback(syncEngineImpl,batchId,callback){var newCallbacks=syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];if(!newCallbacks){newCallbacks=new SortedMap(primitiveComparator);}newCallbacks=newCallbacks.insert(batchId,callback);syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()]=newCallbacks;}/**
 * Resolves or rejects the user callback for the given batch and then discards
 * it.
 */function processUserCallback(syncEngine,batchId,error){var syncEngineImpl=debugCast(syncEngine);var newCallbacks=syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];// NOTE: Mutations restored from persistence won't have callbacks, so it's
// okay for there to be no callback for this ID.
if(newCallbacks){var callback=newCallbacks.get(batchId);if(callback){if(error){callback.reject(error);}else{callback.resolve();}newCallbacks=newCallbacks.remove(batchId);}syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()]=newCallbacks;}}function removeAndCleanupTarget(syncEngineImpl,targetId){var error=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);var _iteratorNormalCompletion48=true;var _didIteratorError48=false;var _iteratorError48=undefined;try{for(var _iterator48=syncEngineImpl.queriesByTarget.get(targetId)[Symbol.iterator](),_step48;!(_iteratorNormalCompletion48=(_step48=_iterator48.next()).done);_iteratorNormalCompletion48=true){var query=_step48.value;syncEngineImpl.queryViewsByQuery["delete"](query);if(error){syncEngineImpl.syncEngineListener.onWatchError(query,error);}}}catch(err){_didIteratorError48=true;_iteratorError48=err;}finally{try{if(!_iteratorNormalCompletion48&&_iterator48["return"]!=null){_iterator48["return"]();}}finally{if(_didIteratorError48){throw _iteratorError48;}}}syncEngineImpl.queriesByTarget["delete"](targetId);if(syncEngineImpl.isPrimaryClient){var limboKeys=syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);limboKeys.forEach(function(limboKey){var isReferenced=syncEngineImpl.limboDocumentRefs.containsKey(limboKey);if(!isReferenced){// We removed the last reference for this key
removeLimboTarget(syncEngineImpl,limboKey);}});}}function removeLimboTarget(syncEngineImpl,key){// It's possible that the target already got removed because the query failed. In that case,
// the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.
var limboTargetId=syncEngineImpl.activeLimboTargetsByKey.get(key);if(limboTargetId===null){// This target already got removed, because the query failed.
return;}remoteStoreUnlisten(syncEngineImpl.remoteStore,limboTargetId);syncEngineImpl.activeLimboTargetsByKey=syncEngineImpl.activeLimboTargetsByKey.remove(key);syncEngineImpl.activeLimboResolutionsByTarget["delete"](limboTargetId);pumpEnqueuedLimboResolutions(syncEngineImpl);}function updateTrackedLimbos(syncEngineImpl,targetId,limboChanges){var _iteratorNormalCompletion49=true;var _didIteratorError49=false;var _iteratorError49=undefined;try{for(var _iterator49=limboChanges[Symbol.iterator](),_step49;!(_iteratorNormalCompletion49=(_step49=_iterator49.next()).done);_iteratorNormalCompletion49=true){var limboChange=_step49.value;if(limboChange instanceof AddedLimboDocument){syncEngineImpl.limboDocumentRefs.addReference(limboChange.key,targetId);trackLimboChange(syncEngineImpl,limboChange);}else if(limboChange instanceof RemovedLimboDocument){logDebug(LOG_TAG$7,'Document no longer in limbo: '+limboChange.key);syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key,targetId);var isReferenced=syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);if(!isReferenced){// We removed the last reference for this key
removeLimboTarget(syncEngineImpl,limboChange.key);}}else{fail();}}}catch(err){_didIteratorError49=true;_iteratorError49=err;}finally{try{if(!_iteratorNormalCompletion49&&_iterator49["return"]!=null){_iterator49["return"]();}}finally{if(_didIteratorError49){throw _iteratorError49;}}}}function trackLimboChange(syncEngineImpl,limboChange){var key=limboChange.key;if(!syncEngineImpl.activeLimboTargetsByKey.get(key)){logDebug(LOG_TAG$7,'New document in limbo: '+key);syncEngineImpl.enqueuedLimboResolutions.push(key);pumpEnqueuedLimboResolutions(syncEngineImpl);}}/**
 * Starts listens for documents in limbo that are enqueued for resolution,
 * subject to a maximum number of concurrent resolutions.
 *
 * Without bounding the number of concurrent resolutions, the server can fail
 * with "resource exhausted" errors which can lead to pathological client
 * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.
 */function pumpEnqueuedLimboResolutions(syncEngineImpl){while(syncEngineImpl.enqueuedLimboResolutions.length>0&&syncEngineImpl.activeLimboTargetsByKey.size<syncEngineImpl.maxConcurrentLimboResolutions){var key=syncEngineImpl.enqueuedLimboResolutions.shift();var limboTargetId=syncEngineImpl.limboTargetIdGenerator.next();syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId,new LimboResolution(key));syncEngineImpl.activeLimboTargetsByKey=syncEngineImpl.activeLimboTargetsByKey.insert(key,limboTargetId);remoteStoreListen(syncEngineImpl.remoteStore,new TargetData(queryToTarget(newQueryForPath(key.path)),limboTargetId,2/* LimboResolution */,ListenSequence.INVALID));}}function emitNewSnapsAndNotifyLocalStore(syncEngine,changes,remoteEvent){var syncEngineImpl,newSnaps,docChangesInAllViews,queriesProcessed;return regeneratorRuntime.async(function emitNewSnapsAndNotifyLocalStore$(_context46){while(1){switch(_context46.prev=_context46.next){case 0:syncEngineImpl=debugCast(syncEngine);newSnaps=[];docChangesInAllViews=[];queriesProcessed=[];if(!syncEngineImpl.queryViewsByQuery.isEmpty()){_context46.next=6;break;}return _context46.abrupt("return");case 6:syncEngineImpl.queryViewsByQuery.forEach(function(_,queryView){queriesProcessed.push(syncEngineImpl.applyDocChanges(queryView,changes,remoteEvent).then(function(viewSnapshot){if(viewSnapshot){if(syncEngineImpl.isPrimaryClient){syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId,viewSnapshot.fromCache?'not-current':'current');}newSnaps.push(viewSnapshot);var docChanges=LocalViewChanges.fromSnapshot(queryView.targetId,viewSnapshot);docChangesInAllViews.push(docChanges);}}));});_context46.next=9;return regeneratorRuntime.awrap(Promise.all(queriesProcessed));case 9:syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);_context46.next=12;return regeneratorRuntime.awrap(notifyLocalViewChanges(syncEngineImpl.localStore,docChangesInAllViews));case 12:case"end":return _context46.stop();}}});}function applyDocChanges(syncEngineImpl,queryView,changes,remoteEvent){var viewDocChanges,targetChange,viewChange;return regeneratorRuntime.async(function applyDocChanges$(_context47){while(1){switch(_context47.prev=_context47.next){case 0:viewDocChanges=queryView.view.computeDocChanges(changes);if(!viewDocChanges.needsRefill){_context47.next=5;break;}_context47.next=4;return regeneratorRuntime.awrap(executeQuery(syncEngineImpl.localStore,queryView.query,/* usePreviousResults= */false).then(function(_ref){var documents=_ref.documents;return queryView.view.computeDocChanges(documents,viewDocChanges);}));case 4:viewDocChanges=_context47.sent;case 5:targetChange=remoteEvent&&remoteEvent.targetChanges.get(queryView.targetId);viewChange=queryView.view.applyChanges(viewDocChanges,/* updateLimboDocuments= */syncEngineImpl.isPrimaryClient,targetChange);updateTrackedLimbos(syncEngineImpl,queryView.targetId,viewChange.limboChanges);return _context47.abrupt("return",viewChange.snapshot);case 9:case"end":return _context47.stop();}}});}function syncEngineHandleCredentialChange(syncEngine,user){var syncEngineImpl,userChanged,result;return regeneratorRuntime.async(function syncEngineHandleCredentialChange$(_context48){while(1){switch(_context48.prev=_context48.next){case 0:syncEngineImpl=debugCast(syncEngine);userChanged=!syncEngineImpl.currentUser.isEqual(user);if(!userChanged){_context48.next=12;break;}logDebug(LOG_TAG$7,'User change. New user:',user.toKey());_context48.next=6;return regeneratorRuntime.awrap(handleUserChange(syncEngineImpl.localStore,user));case 6:result=_context48.sent;syncEngineImpl.currentUser=user;// Fails tasks waiting for pending writes requested by previous user.
rejectOutstandingPendingWritesCallbacks(syncEngineImpl,"'waitForPendingWrites' promise is rejected due to a user change.");// TODO(b/114226417): Consider calling this only in the primary tab.
syncEngineImpl.sharedClientState.handleUserChange(user,result.removedBatchIds,result.addedBatchIds);_context48.next=12;return regeneratorRuntime.awrap(emitNewSnapsAndNotifyLocalStore(syncEngineImpl,result.affectedDocuments));case 12:case"end":return _context48.stop();}}});}function getRemoteKeysForTarget(syncEngine,targetId){var syncEngineImpl=debugCast(syncEngine);var limboResolution=syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);if(limboResolution&&limboResolution.receivedDocument){return documentKeySet().add(limboResolution.key);}else{var keySet=documentKeySet();var queries=syncEngineImpl.queriesByTarget.get(targetId);if(!queries){return keySet;}var _iteratorNormalCompletion50=true;var _didIteratorError50=false;var _iteratorError50=undefined;try{for(var _iterator50=queries[Symbol.iterator](),_step50;!(_iteratorNormalCompletion50=(_step50=_iterator50.next()).done);_iteratorNormalCompletion50=true){var query=_step50.value;var queryView=syncEngineImpl.queryViewsByQuery.get(query);keySet=keySet.unionWith(queryView.view.syncedDocuments);}}catch(err){_didIteratorError50=true;_iteratorError50=err;}finally{try{if(!_iteratorNormalCompletion50&&_iterator50["return"]!=null){_iterator50["return"]();}}finally{if(_didIteratorError50){throw _iteratorError50;}}}return keySet;}}function ensureWatchCallbacks(syncEngine){var syncEngineImpl=debugCast(syncEngine);syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent=applyRemoteEvent.bind(null,syncEngineImpl);syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget=getRemoteKeysForTarget.bind(null,syncEngineImpl);syncEngineImpl.remoteStore.remoteSyncer.rejectListen=rejectListen.bind(null,syncEngineImpl);syncEngineImpl.syncEngineListener.onWatchChange=eventManagerOnWatchChange.bind(null,syncEngineImpl.eventManager);syncEngineImpl.syncEngineListener.onWatchError=eventManagerOnWatchError.bind(null,syncEngineImpl.eventManager);return syncEngineImpl;}function ensureWriteCallbacks(syncEngine){var syncEngineImpl=debugCast(syncEngine);syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite=applySuccessfulWrite.bind(null,syncEngineImpl);syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite=rejectFailedWrite.bind(null,syncEngineImpl);return syncEngineImpl;}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // TOOD(b/140938512): Drop SimpleQueryEngine and rename IndexFreeQueryEngine.
/**
 * A query engine that takes advantage of the target document mapping in the
 * QueryCache. The IndexFreeQueryEngine optimizes query execution by only
 * reading the documents that previously matched a query plus any documents that were
 * edited after the query was last listened to.
 *
 * There are some cases where Index-Free queries are not guaranteed to produce
 * the same results as full collection scans. In these cases, the
 * IndexFreeQueryEngine falls back to full query processing. These cases are:
 *
 * - Limit queries where a document that matched the query previously no longer
 *   matches the query.
 *
 * - Limit queries where a document edit may cause the document to sort below
 *   another document that is in the local cache.
 *
 * - Queries that have never been CURRENT or free of Limbo documents.
 */var IndexFreeQueryEngine=/*#__PURE__*/function(){function IndexFreeQueryEngine(){_classCallCheck(this,IndexFreeQueryEngine);}_createClass(IndexFreeQueryEngine,[{key:"setLocalDocumentsView",value:function setLocalDocumentsView(localDocuments){this.localDocumentsView=localDocuments;}},{key:"getDocumentsMatchingQuery",value:function getDocumentsMatchingQuery(transaction,query,lastLimboFreeSnapshotVersion,remoteKeys){var _this65=this;// Queries that match all documents don't benefit from using
// IndexFreeQueries. It is more efficient to scan all documents in a
// collection, rather than to perform individual lookups.
if(matchesAllDocuments(query)){return this.executeFullCollectionScan(transaction,query);}// Queries that have never seen a snapshot without limbo free documents
// should also be run as a full collection scan.
if(lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())){return this.executeFullCollectionScan(transaction,query);}return this.localDocumentsView.getDocuments(transaction,remoteKeys).next(function(documents){var previousResults=_this65.applyQuery(query,documents);if((hasLimitToFirst(query)||hasLimitToLast(query))&&_this65.needsRefill(query.limitType,previousResults,remoteKeys,lastLimboFreeSnapshotVersion)){return _this65.executeFullCollectionScan(transaction,query);}if(getLogLevel()<=_logger.LogLevel.DEBUG){logDebug('IndexFreeQueryEngine','Re-using previous result from %s to execute query: %s',lastLimboFreeSnapshotVersion.toString(),stringifyQuery(query));}// Retrieve all results for documents that were updated since the last
// limbo-document free remote snapshot.
return _this65.localDocumentsView.getDocumentsMatchingQuery(transaction,query,lastLimboFreeSnapshotVersion).next(function(updatedResults){// We merge `previousResults` into `updateResults`, since
// `updateResults` is already a DocumentMap. If a document is
// contained in both lists, then its contents are the same.
previousResults.forEach(function(doc){updatedResults=updatedResults.insert(doc.key,doc);});return updatedResults;});});}/** Applies the query filter and sorting to the provided documents.  */},{key:"applyQuery",value:function applyQuery(query,documents){// Sort the documents and re-apply the query filter since previously
// matching documents do not necessarily still match the query.
var queryResults=new SortedSet(newQueryComparator(query));documents.forEach(function(_,maybeDoc){if(maybeDoc instanceof Document&&queryMatches(query,maybeDoc)){queryResults=queryResults.add(maybeDoc);}});return queryResults;}/**
     * Determines if a limit query needs to be refilled from cache, making it
     * ineligible for index-free execution.
     *
     * @param sortedPreviousResults The documents that matched the query when it
     * was last synchronized, sorted by the query's comparator.
     * @param remoteKeys The document keys that matched the query at the last
     * snapshot.
     * @param limboFreeSnapshotVersion The version of the snapshot when the query
     * was last synchronized.
     */},{key:"needsRefill",value:function needsRefill(limitType,sortedPreviousResults,remoteKeys,limboFreeSnapshotVersion){// The query needs to be refilled if a previously matching document no
// longer matches.
if(remoteKeys.size!==sortedPreviousResults.size){return true;}// Limit queries are not eligible for index-free query execution if there is
// a potential that an older document from cache now sorts before a document
// that was previously part of the limit. This, however, can only happen if
// the document at the edge of the limit goes out of limit.
// If a document that is not the limit boundary sorts differently,
// the boundary of the limit itself did not change and documents from cache
// will continue to be "rejected" by this boundary. Therefore, we can ignore
// any modifications that don't affect the last document.
var docAtLimitEdge=limitType==="F"/* First */?sortedPreviousResults.last():sortedPreviousResults.first();if(!docAtLimitEdge){// We don't need to refill the query if there were already no documents.
return false;}return docAtLimitEdge.hasPendingWrites||docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion)>0;}},{key:"executeFullCollectionScan",value:function executeFullCollectionScan(transaction,query){if(getLogLevel()<=_logger.LogLevel.DEBUG){logDebug('IndexFreeQueryEngine','Using full collection scan to execute query:',stringifyQuery(query));}return this.localDocumentsView.getDocumentsMatchingQuery(transaction,query,SnapshotVersion.min());}}]);return IndexFreeQueryEngine;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var MemoryMutationQueue=/*#__PURE__*/function(){function MemoryMutationQueue(indexManager,referenceDelegate){_classCallCheck(this,MemoryMutationQueue);this.indexManager=indexManager;this.referenceDelegate=referenceDelegate;/**
         * The set of all mutations that have been sent but not yet been applied to
         * the backend.
         */this.mutationQueue=[];/** Next value to use when assigning sequential IDs to each mutation batch. */this.nextBatchId=1;/** An ordered mapping between documents and the mutations batch IDs. */this.batchesByDocumentKey=new SortedSet(DocReference.compareByKey);}_createClass(MemoryMutationQueue,[{key:"checkEmpty",value:function checkEmpty(transaction){return PersistencePromise.resolve(this.mutationQueue.length===0);}},{key:"addMutationBatch",value:function addMutationBatch(transaction,localWriteTime,baseMutations,mutations){var batchId=this.nextBatchId;this.nextBatchId++;if(this.mutationQueue.length>0){var prior=this.mutationQueue[this.mutationQueue.length-1];}var batch=new MutationBatch(batchId,localWriteTime,baseMutations,mutations);this.mutationQueue.push(batch);// Track references by document key and index collection parents.
var _iteratorNormalCompletion51=true;var _didIteratorError51=false;var _iteratorError51=undefined;try{for(var _iterator51=mutations[Symbol.iterator](),_step51;!(_iteratorNormalCompletion51=(_step51=_iterator51.next()).done);_iteratorNormalCompletion51=true){var mutation=_step51.value;this.batchesByDocumentKey=this.batchesByDocumentKey.add(new DocReference(mutation.key,batchId));this.indexManager.addToCollectionParentIndex(transaction,mutation.key.path.popLast());}}catch(err){_didIteratorError51=true;_iteratorError51=err;}finally{try{if(!_iteratorNormalCompletion51&&_iterator51["return"]!=null){_iterator51["return"]();}}finally{if(_didIteratorError51){throw _iteratorError51;}}}return PersistencePromise.resolve(batch);}},{key:"lookupMutationBatch",value:function lookupMutationBatch(transaction,batchId){return PersistencePromise.resolve(this.findMutationBatch(batchId));}},{key:"getNextMutationBatchAfterBatchId",value:function getNextMutationBatchAfterBatchId(transaction,batchId){var nextBatchId=batchId+1;// The requested batchId may still be out of range so normalize it to the
// start of the queue.
var rawIndex=this.indexOfBatchId(nextBatchId);var index=rawIndex<0?0:rawIndex;return PersistencePromise.resolve(this.mutationQueue.length>index?this.mutationQueue[index]:null);}},{key:"getHighestUnacknowledgedBatchId",value:function getHighestUnacknowledgedBatchId(){return PersistencePromise.resolve(this.mutationQueue.length===0?BATCHID_UNKNOWN:this.nextBatchId-1);}},{key:"getAllMutationBatches",value:function getAllMutationBatches(transaction){return PersistencePromise.resolve(this.mutationQueue.slice());}},{key:"getAllMutationBatchesAffectingDocumentKey",value:function getAllMutationBatchesAffectingDocumentKey(transaction,documentKey){var _this66=this;var start=new DocReference(documentKey,0);var end=new DocReference(documentKey,Number.POSITIVE_INFINITY);var result=[];this.batchesByDocumentKey.forEachInRange([start,end],function(ref){var batch=_this66.findMutationBatch(ref.targetOrBatchId);result.push(batch);});return PersistencePromise.resolve(result);}},{key:"getAllMutationBatchesAffectingDocumentKeys",value:function getAllMutationBatchesAffectingDocumentKeys(transaction,documentKeys){var _this67=this;var uniqueBatchIDs=new SortedSet(primitiveComparator);documentKeys.forEach(function(documentKey){var start=new DocReference(documentKey,0);var end=new DocReference(documentKey,Number.POSITIVE_INFINITY);_this67.batchesByDocumentKey.forEachInRange([start,end],function(ref){uniqueBatchIDs=uniqueBatchIDs.add(ref.targetOrBatchId);});});return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));}},{key:"getAllMutationBatchesAffectingQuery",value:function getAllMutationBatchesAffectingQuery(transaction,query){// Use the query path as a prefix for testing if a document matches the
// query.
var prefix=query.path;var immediateChildrenPathLength=prefix.length+1;// Construct a document reference for actually scanning the index. Unlike
// the prefix the document key in this reference must have an even number of
// segments. The empty segment can be used a suffix of the query path
// because it precedes all other segments in an ordered traversal.
var startPath=prefix;if(!DocumentKey.isDocumentKey(startPath)){startPath=startPath.child('');}var start=new DocReference(new DocumentKey(startPath),0);// Find unique batchIDs referenced by all documents potentially matching the
// query.
var uniqueBatchIDs=new SortedSet(primitiveComparator);this.batchesByDocumentKey.forEachWhile(function(ref){var rowKeyPath=ref.key.path;if(!prefix.isPrefixOf(rowKeyPath)){return false;}else{// Rows with document keys more than one segment longer than the query
// path can't be matches. For example, a query on 'rooms' can't match
// the document /rooms/abc/messages/xyx.
// TODO(mcg): we'll need a different scanner when we implement
// ancestor queries.
if(rowKeyPath.length===immediateChildrenPathLength){uniqueBatchIDs=uniqueBatchIDs.add(ref.targetOrBatchId);}return true;}},start);return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));}},{key:"findMutationBatches",value:function findMutationBatches(batchIDs){var _this68=this;// Construct an array of matching batches, sorted by batchID to ensure that
// multiple mutations affecting the same document key are applied in order.
var result=[];batchIDs.forEach(function(batchId){var batch=_this68.findMutationBatch(batchId);if(batch!==null){result.push(batch);}});return result;}},{key:"removeMutationBatch",value:function removeMutationBatch(transaction,batch){var _this69=this;// Find the position of the first batch for removal.
var batchIndex=this.indexOfExistingBatchId(batch.batchId,'removed');hardAssert(batchIndex===0);this.mutationQueue.shift();var references=this.batchesByDocumentKey;return PersistencePromise.forEach(batch.mutations,function(mutation){var ref=new DocReference(mutation.key,batch.batchId);references=references["delete"](ref);return _this69.referenceDelegate.markPotentiallyOrphaned(transaction,mutation.key);}).next(function(){_this69.batchesByDocumentKey=references;});}},{key:"removeCachedMutationKeys",value:function removeCachedMutationKeys(batchId){// No-op since the memory mutation queue does not maintain a separate cache.
}},{key:"containsKey",value:function containsKey(txn,key){var ref=new DocReference(key,0);var firstRef=this.batchesByDocumentKey.firstAfterOrEqual(ref);return PersistencePromise.resolve(key.isEqual(firstRef&&firstRef.key));}},{key:"performConsistencyCheck",value:function performConsistencyCheck(txn){if(this.mutationQueue.length===0);return PersistencePromise.resolve();}/**
     * Finds the index of the given batchId in the mutation queue and asserts that
     * the resulting index is within the bounds of the queue.
     *
     * @param batchId The batchId to search for
     * @param action A description of what the caller is doing, phrased in passive
     * form (e.g. "acknowledged" in a routine that acknowledges batches).
     */},{key:"indexOfExistingBatchId",value:function indexOfExistingBatchId(batchId,action){var index=this.indexOfBatchId(batchId);return index;}/**
     * Finds the index of the given batchId in the mutation queue. This operation
     * is O(1).
     *
     * @return The computed index of the batch with the given batchId, based on
     * the state of the queue. Note this index can be negative if the requested
     * batchId has already been remvoed from the queue or past the end of the
     * queue if the batchId is larger than the last added batch.
     */},{key:"indexOfBatchId",value:function indexOfBatchId(batchId){if(this.mutationQueue.length===0){// As an index this is past the end of the queue
return 0;}// Examine the front of the queue to figure out the difference between the
// batchId and indexes in the array. Note that since the queue is ordered
// by batchId, if the first batch has a larger batchId then the requested
// batchId doesn't exist in the queue.
var firstBatchId=this.mutationQueue[0].batchId;return batchId-firstBatchId;}/**
     * A version of lookupMutationBatch that doesn't return a promise, this makes
     * other functions that uses this code easier to read and more efficent.
     */},{key:"findMutationBatch",value:function findMutationBatch(batchId){var index=this.indexOfBatchId(batchId);if(index<0||index>=this.mutationQueue.length){return null;}var batch=this.mutationQueue[index];return batch;}}]);return MemoryMutationQueue;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function documentEntryMap(){return new SortedMap(DocumentKey.comparator);}var MemoryRemoteDocumentCache=/*#__PURE__*/function(){/**
     * @param sizer Used to assess the size of a document. For eager GC, this is expected to just
     * return 0 to avoid unnecessarily doing the work of calculating the size.
     */function MemoryRemoteDocumentCache(indexManager,sizer){_classCallCheck(this,MemoryRemoteDocumentCache);this.indexManager=indexManager;this.sizer=sizer;/** Underlying cache of documents and their read times. */this.docs=documentEntryMap();/** Size of all cached documents. */this.size=0;}/**
     * Adds the supplied entry to the cache and updates the cache size as appropriate.
     *
     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer
     * returned by `newChangeBuffer()`.
     */_createClass(MemoryRemoteDocumentCache,[{key:"addEntry",value:function addEntry(transaction,doc,readTime){var key=doc.key;var entry=this.docs.get(key);var previousSize=entry?entry.size:0;var currentSize=this.sizer(doc);this.docs=this.docs.insert(key,{maybeDocument:doc,size:currentSize,readTime:readTime});this.size+=currentSize-previousSize;return this.indexManager.addToCollectionParentIndex(transaction,key.path.popLast());}/**
     * Removes the specified entry from the cache and updates the cache size as appropriate.
     *
     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer
     * returned by `newChangeBuffer()`.
     */},{key:"removeEntry",value:function removeEntry(documentKey){var entry=this.docs.get(documentKey);if(entry){this.docs=this.docs.remove(documentKey);this.size-=entry.size;}}},{key:"getEntry",value:function getEntry(transaction,documentKey){var entry=this.docs.get(documentKey);return PersistencePromise.resolve(entry?entry.maybeDocument:null);}},{key:"getEntries",value:function getEntries(transaction,documentKeys){var _this70=this;var results=nullableMaybeDocumentMap();documentKeys.forEach(function(documentKey){var entry=_this70.docs.get(documentKey);results=results.insert(documentKey,entry?entry.maybeDocument:null);});return PersistencePromise.resolve(results);}},{key:"getDocumentsMatchingQuery",value:function getDocumentsMatchingQuery(transaction,query,sinceReadTime){var results=documentMap();// Documents are ordered by key, so we can use a prefix scan to narrow down
// the documents we need to match the query against.
var prefix=new DocumentKey(query.path.child(''));var iterator=this.docs.getIteratorFrom(prefix);while(iterator.hasNext()){var _iterator$getNext=iterator.getNext(),key=_iterator$getNext.key,_iterator$getNext$val=_iterator$getNext.value,maybeDocument=_iterator$getNext$val.maybeDocument,readTime=_iterator$getNext$val.readTime;if(!query.path.isPrefixOf(key.path)){break;}if(readTime.compareTo(sinceReadTime)<=0){continue;}if(maybeDocument instanceof Document&&queryMatches(query,maybeDocument)){results=results.insert(maybeDocument.key,maybeDocument);}}return PersistencePromise.resolve(results);}},{key:"forEachDocumentKey",value:function forEachDocumentKey(transaction,f){return PersistencePromise.forEach(this.docs,function(key){return f(key);});}},{key:"newChangeBuffer",value:function newChangeBuffer(options){// `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps
// a separate changelog and does not need special handling for removals.
return new MemoryRemoteDocumentCache.RemoteDocumentChangeBuffer(this);}},{key:"getSize",value:function getSize(txn){return PersistencePromise.resolve(this.size);}}]);return MemoryRemoteDocumentCache;}();/**
 * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.
 */MemoryRemoteDocumentCache.RemoteDocumentChangeBuffer=/*#__PURE__*/function(_RemoteDocumentChange){_inherits(_class,_RemoteDocumentChange);function _class(documentCache){var _this71;_classCallCheck(this,_class);_this71=_possibleConstructorReturn(this,_getPrototypeOf(_class).call(this));_this71.documentCache=documentCache;return _this71;}_createClass(_class,[{key:"applyChanges",value:function applyChanges(transaction){var _this72=this;var promises=[];this.changes.forEach(function(key,doc){if(doc){promises.push(_this72.documentCache.addEntry(transaction,doc,_this72.readTime));}else{_this72.documentCache.removeEntry(key);}});return PersistencePromise.waitFor(promises);}},{key:"getFromCache",value:function getFromCache(transaction,documentKey){return this.documentCache.getEntry(transaction,documentKey);}},{key:"getAllFromCache",value:function getAllFromCache(transaction,documentKeys){return this.documentCache.getEntries(transaction,documentKeys);}}]);return _class;}(RemoteDocumentChangeBuffer);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var MemoryTargetCache=/*#__PURE__*/function(){function MemoryTargetCache(persistence){_classCallCheck(this,MemoryTargetCache);this.persistence=persistence;/**
         * Maps a target to the data about that target
         */this.targets=new ObjectMap(function(t){return canonifyTarget(t);},targetEquals);/** The last received snapshot version. */this.lastRemoteSnapshotVersion=SnapshotVersion.min();/** The highest numbered target ID encountered. */this.highestTargetId=0;/** The highest sequence number encountered. */this.highestSequenceNumber=0;/**
         * A ordered bidirectional mapping between documents and the remote target
         * IDs.
         */this.references=new ReferenceSet();this.targetCount=0;this.targetIdGenerator=TargetIdGenerator.forTargetCache();}_createClass(MemoryTargetCache,[{key:"forEachTarget",value:function forEachTarget(txn,f){this.targets.forEach(function(_,targetData){return f(targetData);});return PersistencePromise.resolve();}},{key:"getLastRemoteSnapshotVersion",value:function getLastRemoteSnapshotVersion(transaction){return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);}},{key:"getHighestSequenceNumber",value:function getHighestSequenceNumber(transaction){return PersistencePromise.resolve(this.highestSequenceNumber);}},{key:"allocateTargetId",value:function allocateTargetId(transaction){this.highestTargetId=this.targetIdGenerator.next();return PersistencePromise.resolve(this.highestTargetId);}},{key:"setTargetsMetadata",value:function setTargetsMetadata(transaction,highestListenSequenceNumber,lastRemoteSnapshotVersion){if(lastRemoteSnapshotVersion){this.lastRemoteSnapshotVersion=lastRemoteSnapshotVersion;}if(highestListenSequenceNumber>this.highestSequenceNumber){this.highestSequenceNumber=highestListenSequenceNumber;}return PersistencePromise.resolve();}},{key:"saveTargetData",value:function saveTargetData(targetData){this.targets.set(targetData.target,targetData);var targetId=targetData.targetId;if(targetId>this.highestTargetId){this.targetIdGenerator=new TargetIdGenerator(targetId);this.highestTargetId=targetId;}if(targetData.sequenceNumber>this.highestSequenceNumber){this.highestSequenceNumber=targetData.sequenceNumber;}}},{key:"addTargetData",value:function addTargetData(transaction,targetData){this.saveTargetData(targetData);this.targetCount+=1;return PersistencePromise.resolve();}},{key:"updateTargetData",value:function updateTargetData(transaction,targetData){this.saveTargetData(targetData);return PersistencePromise.resolve();}},{key:"removeTargetData",value:function removeTargetData(transaction,targetData){this.targets["delete"](targetData.target);this.references.removeReferencesForId(targetData.targetId);this.targetCount-=1;return PersistencePromise.resolve();}},{key:"removeTargets",value:function removeTargets(transaction,upperBound,activeTargetIds){var _this73=this;var count=0;var removals=[];this.targets.forEach(function(key,targetData){if(targetData.sequenceNumber<=upperBound&&activeTargetIds.get(targetData.targetId)===null){_this73.targets["delete"](key);removals.push(_this73.removeMatchingKeysForTargetId(transaction,targetData.targetId));count++;}});return PersistencePromise.waitFor(removals).next(function(){return count;});}},{key:"getTargetCount",value:function getTargetCount(transaction){return PersistencePromise.resolve(this.targetCount);}},{key:"getTargetData",value:function getTargetData(transaction,target){var targetData=this.targets.get(target)||null;return PersistencePromise.resolve(targetData);}},{key:"addMatchingKeys",value:function addMatchingKeys(txn,keys,targetId){this.references.addReferences(keys,targetId);return PersistencePromise.resolve();}},{key:"removeMatchingKeys",value:function removeMatchingKeys(txn,keys,targetId){this.references.removeReferences(keys,targetId);var referenceDelegate=this.persistence.referenceDelegate;var promises=[];if(referenceDelegate){keys.forEach(function(key){promises.push(referenceDelegate.markPotentiallyOrphaned(txn,key));});}return PersistencePromise.waitFor(promises);}},{key:"removeMatchingKeysForTargetId",value:function removeMatchingKeysForTargetId(txn,targetId){this.references.removeReferencesForId(targetId);return PersistencePromise.resolve();}},{key:"getMatchingKeysForTargetId",value:function getMatchingKeysForTargetId(txn,targetId){var matchingKeys=this.references.referencesForId(targetId);return PersistencePromise.resolve(matchingKeys);}},{key:"containsKey",value:function containsKey(txn,key){return PersistencePromise.resolve(this.references.containsKey(key));}}]);return MemoryTargetCache;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$8='MemoryPersistence';/**
 * A memory-backed instance of Persistence. Data is stored only in RAM and
 * not persisted across sessions.
 */var MemoryPersistence=/*#__PURE__*/function(){/**
     * The constructor accepts a factory for creating a reference delegate. This
     * allows both the delegate and this instance to have strong references to
     * each other without having nullable fields that would then need to be
     * checked or asserted on every access.
     */function MemoryPersistence(referenceDelegateFactory){var _this74=this;_classCallCheck(this,MemoryPersistence);this.mutationQueues={};this.listenSequence=new ListenSequence(0);this._started=false;this._started=true;this.referenceDelegate=referenceDelegateFactory(this);this.targetCache=new MemoryTargetCache(this);var sizer=function sizer(doc){return _this74.referenceDelegate.documentSize(doc);};this.indexManager=new MemoryIndexManager();this.remoteDocumentCache=new MemoryRemoteDocumentCache(this.indexManager,sizer);}_createClass(MemoryPersistence,[{key:"start",value:function start(){return Promise.resolve();}},{key:"shutdown",value:function shutdown(){// No durable state to ensure is closed on shutdown.
this._started=false;return Promise.resolve();}},{key:"setDatabaseDeletedListener",value:function setDatabaseDeletedListener(){// No op.
}},{key:"setNetworkEnabled",value:function setNetworkEnabled(){// No op.
}},{key:"getIndexManager",value:function getIndexManager(){return this.indexManager;}},{key:"getMutationQueue",value:function getMutationQueue(user){var queue=this.mutationQueues[user.toKey()];if(!queue){queue=new MemoryMutationQueue(this.indexManager,this.referenceDelegate);this.mutationQueues[user.toKey()]=queue;}return queue;}},{key:"getTargetCache",value:function getTargetCache(){return this.targetCache;}},{key:"getRemoteDocumentCache",value:function getRemoteDocumentCache(){return this.remoteDocumentCache;}},{key:"runTransaction",value:function runTransaction(action,mode,transactionOperation){var _this75=this;logDebug(LOG_TAG$8,'Starting transaction:',action);var txn=new MemoryTransaction(this.listenSequence.next());this.referenceDelegate.onTransactionStarted();return transactionOperation(txn).next(function(result){return _this75.referenceDelegate.onTransactionCommitted(txn).next(function(){return result;});}).toPromise().then(function(result){txn.raiseOnCommittedEvent();return result;});}},{key:"mutationQueuesContainKey",value:function mutationQueuesContainKey(transaction,key){return PersistencePromise.or(Object.values(this.mutationQueues).map(function(queue){return function(){return queue.containsKey(transaction,key);};}));}},{key:"started",get:function get(){return this._started;}}]);return MemoryPersistence;}();/**
 * Memory persistence is not actually transactional, but future implementations
 * may have transaction-scoped state.
 */var MemoryTransaction=/*#__PURE__*/function(_PersistenceTransacti){_inherits(MemoryTransaction,_PersistenceTransacti);function MemoryTransaction(currentSequenceNumber){var _this76;_classCallCheck(this,MemoryTransaction);_this76=_possibleConstructorReturn(this,_getPrototypeOf(MemoryTransaction).call(this));_this76.currentSequenceNumber=currentSequenceNumber;return _this76;}return MemoryTransaction;}(PersistenceTransaction);var MemoryEagerDelegate=/*#__PURE__*/function(){function MemoryEagerDelegate(persistence){_classCallCheck(this,MemoryEagerDelegate);this.persistence=persistence;/** Tracks all documents that are active in Query views. */this.localViewReferences=new ReferenceSet();/** The list of documents that are potentially GCed after each transaction. */this._orphanedDocuments=null;}_createClass(MemoryEagerDelegate,[{key:"addReference",value:function addReference(txn,targetId,key){this.localViewReferences.addReference(key,targetId);this.orphanedDocuments["delete"](key.toString());return PersistencePromise.resolve();}},{key:"removeReference",value:function removeReference(txn,targetId,key){this.localViewReferences.removeReference(key,targetId);this.orphanedDocuments.add(key.toString());return PersistencePromise.resolve();}},{key:"markPotentiallyOrphaned",value:function markPotentiallyOrphaned(txn,key){this.orphanedDocuments.add(key.toString());return PersistencePromise.resolve();}},{key:"removeTarget",value:function removeTarget(txn,targetData){var _this77=this;var orphaned=this.localViewReferences.removeReferencesForId(targetData.targetId);orphaned.forEach(function(key){return _this77.orphanedDocuments.add(key.toString());});var cache=this.persistence.getTargetCache();return cache.getMatchingKeysForTargetId(txn,targetData.targetId).next(function(keys){keys.forEach(function(key){return _this77.orphanedDocuments.add(key.toString());});}).next(function(){return cache.removeTargetData(txn,targetData);});}},{key:"onTransactionStarted",value:function onTransactionStarted(){this._orphanedDocuments=new Set();}},{key:"onTransactionCommitted",value:function onTransactionCommitted(txn){var _this78=this;// Remove newly orphaned documents.
var cache=this.persistence.getRemoteDocumentCache();var changeBuffer=cache.newChangeBuffer();return PersistencePromise.forEach(this.orphanedDocuments,function(path){var key=DocumentKey.fromPath(path);return _this78.isReferenced(txn,key).next(function(isReferenced){if(!isReferenced){changeBuffer.removeEntry(key);}});}).next(function(){_this78._orphanedDocuments=null;return changeBuffer.apply(txn);});}},{key:"updateLimboDocument",value:function updateLimboDocument(txn,key){var _this79=this;return this.isReferenced(txn,key).next(function(isReferenced){if(isReferenced){_this79.orphanedDocuments["delete"](key.toString());}else{_this79.orphanedDocuments.add(key.toString());}});}},{key:"documentSize",value:function documentSize(doc){// For eager GC, we don't care about the document size, there are no size thresholds.
return 0;}},{key:"isReferenced",value:function isReferenced(txn,key){var _this80=this;return PersistencePromise.or([function(){return PersistencePromise.resolve(_this80.localViewReferences.containsKey(key));},function(){return _this80.persistence.getTargetCache().containsKey(txn,key);},function(){return _this80.persistence.mutationQueuesContainKey(txn,key);}]);}},{key:"orphanedDocuments",get:function get(){if(!this._orphanedDocuments){throw fail();}else{return this._orphanedDocuments;}}}],[{key:"factory",value:function factory(persistence){return new MemoryEagerDelegate(persistence);}}]);return MemoryEagerDelegate;}();/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Used by tests so we can match @grpc/proto-loader behavior. */var protoLoaderOptions={longs:String,enums:String,defaults:true,oneofs:false};/**
 * Loads the protocol buffer definitions for Firestore.
 *
 * @returns The GrpcObject representing our protos.
 */function loadProtos(){var root=(0,_path2.resolve)(__dirname,"src/protos");var firestoreProtoFile=(0,_path2.join)(root,'google/firestore/v1/firestore.proto');var packageDefinition=(0,_protoLoader.loadSync)(firestoreProtoFile,Object.assign(Object.assign({},protoLoaderOptions),{includeDirs:[root]}));return(0,_grpcJs.loadPackageDefinition)(packageDefinition);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Provides a simple helper class that implements the Stream interface to
 * bridge to other implementations that are streams but do not implement the
 * interface. The stream callbacks are invoked with the callOn... methods.
 */var StreamBridge=/*#__PURE__*/function(){function StreamBridge(args){_classCallCheck(this,StreamBridge);this.sendFn=args.sendFn;this.closeFn=args.closeFn;}_createClass(StreamBridge,[{key:"onOpen",value:function onOpen(callback){this.wrappedOnOpen=callback;}},{key:"onClose",value:function onClose(callback){this.wrappedOnClose=callback;}},{key:"onMessage",value:function onMessage(callback){this.wrappedOnMessage=callback;}},{key:"close",value:function close(){this.closeFn();}},{key:"send",value:function send(msg){this.sendFn(msg);}},{key:"callOnOpen",value:function callOnOpen(){this.wrappedOnOpen();}},{key:"callOnClose",value:function callOnClose(err){this.wrappedOnClose(err);}},{key:"callOnMessage",value:function callOnMessage(msg){this.wrappedOnMessage(msg);}}]);return StreamBridge;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /*
 * Utilities for dealing with node.js-style APIs. See nodePromise for more
 * details.
 */ /**
 * Creates a node-style callback that resolves or rejects a new Promise. The
 * callback is passed to the given action which can then use the callback as
 * a parameter to a node-style function.
 *
 * The intent is to directly bridge a node-style function (which takes a
 * callback) into a Promise without manually converting between the node-style
 * callback and the promise at each call.
 *
 * In effect it allows you to convert:
 *
 * @example
 * new Promise((resolve: (value?: fs.Stats) => void,
 *              reject: (error?: any) => void) => {
 *   fs.stat(path, (error?: any, stat?: fs.Stats) => {
 *     if (error) {
 *       reject(error);
 *     } else {
 *       resolve(stat);
 *     }
 *   });
 * });
 *
 * Into
 * @example
 * nodePromise((callback: NodeCallback<fs.Stats>) => {
 *   fs.stat(path, callback);
 * });
 *
 * @param action a function that takes a node-style callback as an argument and
 *     then uses that callback to invoke some node-style API.
 * @return a new Promise which will be rejected if the callback is given the
 *     first Error parameter or will resolve to the value given otherwise.
 */function nodePromise(action){return new Promise(function(resolve,reject){action(function(error,value){if(error){reject(error);}else{resolve(value);}});});}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$9='Connection';var X_GOOG_API_CLIENT_VALUE="gl-node/".concat(process.versions.node," fire/").concat(version," grpc/").concat(_package.version);function createMetadata(databasePath,token){hardAssert(token===null||token.type==='OAuth');var metadata=new _grpcJs.Metadata();if(token){for(var header in token.authHeaders){if(token.authHeaders.hasOwnProperty(header)){metadata.set(header,token.authHeaders[header]);}}}metadata.set('x-goog-api-client',X_GOOG_API_CLIENT_VALUE);// This header is used to improve routing and project isolation by the
// backend.
metadata.set('google-cloud-resource-prefix',databasePath);return metadata;}/**
 * A Connection implemented by GRPC-Node.
 */var GrpcConnection=/*#__PURE__*/function(){function GrpcConnection(protos,databaseInfo){_classCallCheck(this,GrpcConnection);this.databaseInfo=databaseInfo;// We cache stubs for the most-recently-used token.
this.cachedStub=null;// eslint-disable-next-line @typescript-eslint/no-explicit-any
this.firestore=protos['google']['firestore']['v1'];this.databasePath="projects/".concat(databaseInfo.databaseId.projectId,"/databases/").concat(databaseInfo.databaseId.database);}_createClass(GrpcConnection,[{key:"ensureActiveStub",value:function ensureActiveStub(){if(!this.cachedStub){logDebug(LOG_TAG$9,'Creating Firestore stub.');var credentials$1=this.databaseInfo.ssl?_grpcJs.credentials.createSsl():_grpcJs.credentials.createInsecure();this.cachedStub=new this.firestore.Firestore(this.databaseInfo.host,credentials$1);}return this.cachedStub;}},{key:"invokeRPC",value:function invokeRPC(rpcName,path,request,token){var stub=this.ensureActiveStub();var metadata=createMetadata(this.databasePath,token);var jsonRequest=Object.assign({database:this.databasePath},request);return nodePromise(function(callback){logDebug(LOG_TAG$9,"RPC '".concat(rpcName,"' invoked with request:"),request);return stub[rpcName](jsonRequest,metadata,function(grpcError,value){if(grpcError){logDebug(LOG_TAG$9,"RPC '".concat(rpcName,"' failed with error:"),grpcError);callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code),grpcError.message));}else{logDebug(LOG_TAG$9,"RPC '".concat(rpcName,"' completed with response:"),value);callback(undefined,value);}});});}},{key:"invokeStreamingRPC",value:function invokeStreamingRPC(rpcName,path,request,token){var results=[];var responseDeferred=new Deferred();logDebug(LOG_TAG$9,"RPC '".concat(rpcName,"' invoked (streaming) with request:"),request);var stub=this.ensureActiveStub();var metadata=createMetadata(this.databasePath,token);var jsonRequest=Object.assign(Object.assign({},request),{database:this.databasePath});var stream=stub[rpcName](jsonRequest,metadata);stream.on('data',function(response){logDebug(LOG_TAG$9,"RPC ".concat(rpcName," received result:"),response);results.push(response);});stream.on('end',function(){logDebug(LOG_TAG$9,"RPC '".concat(rpcName,"' completed."));responseDeferred.resolve(results);});stream.on('error',function(grpcError){logDebug(LOG_TAG$9,"RPC '".concat(rpcName,"' failed with error:"),grpcError);var code=mapCodeFromRpcCode(grpcError.code);responseDeferred.reject(new FirestoreError(code,grpcError.message));});return responseDeferred.promise;}// TODO(mikelehen): This "method" is a monster. Should be refactored.
},{key:"openStream",value:function openStream(rpcName,token){var stub=this.ensureActiveStub();var metadata=createMetadata(this.databasePath,token);var grpcStream=stub[rpcName](metadata);var closed=false;var close=function close(err){if(!closed){closed=true;stream.callOnClose(err);grpcStream.end();}};var stream=new StreamBridge({sendFn:function sendFn(msg){if(!closed){logDebug(LOG_TAG$9,'GRPC stream sending:',msg);try{grpcStream.write(msg);}catch(e){// This probably means we didn't conform to the proto.  Make sure to
// log the message we sent.
logError('Failure sending:',msg);logError('Error:',e);throw e;}}else{logDebug(LOG_TAG$9,'Not sending because gRPC stream is closed:',msg);}},closeFn:function closeFn(){logDebug(LOG_TAG$9,'GRPC stream closed locally via close().');close();}});grpcStream.on('data',function(msg){if(!closed){logDebug(LOG_TAG$9,'GRPC stream received:',msg);stream.callOnMessage(msg);}});grpcStream.on('end',function(){logDebug(LOG_TAG$9,'GRPC stream ended.');close();});grpcStream.on('error',function(grpcError){if(!closed){logWarn(LOG_TAG$9,'GRPC stream error. Code:',grpcError.code,'Message:',grpcError.message);var code=mapCodeFromRpcCode(grpcError.code);close(new FirestoreError(code,grpcError.message));}});logDebug(LOG_TAG$9,'Opening GRPC stream');// TODO(dimond): Since grpc has no explicit open status (or does it?) we
// simulate an onOpen in the next loop after the stream had it's listeners
// registered
setTimeout(function(){stream.callOnOpen();},0);return stream;}}]);return GrpcConnection;}();/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var NoopConnectivityMonitor=/*#__PURE__*/function(){function NoopConnectivityMonitor(){_classCallCheck(this,NoopConnectivityMonitor);}_createClass(NoopConnectivityMonitor,[{key:"addCallback",value:function addCallback(callback){// No-op.
}},{key:"shutdown",value:function shutdown(){// No-op.
}}]);return NoopConnectivityMonitor;}();/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /** Loads the GRPC stack */function newConnection(databaseInfo){var protos=loadProtos();return new GrpcConnection(protos,databaseInfo);}/** Return the Platform-specific connectivity monitor. */function newConnectivityMonitor(){return new NoopConnectivityMonitor();}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function newSerializer(databaseId){return new JsonProtoSerializer(databaseId,/* useProto3Json= */false);}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var MEMORY_ONLY_PERSISTENCE_ERROR_MESSAGE='You are using the memory-only build of Firestore. Persistence support is '+'only available via the @firebase/firestore bundle or the '+'firebase-firestore.js build.';/**
 * Provides all components needed for Firestore with in-memory persistence.
 * Uses EagerGC garbage collection.
 */var MemoryOfflineComponentProvider=/*#__PURE__*/function(){function MemoryOfflineComponentProvider(){_classCallCheck(this,MemoryOfflineComponentProvider);}_createClass(MemoryOfflineComponentProvider,[{key:"initialize",value:function initialize(cfg){return regeneratorRuntime.async(function initialize$(_context49){while(1){switch(_context49.prev=_context49.next){case 0:this.sharedClientState=this.createSharedClientState(cfg);this.persistence=this.createPersistence(cfg);_context49.next=4;return regeneratorRuntime.awrap(this.persistence.start());case 4:this.gcScheduler=this.createGarbageCollectionScheduler(cfg);this.localStore=this.createLocalStore(cfg);case 6:case"end":return _context49.stop();}}},null,this);}},{key:"createGarbageCollectionScheduler",value:function createGarbageCollectionScheduler(cfg){return null;}},{key:"createLocalStore",value:function createLocalStore(cfg){return newLocalStore(this.persistence,new IndexFreeQueryEngine(),cfg.initialUser);}},{key:"createPersistence",value:function createPersistence(cfg){if(cfg.persistenceSettings.durable){throw new FirestoreError(Code.FAILED_PRECONDITION,MEMORY_ONLY_PERSISTENCE_ERROR_MESSAGE);}return new MemoryPersistence(MemoryEagerDelegate.factory);}},{key:"createSharedClientState",value:function createSharedClientState(cfg){return new MemorySharedClientState();}},{key:"terminate",value:function terminate(){return regeneratorRuntime.async(function terminate$(_context50){while(1){switch(_context50.prev=_context50.next){case 0:if(this.gcScheduler){this.gcScheduler.stop();}_context50.next=3;return regeneratorRuntime.awrap(this.sharedClientState.shutdown());case 3:_context50.next=5;return regeneratorRuntime.awrap(this.persistence.shutdown());case 5:case"end":return _context50.stop();}}},null,this);}},{key:"clearPersistence",value:function clearPersistence(databaseId,persistenceKey){throw new FirestoreError(Code.FAILED_PRECONDITION,MEMORY_ONLY_PERSISTENCE_ERROR_MESSAGE);}}]);return MemoryOfflineComponentProvider;}();/**
 * Initializes and wires the components that are needed to interface with the
 * network.
 */var OnlineComponentProvider=/*#__PURE__*/function(){function OnlineComponentProvider(){_classCallCheck(this,OnlineComponentProvider);}_createClass(OnlineComponentProvider,[{key:"initialize",value:function initialize(offlineComponentProvider,cfg){var _this81=this;return regeneratorRuntime.async(function initialize$(_context51){while(1){switch(_context51.prev=_context51.next){case 0:if(!this.localStore){_context51.next=2;break;}return _context51.abrupt("return");case 2:this.localStore=offlineComponentProvider.localStore;this.sharedClientState=offlineComponentProvider.sharedClientState;this.datastore=this.createDatastore(cfg);this.remoteStore=this.createRemoteStore(cfg);this.eventManager=this.createEventManager(cfg);this.syncEngine=this.createSyncEngine(cfg);this.sharedClientState.onlineStateHandler=function(onlineState){return applyOnlineStateChange(_this81.syncEngine,onlineState,1/* SharedClientState */);};this.remoteStore.remoteSyncer.handleCredentialChange=syncEngineHandleCredentialChange.bind(null,this.syncEngine);_context51.next=12;return regeneratorRuntime.awrap(remoteStoreApplyPrimaryState(this.remoteStore,this.syncEngine.isPrimaryClient));case 12:case"end":return _context51.stop();}}},null,this);}},{key:"createEventManager",value:function createEventManager(cfg){return newEventManager();}},{key:"createDatastore",value:function createDatastore(cfg){var serializer=newSerializer(cfg.databaseInfo.databaseId);var connection=newConnection(cfg.databaseInfo);return newDatastore(cfg.credentials,connection,serializer);}},{key:"createRemoteStore",value:function createRemoteStore(cfg){var _this82=this;return newRemoteStore(this.localStore,this.datastore,cfg.asyncQueue,function(onlineState){return applyOnlineStateChange(_this82.syncEngine,onlineState,0/* RemoteStore */);},newConnectivityMonitor());}},{key:"createSyncEngine",value:function createSyncEngine(cfg){return newSyncEngine(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,cfg.initialUser,cfg.maxConcurrentLimboResolutions,!cfg.persistenceSettings.durable||!cfg.persistenceSettings.synchronizeTabs);}},{key:"terminate",value:function terminate(){return remoteStoreShutdown(this.remoteStore);}}]);return OnlineComponentProvider;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /*
 * A wrapper implementation of Observer<T> that will dispatch events
 * asynchronously. To allow immediate silencing, a mute call is added which
 * causes events scheduled to no longer be raised.
 */var AsyncObserver=/*#__PURE__*/function(){function AsyncObserver(observer){_classCallCheck(this,AsyncObserver);this.observer=observer;/**
         * When set to true, will not raise future events. Necessary to deal with
         * async detachment of listener.
         */this.muted=false;}_createClass(AsyncObserver,[{key:"next",value:function next(value){if(this.observer.next){this.scheduleEvent(this.observer.next,value);}}},{key:"error",value:function error(_error){if(this.observer.error){this.scheduleEvent(this.observer.error,_error);}else{console.error('Uncaught Error in snapshot listener:',_error);}}},{key:"mute",value:function mute(){this.muted=true;}},{key:"scheduleEvent",value:function scheduleEvent(eventHandler,event){var _this83=this;if(!this.muted){setTimeout(function(){if(!_this83.muted){eventHandler(event);}},0);}}}]);return AsyncObserver;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Internal transaction object responsible for accumulating the mutations to
 * perform and the base versions for any documents read.
 */var Transaction=/*#__PURE__*/function(){function Transaction(datastore){_classCallCheck(this,Transaction);this.datastore=datastore;// The version of each document that was read during this transaction.
this.readVersions=new Map();this.mutations=[];this.committed=false;/**
         * A deferred usage error that occurred previously in this transaction that
         * will cause the transaction to fail once it actually commits.
         */this.lastWriteError=null;/**
         * Set of documents that have been written in the transaction.
         *
         * When there's more than one write to the same key in a transaction, any
         * writes after the first are handled differently.
         */this.writtenDocs=new Set();}_createClass(Transaction,[{key:"lookup",value:function lookup(keys){var _this84=this;var docs;return regeneratorRuntime.async(function lookup$(_context52){while(1){switch(_context52.prev=_context52.next){case 0:this.ensureCommitNotCalled();if(!(this.mutations.length>0)){_context52.next=3;break;}throw new FirestoreError(Code.INVALID_ARGUMENT,'Firestore transactions require all reads to be executed before all writes.');case 3:_context52.next=5;return regeneratorRuntime.awrap(invokeBatchGetDocumentsRpc(this.datastore,keys));case 5:docs=_context52.sent;docs.forEach(function(doc){if(doc instanceof NoDocument||doc instanceof Document){_this84.recordVersion(doc);}else{fail();}});return _context52.abrupt("return",docs);case 8:case"end":return _context52.stop();}}},null,this);}},{key:"set",value:function set(key,data){this.write(data.toMutations(key,this.precondition(key)));this.writtenDocs.add(key.toString());}},{key:"update",value:function update(key,data){try{this.write(data.toMutations(key,this.preconditionForUpdate(key)));}catch(e){this.lastWriteError=e;}this.writtenDocs.add(key.toString());}},{key:"delete",value:function _delete(key){this.write([new DeleteMutation(key,this.precondition(key))]);this.writtenDocs.add(key.toString());}},{key:"commit",value:function commit(){var _this85=this;var unwritten;return regeneratorRuntime.async(function commit$(_context53){while(1){switch(_context53.prev=_context53.next){case 0:this.ensureCommitNotCalled();if(!this.lastWriteError){_context53.next=3;break;}throw this.lastWriteError;case 3:unwritten=this.readVersions;// For each mutation, note that the doc was written.
this.mutations.forEach(function(mutation){unwritten["delete"](mutation.key.toString());});// For each document that was read but not written to, we want to perform
// a `verify` operation.
unwritten.forEach(function(_,path){var key=DocumentKey.fromPath(path);_this85.mutations.push(new VerifyMutation(key,_this85.precondition(key)));});_context53.next=8;return regeneratorRuntime.awrap(invokeCommitRpc(this.datastore,this.mutations));case 8:this.committed=true;case 9:case"end":return _context53.stop();}}},null,this);}},{key:"recordVersion",value:function recordVersion(doc){var docVersion;if(doc instanceof Document){docVersion=doc.version;}else if(doc instanceof NoDocument){// For deleted docs, we must use baseVersion 0 when we overwrite them.
docVersion=SnapshotVersion.min();}else{throw fail();}var existingVersion=this.readVersions.get(doc.key.toString());if(existingVersion){if(!docVersion.isEqual(existingVersion)){// This transaction will fail no matter what.
throw new FirestoreError(Code.ABORTED,'Document version changed between two reads.');}}else{this.readVersions.set(doc.key.toString(),docVersion);}}/**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */},{key:"precondition",value:function precondition(key){var version=this.readVersions.get(key.toString());if(!this.writtenDocs.has(key.toString())&&version){return Precondition.updateTime(version);}else{return Precondition.none();}}/**
     * Returns the precondition for a document if the operation is an update.
     */},{key:"preconditionForUpdate",value:function preconditionForUpdate(key){var version=this.readVersions.get(key.toString());// The first time a document is written, we want to take into account the
// read time and existence
if(!this.writtenDocs.has(key.toString())&&version){if(version.isEqual(SnapshotVersion.min())){// The document doesn't exist, so fail the transaction.
// This has to be validated locally because you can't send a
// precondition that a document does not exist without changing the
// semantics of the backend write to be an insert. This is the reverse
// of what we want, since we want to assert that the document doesn't
// exist but then send the update and have it fail. Since we can't
// express that to the backend, we have to validate locally.
// Note: this can change once we can send separate verify writes in the
// transaction.
throw new FirestoreError(Code.INVALID_ARGUMENT,"Can't update a document that doesn't exist.");}// Document exists, base precondition on document update time.
return Precondition.updateTime(version);}else{// Document was not read, so we just use the preconditions for a blind
// update.
return Precondition.exists(true);}}},{key:"write",value:function write(mutations){this.ensureCommitNotCalled();this.mutations=this.mutations.concat(mutations);}},{key:"ensureCommitNotCalled",value:function ensureCommitNotCalled(){}}]);return Transaction;}();/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var RETRY_COUNT=5;/**
 * TransactionRunner encapsulates the logic needed to run and retry transactions
 * with backoff.
 */var TransactionRunner=/*#__PURE__*/function(){function TransactionRunner(asyncQueue,datastore,updateFunction,deferred){_classCallCheck(this,TransactionRunner);this.asyncQueue=asyncQueue;this.datastore=datastore;this.updateFunction=updateFunction;this.deferred=deferred;this.retries=RETRY_COUNT;this.backoff=new ExponentialBackoff(this.asyncQueue,"transaction_retry"/* TransactionRetry */);}/** Runs the transaction and sets the result on deferred. */_createClass(TransactionRunner,[{key:"run",value:function run(){this.runWithBackOff();}},{key:"runWithBackOff",value:function runWithBackOff(){var _this86=this;this.backoff.backoffAndRun(function _callee6(){var transaction,userPromise;return regeneratorRuntime.async(function _callee6$(_context54){while(1){switch(_context54.prev=_context54.next){case 0:transaction=new Transaction(_this86.datastore);userPromise=_this86.tryRunUpdateFunction(transaction);if(userPromise){userPromise.then(function(result){_this86.asyncQueue.enqueueAndForget(function(){return transaction.commit().then(function(){_this86.deferred.resolve(result);})["catch"](function(commitError){_this86.handleTransactionError(commitError);});});})["catch"](function(userPromiseError){_this86.handleTransactionError(userPromiseError);});}case 3:case"end":return _context54.stop();}}});});}},{key:"tryRunUpdateFunction",value:function tryRunUpdateFunction(transaction){try{var userPromise=this.updateFunction(transaction);if(isNullOrUndefined(userPromise)||!userPromise["catch"]||!userPromise.then){this.deferred.reject(Error('Transaction callback must return a Promise'));return null;}return userPromise;}catch(error){// Do not retry errors thrown by user provided updateFunction.
this.deferred.reject(error);return null;}}},{key:"handleTransactionError",value:function handleTransactionError(error){var _this87=this;if(this.retries>0&&this.isRetryableTransactionError(error)){this.retries-=1;this.asyncQueue.enqueueAndForget(function(){_this87.runWithBackOff();return Promise.resolve();});}else{this.deferred.reject(error);}}},{key:"isRetryableTransactionError",value:function isRetryableTransactionError(error){if(error.name==='FirebaseError'){// In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and
// non-matching document versions with ABORTED. These errors should be retried.
var code=error.code;return code==='aborted'||code==='failed-precondition'||!isPermanentError(code);}return false;}}]);return TransactionRunner;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var LOG_TAG$a='FirestoreClient';var MAX_CONCURRENT_LIMBO_RESOLUTIONS=100;/** DOMException error code constants. */var DOM_EXCEPTION_INVALID_STATE=11;var DOM_EXCEPTION_ABORTED=20;var DOM_EXCEPTION_QUOTA_EXCEEDED=22;/**
 * FirestoreClient is a top-level class that constructs and owns all of the
 * pieces of the client SDK architecture. It is responsible for creating the
 * async queue that is shared by all of the other components in the system.
 */var FirestoreClient=/*#__PURE__*/function(){function FirestoreClient(credentials,/**
     * Asynchronous queue responsible for all of our internal processing. When
     * we get incoming work from the user (via public API) or the network
     * (incoming GRPC messages), we should always schedule onto this queue.
     * This ensures all of our work is properly serialized (e.g. we don't
     * start processing a new operation while the previous one is waiting for
     * an async I/O to complete).
     */asyncQueue){_classCallCheck(this,FirestoreClient);this.credentials=credentials;this.asyncQueue=asyncQueue;this.clientId=AutoId.newId();// We defer our initialization until we get the current user from
// setChangeListener(). We block the async queue until we got the initial
// user and the initialization is completed. This will prevent any scheduled
// work from happening before initialization is completed.
//
// If initializationDone resolved then the FirestoreClient is in a usable
// state.
this.initializationDone=new Deferred();}/**
     * Starts up the FirestoreClient, returning only whether or not enabling
     * persistence succeeded.
     *
     * The intent here is to "do the right thing" as far as users are concerned.
     * Namely, in cases where offline persistence is requested and possible,
     * enable it, but otherwise fall back to persistence disabled. For the most
     * part we expect this to succeed one way or the other so we don't expect our
     * users to actually wait on the firestore.enablePersistence Promise since
     * they generally won't care.
     *
     * Of course some users actually do care about whether or not persistence
     * was successfully enabled, so the Promise returned from this method
     * indicates this outcome.
     *
     * This presents a problem though: even before enablePersistence resolves or
     * rejects, users may have made calls to e.g. firestore.collection() which
     * means that the FirestoreClient in there will be available and will be
     * enqueuing actions on the async queue.
     *
     * Meanwhile any failure of an operation on the async queue causes it to
     * panic and reject any further work, on the premise that unhandled errors
     * are fatal.
     *
     * Consequently the fallback is handled internally here in start, and if the
     * fallback succeeds we signal success to the async queue even though the
     * start() itself signals failure.
     *
     * @param databaseInfo The connection information for the current instance.
     * @param offlineComponentProvider Provider that returns all components
     * required for memory-only or IndexedDB persistence.
     * @param onlineComponentProvider Provider that returns all components
     * required for online support.
     * @param persistenceSettings Settings object to configure offline
     *     persistence.
     * @returns A deferred result indicating the user-visible result of enabling
     *     offline persistence. This method will reject this if IndexedDB fails to
     *     start for any reason. If usePersistence is false this is
     *     unconditionally resolved.
     */_createClass(FirestoreClient,[{key:"start",value:function start(databaseInfo,offlineComponentProvider,onlineComponentProvider,persistenceSettings){var _this88=this;this.verifyNotTerminated();this.databaseInfo=databaseInfo;// If usePersistence is true, certain classes of errors while starting are
// recoverable but only by falling back to persistence disabled.
//
// If there's an error in the first case but not in recovery we cannot
// reject the promise blocking the async queue because this will cause the
// async queue to panic.
var persistenceResult=new Deferred();var initialized=false;this.credentials.setChangeListener(function(user){if(!initialized){initialized=true;logDebug(LOG_TAG$a,'Initializing. user=',user.uid);return _this88.initializeComponents(offlineComponentProvider,onlineComponentProvider,persistenceSettings,user,persistenceResult).then(_this88.initializationDone.resolve,_this88.initializationDone.reject);}else{_this88.asyncQueue.enqueueRetryable(function(){return remoteStoreHandleCredentialChange(_this88.remoteStore,user);});}});// Block the async queue until initialization is done
this.asyncQueue.enqueueAndForget(function(){return _this88.initializationDone.promise;});// Return only the result of enabling persistence. Note that this does not
// need to await the completion of initializationDone because the result of
// this method should not reflect any other kind of failure to start.
return persistenceResult.promise;}/** Enables the network connection and requeues all pending operations. */},{key:"enableNetwork",value:function enableNetwork(){var _this89=this;this.verifyNotTerminated();return this.asyncQueue.enqueue(function(){_this89.persistence.setNetworkEnabled(true);return remoteStoreEnableNetwork(_this89.remoteStore);});}/**
     * Initializes persistent storage, attempting to use IndexedDB if
     * usePersistence is true or memory-only if false.
     *
     * If IndexedDB fails because it's already open in another tab or because the
     * platform can't possibly support our implementation then this method rejects
     * the persistenceResult and falls back on memory-only persistence.
     *
     * @param offlineComponentProvider Provider that returns all components
     * required for memory-only or IndexedDB persistence.
     * @param onlineComponentProvider Provider that returns all components
     * required for online support.
     * @param persistenceSettings Settings object to configure offline persistence
     * @param user The initial user
     * @param persistenceResult A deferred result indicating the user-visible
     *     result of enabling offline persistence. This method will reject this if
     *     IndexedDB fails to start for any reason. If usePersistence is false
     *     this is unconditionally resolved.
     * @returns a Promise indicating whether or not initialization should
     *     continue, i.e. that one of the persistence implementations actually
     *     succeeded.
     */},{key:"initializeComponents",value:function initializeComponents(offlineComponentProvider,onlineComponentProvider,persistenceSettings,user,persistenceResult){var _this90=this;var componentConfiguration;return regeneratorRuntime.async(function initializeComponents$(_context56){while(1){switch(_context56.prev=_context56.next){case 0:_context56.prev=0;componentConfiguration={asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,credentials:this.credentials,initialUser:user,maxConcurrentLimboResolutions:MAX_CONCURRENT_LIMBO_RESOLUTIONS,persistenceSettings:persistenceSettings};_context56.next=4;return regeneratorRuntime.awrap(offlineComponentProvider.initialize(componentConfiguration));case 4:_context56.next=6;return regeneratorRuntime.awrap(onlineComponentProvider.initialize(offlineComponentProvider,componentConfiguration));case 6:this.persistence=offlineComponentProvider.persistence;this.sharedClientState=offlineComponentProvider.sharedClientState;this.localStore=offlineComponentProvider.localStore;this.gcScheduler=offlineComponentProvider.gcScheduler;this.datastore=onlineComponentProvider.datastore;this.remoteStore=onlineComponentProvider.remoteStore;this.syncEngine=onlineComponentProvider.syncEngine;this.eventMgr=onlineComponentProvider.eventManager;this.eventMgr.onListen=syncEngineListen.bind(null,this.syncEngine);this.eventMgr.onUnlisten=syncEngineUnlisten.bind(null,this.syncEngine);// When a user calls clearPersistence() in one client, all other clients
// need to be terminated to allow the delete to succeed.
this.persistence.setDatabaseDeletedListener(function _callee7(){return regeneratorRuntime.async(function _callee7$(_context55){while(1){switch(_context55.prev=_context55.next){case 0:_context55.next=2;return regeneratorRuntime.awrap(_this90.terminate());case 2:case"end":return _context55.stop();}}});});persistenceResult.resolve();_context56.next=27;break;case 20:_context56.prev=20;_context56.t0=_context56["catch"](0);// Regardless of whether or not the retry succeeds, from an user
// perspective, offline persistence has failed.
persistenceResult.reject(_context56.t0);// An unknown failure on the first stage shuts everything down.
if(this.canFallback(_context56.t0)){_context56.next=25;break;}throw _context56.t0;case 25:console.warn('Error enabling offline persistence. Falling back to'+' persistence disabled: '+_context56.t0);return _context56.abrupt("return",this.initializeComponents(new MemoryOfflineComponentProvider(),new OnlineComponentProvider(),{durable:false},user,persistenceResult));case 27:case"end":return _context56.stop();}}},null,this,[[0,20]]);}/**
     * Decides whether the provided error allows us to gracefully disable
     * persistence (as opposed to crashing the client).
     */},{key:"canFallback",value:function canFallback(error){if(error.name==='FirebaseError'){return error.code===Code.FAILED_PRECONDITION||error.code===Code.UNIMPLEMENTED;}else if(typeof DOMException!=='undefined'&&error instanceof DOMException){// There are a few known circumstances where we can open IndexedDb but
// trying to read/write will fail (e.g. quota exceeded). For
// well-understood cases, we attempt to detect these and then gracefully
// fall back to memory persistence.
// NOTE: Rather than continue to add to this list, we could decide to
// always fall back, with the risk that we might accidentally hide errors
// representing actual SDK bugs.
return(// When the browser is out of quota we could get either quota exceeded
// or an aborted error depending on whether the error happened during
// schema migration.
error.code===DOM_EXCEPTION_QUOTA_EXCEEDED||error.code===DOM_EXCEPTION_ABORTED||// Firefox Private Browsing mode disables IndexedDb and returns
// INVALID_STATE for any usage.
error.code===DOM_EXCEPTION_INVALID_STATE);}return true;}/**
     * Checks that the client has not been terminated. Ensures that other methods on
     * this class cannot be called after the client is terminated.
     */},{key:"verifyNotTerminated",value:function verifyNotTerminated(){if(this.asyncQueue.isShuttingDown){throw new FirestoreError(Code.FAILED_PRECONDITION,'The client has already been terminated.');}}/** Disables the network connection. Pending operations will not complete. */},{key:"disableNetwork",value:function disableNetwork(){var _this91=this;this.verifyNotTerminated();return this.asyncQueue.enqueue(function(){_this91.persistence.setNetworkEnabled(false);return remoteStoreDisableNetwork(_this91.remoteStore);});}},{key:"terminate",value:function terminate(){var _this92=this;this.asyncQueue.enterRestrictedMode();var deferred=new Deferred();this.asyncQueue.enqueueAndForgetEvenWhileRestricted(function _callee8(){var firestoreError;return regeneratorRuntime.async(function _callee8$(_context57){while(1){switch(_context57.prev=_context57.next){case 0:_context57.prev=0;// PORTING NOTE: LocalStore does not need an explicit shutdown on web.
if(_this92.gcScheduler){_this92.gcScheduler.stop();}_context57.next=4;return regeneratorRuntime.awrap(remoteStoreShutdown(_this92.remoteStore));case 4:_context57.next=6;return regeneratorRuntime.awrap(_this92.sharedClientState.shutdown());case 6:_context57.next=8;return regeneratorRuntime.awrap(_this92.persistence.shutdown());case 8:// `removeChangeListener` must be called after shutting down the
// RemoteStore as it will prevent the RemoteStore from retrieving
// auth tokens.
_this92.credentials.removeChangeListener();deferred.resolve();_context57.next=16;break;case 12:_context57.prev=12;_context57.t0=_context57["catch"](0);firestoreError=wrapInUserErrorIfRecoverable(_context57.t0,"Failed to shutdown persistence");deferred.reject(firestoreError);case 16:case"end":return _context57.stop();}}},null,null,[[0,12]]);});return deferred.promise;}/**
     * Returns a Promise that resolves when all writes that were pending at the time this
     * method was called received server acknowledgement. An acknowledgement can be either acceptance
     * or rejection.
     */},{key:"waitForPendingWrites",value:function waitForPendingWrites(){var _this93=this;this.verifyNotTerminated();var deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return registerPendingWritesCallback(_this93.syncEngine,deferred);});return deferred.promise;}},{key:"listen",value:function listen(query,options,observer){var _this94=this;this.verifyNotTerminated();var wrappedObserver=new AsyncObserver(observer);var listener=new QueryListener(query,wrappedObserver,options);this.asyncQueue.enqueueAndForget(function(){return eventManagerListen(_this94.eventMgr,listener);});return function(){wrappedObserver.mute();_this94.asyncQueue.enqueueAndForget(function(){return eventManagerUnlisten(_this94.eventMgr,listener);});};}},{key:"getDocumentFromLocalCache",value:function getDocumentFromLocalCache(docKey){var _this95=this;var deferred;return regeneratorRuntime.async(function getDocumentFromLocalCache$(_context58){while(1){switch(_context58.prev=_context58.next){case 0:this.verifyNotTerminated();_context58.next=3;return regeneratorRuntime.awrap(this.initializationDone.promise);case 3:deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return readDocumentFromCache(_this95.localStore,docKey,deferred);});return _context58.abrupt("return",deferred.promise);case 6:case"end":return _context58.stop();}}},null,this);}},{key:"getDocumentViaSnapshotListener",value:function getDocumentViaSnapshotListener(key){var _this96=this;var options,deferred,_args59=arguments;return regeneratorRuntime.async(function getDocumentViaSnapshotListener$(_context59){while(1){switch(_context59.prev=_context59.next){case 0:options=_args59.length>1&&_args59[1]!==undefined?_args59[1]:{};this.verifyNotTerminated();_context59.next=4;return regeneratorRuntime.awrap(this.initializationDone.promise);case 4:deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return readDocumentViaSnapshotListener(_this96.eventMgr,_this96.asyncQueue,key,options,deferred);});return _context59.abrupt("return",deferred.promise);case 7:case"end":return _context59.stop();}}},null,this);}},{key:"getDocumentsFromLocalCache",value:function getDocumentsFromLocalCache(query){var _this97=this;var deferred;return regeneratorRuntime.async(function getDocumentsFromLocalCache$(_context60){while(1){switch(_context60.prev=_context60.next){case 0:this.verifyNotTerminated();_context60.next=3;return regeneratorRuntime.awrap(this.initializationDone.promise);case 3:deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return executeQueryFromCache(_this97.localStore,query,deferred);});return _context60.abrupt("return",deferred.promise);case 6:case"end":return _context60.stop();}}},null,this);}},{key:"getDocumentsViaSnapshotListener",value:function getDocumentsViaSnapshotListener(query){var _this98=this;var options,deferred,_args61=arguments;return regeneratorRuntime.async(function getDocumentsViaSnapshotListener$(_context61){while(1){switch(_context61.prev=_context61.next){case 0:options=_args61.length>1&&_args61[1]!==undefined?_args61[1]:{};this.verifyNotTerminated();_context61.next=4;return regeneratorRuntime.awrap(this.initializationDone.promise);case 4:deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return executeQueryViaSnapshotListener(_this98.eventMgr,_this98.asyncQueue,query,options,deferred);});return _context61.abrupt("return",deferred.promise);case 7:case"end":return _context61.stop();}}},null,this);}},{key:"write",value:function write(mutations){var _this99=this;this.verifyNotTerminated();var deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){return syncEngineWrite(_this99.syncEngine,mutations,deferred);});return deferred.promise;}},{key:"databaseId",value:function databaseId(){return this.databaseInfo.databaseId;}},{key:"addSnapshotsInSyncListener",value:function addSnapshotsInSyncListener(observer){var _this100=this;this.verifyNotTerminated();var wrappedObserver=new AsyncObserver(observer);this.asyncQueue.enqueueAndForget(function _callee9(){return regeneratorRuntime.async(function _callee9$(_context62){while(1){switch(_context62.prev=_context62.next){case 0:return _context62.abrupt("return",_addSnapshotsInSyncListener(_this100.eventMgr,wrappedObserver));case 1:case"end":return _context62.stop();}}});});return function(){wrappedObserver.mute();_this100.asyncQueue.enqueueAndForget(function _callee10(){return regeneratorRuntime.async(function _callee10$(_context63){while(1){switch(_context63.prev=_context63.next){case 0:return _context63.abrupt("return",removeSnapshotsInSyncListener(_this100.eventMgr,wrappedObserver));case 1:case"end":return _context63.stop();}}});});};}},{key:"transaction",/**
     * Takes an updateFunction in which a set of reads and writes can be performed
     * atomically. In the updateFunction, the client can read and write values
     * using the supplied transaction object. After the updateFunction, all
     * changes will be committed. If a retryable error occurs (ex: some other
     * client has changed any of the data referenced), then the updateFunction
     * will be called again after a backoff. If the updateFunction still fails
     * after all retries, then the transaction will be rejected.
     *
     * The transaction object passed to the updateFunction contains methods for
     * accessing documents and collections. Unlike other datastore access, data
     * accessed with the transaction will not reflect local changes that have not
     * been committed. For this reason, it is required that all reads are
     * performed before any writes. Transactions must be performed while online.
     */value:function transaction(updateFunction){var _this101=this;this.verifyNotTerminated();var deferred=new Deferred();this.asyncQueue.enqueueAndForget(function(){new TransactionRunner(_this101.asyncQueue,_this101.datastore,updateFunction,deferred).run();return Promise.resolve();});return deferred.promise;}},{key:"clientTerminated",get:function get(){// Technically, the asyncQueue is still running, but only accepting operations
// related to termination or supposed to be run after termination. It is effectively
// terminated to the eyes of users.
return this.asyncQueue.isShuttingDown;}}]);return FirestoreClient;}();function readDocumentFromCache(localStore,docKey,result){var maybeDoc,firestoreError;return regeneratorRuntime.async(function readDocumentFromCache$(_context64){while(1){switch(_context64.prev=_context64.next){case 0:_context64.prev=0;_context64.next=3;return regeneratorRuntime.awrap(readLocalDocument(localStore,docKey));case 3:maybeDoc=_context64.sent;if(maybeDoc instanceof Document){result.resolve(maybeDoc);}else if(maybeDoc instanceof NoDocument){result.resolve(null);}else{result.reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get document from cache. (However, this document may '+"exist on the server. Run again without setting 'source' in "+'the GetOptions to attempt to retrieve the document from the '+'server.)'));}_context64.next=11;break;case 7:_context64.prev=7;_context64.t0=_context64["catch"](0);firestoreError=wrapInUserErrorIfRecoverable(_context64.t0,"Failed to get document '".concat(docKey," from cache"));result.reject(firestoreError);case 11:case"end":return _context64.stop();}}},null,null,[[0,7]]);}/**
 * Retrieves a latency-compensated document from the backend via a
 * SnapshotListener.
 */function readDocumentViaSnapshotListener(eventManager,asyncQueue,key,options,result){var wrappedObserver=new AsyncObserver({next:function next(snap){// Remove query first before passing event to user to avoid
// user actions affecting the now stale query.
asyncQueue.enqueueAndForget(function(){return eventManagerUnlisten(eventManager,listener);});var exists=snap.docs.has(key);if(!exists&&snap.fromCache){// TODO(dimond): If we're online and the document doesn't
// exist then we resolve with a doc.exists set to false. If
// we're offline however, we reject the Promise in this
// case. Two options: 1) Cache the negative response from
// the server so we can deliver that even when you're
// offline 2) Actually reject the Promise in the online case
// if the document doesn't exist.
result.reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get document because the client is offline.'));}else if(exists&&snap.fromCache&&options&&options.source==='server'){result.reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get document from server. (However, this '+'document does exist in the local cache. Run again '+'without setting source to "server" to '+'retrieve the cached document.)'));}else{result.resolve(snap);}},error:function error(e){return result.reject(e);}});var listener=new QueryListener(newQueryForPath(key.path),wrappedObserver,{includeMetadataChanges:true,waitForSyncWhenOnline:true});return eventManagerListen(eventManager,listener);}function executeQueryFromCache(localStore,query,result){var queryResult,view,viewDocChanges,viewChange,firestoreError;return regeneratorRuntime.async(function executeQueryFromCache$(_context65){while(1){switch(_context65.prev=_context65.next){case 0:_context65.prev=0;_context65.next=3;return regeneratorRuntime.awrap(executeQuery(localStore,query,/* usePreviousResults= */true));case 3:queryResult=_context65.sent;view=new View(query,queryResult.remoteKeys);viewDocChanges=view.computeDocChanges(queryResult.documents);viewChange=view.applyChanges(viewDocChanges,/* updateLimboDocuments= */false);result.resolve(viewChange.snapshot);_context65.next=14;break;case 10:_context65.prev=10;_context65.t0=_context65["catch"](0);firestoreError=wrapInUserErrorIfRecoverable(_context65.t0,"Failed to execute query '".concat(query," against cache"));result.reject(firestoreError);case 14:case"end":return _context65.stop();}}},null,null,[[0,10]]);}/**
 * Retrieves a latency-compensated query snapshot from the backend via a
 * SnapshotListener.
 */function executeQueryViaSnapshotListener(eventManager,asyncQueue,query,options,result){var wrappedObserver=new AsyncObserver({next:function next(snapshot){// Remove query first before passing event to user to avoid
// user actions affecting the now stale query.
asyncQueue.enqueueAndForget(function(){return eventManagerUnlisten(eventManager,listener);});if(snapshot.fromCache&&options.source==='server'){result.reject(new FirestoreError(Code.UNAVAILABLE,'Failed to get documents from server. (However, these '+'documents may exist in the local cache. Run again '+'without setting source to "server" to '+'retrieve the cached documents.)'));}else{result.resolve(snapshot);}},error:function error(e){return result.reject(e);}});var listener=new QueryListener(query,wrappedObserver,{includeMetadataChanges:true,waitForSyncWhenOnline:true});return eventManagerListen(eventManager,listener);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
/**
 * A field class base class that is shared by the lite, full and legacy SDK,
 * which supports shared code that deals with FieldPaths.
 */ // Use underscore prefix to hide this class from our Public API.
// eslint-disable-next-line @typescript-eslint/naming-convention
var _BaseFieldPath=function _BaseFieldPath(fieldNames){_classCallCheck(this,_BaseFieldPath);validateNamedArrayAtLeastNumberOfElements('FieldPath',fieldNames,'fieldNames',1);for(var i=0;i<fieldNames.length;++i){validateArgType('FieldPath','string',i,fieldNames[i]);if(fieldNames[i].length===0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). "+'Field names must not be empty.');}}this._internalPath=new FieldPath(fieldNames);};/**
 * A `FieldPath` refers to a field in a document. The path may consist of a
 * single field name (referring to a top-level field in the document), or a list
 * of field names (referring to a nested field in the document).
 */var FieldPath$1=/*#__PURE__*/function(_BaseFieldPath2){_inherits(FieldPath$1,_BaseFieldPath2);/**
     * Creates a FieldPath from the provided field names. If more than one field
     * name is provided, the path will point to a nested field in a document.
     *
     * @param fieldNames A list of field names.
     */function FieldPath$1(){_classCallCheck(this,FieldPath$1);for(var _len6=arguments.length,fieldNames=new Array(_len6),_key9=0;_key9<_len6;_key9++){fieldNames[_key9]=arguments[_key9];}return _possibleConstructorReturn(this,_getPrototypeOf(FieldPath$1).call(this,fieldNames));}_createClass(FieldPath$1,[{key:"isEqual",value:function isEqual(other){if(!(other instanceof FieldPath$1)){throw invalidClassError('isEqual','FieldPath',1,other);}return this._internalPath.isEqual(other._internalPath);}}],[{key:"documentId",value:function documentId(){/**
         * Internal Note: The backend doesn't technically support querying by
         * document ID. Instead it queries by the entire document name (full path
         * included), but in the cases we currently support documentId(), the net
         * effect is the same.
         */return new FieldPath$1(FieldPath.keyField().canonicalString());}}]);return FieldPath$1;}(_BaseFieldPath);/**
 * Matches any characters in a field path string that are reserved.
 */var RESERVED=new RegExp('[~\\*/\\[\\]]');/**
 * Parses a field path string into a FieldPath, treating dots as separators.
 */function fromDotSeparatedString(path){var found=path.search(RESERVED);if(found>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field path (".concat(path,"). Paths must not contain ")+"'~', '*', '/', '[', or ']'");}try{return _construct(FieldPath$1,_toConsumableArray(path.split('.')));}catch(e){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid field path (".concat(path,"). Paths must not be empty, ")+"begin with '.', end with '.', or contain '..'");}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var OAuthToken=function OAuthToken(value,user){_classCallCheck(this,OAuthToken);this.user=user;this.type='OAuth';this.authHeaders={};// Set the headers using Object Literal notation to avoid minification
this.authHeaders['Authorization']="Bearer ".concat(value);};/** A CredentialsProvider that always yields an empty token. */var EmptyCredentialsProvider=/*#__PURE__*/function(){function EmptyCredentialsProvider(){_classCallCheck(this,EmptyCredentialsProvider);/**
         * Stores the listener registered with setChangeListener()
         * This isn't actually necessary since the UID never changes, but we use this
         * to verify the listen contract is adhered to in tests.
         */this.changeListener=null;}_createClass(EmptyCredentialsProvider,[{key:"getToken",value:function getToken(){return Promise.resolve(null);}},{key:"invalidateToken",value:function invalidateToken(){}},{key:"setChangeListener",value:function setChangeListener(changeListener){this.changeListener=changeListener;// Fire with initial user.
changeListener(User.UNAUTHENTICATED);}},{key:"removeChangeListener",value:function removeChangeListener(){this.changeListener=null;}}]);return EmptyCredentialsProvider;}();var FirebaseCredentialsProvider=/*#__PURE__*/function(){function FirebaseCredentialsProvider(authProvider){var _this102=this;_classCallCheck(this,FirebaseCredentialsProvider);/**
         * The auth token listener registered with FirebaseApp, retained here so we
         * can unregister it.
         */this.tokenListener=null;/** Tracks the current User. */this.currentUser=User.UNAUTHENTICATED;this.receivedInitialUser=false;/**
         * Counter used to detect if the token changed while a getToken request was
         * outstanding.
         */this.tokenCounter=0;/** The listener registered with setChangeListener(). */this.changeListener=null;this.forceRefresh=false;this.tokenListener=function(){_this102.tokenCounter++;_this102.currentUser=_this102.getUser();_this102.receivedInitialUser=true;if(_this102.changeListener){_this102.changeListener(_this102.currentUser);}};this.tokenCounter=0;this.auth=authProvider.getImmediate({optional:true});if(this.auth){this.auth.addAuthTokenListener(this.tokenListener);}else{// if auth is not available, invoke tokenListener once with null token
this.tokenListener(null);authProvider.get().then(function(auth){_this102.auth=auth;if(_this102.tokenListener){// tokenListener can be removed by removeChangeListener()
_this102.auth.addAuthTokenListener(_this102.tokenListener);}},function(){/* this.authProvider.get() never rejects */});}}_createClass(FirebaseCredentialsProvider,[{key:"getToken",value:function getToken(){var _this103=this;// Take note of the current value of the tokenCounter so that this method
// can fail (with an ABORTED error) if there is a token change while the
// request is outstanding.
var initialTokenCounter=this.tokenCounter;var forceRefresh=this.forceRefresh;this.forceRefresh=false;if(!this.auth){return Promise.resolve(null);}return this.auth.getToken(forceRefresh).then(function(tokenData){// Cancel the request since the token changed while the request was
// outstanding so the response is potentially for a previous user (which
// user, we can't be sure).
if(_this103.tokenCounter!==initialTokenCounter){logDebug('FirebaseCredentialsProvider','getToken aborted due to token change.');return _this103.getToken();}else{if(tokenData){hardAssert(typeof tokenData.accessToken==='string');return new OAuthToken(tokenData.accessToken,_this103.currentUser);}else{return null;}}});}},{key:"invalidateToken",value:function invalidateToken(){this.forceRefresh=true;}},{key:"setChangeListener",value:function setChangeListener(changeListener){this.changeListener=changeListener;// Fire the initial event
if(this.receivedInitialUser){changeListener(this.currentUser);}}},{key:"removeChangeListener",value:function removeChangeListener(){if(this.auth){this.auth.removeAuthTokenListener(this.tokenListener);}this.tokenListener=null;this.changeListener=null;}// Auth.getUid() can return null even with a user logged in. It is because
// getUid() is synchronous, but the auth code populating Uid is asynchronous.
// This method should only be called in the AuthTokenListener callback
// to guarantee to get the actual user.
},{key:"getUser",value:function getUser(){var currentUid=this.auth&&this.auth.getUid();hardAssert(currentUid===null||typeof currentUid==='string');return new User(currentUid);}}]);return FirebaseCredentialsProvider;}();/*
 * FirstPartyToken provides a fresh token each time its value
 * is requested, because if the token is too old, requests will be rejected.
 * Technically this may no longer be necessary since the SDK should gracefully
 * recover from unauthenticated errors (see b/33147818 for context), but it's
 * safer to keep the implementation as-is.
 */var FirstPartyToken=/*#__PURE__*/function(){function FirstPartyToken(gapi,sessionIndex){_classCallCheck(this,FirstPartyToken);this.gapi=gapi;this.sessionIndex=sessionIndex;this.type='FirstParty';this.user=User.FIRST_PARTY;}_createClass(FirstPartyToken,[{key:"authHeaders",get:function get(){var headers={'X-Goog-AuthUser':this.sessionIndex};// Use array notation to prevent minification
var authHeader=this.gapi['auth']['getAuthHeaderValueForFirstParty']([]);if(authHeader){headers['Authorization']=authHeader;}return headers;}}]);return FirstPartyToken;}();/*
 * Provides user credentials required for the Firestore JavaScript SDK
 * to authenticate the user, using technique that is only available
 * to applications hosted by Google.
 */var FirstPartyCredentialsProvider=/*#__PURE__*/function(){function FirstPartyCredentialsProvider(gapi,sessionIndex){_classCallCheck(this,FirstPartyCredentialsProvider);this.gapi=gapi;this.sessionIndex=sessionIndex;}_createClass(FirstPartyCredentialsProvider,[{key:"getToken",value:function getToken(){return Promise.resolve(new FirstPartyToken(this.gapi,this.sessionIndex));}},{key:"setChangeListener",value:function setChangeListener(changeListener){// Fire with initial uid.
changeListener(User.FIRST_PARTY);}},{key:"removeChangeListener",value:function removeChangeListener(){}},{key:"invalidateToken",value:function invalidateToken(){}}]);return FirstPartyCredentialsProvider;}();/**
 * Builds a CredentialsProvider depending on the type of
 * the credentials passed in.
 */function makeCredentialsProvider(credentials){if(!credentials){return new EmptyCredentialsProvider();}switch(credentials['type']){case'gapi':var client=credentials['client'];// Make sure this really is a Gapi client.
hardAssert(!!(_typeof(client)==='object'&&client!==null&&client['auth']&&client['auth']['getAuthHeaderValueForFirstParty']));return new FirstPartyCredentialsProvider(client,credentials['sessionIndex']||'0');case'provider':return credentials['client'];default:throw new FirestoreError(Code.INVALID_ARGUMENT,'makeCredentialsProvider failed due to invalid credential type');}}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */function isPartialObserver(obj){return implementsAnyMethods(obj,['next','error','complete']);}/**
 * Returns true if obj is an object and contains at least one of the specified
 * methods.
 */function implementsAnyMethods(obj,methods){if(_typeof(obj)!=='object'||obj===null){return false;}var object=obj;var _iteratorNormalCompletion52=true;var _didIteratorError52=false;var _iteratorError52=undefined;try{for(var _iterator52=methods[Symbol.iterator](),_step52;!(_iteratorNormalCompletion52=(_step52=_iterator52.next()).done);_iteratorNormalCompletion52=true){var method=_step52.value;if(method in object&&typeof object[method]==='function'){return true;}}}catch(err){_didIteratorError52=true;_iteratorError52=err;}finally{try{if(!_iteratorNormalCompletion52&&_iterator52["return"]!=null){_iterator52["return"]();}}finally{if(_didIteratorError52){throw _iteratorError52;}}}return false;}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Sentinel values that can be used when writing document fields with `set()`
 * or `update()`.
 */var FieldValue=/**
     * @param _methodName The public API endpoint that returns this class.
     */function FieldValue(_methodName){_classCallCheck(this,FieldValue);this._methodName=_methodName;};/**
 * Returns a sentinel for use with {@link updateDoc()} or
 * {@link setDoc `setDoc({}, { merge: true })`} to mark a field for deletion.
 */function deleteField(){return new DeleteFieldValueImpl('deleteField');}/**
 * Returns a sentinel used with {@link setDoc()} or {@link updateDoc()} to
 * include a server-generated timestamp in the written data.
 */function serverTimestamp$1(){return new ServerTimestampFieldValueImpl('serverTimestamp');}/**
 * Returns a special value that can be used with {@link setDoc()} or {@link
 * updateDoc()} that tells the server to union the given elements with any array
 * value that already exists on the server. Each specified element that doesn't
 * already exist in the array will be added to the end. If the field being
 * modified is not already an array it will be overwritten with an array
 * containing exactly the specified elements.
 *
 * @param elements The elements to union into the array.
 * @return The `FieldValue` sentinel for use in a call to `setDoc()` or
 * `updateDoc()`.
 */function _arrayUnion(){for(var _len7=arguments.length,elements=new Array(_len7),_key10=0;_key10<_len7;_key10++){elements[_key10]=arguments[_key10];}validateAtLeastNumberOfArgs('arrayUnion()',arguments,1);// NOTE: We don't actually parse the data until it's used in set() or
// update() since we'd need the Firestore instance to do this.
return new ArrayUnionFieldValueImpl('arrayUnion',elements);}/**
 * Returns a special value that can be used with {@link setDoc()} or {@link
 * updateDoc()} that tells the server to remove the given elements from any
 * array value that already exists on the server. All instances of each element
 * specified will be removed from the array. If the field being modified is not
 * already an array it will be overwritten with an empty array.
 *
 * @param elements The elements to remove from the array.
 * @return The `FieldValue` sentinel for use in a call to `setDoc()` or
 * `updateDoc()`
 */function _arrayRemove(){for(var _len8=arguments.length,elements=new Array(_len8),_key11=0;_key11<_len8;_key11++){elements[_key11]=arguments[_key11];}validateAtLeastNumberOfArgs('arrayRemove()',arguments,1);// NOTE: We don't actually parse the data until it's used in set() or
// update() since we'd need the Firestore instance to do this.
return new ArrayRemoveFieldValueImpl('arrayRemove',elements);}/**
 * Returns a special value that can be used with {@link setDoc()} or {@link
 * updateDoc()} that tells the server to increment the field's current value by
 * the given value.
 *
 * If either the operand or the current field value uses floating point
 * precision, all arithmetic follows IEEE 754 semantics. If both values are
 * integers, values outside of JavaScript's safe number range
 * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to
 * precision loss. Furthermore, once processed by the Firestore backend, all
 * integer operations are capped between -2^63 and 2^63-1.
 *
 * If the current field value is not of type `number`, or if the field does not
 * yet exist, the transformation sets the field to the given value.
 *
 * @param n The value to increment by.
 * @return The `FieldValue` sentinel for use in a call to `setDoc()` or
 * `updateDoc()`
 */function _increment(n){return new NumericIncrementFieldValueImpl('increment',n);}/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var DeleteFieldValueImpl=/*#__PURE__*/function(_FieldValue){_inherits(DeleteFieldValueImpl,_FieldValue);function DeleteFieldValueImpl(){_classCallCheck(this,DeleteFieldValueImpl);return _possibleConstructorReturn(this,_getPrototypeOf(DeleteFieldValueImpl).apply(this,arguments));}_createClass(DeleteFieldValueImpl,[{key:"_toFieldTransform",value:function _toFieldTransform(context){if(context.dataSource===2/* MergeSet */){// No transform to add for a delete, but we need to add it to our
// fieldMask so it gets deleted.
context.fieldMask.push(context.path);}else if(context.dataSource===1/* Update */){throw context.createError("".concat(this._methodName,"() can only appear at the top level ")+'of your update data');}else{// We shouldn't encounter delete sentinels for queries or non-merge set() calls.
throw context.createError("".concat(this._methodName,"() cannot be used with set() unless you pass ")+'{merge:true}');}return null;}},{key:"isEqual",value:function isEqual(other){return other instanceof DeleteFieldValueImpl;}}]);return DeleteFieldValueImpl;}(FieldValue);/**
 * Creates a child context for parsing SerializableFieldValues.
 *
 * This is different than calling `ParseContext.contextWith` because it keeps
 * the fieldTransforms and fieldMask separate.
 *
 * The created context has its `dataSource` set to `UserDataSource.Argument`.
 * Although these values are used with writes, any elements in these FieldValues
 * are not considered writes since they cannot contain any FieldValue sentinels,
 * etc.
 *
 * @param fieldValue The sentinel FieldValue for which to create a child
 *     context.
 * @param context The parent context.
 * @param arrayElement Whether or not the FieldValue has an array.
 */function createSentinelChildContext(fieldValue,context,arrayElement){return new ParseContext({dataSource:3/* Argument */,targetDoc:context.settings.targetDoc,methodName:fieldValue._methodName,arrayElement:arrayElement},context.databaseId,context.serializer,context.ignoreUndefinedProperties);}var ServerTimestampFieldValueImpl=/*#__PURE__*/function(_FieldValue2){_inherits(ServerTimestampFieldValueImpl,_FieldValue2);function ServerTimestampFieldValueImpl(){_classCallCheck(this,ServerTimestampFieldValueImpl);return _possibleConstructorReturn(this,_getPrototypeOf(ServerTimestampFieldValueImpl).apply(this,arguments));}_createClass(ServerTimestampFieldValueImpl,[{key:"_toFieldTransform",value:function _toFieldTransform(context){return new FieldTransform(context.path,new ServerTimestampTransform());}},{key:"isEqual",value:function isEqual(other){return other instanceof ServerTimestampFieldValueImpl;}}]);return ServerTimestampFieldValueImpl;}(FieldValue);var ArrayUnionFieldValueImpl=/*#__PURE__*/function(_FieldValue3){_inherits(ArrayUnionFieldValueImpl,_FieldValue3);function ArrayUnionFieldValueImpl(methodName,_elements){var _this104;_classCallCheck(this,ArrayUnionFieldValueImpl);_this104=_possibleConstructorReturn(this,_getPrototypeOf(ArrayUnionFieldValueImpl).call(this,methodName));_this104._elements=_elements;return _this104;}_createClass(ArrayUnionFieldValueImpl,[{key:"_toFieldTransform",value:function _toFieldTransform(context){var parseContext=createSentinelChildContext(this,context,/*array=*/true);var parsedElements=this._elements.map(function(element){return parseData(element,parseContext);});var arrayUnion=new ArrayUnionTransformOperation(parsedElements);return new FieldTransform(context.path,arrayUnion);}},{key:"isEqual",value:function isEqual(other){// TODO(mrschmidt): Implement isEquals
return this===other;}}]);return ArrayUnionFieldValueImpl;}(FieldValue);var ArrayRemoveFieldValueImpl=/*#__PURE__*/function(_FieldValue4){_inherits(ArrayRemoveFieldValueImpl,_FieldValue4);function ArrayRemoveFieldValueImpl(methodName,_elements){var _this105;_classCallCheck(this,ArrayRemoveFieldValueImpl);_this105=_possibleConstructorReturn(this,_getPrototypeOf(ArrayRemoveFieldValueImpl).call(this,methodName));_this105._elements=_elements;return _this105;}_createClass(ArrayRemoveFieldValueImpl,[{key:"_toFieldTransform",value:function _toFieldTransform(context){var parseContext=createSentinelChildContext(this,context,/*array=*/true);var parsedElements=this._elements.map(function(element){return parseData(element,parseContext);});var arrayUnion=new ArrayRemoveTransformOperation(parsedElements);return new FieldTransform(context.path,arrayUnion);}},{key:"isEqual",value:function isEqual(other){// TODO(mrschmidt): Implement isEquals
return this===other;}}]);return ArrayRemoveFieldValueImpl;}(FieldValue);var NumericIncrementFieldValueImpl=/*#__PURE__*/function(_FieldValue5){_inherits(NumericIncrementFieldValueImpl,_FieldValue5);function NumericIncrementFieldValueImpl(methodName,_operand){var _this106;_classCallCheck(this,NumericIncrementFieldValueImpl);_this106=_possibleConstructorReturn(this,_getPrototypeOf(NumericIncrementFieldValueImpl).call(this,methodName));_this106._operand=_operand;return _this106;}_createClass(NumericIncrementFieldValueImpl,[{key:"_toFieldTransform",value:function _toFieldTransform(context){var numericIncrement=new NumericIncrementTransformOperation(context.serializer,toNumber(context.serializer,this._operand));return new FieldTransform(context.path,numericIncrement);}},{key:"isEqual",value:function isEqual(other){// TODO(mrschmidt): Implement isEquals
return this===other;}}]);return NumericIncrementFieldValueImpl;}(FieldValue);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * An immutable object representing a geographic location in Firestore. The
 * location is represented as latitude/longitude pair.
 *
 * Latitude values are in the range of [-90, 90].
 * Longitude values are in the range of [-180, 180].
 */var GeoPoint=/*#__PURE__*/function(){/**
     * Creates a new immutable `GeoPoint` object with the provided latitude and
     * longitude values.
     * @param latitude The latitude as number between -90 and 90.
     * @param longitude The longitude as number between -180 and 180.
     */function GeoPoint(latitude,longitude){_classCallCheck(this,GeoPoint);validateExactNumberOfArgs('GeoPoint',arguments,2);validateArgType('GeoPoint','number',1,latitude);validateArgType('GeoPoint','number',2,longitude);if(!isFinite(latitude)||latitude<-90||latitude>90){throw new FirestoreError(Code.INVALID_ARGUMENT,'Latitude must be a number between -90 and 90, but was: '+latitude);}if(!isFinite(longitude)||longitude<-180||longitude>180){throw new FirestoreError(Code.INVALID_ARGUMENT,'Longitude must be a number between -180 and 180, but was: '+longitude);}this._lat=latitude;this._long=longitude;}/**
     * The latitude of this `GeoPoint` instance.
     */_createClass(GeoPoint,[{key:"isEqual",/**
     * Returns true if this `GeoPoint` is equal to the provided one.
     *
     * @param other The `GeoPoint` to compare against.
     * @return true if this `GeoPoint` is equal to the provided one.
     */value:function isEqual(other){return this._lat===other._lat&&this._long===other._long;}},{key:"toJSON",value:function toJSON(){return{latitude:this._lat,longitude:this._long};}/**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */},{key:"_compareTo",value:function _compareTo(other){return primitiveComparator(this._lat,other._lat)||primitiveComparator(this._long,other._long);}},{key:"latitude",get:function get(){return this._lat;}/**
     * The longitude of this `GeoPoint` instance.
     */},{key:"longitude",get:function get(){return this._long;}}]);return GeoPoint;}();/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A class implemented by all API types of the legacy Firestore API which
 * contains a reference to the API type in the firestore-exp API. All internal
 * code unwraps these references, which allows us to only use firestore-exp
 * types in the SDK.
 */var Compat=function Compat(_delegate){_classCallCheck(this,Compat);this._delegate=_delegate;};/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var RESERVED_FIELD_REGEX=/^__.*__$/;/**
 * A reference to a document in a Firebase project.
 *
 * This class serves as a common base class for the public DocumentReferences
 * exposed in the lite, full and legacy SDK.
 */ // Use underscore prefix to hide this class from our Public API.
// eslint-disable-next-line @typescript-eslint/naming-convention
var _DocumentKeyReference=function _DocumentKeyReference(_databaseId,_key,_converter){_classCallCheck(this,_DocumentKeyReference);this._databaseId=_databaseId;this._key=_key;this._converter=_converter;};/** The result of parsing document data (e.g. for a setData call). */var ParsedSetData=/*#__PURE__*/function(){function ParsedSetData(data,fieldMask,fieldTransforms){_classCallCheck(this,ParsedSetData);this.data=data;this.fieldMask=fieldMask;this.fieldTransforms=fieldTransforms;}_createClass(ParsedSetData,[{key:"toMutations",value:function toMutations(key,precondition){var mutations=[];if(this.fieldMask!==null){mutations.push(new PatchMutation(key,this.data,this.fieldMask,precondition));}else{mutations.push(new SetMutation(key,this.data,precondition));}if(this.fieldTransforms.length>0){mutations.push(new TransformMutation(key,this.fieldTransforms));}return mutations;}}]);return ParsedSetData;}();/** The result of parsing "update" data (i.e. for an updateData call). */var ParsedUpdateData=/*#__PURE__*/function(){function ParsedUpdateData(data,fieldMask,fieldTransforms){_classCallCheck(this,ParsedUpdateData);this.data=data;this.fieldMask=fieldMask;this.fieldTransforms=fieldTransforms;}_createClass(ParsedUpdateData,[{key:"toMutations",value:function toMutations(key,precondition){var mutations=[new PatchMutation(key,this.data,this.fieldMask,precondition)];if(this.fieldTransforms.length>0){mutations.push(new TransformMutation(key,this.fieldTransforms));}return mutations;}}]);return ParsedUpdateData;}();function isWrite(dataSource){switch(dataSource){case 0/* Set */:// fall through
case 2/* MergeSet */:// fall through
case 1/* Update */:return true;case 3/* Argument */:case 4/* ArrayArgument */:return false;default:throw fail();}}/** A "context" object passed around while parsing user data. */var ParseContext=/*#__PURE__*/function(){/**
     * Initializes a ParseContext with the given source and path.
     *
     * @param settings The settings for the parser.
     * @param databaseId The database ID of the Firestore instance.
     * @param serializer The serializer to use to generate the Value proto.
     * @param ignoreUndefinedProperties Whether to ignore undefined properties
     * rather than throw.
     * @param fieldTransforms A mutable list of field transforms encountered while
     *     parsing the data.
     * @param fieldMask A mutable list of field paths encountered while parsing
     *     the data.
     *
     * TODO(b/34871131): We don't support array paths right now, so path can be
     * null to indicate the context represents any location within an array (in
     * which case certain features will not work and errors will be somewhat
     * compromised).
     */function ParseContext(settings,databaseId,serializer,ignoreUndefinedProperties,fieldTransforms,fieldMask){_classCallCheck(this,ParseContext);this.settings=settings;this.databaseId=databaseId;this.serializer=serializer;this.ignoreUndefinedProperties=ignoreUndefinedProperties;// Minor hack: If fieldTransforms is undefined, we assume this is an
// external call and we need to validate the entire path.
if(fieldTransforms===undefined){this.validatePath();}this.fieldTransforms=fieldTransforms||[];this.fieldMask=fieldMask||[];}_createClass(ParseContext,[{key:"contextWith",/** Returns a new context with the specified settings overwritten. */value:function contextWith(configuration){return new ParseContext(Object.assign(Object.assign({},this.settings),configuration),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask);}},{key:"childContextForField",value:function childContextForField(field){var _a;var childPath=(_a=this.path)===null||_a===void 0?void 0:_a.child(field);var context=this.contextWith({path:childPath,arrayElement:false});context.validatePathSegment(field);return context;}},{key:"childContextForFieldPath",value:function childContextForFieldPath(field){var _a;var childPath=(_a=this.path)===null||_a===void 0?void 0:_a.child(field);var context=this.contextWith({path:childPath,arrayElement:false});context.validatePath();return context;}},{key:"childContextForArray",value:function childContextForArray(index){// TODO(b/34871131): We don't support array paths right now; so make path
// undefined.
return this.contextWith({path:undefined,arrayElement:true});}},{key:"createError",value:function createError(reason){return _createError(reason,this.settings.methodName,this.settings.hasConverter||false,this.path,this.settings.targetDoc);}/** Returns 'true' if 'fieldPath' was traversed when creating this context. */},{key:"contains",value:function contains(fieldPath){return this.fieldMask.find(function(field){return fieldPath.isPrefixOf(field);})!==undefined||this.fieldTransforms.find(function(transform){return fieldPath.isPrefixOf(transform.field);})!==undefined;}},{key:"validatePath",value:function validatePath(){// TODO(b/34871131): Remove null check once we have proper paths for fields
// within arrays.
if(!this.path){return;}for(var i=0;i<this.path.length;i++){this.validatePathSegment(this.path.get(i));}}},{key:"validatePathSegment",value:function validatePathSegment(segment){if(segment.length===0){throw this.createError('Document fields must not be empty');}if(isWrite(this.dataSource)&&RESERVED_FIELD_REGEX.test(segment)){throw this.createError('Document fields cannot begin and end with "__"');}}},{key:"path",get:function get(){return this.settings.path;}},{key:"dataSource",get:function get(){return this.settings.dataSource;}}]);return ParseContext;}();/**
 * Helper for parsing raw user input (provided via the API) into internal model
 * classes.
 */var UserDataReader=/*#__PURE__*/function(){function UserDataReader(databaseId,ignoreUndefinedProperties,serializer){_classCallCheck(this,UserDataReader);this.databaseId=databaseId;this.ignoreUndefinedProperties=ignoreUndefinedProperties;this.serializer=serializer||newSerializer(databaseId);}/** Creates a new top-level parse context. */_createClass(UserDataReader,[{key:"createContext",value:function createContext(dataSource,methodName,targetDoc){var hasConverter=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;return new ParseContext({dataSource:dataSource,methodName:methodName,targetDoc:targetDoc,path:FieldPath.emptyPath(),arrayElement:false,hasConverter:hasConverter},this.databaseId,this.serializer,this.ignoreUndefinedProperties);}}]);return UserDataReader;}();/** Parse document data from a set() call. */function parseSetData(userDataReader,methodName,targetDoc,input,hasConverter){var options=arguments.length>5&&arguments[5]!==undefined?arguments[5]:{};var context=userDataReader.createContext(options.merge||options.mergeFields?2/* MergeSet */:0/* Set */,methodName,targetDoc,hasConverter);validatePlainObject('Data must be an object, but it was:',context,input);var updateData=parseObject(input,context);var fieldMask;var fieldTransforms;if(options.merge){fieldMask=new FieldMask(context.fieldMask);fieldTransforms=context.fieldTransforms;}else if(options.mergeFields){var validatedFieldPaths=[];var _iteratorNormalCompletion53=true;var _didIteratorError53=false;var _iteratorError53=undefined;try{for(var _iterator53=options.mergeFields[Symbol.iterator](),_step53;!(_iteratorNormalCompletion53=(_step53=_iterator53.next()).done);_iteratorNormalCompletion53=true){var stringOrFieldPath=_step53.value;var fieldPath=void 0;if(stringOrFieldPath instanceof _BaseFieldPath){fieldPath=stringOrFieldPath._internalPath;}else if(typeof stringOrFieldPath==='string'){fieldPath=fieldPathFromDotSeparatedString(methodName,stringOrFieldPath,targetDoc);}else{throw fail();}if(!context.contains(fieldPath)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Field '".concat(fieldPath,"' is specified in your field mask but missing from your input data."));}if(!fieldMaskContains(validatedFieldPaths,fieldPath)){validatedFieldPaths.push(fieldPath);}}}catch(err){_didIteratorError53=true;_iteratorError53=err;}finally{try{if(!_iteratorNormalCompletion53&&_iterator53["return"]!=null){_iterator53["return"]();}}finally{if(_didIteratorError53){throw _iteratorError53;}}}fieldMask=new FieldMask(validatedFieldPaths);fieldTransforms=context.fieldTransforms.filter(function(transform){return fieldMask.covers(transform.field);});}else{fieldMask=null;fieldTransforms=context.fieldTransforms;}return new ParsedSetData(new ObjectValue(updateData),fieldMask,fieldTransforms);}/** Parse update data from an update() call. */function parseUpdateData(userDataReader,methodName,targetDoc,input){var context=userDataReader.createContext(1/* Update */,methodName,targetDoc);validatePlainObject('Data must be an object, but it was:',context,input);var fieldMaskPaths=[];var updateData=new ObjectValueBuilder();_forEach(input,function(key,value){var path=fieldPathFromDotSeparatedString(methodName,key,targetDoc);var childContext=context.childContextForFieldPath(path);if(value instanceof DeleteFieldValueImpl||value instanceof Compat&&value._delegate instanceof DeleteFieldValueImpl){// Add it to the field mask, but don't add anything to updateData.
fieldMaskPaths.push(path);}else{var parsedValue=parseData(value,childContext);if(parsedValue!=null){fieldMaskPaths.push(path);updateData.set(path,parsedValue);}}});var mask=new FieldMask(fieldMaskPaths);return new ParsedUpdateData(updateData.build(),mask,context.fieldTransforms);}/** Parse update data from a list of field/value arguments. */function parseUpdateVarargs(userDataReader,methodName,targetDoc,field,value,moreFieldsAndValues){var context=userDataReader.createContext(1/* Update */,methodName,targetDoc);var keys=[fieldPathFromArgument(methodName,field,targetDoc)];var values=[value];if(moreFieldsAndValues.length%2!==0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Function ".concat(methodName,"() needs to be called with an even number ")+'of arguments that alternate between field names and values.');}for(var i=0;i<moreFieldsAndValues.length;i+=2){keys.push(fieldPathFromArgument(methodName,moreFieldsAndValues[i]));values.push(moreFieldsAndValues[i+1]);}var fieldMaskPaths=[];var updateData=new ObjectValueBuilder();// We iterate in reverse order to pick the last value for a field if the
// user specified the field multiple times.
for(var _i4=keys.length-1;_i4>=0;--_i4){if(!fieldMaskContains(fieldMaskPaths,keys[_i4])){var path=keys[_i4];var _value=values[_i4];var childContext=context.childContextForFieldPath(path);if(_value instanceof DeleteFieldValueImpl||_value instanceof Compat&&_value._delegate instanceof DeleteFieldValueImpl){// Add it to the field mask, but don't add anything to updateData.
fieldMaskPaths.push(path);}else{var parsedValue=parseData(_value,childContext);if(parsedValue!=null){fieldMaskPaths.push(path);updateData.set(path,parsedValue);}}}}var mask=new FieldMask(fieldMaskPaths);return new ParsedUpdateData(updateData.build(),mask,context.fieldTransforms);}/**
 * Parse a "query value" (e.g. value in a where filter or a value in a cursor
 * bound).
 *
 * @param allowArrays Whether the query value is an array that may directly
 * contain additional arrays (e.g. the operand of an `in` query).
 */function parseQueryValue(userDataReader,methodName,input){var allowArrays=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var context=userDataReader.createContext(allowArrays?4/* ArrayArgument */:3/* Argument */,methodName);var parsed=parseData(input,context);return parsed;}/**
 * Parses user data to Protobuf Values.
 *
 * @param input Data to be parsed.
 * @param context A context object representing the current path being parsed,
 * the source of the data being parsed, etc.
 * @return The parsed value, or null if the value was a FieldValue sentinel
 * that should not be included in the resulting parsed data.
 */function parseData(input,context){// Unwrap the API type from the Compat SDK. This will return the API type
// from firestore-exp.
if(input instanceof Compat){input=input._delegate;}if(looksLikeJsonObject(input)){validatePlainObject('Unsupported field value:',context,input);return parseObject(input,context);}else if(input instanceof FieldValue){// FieldValues usually parse into transforms (except FieldValue.delete())
// in which case we do not want to include this field in our parsed data
// (as doing so will overwrite the field directly prior to the transform
// trying to transform it). So we don't add this location to
// context.fieldMask and we return null as our parsing result.
parseSentinelFieldValue(input,context);return null;}else{// If context.path is null we are inside an array and we don't support
// field mask paths more granular than the top-level array.
if(context.path){context.fieldMask.push(context.path);}if(input instanceof Array){// TODO(b/34871131): Include the path containing the array in the error
// message.
// In the case of IN queries, the parsed data is an array (representing
// the set of values to be included for the IN query) that may directly
// contain additional arrays (each representing an individual field
// value), so we disable this validation.
if(context.settings.arrayElement&&context.dataSource!==4/* ArrayArgument */){throw context.createError('Nested arrays are not supported');}return parseArray(input,context);}else{return parseScalarValue(input,context);}}}function parseObject(obj,context){var fields={};if(_isEmpty(obj)){// If we encounter an empty object, we explicitly add it to the update
// mask to ensure that the server creates a map entry.
if(context.path&&context.path.length>0){context.fieldMask.push(context.path);}}else{_forEach(obj,function(key,val){var parsedValue=parseData(val,context.childContextForField(key));if(parsedValue!=null){fields[key]=parsedValue;}});}return{mapValue:{fields:fields}};}function parseArray(array,context){var values=[];var entryIndex=0;var _iteratorNormalCompletion54=true;var _didIteratorError54=false;var _iteratorError54=undefined;try{for(var _iterator54=array[Symbol.iterator](),_step54;!(_iteratorNormalCompletion54=(_step54=_iterator54.next()).done);_iteratorNormalCompletion54=true){var entry=_step54.value;var parsedEntry=parseData(entry,context.childContextForArray(entryIndex));if(parsedEntry==null){// Just include nulls in the array for fields being replaced with a
// sentinel.
parsedEntry={nullValue:'NULL_VALUE'};}values.push(parsedEntry);entryIndex++;}}catch(err){_didIteratorError54=true;_iteratorError54=err;}finally{try{if(!_iteratorNormalCompletion54&&_iterator54["return"]!=null){_iterator54["return"]();}}finally{if(_didIteratorError54){throw _iteratorError54;}}}return{arrayValue:{values:values}};}/**
 * "Parses" the provided FieldValueImpl, adding any necessary transforms to
 * context.fieldTransforms.
 */function parseSentinelFieldValue(value,context){// Sentinels are only supported with writes, and not within arrays.
if(!isWrite(context.dataSource)){throw context.createError("".concat(value._methodName,"() can only be used with update() and set()"));}if(!context.path){throw context.createError("".concat(value._methodName,"() is not currently supported inside arrays"));}var fieldTransform=value._toFieldTransform(context);if(fieldTransform){context.fieldTransforms.push(fieldTransform);}}/**
 * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)
 *
 * @return The parsed value
 */function parseScalarValue(value,context){if(value===null){return{nullValue:'NULL_VALUE'};}else if(typeof value==='number'){return toNumber(context.serializer,value);}else if(typeof value==='boolean'){return{booleanValue:value};}else if(typeof value==='string'){return{stringValue:value};}else if(value instanceof Date){var timestamp=Timestamp.fromDate(value);return{timestampValue:toTimestamp(context.serializer,timestamp)};}else if(value instanceof Timestamp){// Firestore backend truncates precision down to microseconds. To ensure
// offline mode works the same with regards to truncation, perform the
// truncation immediately without waiting for the backend to do that.
var _timestamp=new Timestamp(value.seconds,Math.floor(value.nanoseconds/1000)*1000);return{timestampValue:toTimestamp(context.serializer,_timestamp)};}else if(value instanceof GeoPoint){return{geoPointValue:{latitude:value.latitude,longitude:value.longitude}};}else if(value instanceof Bytes){return{bytesValue:toBytes(context.serializer,value._byteString)};}else if(value instanceof _DocumentKeyReference){var thisDb=context.databaseId;var otherDb=value._databaseId;if(!otherDb.isEqual(thisDb)){throw context.createError('Document reference is for database '+"".concat(otherDb.projectId,"/").concat(otherDb.database," but should be ")+"for database ".concat(thisDb.projectId,"/").concat(thisDb.database));}return{referenceValue:toResourceName(value._databaseId||context.databaseId,value._key.path)};}else if(value===undefined&&context.ignoreUndefinedProperties){return null;}else{throw context.createError("Unsupported field value: ".concat(valueDescription(value)));}}/**
 * Checks whether an object looks like a JSON object that should be converted
 * into a struct. Normal class/prototype instances are considered to look like
 * JSON objects since they should be converted to a struct value. Arrays, Dates,
 * GeoPoints, etc. are not considered to look like JSON objects since they map
 * to specific FieldValue types other than ObjectValue.
 */function looksLikeJsonObject(input){return _typeof(input)==='object'&&input!==null&&!(input instanceof Array)&&!(input instanceof Date)&&!(input instanceof Timestamp)&&!(input instanceof GeoPoint)&&!(input instanceof Bytes)&&!(input instanceof _DocumentKeyReference)&&!(input instanceof FieldValue);}function validatePlainObject(message,context,input){if(!looksLikeJsonObject(input)||!isPlainObject(input)){var description=valueDescription(input);if(description==='an object'){// Massage the error if it was an object.
throw context.createError(message+' a custom object');}else{throw context.createError(message+' '+description);}}}/**
 * Helper that calls fromDotSeparatedString() but wraps any error thrown.
 */function fieldPathFromArgument(methodName,path,targetDoc){if(path instanceof _BaseFieldPath){return path._internalPath;}else if(typeof path==='string'){return fieldPathFromDotSeparatedString(methodName,path);}else{var message='Field path arguments must be of type string or FieldPath.';throw _createError(message,methodName,/* hasConverter= */false,/* path= */undefined,targetDoc);}}/**
 * Wraps fromDotSeparatedString with an error message about the method that
 * was thrown.
 * @param methodName The publicly visible method name
 * @param path The dot-separated string form of a field path which will be split
 * on dots.
 * @param targetDoc The document against which the field path will be evaluated.
 */function fieldPathFromDotSeparatedString(methodName,path,targetDoc){try{return fromDotSeparatedString(path)._internalPath;}catch(e){var message=errorMessage(e);throw _createError(message,methodName,/* hasConverter= */false,/* path= */undefined,targetDoc);}}function _createError(reason,methodName,hasConverter,path,targetDoc){var hasPath=path&&!path.isEmpty();var hasDocument=targetDoc!==undefined;var message="Function ".concat(methodName,"() called with invalid data");if(hasConverter){message+=' (via `toFirestore()`)';}message+='. ';var description='';if(hasPath||hasDocument){description+=' (found';if(hasPath){description+=" in field ".concat(path);}if(hasDocument){description+=" in document ".concat(targetDoc);}description+=')';}return new FirestoreError(Code.INVALID_ARGUMENT,message+reason+description);}/**
 * Extracts the message from a caught exception, which should be an Error object
 * though JS doesn't guarantee that.
 */function errorMessage(error){return error instanceof Error?error.message:error.toString();}/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */function fieldMaskContains(haystack,needle){return haystack.some(function(v){return v.isEqual(needle);});}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Converts Firestore's internal types to the JavaScript types that we expose
 * to the user.
 */var UserDataWriter=/*#__PURE__*/function(){function UserDataWriter(databaseId,timestampsInSnapshots,serverTimestampBehavior,referenceFactory,bytesFactory){_classCallCheck(this,UserDataWriter);this.databaseId=databaseId;this.timestampsInSnapshots=timestampsInSnapshots;this.serverTimestampBehavior=serverTimestampBehavior;this.referenceFactory=referenceFactory;this.bytesFactory=bytesFactory;}_createClass(UserDataWriter,[{key:"convertValue",value:function convertValue(value){switch(typeOrder(value)){case 0/* NullValue */:return null;case 1/* BooleanValue */:return value.booleanValue;case 2/* NumberValue */:return normalizeNumber(value.integerValue||value.doubleValue);case 3/* TimestampValue */:return this.convertTimestamp(value.timestampValue);case 4/* ServerTimestampValue */:return this.convertServerTimestamp(value);case 5/* StringValue */:return value.stringValue;case 6/* BlobValue */:return this.bytesFactory(normalizeByteString(value.bytesValue));case 7/* RefValue */:return this.convertReference(value.referenceValue);case 8/* GeoPointValue */:return this.convertGeoPoint(value.geoPointValue);case 9/* ArrayValue */:return this.convertArray(value.arrayValue);case 10/* ObjectValue */:return this.convertObject(value.mapValue);default:throw fail();}}},{key:"convertObject",value:function convertObject(mapValue){var _this107=this;var result={};_forEach(mapValue.fields||{},function(key,value){result[key]=_this107.convertValue(value);});return result;}},{key:"convertGeoPoint",value:function convertGeoPoint(value){return new GeoPoint(normalizeNumber(value.latitude),normalizeNumber(value.longitude));}},{key:"convertArray",value:function convertArray(arrayValue){var _this108=this;return(arrayValue.values||[]).map(function(value){return _this108.convertValue(value);});}},{key:"convertServerTimestamp",value:function convertServerTimestamp(value){switch(this.serverTimestampBehavior){case'previous':var previousValue=getPreviousValue(value);if(previousValue==null){return null;}return this.convertValue(previousValue);case'estimate':return this.convertTimestamp(getLocalWriteTime(value));default:return null;}}},{key:"convertTimestamp",value:function convertTimestamp(value){var normalizedValue=normalizeTimestamp(value);var timestamp=new Timestamp(normalizedValue.seconds,normalizedValue.nanos);if(this.timestampsInSnapshots){return timestamp;}else{return timestamp.toDate();}}},{key:"convertReference",value:function convertReference(name){var resourcePath=ResourcePath.fromString(name);hardAssert(isValidResourceName(resourcePath));var databaseId=new DatabaseId(resourcePath.get(1),resourcePath.get(3));var key=new DocumentKey(resourcePath.popFirst(5));if(!databaseId.isEqual(this.databaseId)){// TODO(b/64130202): Somehow support foreign references.
logError("Document ".concat(key," contains a document ")+"reference within a different database ("+"".concat(databaseId.projectId,"/").concat(databaseId.database,") which is not ")+"supported. It will be treated as a reference in the current "+"database (".concat(this.databaseId.projectId,"/").concat(this.databaseId.database,") ")+"instead.");}return this.referenceFactory(key);}}]);return UserDataWriter;}();/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // settings() defaults:
var DEFAULT_HOST='firestore.googleapis.com';var DEFAULT_SSL=true;var DEFAULT_TIMESTAMPS_IN_SNAPSHOTS=true;var DEFAULT_FORCE_LONG_POLLING=false;var DEFAULT_IGNORE_UNDEFINED_PROPERTIES=false;/**
 * Constant used to indicate the LRU garbage collection should be disabled.
 * Set this value as the `cacheSizeBytes` on the settings passed to the
 * `Firestore` instance.
 */var CACHE_SIZE_UNLIMITED=LruParams.COLLECTION_DISABLED;// enablePersistence() defaults:
var DEFAULT_SYNCHRONIZE_TABS=false;/**
 * A concrete type describing all the values that can be applied via a
 * user-supplied firestore.Settings object. This is a separate type so that
 * defaults can be supplied and the value can be checked for equality.
 */var FirestoreSettings=/*#__PURE__*/function(){function FirestoreSettings(settings){_classCallCheck(this,FirestoreSettings);var _a,_b,_c,_d;if(settings.host===undefined){if(settings.ssl!==undefined){throw new FirestoreError(Code.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");}this.host=DEFAULT_HOST;this.ssl=DEFAULT_SSL;}else{validateNamedType('settings','non-empty string','host',settings.host);this.host=settings.host;validateNamedOptionalType('settings','boolean','ssl',settings.ssl);this.ssl=(_a=settings.ssl)!==null&&_a!==void 0?_a:DEFAULT_SSL;}validateOptionNames('settings',settings,['host','ssl','credentials','timestampsInSnapshots','cacheSizeBytes','experimentalForceLongPolling','ignoreUndefinedProperties']);validateNamedOptionalType('settings','object','credentials',settings.credentials);this.credentials=settings.credentials;validateNamedOptionalType('settings','boolean','timestampsInSnapshots',settings.timestampsInSnapshots);validateNamedOptionalType('settings','boolean','ignoreUndefinedProperties',settings.ignoreUndefinedProperties);// Nobody should set timestampsInSnapshots anymore, but the error depends on
// whether they set it to true or false...
if(settings.timestampsInSnapshots===true){logError("The setting 'timestampsInSnapshots: true' is no longer required "+'and should be removed.');}else if(settings.timestampsInSnapshots===false){logError("Support for 'timestampsInSnapshots: false' will be removed soon. "+'You must update your code to handle Timestamp objects.');}this.timestampsInSnapshots=(_b=settings.timestampsInSnapshots)!==null&&_b!==void 0?_b:DEFAULT_TIMESTAMPS_IN_SNAPSHOTS;this.ignoreUndefinedProperties=(_c=settings.ignoreUndefinedProperties)!==null&&_c!==void 0?_c:DEFAULT_IGNORE_UNDEFINED_PROPERTIES;validateNamedOptionalType('settings','number','cacheSizeBytes',settings.cacheSizeBytes);if(settings.cacheSizeBytes===undefined){this.cacheSizeBytes=LruParams.DEFAULT_CACHE_SIZE_BYTES;}else{if(settings.cacheSizeBytes!==CACHE_SIZE_UNLIMITED&&settings.cacheSizeBytes<LruParams.MINIMUM_CACHE_SIZE_BYTES){throw new FirestoreError(Code.INVALID_ARGUMENT,"cacheSizeBytes must be at least ".concat(LruParams.MINIMUM_CACHE_SIZE_BYTES));}else{this.cacheSizeBytes=settings.cacheSizeBytes;}}validateNamedOptionalType('settings','boolean','experimentalForceLongPolling',settings.experimentalForceLongPolling);this.experimentalForceLongPolling=(_d=settings.experimentalForceLongPolling)!==null&&_d!==void 0?_d:DEFAULT_FORCE_LONG_POLLING;}_createClass(FirestoreSettings,[{key:"isEqual",value:function isEqual(other){return this.host===other.host&&this.ssl===other.ssl&&this.timestampsInSnapshots===other.timestampsInSnapshots&&this.credentials===other.credentials&&this.cacheSizeBytes===other.cacheSizeBytes&&this.experimentalForceLongPolling===other.experimentalForceLongPolling&&this.ignoreUndefinedProperties===other.ignoreUndefinedProperties;}}]);return FirestoreSettings;}();/**
 * The root reference to the database.
 */var Firestore=/*#__PURE__*/function(){// Note: We are using `MemoryComponentProvider` as a default
// ComponentProvider to ensure backwards compatibility with the format
// expected by the console build.
function Firestore(databaseIdOrApp,authProvider){var _this109=this;var _offlineComponentProvider=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new MemoryOfflineComponentProvider();var _onlineComponentProvider=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new OnlineComponentProvider();_classCallCheck(this,Firestore);this._offlineComponentProvider=_offlineComponentProvider;this._onlineComponentProvider=_onlineComponentProvider;this._firebaseApp=null;// Public for use in tests.
// TODO(mikelehen): Use modularized initialization instead.
this._queue=new AsyncQueue();this.INTERNAL={"delete":function _delete(){return regeneratorRuntime.async(function _delete$(_context66){while(1){switch(_context66.prev=_context66.next){case 0:// The client must be initalized to ensure that all subsequent API usage
// throws an exception.
_this109.ensureClientConfigured();_context66.next=3;return regeneratorRuntime.awrap(_this109._firestoreClient.terminate());case 3:case"end":return _context66.stop();}}});}};if(_typeof(databaseIdOrApp.options)==='object'){// This is very likely a Firebase app object
// TODO(b/34177605): Can we somehow use instanceof?
var app=databaseIdOrApp;this._firebaseApp=app;this._databaseId=Firestore.databaseIdFromApp(app);this._persistenceKey=app.name;this._credentials=new FirebaseCredentialsProvider(authProvider);}else{var external=databaseIdOrApp;if(!external.projectId){throw new FirestoreError(Code.INVALID_ARGUMENT,'Must provide projectId');}this._databaseId=new DatabaseId(external.projectId,external.database);// Use a default persistenceKey that lines up with FirebaseApp.
this._persistenceKey='[DEFAULT]';this._credentials=new EmptyCredentialsProvider();}this._settings=new FirestoreSettings({});}_createClass(Firestore,[{key:"settings",value:function settings(settingsLiteral){validateExactNumberOfArgs('Firestore.settings',arguments,1);validateArgType('Firestore.settings','object',1,settingsLiteral);if(settingsLiteral.merge){settingsLiteral=Object.assign(Object.assign({},this._settings),settingsLiteral);// Remove the property from the settings once the merge is completed
delete settingsLiteral.merge;}var newSettings=new FirestoreSettings(settingsLiteral);if(this._firestoreClient&&!this._settings.isEqual(newSettings)){throw new FirestoreError(Code.FAILED_PRECONDITION,'Firestore has already been started and its settings can no longer '+'be changed. You can only call settings() before calling any other '+'methods on a Firestore object.');}this._settings=newSettings;if(newSettings.credentials!==undefined){this._credentials=makeCredentialsProvider(newSettings.credentials);}}},{key:"enableNetwork",value:function enableNetwork(){this.ensureClientConfigured();return this._firestoreClient.enableNetwork();}},{key:"disableNetwork",value:function disableNetwork(){this.ensureClientConfigured();return this._firestoreClient.disableNetwork();}},{key:"enablePersistence",value:function enablePersistence(settings){var _a,_b;if(this._firestoreClient){throw new FirestoreError(Code.FAILED_PRECONDITION,'Firestore has already been started and persistence can no longer '+'be enabled. You can only call enablePersistence() before calling '+'any other methods on a Firestore object.');}var synchronizeTabs=false;var experimentalForceOwningTab=false;if(settings){if(settings.experimentalTabSynchronization!==undefined){logError("The 'experimentalTabSynchronization' setting will be removed. Use 'synchronizeTabs' instead.");}synchronizeTabs=(_b=(_a=settings.synchronizeTabs)!==null&&_a!==void 0?_a:settings.experimentalTabSynchronization)!==null&&_b!==void 0?_b:DEFAULT_SYNCHRONIZE_TABS;experimentalForceOwningTab=settings.experimentalForceOwningTab?settings.experimentalForceOwningTab:false;if(synchronizeTabs&&experimentalForceOwningTab){throw new FirestoreError(Code.INVALID_ARGUMENT,"The 'experimentalForceOwningTab' setting cannot be used with 'synchronizeTabs'.");}}return this.configureClient(this._offlineComponentProvider,this._onlineComponentProvider,{durable:true,cacheSizeBytes:this._settings.cacheSizeBytes,synchronizeTabs:synchronizeTabs,forceOwningTab:experimentalForceOwningTab});}},{key:"clearPersistence",value:function clearPersistence(){var _this110=this;var deferred;return regeneratorRuntime.async(function clearPersistence$(_context68){while(1){switch(_context68.prev=_context68.next){case 0:if(!(this._firestoreClient!==undefined&&!this._firestoreClient.clientTerminated)){_context68.next=2;break;}throw new FirestoreError(Code.FAILED_PRECONDITION,'Persistence can only be cleared before a Firestore instance is '+'initialized or after it is terminated.');case 2:deferred=new Deferred();this._queue.enqueueAndForgetEvenWhileRestricted(function _callee11(){return regeneratorRuntime.async(function _callee11$(_context67){while(1){switch(_context67.prev=_context67.next){case 0:_context67.prev=0;_context67.next=3;return regeneratorRuntime.awrap(_this110._offlineComponentProvider.clearPersistence(_this110._databaseId,_this110._persistenceKey));case 3:deferred.resolve();_context67.next=9;break;case 6:_context67.prev=6;_context67.t0=_context67["catch"](0);deferred.reject(_context67.t0);case 9:case"end":return _context67.stop();}}},null,null,[[0,6]]);});return _context68.abrupt("return",deferred.promise);case 5:case"end":return _context68.stop();}}},null,this);}},{key:"terminate",value:function terminate(){this.app._removeServiceInstance('firestore');return this.INTERNAL["delete"]();}},{key:"waitForPendingWrites",value:function waitForPendingWrites(){this.ensureClientConfigured();return this._firestoreClient.waitForPendingWrites();}},{key:"onSnapshotsInSync",value:function onSnapshotsInSync(arg){this.ensureClientConfigured();if(isPartialObserver(arg)){return this._firestoreClient.addSnapshotsInSyncListener(arg);}else{validateArgType('Firestore.onSnapshotsInSync','function',1,arg);var observer={next:arg};return this._firestoreClient.addSnapshotsInSyncListener(observer);}}},{key:"ensureClientConfigured",value:function ensureClientConfigured(){if(!this._firestoreClient){// Kick off starting the client but don't actually wait for it.
// eslint-disable-next-line @typescript-eslint/no-floating-promises
this.configureClient(new MemoryOfflineComponentProvider(),new OnlineComponentProvider(),{durable:false});}return this._firestoreClient;}},{key:"makeDatabaseInfo",value:function makeDatabaseInfo(){return new DatabaseInfo(this._databaseId,this._persistenceKey,this._settings.host,this._settings.ssl,this._settings.experimentalForceLongPolling);}},{key:"configureClient",value:function configureClient(offlineComponentProvider,onlineComponentProvider,persistenceSettings){var databaseInfo=this.makeDatabaseInfo();this._firestoreClient=new FirestoreClient(this._credentials,this._queue);return this._firestoreClient.start(databaseInfo,offlineComponentProvider,onlineComponentProvider,persistenceSettings);}},{key:"collection",value:function collection(pathString){validateExactNumberOfArgs('Firestore.collection',arguments,1);validateArgType('Firestore.collection','non-empty string',1,pathString);this.ensureClientConfigured();return new CollectionReference(ResourcePath.fromString(pathString),this,/* converter= */null);}},{key:"doc",value:function doc(pathString){validateExactNumberOfArgs('Firestore.doc',arguments,1);validateArgType('Firestore.doc','non-empty string',1,pathString);this.ensureClientConfigured();return DocumentReference.forPath(ResourcePath.fromString(pathString),this,/* converter= */null);}},{key:"collectionGroup",value:function collectionGroup(collectionId){validateExactNumberOfArgs('Firestore.collectionGroup',arguments,1);validateArgType('Firestore.collectionGroup','non-empty string',1,collectionId);if(collectionId.indexOf('/')>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid collection ID '".concat(collectionId,"' passed to function ")+"Firestore.collectionGroup(). Collection IDs must not contain '/'.");}this.ensureClientConfigured();return new Query(newQueryForCollectionGroup(collectionId),this,/* converter= */null);}},{key:"runTransaction",value:function runTransaction(updateFunction){var _this111=this;validateExactNumberOfArgs('Firestore.runTransaction',arguments,1);validateArgType('Firestore.runTransaction','function',1,updateFunction);return this.ensureClientConfigured().transaction(function(transaction){return updateFunction(new Transaction$1(_this111,transaction));});}},{key:"batch",value:function batch(){this.ensureClientConfigured();return new WriteBatch(this);}},{key:"_areTimestampsInSnapshotsEnabled",// Note: this is not a property because the minifier can't work correctly with
// the way TypeScript compiler outputs properties.
value:function _areTimestampsInSnapshotsEnabled(){return this._settings.timestampsInSnapshots;}// Visible for testing.
},{key:"_getSettings",value:function _getSettings(){return this._settings;}},{key:"_dataReader",get:function get(){if(!this._userDataReader){// Lazy initialize UserDataReader once the settings are frozen
this._userDataReader=new UserDataReader(this._databaseId,this._settings.ignoreUndefinedProperties);}return this._userDataReader;}},{key:"_isTerminated",get:function get(){this.ensureClientConfigured();return this._firestoreClient.clientTerminated;}},{key:"app",get:function get(){if(!this._firebaseApp){throw new FirestoreError(Code.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is "+'not available');}return this._firebaseApp;}}],[{key:"databaseIdFromApp",value:function databaseIdFromApp(app){if(!contains(app.options,'projectId')){throw new FirestoreError(Code.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');}var projectId=app.options.projectId;if(!projectId||typeof projectId!=='string'){throw new FirestoreError(Code.INVALID_ARGUMENT,'projectId must be a string in FirebaseApp.options');}return new DatabaseId(projectId);}},{key:"setLogLevel",value:function setLogLevel(level){validateExactNumberOfArgs('Firestore.setLogLevel',arguments,1);validateStringEnum('setLogLevel',['debug','error','silent','warn','info','verbose'],1,level);_setLogLevel(level);}},{key:"logLevel",get:function get(){switch(getLogLevel()){case _logger.LogLevel.DEBUG:return'debug';case _logger.LogLevel.ERROR:return'error';case _logger.LogLevel.SILENT:return'silent';case _logger.LogLevel.WARN:return'warn';case _logger.LogLevel.INFO:return'info';case _logger.LogLevel.VERBOSE:return'verbose';default:// The default log level is error
return'error';}}}]);return Firestore;}();/**
 * A reference to a transaction.
 */var Transaction$1=/*#__PURE__*/function(){function Transaction$1(_firestore,_transaction){_classCallCheck(this,Transaction$1);this._firestore=_firestore;this._transaction=_transaction;}_createClass(Transaction$1,[{key:"get",value:function get(documentRef){var _this112=this;validateExactNumberOfArgs('Transaction.get',arguments,1);var ref=validateReference('Transaction.get',documentRef,this._firestore);return this._transaction.lookup([ref._key]).then(function(docs){if(!docs||docs.length!==1){return fail();}var doc=docs[0];if(doc instanceof NoDocument){return new DocumentSnapshot(_this112._firestore,ref._key,null,/* fromCache= */false,/* hasPendingWrites= */false,ref._converter);}else if(doc instanceof Document){return new DocumentSnapshot(_this112._firestore,ref._key,doc,/* fromCache= */false,/* hasPendingWrites= */false,ref._converter);}else{throw fail();}});}},{key:"set",value:function set(documentRef,value,options){validateBetweenNumberOfArgs('Transaction.set',arguments,2,3);var ref=validateReference('Transaction.set',documentRef,this._firestore);options=validateSetOptions('Transaction.set',options);var convertedValue=applyFirestoreDataConverter(ref._converter,value,options);var parsed=parseSetData(this._firestore._dataReader,'Transaction.set',ref._key,convertedValue,ref._converter!==null,options);this._transaction.set(ref._key,parsed);return this;}},{key:"update",value:function update(documentRef,fieldOrUpdateData,value){for(var _len9=arguments.length,moreFieldsAndValues=new Array(_len9>3?_len9-3:0),_key12=3;_key12<_len9;_key12++){moreFieldsAndValues[_key12-3]=arguments[_key12];}var ref;var parsed;if(typeof fieldOrUpdateData==='string'||fieldOrUpdateData instanceof FieldPath$1){validateAtLeastNumberOfArgs('Transaction.update',arguments,3);ref=validateReference('Transaction.update',documentRef,this._firestore);parsed=parseUpdateVarargs(this._firestore._dataReader,'Transaction.update',ref._key,fieldOrUpdateData,value,moreFieldsAndValues);}else{validateExactNumberOfArgs('Transaction.update',arguments,2);ref=validateReference('Transaction.update',documentRef,this._firestore);parsed=parseUpdateData(this._firestore._dataReader,'Transaction.update',ref._key,fieldOrUpdateData);}this._transaction.update(ref._key,parsed);return this;}},{key:"delete",value:function _delete(documentRef){validateExactNumberOfArgs('Transaction.delete',arguments,1);var ref=validateReference('Transaction.delete',documentRef,this._firestore);this._transaction["delete"](ref._key);return this;}}]);return Transaction$1;}();var WriteBatch=/*#__PURE__*/function(){function WriteBatch(_firestore){_classCallCheck(this,WriteBatch);this._firestore=_firestore;this._mutations=[];this._committed=false;}_createClass(WriteBatch,[{key:"set",value:function set(documentRef,value,options){validateBetweenNumberOfArgs('WriteBatch.set',arguments,2,3);this.verifyNotCommitted();var ref=validateReference('WriteBatch.set',documentRef,this._firestore);options=validateSetOptions('WriteBatch.set',options);var convertedValue=applyFirestoreDataConverter(ref._converter,value,options);var parsed=parseSetData(this._firestore._dataReader,'WriteBatch.set',ref._key,convertedValue,ref._converter!==null,options);this._mutations=this._mutations.concat(parsed.toMutations(ref._key,Precondition.none()));return this;}},{key:"update",value:function update(documentRef,fieldOrUpdateData,value){for(var _len10=arguments.length,moreFieldsAndValues=new Array(_len10>3?_len10-3:0),_key13=3;_key13<_len10;_key13++){moreFieldsAndValues[_key13-3]=arguments[_key13];}this.verifyNotCommitted();var ref;var parsed;if(typeof fieldOrUpdateData==='string'||fieldOrUpdateData instanceof FieldPath$1){validateAtLeastNumberOfArgs('WriteBatch.update',arguments,3);ref=validateReference('WriteBatch.update',documentRef,this._firestore);parsed=parseUpdateVarargs(this._firestore._dataReader,'WriteBatch.update',ref._key,fieldOrUpdateData,value,moreFieldsAndValues);}else{validateExactNumberOfArgs('WriteBatch.update',arguments,2);ref=validateReference('WriteBatch.update',documentRef,this._firestore);parsed=parseUpdateData(this._firestore._dataReader,'WriteBatch.update',ref._key,fieldOrUpdateData);}this._mutations=this._mutations.concat(parsed.toMutations(ref._key,Precondition.exists(true)));return this;}},{key:"delete",value:function _delete(documentRef){validateExactNumberOfArgs('WriteBatch.delete',arguments,1);this.verifyNotCommitted();var ref=validateReference('WriteBatch.delete',documentRef,this._firestore);this._mutations=this._mutations.concat(new DeleteMutation(ref._key,Precondition.none()));return this;}},{key:"commit",value:function commit(){this.verifyNotCommitted();this._committed=true;if(this._mutations.length>0){return this._firestore.ensureClientConfigured().write(this._mutations);}return Promise.resolve();}},{key:"verifyNotCommitted",value:function verifyNotCommitted(){if(this._committed){throw new FirestoreError(Code.FAILED_PRECONDITION,'A write batch can no longer be used after commit() '+'has been called.');}}}]);return WriteBatch;}();/**
 * A reference to a particular document in a collection in the database.
 */var DocumentReference=/*#__PURE__*/function(_DocumentKeyReference2){_inherits(DocumentReference,_DocumentKeyReference2);function DocumentReference(_key,firestore,_converter){var _this113;_classCallCheck(this,DocumentReference);_this113=_possibleConstructorReturn(this,_getPrototypeOf(DocumentReference).call(this,firestore._databaseId,_key,_converter));_this113._key=_key;_this113.firestore=firestore;_this113._converter=_converter;_this113._firestoreClient=_this113.firestore.ensureClientConfigured();return _this113;}_createClass(DocumentReference,[{key:"collection",value:function collection(pathString){validateExactNumberOfArgs('DocumentReference.collection',arguments,1);validateArgType('DocumentReference.collection','non-empty string',1,pathString);if(!pathString){throw new FirestoreError(Code.INVALID_ARGUMENT,'Must provide a non-empty collection name to collection()');}var path=ResourcePath.fromString(pathString);return new CollectionReference(this._key.path.child(path),this.firestore,/* converter= */null);}},{key:"isEqual",value:function isEqual(other){if(!(other instanceof DocumentReference)){throw invalidClassError('isEqual','DocumentReference',1,other);}return this.firestore===other.firestore&&this._key.isEqual(other._key)&&this._converter===other._converter;}},{key:"set",value:function set(value,options){validateBetweenNumberOfArgs('DocumentReference.set',arguments,1,2);options=validateSetOptions('DocumentReference.set',options);var convertedValue=applyFirestoreDataConverter(this._converter,value,options);var parsed=parseSetData(this.firestore._dataReader,'DocumentReference.set',this._key,convertedValue,this._converter!==null,options);return this._firestoreClient.write(parsed.toMutations(this._key,Precondition.none()));}},{key:"update",value:function update(fieldOrUpdateData,value){for(var _len11=arguments.length,moreFieldsAndValues=new Array(_len11>2?_len11-2:0),_key14=2;_key14<_len11;_key14++){moreFieldsAndValues[_key14-2]=arguments[_key14];}var parsed;if(typeof fieldOrUpdateData==='string'||fieldOrUpdateData instanceof FieldPath$1){validateAtLeastNumberOfArgs('DocumentReference.update',arguments,2);parsed=parseUpdateVarargs(this.firestore._dataReader,'DocumentReference.update',this._key,fieldOrUpdateData,value,moreFieldsAndValues);}else{validateExactNumberOfArgs('DocumentReference.update',arguments,1);parsed=parseUpdateData(this.firestore._dataReader,'DocumentReference.update',this._key,fieldOrUpdateData);}return this._firestoreClient.write(parsed.toMutations(this._key,Precondition.exists(true)));}},{key:"delete",value:function _delete(){validateExactNumberOfArgs('DocumentReference.delete',arguments,0);return this._firestoreClient.write([new DeleteMutation(this._key,Precondition.none())]);}},{key:"onSnapshot",value:function onSnapshot(){var _this114=this;for(var _len12=arguments.length,args=new Array(_len12),_key15=0;_key15<_len12;_key15++){args[_key15]=arguments[_key15];}var _a,_b,_c;validateBetweenNumberOfArgs('DocumentReference.onSnapshot',arguments,1,4);var options={includeMetadataChanges:false};var currArg=0;if(_typeof(args[currArg])==='object'&&!isPartialObserver(args[currArg])){options=args[currArg];validateOptionNames('DocumentReference.onSnapshot',options,['includeMetadataChanges']);validateNamedOptionalType('DocumentReference.onSnapshot','boolean','includeMetadataChanges',options.includeMetadataChanges);currArg++;}var internalOptions={includeMetadataChanges:options.includeMetadataChanges};if(isPartialObserver(args[currArg])){var userObserver=args[currArg];args[currArg]=(_a=userObserver.next)===null||_a===void 0?void 0:_a.bind(userObserver);args[currArg+1]=(_b=userObserver.error)===null||_b===void 0?void 0:_b.bind(userObserver);args[currArg+2]=(_c=userObserver.complete)===null||_c===void 0?void 0:_c.bind(userObserver);}else{validateArgType('DocumentReference.onSnapshot','function',currArg,args[currArg]);validateOptionalArgType('DocumentReference.onSnapshot','function',currArg+1,args[currArg+1]);validateOptionalArgType('DocumentReference.onSnapshot','function',currArg+2,args[currArg+2]);}var observer={next:function next(snapshot){if(args[currArg]){args[currArg](_this114._convertToDocSnapshot(snapshot));}},error:args[currArg+1],complete:args[currArg+2]};return this._firestoreClient.listen(newQueryForPath(this._key.path),internalOptions,observer);}},{key:"get",value:function get(options){var _this115=this;validateBetweenNumberOfArgs('DocumentReference.get',arguments,0,1);validateGetOptions('DocumentReference.get',options);var firestoreClient=this.firestore.ensureClientConfigured();if(options&&options.source==='cache'){return firestoreClient.getDocumentFromLocalCache(this._key).then(function(doc){return new DocumentSnapshot(_this115.firestore,_this115._key,doc,/*fromCache=*/true,doc instanceof Document?doc.hasLocalMutations:false,_this115._converter);});}else{return firestoreClient.getDocumentViaSnapshotListener(this._key,options).then(function(snapshot){return _this115._convertToDocSnapshot(snapshot);});}}},{key:"withConverter",value:function withConverter(converter){return new DocumentReference(this._key,this.firestore,converter);}/**
     * Converts a ViewSnapshot that contains the current document to a
     * DocumentSnapshot.
     */},{key:"_convertToDocSnapshot",value:function _convertToDocSnapshot(snapshot){var doc=snapshot.docs.get(this._key);return new DocumentSnapshot(this.firestore,this._key,doc,snapshot.fromCache,snapshot.hasPendingWrites,this._converter);}},{key:"id",get:function get(){return this._key.path.lastSegment();}},{key:"parent",get:function get(){return new CollectionReference(this._key.path.popLast(),this.firestore,this._converter);}},{key:"path",get:function get(){return this._key.path.canonicalString();}}],[{key:"forPath",value:function forPath(path,firestore,converter){if(path.length%2!==0){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid document reference. Document '+'references must have an even number of segments, but '+"".concat(path.canonicalString()," has ").concat(path.length));}return new DocumentReference(new DocumentKey(path),firestore,converter);}}]);return DocumentReference;}(_DocumentKeyReference);/**
 * Metadata about a snapshot, describing the state of the snapshot.
 */var SnapshotMetadata=/*#__PURE__*/function(){function SnapshotMetadata(hasPendingWrites,fromCache){_classCallCheck(this,SnapshotMetadata);this.hasPendingWrites=hasPendingWrites;this.fromCache=fromCache;}/**
     * Returns true if this `SnapshotMetadata` is equal to the provided one.
     *
     * @param other The `SnapshotMetadata` to compare against.
     * @return true if this `SnapshotMetadata` is equal to the provided one.
     */_createClass(SnapshotMetadata,[{key:"isEqual",value:function isEqual(other){return this.hasPendingWrites===other.hasPendingWrites&&this.fromCache===other.fromCache;}}]);return SnapshotMetadata;}();var DocumentSnapshot=/*#__PURE__*/function(){function DocumentSnapshot(_firestore,_key,_document,_fromCache,_hasPendingWrites,_converter){_classCallCheck(this,DocumentSnapshot);this._firestore=_firestore;this._key=_key;this._document=_document;this._fromCache=_fromCache;this._hasPendingWrites=_hasPendingWrites;this._converter=_converter;}_createClass(DocumentSnapshot,[{key:"data",value:function data(options){var _this116=this;validateBetweenNumberOfArgs('DocumentSnapshot.data',arguments,0,1);options=validateSnapshotOptions('DocumentSnapshot.data',options);if(!this._document){return undefined;}else{// We only want to use the converter and create a new DocumentSnapshot
// if a converter has been provided.
if(this._converter){var snapshot=new QueryDocumentSnapshot(this._firestore,this._key,this._document,this._fromCache,this._hasPendingWrites,/* converter= */null);return this._converter.fromFirestore(snapshot,options);}else{var userDataWriter=new UserDataWriter(this._firestore._databaseId,this._firestore._areTimestampsInSnapshotsEnabled(),options.serverTimestamps||'none',function(key){return new DocumentReference(key,_this116._firestore,/* converter= */null);},function(bytes){return new Blob(bytes);});return userDataWriter.convertValue(this._document.toProto());}}}},{key:"get",value:function get(fieldPath,options){var _this117=this;validateBetweenNumberOfArgs('DocumentSnapshot.get',arguments,1,2);options=validateSnapshotOptions('DocumentSnapshot.get',options);if(this._document){var value=this._document.data().field(fieldPathFromArgument('DocumentSnapshot.get',fieldPath,this._key));if(value!==null){var userDataWriter=new UserDataWriter(this._firestore._databaseId,this._firestore._areTimestampsInSnapshotsEnabled(),options.serverTimestamps||'none',function(key){return new DocumentReference(key,_this117._firestore,_this117._converter);},function(bytes){return new Blob(bytes);});return userDataWriter.convertValue(value);}}return undefined;}},{key:"isEqual",value:function isEqual(other){if(!(other instanceof DocumentSnapshot)){throw invalidClassError('isEqual','DocumentSnapshot',1,other);}return this._firestore===other._firestore&&this._fromCache===other._fromCache&&this._key.isEqual(other._key)&&(this._document===null?other._document===null:this._document.isEqual(other._document))&&this._converter===other._converter;}},{key:"id",get:function get(){return this._key.path.lastSegment();}},{key:"ref",get:function get(){return new DocumentReference(this._key,this._firestore,this._converter);}},{key:"exists",get:function get(){return this._document!==null;}},{key:"metadata",get:function get(){return new SnapshotMetadata(this._hasPendingWrites,this._fromCache);}}]);return DocumentSnapshot;}();var QueryDocumentSnapshot=/*#__PURE__*/function(_DocumentSnapshot){_inherits(QueryDocumentSnapshot,_DocumentSnapshot);function QueryDocumentSnapshot(){_classCallCheck(this,QueryDocumentSnapshot);return _possibleConstructorReturn(this,_getPrototypeOf(QueryDocumentSnapshot).apply(this,arguments));}_createClass(QueryDocumentSnapshot,[{key:"data",value:function data(options){var data=_get(_getPrototypeOf(QueryDocumentSnapshot.prototype),"data",this).call(this,options);return data;}}]);return QueryDocumentSnapshot;}(DocumentSnapshot);function newQueryFilter(query,methodName,dataReader,databaseId,fieldPath,op,value){var fieldValue;if(fieldPath.isKeyField()){if(op==="array-contains"/* ARRAY_CONTAINS */||op==="array-contains-any"/* ARRAY_CONTAINS_ANY */){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid Query. You can't perform '".concat(op,"' ")+'queries on FieldPath.documentId().');}else if(op==="in"/* IN */||op==="not-in"/* NOT_IN */){validateDisjunctiveFilterElements(value,op);var referenceList=[];var _iteratorNormalCompletion55=true;var _didIteratorError55=false;var _iteratorError55=undefined;try{for(var _iterator55=value[Symbol.iterator](),_step55;!(_iteratorNormalCompletion55=(_step55=_iterator55.next()).done);_iteratorNormalCompletion55=true){var arrayValue=_step55.value;referenceList.push(parseDocumentIdValue(databaseId,query,arrayValue));}}catch(err){_didIteratorError55=true;_iteratorError55=err;}finally{try{if(!_iteratorNormalCompletion55&&_iterator55["return"]!=null){_iterator55["return"]();}}finally{if(_didIteratorError55){throw _iteratorError55;}}}fieldValue={arrayValue:{values:referenceList}};}else{fieldValue=parseDocumentIdValue(databaseId,query,value);}}else{if(op==="in"/* IN */||op==="not-in"/* NOT_IN */||op==="array-contains-any"/* ARRAY_CONTAINS_ANY */){validateDisjunctiveFilterElements(value,op);}fieldValue=parseQueryValue(dataReader,methodName,value,/* allowArrays= */op==="in"/* IN */||op==="not-in"/* NOT_IN */);}var filter=FieldFilter.create(fieldPath,op,fieldValue);validateNewFilter(query,filter);return filter;}function newQueryOrderBy(query,fieldPath,direction){if(query.startAt!==null){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You must not call startAt() or startAfter() before '+'calling orderBy().');}if(query.endAt!==null){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You must not call endAt() or endBefore() before '+'calling orderBy().');}var orderBy=new OrderBy(fieldPath,direction);validateNewOrderBy(query,orderBy);return orderBy;}/**
 * Create a Bound from a query and a document.
 *
 * Note that the Bound will always include the key of the document
 * and so only the provided document will compare equal to the returned
 * position.
 *
 * Will throw if the document does not contain all fields of the order by
 * of the query or if any of the fields in the order by are an uncommitted
 * server timestamp.
 */function newQueryBoundFromDocument(query,databaseId,methodName,doc,before){if(!doc){throw new FirestoreError(Code.NOT_FOUND,"Can't use a DocumentSnapshot that doesn't exist for "+"".concat(methodName,"()."));}var components=[];// Because people expect to continue/end a query at the exact document
// provided, we need to use the implicit sort order rather than the explicit
// sort order, because it's guaranteed to contain the document key. That way
// the position becomes unambiguous and the query continues/ends exactly at
// the provided document. Without the key (by using the explicit sort
// orders), multiple documents could match the position, yielding duplicate
// results.
var _iteratorNormalCompletion56=true;var _didIteratorError56=false;var _iteratorError56=undefined;try{for(var _iterator56=queryOrderBy(query)[Symbol.iterator](),_step56;!(_iteratorNormalCompletion56=(_step56=_iterator56.next()).done);_iteratorNormalCompletion56=true){var orderBy=_step56.value;if(orderBy.field.isKeyField()){components.push(refValue(databaseId,doc.key));}else{var value=doc.field(orderBy.field);if(isServerTimestamp(value)){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You are trying to start or end a query using a '+'document for which the field "'+orderBy.field+'" is an uncommitted server timestamp. (Since the value of '+'this field is unknown, you cannot start/end a query with it.)');}else if(value!==null){components.push(value);}else{var field=orderBy.field.canonicalString();throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. You are trying to start or end a query using a "+"document for which the field '".concat(field,"' (used as the ")+"orderBy) does not exist.");}}}}catch(err){_didIteratorError56=true;_iteratorError56=err;}finally{try{if(!_iteratorNormalCompletion56&&_iterator56["return"]!=null){_iterator56["return"]();}}finally{if(_didIteratorError56){throw _iteratorError56;}}}return new Bound(components,before);}/**
 * Converts a list of field values to a Bound for the given query.
 */function newQueryBoundFromFields(query,databaseId,dataReader,methodName,values,before){// Use explicit order by's because it has to match the query the user made
var orderBy=query.explicitOrderBy;if(values.length>orderBy.length){throw new FirestoreError(Code.INVALID_ARGUMENT,"Too many arguments provided to ".concat(methodName,"(). ")+"The number of arguments must be less than or equal to the "+"number of orderBy() clauses");}var components=[];for(var i=0;i<values.length;i++){var rawValue=values[i];var orderByComponent=orderBy[i];if(orderByComponent.field.isKeyField()){if(typeof rawValue!=='string'){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. Expected a string for document ID in "+"".concat(methodName,"(), but got a ").concat(_typeof(rawValue)));}if(!isCollectionGroupQuery(query)&&rawValue.indexOf('/')!==-1){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying a collection and ordering by FieldPath.documentId(), "+"the value passed to ".concat(methodName,"() must be a plain document ID, but ")+"'".concat(rawValue,"' contains a slash."));}var path=query.path.child(ResourcePath.fromString(rawValue));if(!DocumentKey.isDocumentKey(path)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying a collection group and ordering by "+"FieldPath.documentId(), the value passed to ".concat(methodName,"() must result in a ")+"valid document path, but '".concat(path,"' is not because it contains an odd number ")+"of segments.");}var key=new DocumentKey(path);components.push(refValue(databaseId,key));}else{var wrapped=parseQueryValue(dataReader,methodName,rawValue);components.push(wrapped);}}return new Bound(components,before);}/**
 * Parses the given documentIdValue into a ReferenceValue, throwing
 * appropriate errors if the value is anything other than a DocumentReference
 * or String, or if the string is malformed.
 */function parseDocumentIdValue(databaseId,query,documentIdValue){if(typeof documentIdValue==='string'){if(documentIdValue===''){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. When querying with FieldPath.documentId(), you '+'must provide a valid document ID, but it was an empty string.');}if(!isCollectionGroupQuery(query)&&documentIdValue.indexOf('/')!==-1){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying a collection by "+"FieldPath.documentId(), you must provide a plain document ID, but "+"'".concat(documentIdValue,"' contains a '/' character."));}var path=query.path.child(ResourcePath.fromString(documentIdValue));if(!DocumentKey.isDocumentKey(path)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying a collection group by "+"FieldPath.documentId(), the value provided must result in a valid document path, "+"but '".concat(path,"' is not because it has an odd number of segments (").concat(path.length,")."));}return refValue(databaseId,new DocumentKey(path));}else if(documentIdValue instanceof _DocumentKeyReference){return refValue(databaseId,documentIdValue._key);}else{throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. When querying with FieldPath.documentId(), you must provide a valid "+"string or a DocumentReference, but it was: "+"".concat(valueDescription(documentIdValue),"."));}}/**
 * Validates that the value passed into a disjunctive filter satisfies all
 * array requirements.
 */function validateDisjunctiveFilterElements(value,operator){if(!Array.isArray(value)||value.length===0){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid Query. A non-empty array is required for '+"'".concat(operator.toString(),"' filters."));}if(value.length>10){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid Query. '".concat(operator.toString(),"' filters support a ")+'maximum of 10 elements in the value array.');}if(operator==="in"/* IN */||operator==="array-contains-any"/* ARRAY_CONTAINS_ANY */){if(value.indexOf(null)>=0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid Query. '".concat(operator.toString(),"' filters cannot contain 'null' ")+'in the value array.');}if(value.filter(function(element){return Number.isNaN(element);}).length>0){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid Query. '".concat(operator.toString(),"' filters cannot contain 'NaN' ")+'in the value array.');}}}/**
 * Given an operator, returns the set of operators that cannot be used with it.
 *
 * Operators in a query must adhere to the following set of rules:
 * 1. Only one array operator is allowed.
 * 2. Only one disjunctive operator is allowed.
 * 3. NOT_EQUAL cannot be used with another NOT_EQUAL operator.
 * 4. NOT_IN cannot be used with array, disjunctive, or NOT_EQUAL operators.
 *
 * Array operators: ARRAY_CONTAINS, ARRAY_CONTAINS_ANY
 * Disjunctive operators: IN, ARRAY_CONTAINS_ANY, NOT_IN
 */function conflictingOps(op){switch(op){case"!="/* NOT_EQUAL */:return["!="/* NOT_EQUAL */,"not-in"/* NOT_IN */];case"array-contains"/* ARRAY_CONTAINS */:return["array-contains"/* ARRAY_CONTAINS */,"array-contains-any"/* ARRAY_CONTAINS_ANY */,"not-in"/* NOT_IN */];case"in"/* IN */:return["array-contains-any"/* ARRAY_CONTAINS_ANY */,"in"/* IN */,"not-in"/* NOT_IN */];case"array-contains-any"/* ARRAY_CONTAINS_ANY */:return["array-contains"/* ARRAY_CONTAINS */,"array-contains-any"/* ARRAY_CONTAINS_ANY */,"in"/* IN */,"not-in"/* NOT_IN */];case"not-in"/* NOT_IN */:return["array-contains"/* ARRAY_CONTAINS */,"array-contains-any"/* ARRAY_CONTAINS_ANY */,"in"/* IN */,"not-in"/* NOT_IN */,"!="/* NOT_EQUAL */];default:return[];}}function validateNewFilter(query,filter){if(filter.isInequality()){var existingField=getInequalityFilterField(query);if(existingField!==null&&!existingField.isEqual(filter.field)){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. All where filters with an inequality'+' (<, <=, >, or >=) must be on the same field. But you have'+" inequality filters on '".concat(existingField.toString(),"'")+" and '".concat(filter.field.toString(),"'"));}var firstOrderByField=getFirstOrderByField(query);if(firstOrderByField!==null){validateOrderByAndInequalityMatch(query,filter.field,firstOrderByField);}}var conflictingOp=findFilterOperator(query,conflictingOps(filter.op));if(conflictingOp!==null){// Special case when it's a duplicate op to give a slightly clearer error message.
if(conflictingOp===filter.op){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid query. You cannot use more than one '+"'".concat(filter.op.toString(),"' filter."));}else{throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. You cannot use '".concat(filter.op.toString(),"' filters ")+"with '".concat(conflictingOp.toString(),"' filters."));}}}function validateNewOrderBy(query,orderBy){if(getFirstOrderByField(query)===null){// This is the first order by. It must match any inequality.
var inequalityField=getInequalityFilterField(query);if(inequalityField!==null){validateOrderByAndInequalityMatch(query,inequalityField,orderBy.field);}}}function validateOrderByAndInequalityMatch(baseQuery,inequality,orderBy){if(!orderBy.isEqual(inequality)){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid query. You have a where filter with an inequality "+"(<, <=, >, or >=) on field '".concat(inequality.toString(),"' ")+"and so you must also use '".concat(inequality.toString(),"' ")+"as your first orderBy(), but your first orderBy() "+"is on field '".concat(orderBy.toString(),"' instead."));}}function validateHasExplicitOrderByForLimitToLast(query){if(hasLimitToLast(query)&&query.explicitOrderBy.length===0){throw new FirestoreError(Code.UNIMPLEMENTED,'limitToLast() queries require specifying at least one orderBy() clause');}}var Query=/*#__PURE__*/function(){function Query(_query,firestore,_converter){_classCallCheck(this,Query);this._query=_query;this.firestore=firestore;this._converter=_converter;}_createClass(Query,[{key:"where",value:function where(field,opStr,value){validateExactNumberOfArgs('Query.where',arguments,3);validateDefined('Query.where',3,value);// Enumerated from the WhereFilterOp type in index.d.ts.
var whereFilterOpEnums=["<"/* LESS_THAN */,"<="/* LESS_THAN_OR_EQUAL */,"=="/* EQUAL */,"!="/* NOT_EQUAL */,">="/* GREATER_THAN_OR_EQUAL */,">"/* GREATER_THAN */,"array-contains"/* ARRAY_CONTAINS */,"in"/* IN */,"array-contains-any"/* ARRAY_CONTAINS_ANY */,"not-in"/* NOT_IN */];var op=validateStringEnum('Query.where',whereFilterOpEnums,2,opStr);var fieldPath=fieldPathFromArgument('Query.where',field);var filter=newQueryFilter(this._query,'Query.where',this.firestore._dataReader,this.firestore._databaseId,fieldPath,op,value);return new Query(queryWithAddedFilter(this._query,filter),this.firestore,this._converter);}},{key:"orderBy",value:function orderBy(field,directionStr){validateBetweenNumberOfArgs('Query.orderBy',arguments,1,2);validateOptionalArgType('Query.orderBy','non-empty string',2,directionStr);var direction;if(directionStr===undefined||directionStr==='asc'){direction="asc"/* ASCENDING */;}else if(directionStr==='desc'){direction="desc"/* DESCENDING */;}else{throw new FirestoreError(Code.INVALID_ARGUMENT,"Function Query.orderBy() has unknown direction '".concat(directionStr,"', ")+"expected 'asc' or 'desc'.");}var fieldPath=fieldPathFromArgument('Query.orderBy',field);var orderBy=newQueryOrderBy(this._query,fieldPath,direction);return new Query(queryWithAddedOrderBy(this._query,orderBy),this.firestore,this._converter);}},{key:"limit",value:function limit(n){validateExactNumberOfArgs('Query.limit',arguments,1);validateArgType('Query.limit','number',1,n);validatePositiveNumber('Query.limit',1,n);return new Query(queryWithLimit(this._query,n,"F"/* First */),this.firestore,this._converter);}},{key:"limitToLast",value:function limitToLast(n){validateExactNumberOfArgs('Query.limitToLast',arguments,1);validateArgType('Query.limitToLast','number',1,n);validatePositiveNumber('Query.limitToLast',1,n);return new Query(queryWithLimit(this._query,n,"L"/* Last */),this.firestore,this._converter);}},{key:"startAt",value:function startAt(docOrField){for(var _len13=arguments.length,fields=new Array(_len13>1?_len13-1:0),_key16=1;_key16<_len13;_key16++){fields[_key16-1]=arguments[_key16];}validateAtLeastNumberOfArgs('Query.startAt',arguments,1);var bound=this.boundFromDocOrFields('Query.startAt',docOrField,fields,/*before=*/true);return new Query(queryWithStartAt(this._query,bound),this.firestore,this._converter);}},{key:"startAfter",value:function startAfter(docOrField){for(var _len14=arguments.length,fields=new Array(_len14>1?_len14-1:0),_key17=1;_key17<_len14;_key17++){fields[_key17-1]=arguments[_key17];}validateAtLeastNumberOfArgs('Query.startAfter',arguments,1);var bound=this.boundFromDocOrFields('Query.startAfter',docOrField,fields,/*before=*/false);return new Query(queryWithStartAt(this._query,bound),this.firestore,this._converter);}},{key:"endBefore",value:function endBefore(docOrField){for(var _len15=arguments.length,fields=new Array(_len15>1?_len15-1:0),_key18=1;_key18<_len15;_key18++){fields[_key18-1]=arguments[_key18];}validateAtLeastNumberOfArgs('Query.endBefore',arguments,1);var bound=this.boundFromDocOrFields('Query.endBefore',docOrField,fields,/*before=*/true);return new Query(queryWithEndAt(this._query,bound),this.firestore,this._converter);}},{key:"endAt",value:function endAt(docOrField){for(var _len16=arguments.length,fields=new Array(_len16>1?_len16-1:0),_key19=1;_key19<_len16;_key19++){fields[_key19-1]=arguments[_key19];}validateAtLeastNumberOfArgs('Query.endAt',arguments,1);var bound=this.boundFromDocOrFields('Query.endAt',docOrField,fields,/*before=*/false);return new Query(queryWithEndAt(this._query,bound),this.firestore,this._converter);}},{key:"isEqual",value:function isEqual(other){if(!(other instanceof Query)){throw invalidClassError('isEqual','Query',1,other);}return this.firestore===other.firestore&&queryEquals(this._query,other._query)&&this._converter===other._converter;}},{key:"withConverter",value:function withConverter(converter){return new Query(this._query,this.firestore,converter);}/** Helper function to create a bound from a document or fields */},{key:"boundFromDocOrFields",value:function boundFromDocOrFields(methodName,docOrField,fields,before){validateDefined(methodName,1,docOrField);if(docOrField instanceof DocumentSnapshot){validateExactNumberOfArgs(methodName,[docOrField].concat(_toConsumableArray(fields)),1);return newQueryBoundFromDocument(this._query,this.firestore._databaseId,methodName,docOrField._document,before);}else{var allFields=[docOrField].concat(fields);return newQueryBoundFromFields(this._query,this.firestore._databaseId,this.firestore._dataReader,methodName,allFields,before);}}},{key:"onSnapshot",value:function onSnapshot(){var _this118=this;for(var _len17=arguments.length,args=new Array(_len17),_key20=0;_key20<_len17;_key20++){args[_key20]=arguments[_key20];}var _a,_b,_c;validateBetweenNumberOfArgs('Query.onSnapshot',arguments,1,4);var options={};var currArg=0;if(_typeof(args[currArg])==='object'&&!isPartialObserver(args[currArg])){options=args[currArg];validateOptionNames('Query.onSnapshot',options,['includeMetadataChanges']);validateNamedOptionalType('Query.onSnapshot','boolean','includeMetadataChanges',options.includeMetadataChanges);currArg++;}if(isPartialObserver(args[currArg])){var userObserver=args[currArg];args[currArg]=(_a=userObserver.next)===null||_a===void 0?void 0:_a.bind(userObserver);args[currArg+1]=(_b=userObserver.error)===null||_b===void 0?void 0:_b.bind(userObserver);args[currArg+2]=(_c=userObserver.complete)===null||_c===void 0?void 0:_c.bind(userObserver);}else{validateArgType('Query.onSnapshot','function',currArg,args[currArg]);validateOptionalArgType('Query.onSnapshot','function',currArg+1,args[currArg+1]);validateOptionalArgType('Query.onSnapshot','function',currArg+2,args[currArg+2]);}var observer={next:function next(snapshot){if(args[currArg]){args[currArg](new QuerySnapshot(_this118.firestore,_this118._query,snapshot,_this118._converter));}},error:args[currArg+1],complete:args[currArg+2]};validateHasExplicitOrderByForLimitToLast(this._query);var firestoreClient=this.firestore.ensureClientConfigured();return firestoreClient.listen(this._query,options,observer);}},{key:"get",value:function get(options){var _this119=this;validateBetweenNumberOfArgs('Query.get',arguments,0,1);validateGetOptions('Query.get',options);validateHasExplicitOrderByForLimitToLast(this._query);var firestoreClient=this.firestore.ensureClientConfigured();return(options&&options.source==='cache'?firestoreClient.getDocumentsFromLocalCache(this._query):firestoreClient.getDocumentsViaSnapshotListener(this._query,options)).then(function(snap){return new QuerySnapshot(_this119.firestore,_this119._query,snap,_this119._converter);});}}]);return Query;}();var QuerySnapshot=/*#__PURE__*/function(){function QuerySnapshot(_firestore,_originalQuery,_snapshot,_converter){_classCallCheck(this,QuerySnapshot);this._firestore=_firestore;this._originalQuery=_originalQuery;this._snapshot=_snapshot;this._converter=_converter;this._cachedChanges=null;this._cachedChangesIncludeMetadataChanges=null;this.metadata=new SnapshotMetadata(_snapshot.hasPendingWrites,_snapshot.fromCache);}_createClass(QuerySnapshot,[{key:"forEach",value:function forEach(callback,thisArg){var _this120=this;validateBetweenNumberOfArgs('QuerySnapshot.forEach',arguments,1,2);validateArgType('QuerySnapshot.forEach','function',1,callback);this._snapshot.docs.forEach(function(doc){callback.call(thisArg,_this120.convertToDocumentImpl(doc,_this120.metadata.fromCache,_this120._snapshot.mutatedKeys.has(doc.key)));});}},{key:"docChanges",value:function docChanges(options){if(options){validateOptionNames('QuerySnapshot.docChanges',options,['includeMetadataChanges']);validateNamedOptionalType('QuerySnapshot.docChanges','boolean','includeMetadataChanges',options.includeMetadataChanges);}var includeMetadataChanges=!!(options&&options.includeMetadataChanges);if(includeMetadataChanges&&this._snapshot.excludesMetadataChanges){throw new FirestoreError(Code.INVALID_ARGUMENT,'To include metadata changes with your document changes, you must '+'also pass { includeMetadataChanges:true } to onSnapshot().');}if(!this._cachedChanges||this._cachedChangesIncludeMetadataChanges!==includeMetadataChanges){this._cachedChanges=changesFromSnapshot(this._snapshot,includeMetadataChanges,this.convertToDocumentImpl.bind(this));this._cachedChangesIncludeMetadataChanges=includeMetadataChanges;}return this._cachedChanges;}/** Check the equality. The call can be very expensive. */},{key:"isEqual",value:function isEqual(other){if(!(other instanceof QuerySnapshot)){throw invalidClassError('isEqual','QuerySnapshot',1,other);}return this._firestore===other._firestore&&queryEquals(this._originalQuery,other._originalQuery)&&this._snapshot.isEqual(other._snapshot)&&this._converter===other._converter;}},{key:"convertToDocumentImpl",value:function convertToDocumentImpl(doc,fromCache,hasPendingWrites){return new QueryDocumentSnapshot(this._firestore,doc.key,doc,fromCache,hasPendingWrites,this._converter);}},{key:"docs",get:function get(){var result=[];this.forEach(function(doc){return result.push(doc);});return result;}},{key:"empty",get:function get(){return this._snapshot.docs.isEmpty();}},{key:"size",get:function get(){return this._snapshot.docs.size;}},{key:"query",get:function get(){return new Query(this._originalQuery,this._firestore,this._converter);}}]);return QuerySnapshot;}();var CollectionReference=/*#__PURE__*/function(_Query){_inherits(CollectionReference,_Query);function CollectionReference(_path,firestore,_converter){var _this121;_classCallCheck(this,CollectionReference);_this121=_possibleConstructorReturn(this,_getPrototypeOf(CollectionReference).call(this,newQueryForPath(_path),firestore,_converter));_this121._path=_path;if(_path.length%2!==1){throw new FirestoreError(Code.INVALID_ARGUMENT,'Invalid collection reference. Collection '+'references must have an odd number of segments, but '+"".concat(_path.canonicalString()," has ").concat(_path.length));}return _this121;}_createClass(CollectionReference,[{key:"doc",value:function doc(pathString){validateBetweenNumberOfArgs('CollectionReference.doc',arguments,0,1);// We allow omission of 'pathString' but explicitly prohibit passing in both
// 'undefined' and 'null'.
if(arguments.length===0){pathString=AutoId.newId();}validateArgType('CollectionReference.doc','non-empty string',1,pathString);var path=ResourcePath.fromString(pathString);return DocumentReference.forPath(this._query.path.child(path),this.firestore,this._converter);}},{key:"add",value:function add(value){validateExactNumberOfArgs('CollectionReference.add',arguments,1);var convertedValue=this._converter?this._converter.toFirestore(value):value;validateArgType('CollectionReference.add','object',1,convertedValue);var docRef=this.doc();// Call set() with the converted value directly to avoid calling toFirestore() a second time.
return new DocumentReference(docRef._key,this.firestore,null).set(convertedValue).then(function(){return docRef;});}},{key:"withConverter",value:function withConverter(converter){return new CollectionReference(this._path,this.firestore,converter);}},{key:"id",get:function get(){return this._query.path.lastSegment();}},{key:"parent",get:function get(){var parentPath=this._query.path.popLast();if(parentPath.isEmpty()){return null;}else{return new DocumentReference(new DocumentKey(parentPath),this.firestore,/* converter= */null);}}},{key:"path",get:function get(){return this._query.path.canonicalString();}}]);return CollectionReference;}(Query);function validateSetOptions(methodName,options){if(options===undefined){return{merge:false};}validateOptionNames(methodName,options,['merge','mergeFields']);validateNamedOptionalType(methodName,'boolean','merge',options.merge);validateOptionalArrayElements(methodName,'mergeFields','a string or a FieldPath',options.mergeFields,function(element){return typeof element==='string'||element instanceof FieldPath$1;});if(options.mergeFields!==undefined&&options.merge!==undefined){throw new FirestoreError(Code.INVALID_ARGUMENT,"Invalid options passed to function ".concat(methodName,"(): You cannot specify both \"merge\" ")+"and \"mergeFields\".");}return options;}function validateSnapshotOptions(methodName,options){if(options===undefined){return{};}validateOptionNames(methodName,options,['serverTimestamps']);validateNamedOptionalPropertyEquals(methodName,'options','serverTimestamps',options.serverTimestamps,['estimate','previous','none']);return options;}function validateGetOptions(methodName,options){validateOptionalArgType(methodName,'object',1,options);if(options){validateOptionNames(methodName,options,['source']);validateNamedOptionalPropertyEquals(methodName,'options','source',options.source,['default','server','cache']);}}function validateReference(methodName,documentRef,firestore){if(!(documentRef instanceof _DocumentKeyReference)){throw invalidClassError(methodName,'DocumentReference',1,documentRef);}else if(documentRef.firestore!==firestore){throw new FirestoreError(Code.INVALID_ARGUMENT,'Provided document reference is from a different Firestore instance.');}else{return documentRef;}}/**
 * Calculates the array of DocumentChanges for a given ViewSnapshot.
 *
 * Exported for testing.
 *
 * @param snapshot The ViewSnapshot that represents the expected state.
 * @param includeMetadataChanges Whether to include metadata changes.
 * @param converter A factory function that returns a QueryDocumentSnapshot.
 * @return An object that matches the DocumentChange API.
 */function changesFromSnapshot(snapshot,includeMetadataChanges,converter){if(snapshot.oldDocs.isEmpty()){// Special case the first snapshot because index calculation is easy and
// fast
var lastDoc;var index=0;return snapshot.docChanges.map(function(change){var doc=converter(change.doc,snapshot.fromCache,snapshot.mutatedKeys.has(change.doc.key));lastDoc=change.doc;return{type:'added',doc:doc,oldIndex:-1,newIndex:index++};});}else{// A DocumentSet that is updated incrementally as changes are applied to use
// to lookup the index of a document.
var indexTracker=snapshot.oldDocs;return snapshot.docChanges.filter(function(change){return includeMetadataChanges||change.type!==3;}/* Metadata */).map(function(change){var doc=converter(change.doc,snapshot.fromCache,snapshot.mutatedKeys.has(change.doc.key));var oldIndex=-1;var newIndex=-1;if(change.type!==0/* Added */){oldIndex=indexTracker.indexOf(change.doc.key);indexTracker=indexTracker["delete"](change.doc.key);}if(change.type!==1/* Removed */){indexTracker=indexTracker.add(change.doc);newIndex=indexTracker.indexOf(change.doc.key);}return{type:resultChangeType(change.type),doc:doc,oldIndex:oldIndex,newIndex:newIndex};});}}function resultChangeType(type){switch(type){case 0/* Added */:return'added';case 2/* Modified */:case 3/* Metadata */:return'modified';case 1/* Removed */:return'removed';default:return fail();}}/**
 * Converts custom model object of type T into DocumentData by applying the
 * converter if it exists.
 *
 * This function is used when converting user objects to DocumentData
 * because we want to provide the user with a more specific error message if
 * their set() or fails due to invalid data originating from a toFirestore()
 * call.
 */function applyFirestoreDataConverter(converter,value,options){var convertedValue;if(converter){if(options&&(options.merge||options.mergeFields)){// Cast to `any` in order to satisfy the union type constraint on
// toFirestore().
// eslint-disable-next-line @typescript-eslint/no-explicit-any
convertedValue=converter.toFirestore(value,options);}else{convertedValue=converter.toFirestore(value);}}else{convertedValue=value;}return convertedValue;}function contains(obj,key){return Object.prototype.hasOwnProperty.call(obj,key);}var name="@firebase/firestore";var version$1="1.17.2";/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var FieldValue$1=/*#__PURE__*/function(_Compat){_inherits(FieldValue$1,_Compat);function FieldValue$1(){_classCallCheck(this,FieldValue$1);return _possibleConstructorReturn(this,_getPrototypeOf(FieldValue$1).apply(this,arguments));}_createClass(FieldValue$1,[{key:"isEqual",value:function isEqual(other){return this._delegate.isEqual(other._delegate);}}],[{key:"serverTimestamp",value:function serverTimestamp(){validateNoArgs('FieldValue.serverTimestamp',arguments);var delegate=serverTimestamp$1();delegate._methodName='FieldValue.serverTimestamp';return new FieldValue$1(delegate);}},{key:"delete",value:function _delete(){validateNoArgs('FieldValue.delete',arguments);var delegate=deleteField();delegate._methodName='FieldValue.delete';return new FieldValue$1(delegate);}},{key:"arrayUnion",value:function arrayUnion(){for(var _len18=arguments.length,elements=new Array(_len18),_key21=0;_key21<_len18;_key21++){elements[_key21]=arguments[_key21];}validateAtLeastNumberOfArgs('FieldValue.arrayUnion',arguments,1);var delegate=_arrayUnion.apply(void 0,elements);delegate._methodName='FieldValue.arrayUnion';return new FieldValue$1(delegate);}},{key:"arrayRemove",value:function arrayRemove(){for(var _len19=arguments.length,elements=new Array(_len19),_key22=0;_key22<_len19;_key22++){elements[_key22]=arguments[_key22];}validateAtLeastNumberOfArgs('FieldValue.arrayRemove',arguments,1);var delegate=_arrayRemove.apply(void 0,elements);delegate._methodName='FieldValue.arrayRemove';return new FieldValue$1(delegate);}},{key:"increment",value:function increment(n){validateArgType('FieldValue.increment','number',1,n);validateExactNumberOfArgs('FieldValue.increment',arguments,1);var delegate=_increment(n);delegate._methodName='FieldValue.increment';return new FieldValue$1(delegate);}}]);return FieldValue$1;}(Compat);/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */var firestoreNamespace={Firestore:Firestore,GeoPoint:GeoPoint,Timestamp:Timestamp,Blob:Blob,Transaction:Transaction$1,WriteBatch:WriteBatch,DocumentReference:DocumentReference,DocumentSnapshot:DocumentSnapshot,Query:Query,QueryDocumentSnapshot:QueryDocumentSnapshot,QuerySnapshot:QuerySnapshot,CollectionReference:CollectionReference,FieldPath:FieldPath$1,FieldValue:FieldValue$1,setLogLevel:Firestore.setLogLevel,CACHE_SIZE_UNLIMITED:CACHE_SIZE_UNLIMITED};/**
 * Configures Firestore as part of the Firebase SDK by calling registerService.
 *
 * @param firebase The FirebaseNamespace to register Firestore with
 * @param firestoreFactory A factory function that returns a new Firestore
 *    instance.
 */function configureForFirebase(firebase,firestoreFactory){firebase.INTERNAL.registerComponent(new _component.Component('firestore',function(container){var app=container.getProvider('app').getImmediate();return firestoreFactory(app,container.getProvider('auth-internal'));},"PUBLIC"/* PUBLIC */).setServiceProps(Object.assign({},firestoreNamespace)));}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Registers the memory-only Firestore build for Node with the components
 * framework.
 */function registerFirestore(instance){configureForFirebase(instance,function(app,auth){return new Firestore(app,auth,new MemoryOfflineComponentProvider(),new OnlineComponentProvider());});instance.registerVersion(name,version$1,'node');}registerFirestore(_app["default"]);