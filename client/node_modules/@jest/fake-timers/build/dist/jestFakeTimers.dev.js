'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _jestMessageUtil() {
  var data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
    return data;
  };

  return data;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var MS_IN_A_YEAR = 31536000000; // TODO: Copied from `jest-util` to avoid cyclic dependency. Import from `jest-util` in the next major

var setGlobal = function setGlobal(globalToMutate, key, value) {
  // @ts-ignore: no index
  globalToMutate[key] = value;
};

var FakeTimers =
/*#__PURE__*/
function () {
  function FakeTimers(_ref) {
    var global = _ref.global,
        moduleMocker = _ref.moduleMocker,
        timerConfig = _ref.timerConfig,
        config = _ref.config,
        maxLoops = _ref.maxLoops;

    _classCallCheck(this, FakeTimers);

    _defineProperty(this, '_cancelledImmediates', void 0);

    _defineProperty(this, '_cancelledTicks', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_disposed', void 0);

    _defineProperty(this, '_fakeTimerAPIs', void 0);

    _defineProperty(this, '_global', void 0);

    _defineProperty(this, '_immediates', void 0);

    _defineProperty(this, '_maxLoops', void 0);

    _defineProperty(this, '_moduleMocker', void 0);

    _defineProperty(this, '_now', void 0);

    _defineProperty(this, '_ticks', void 0);

    _defineProperty(this, '_timerAPIs', void 0);

    _defineProperty(this, '_timers', void 0);

    _defineProperty(this, '_uuidCounter', void 0);

    _defineProperty(this, '_timerConfig', void 0);

    this._global = global;
    this._timerConfig = timerConfig;
    this._config = config;
    this._maxLoops = maxLoops || 100000;
    this._uuidCounter = 1;
    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference

    this._timerAPIs = {
      clearImmediate: global.clearImmediate,
      clearInterval: global.clearInterval,
      clearTimeout: global.clearTimeout,
      nextTick: global.process && global.process.nextTick,
      setImmediate: global.setImmediate,
      setInterval: global.setInterval,
      setTimeout: global.setTimeout
    };
    this.reset();

    this._createMocks();
  }

  _createClass(FakeTimers, [{
    key: "clearAllTimers",
    value: function clearAllTimers() {
      var _this = this;

      this._immediates.forEach(function (immediate) {
        return _this._fakeClearImmediate(immediate.uuid);
      });

      this._timers.clear();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._disposed = true;
      this.clearAllTimers();
    }
  }, {
    key: "reset",
    value: function reset() {
      this._cancelledTicks = {};
      this._cancelledImmediates = {};
      this._now = 0;
      this._ticks = [];
      this._immediates = [];
      this._timers = new Map();
    }
  }, {
    key: "runAllTicks",
    value: function runAllTicks() {
      this._checkFakeTimers(); // Only run a generous number of ticks and then bail.
      // This is just to help avoid recursive loops


      var i;

      for (i = 0; i < this._maxLoops; i++) {
        var tick = this._ticks.shift();

        if (tick === undefined) {
          break;
        }

        if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {
          // Callback may throw, so update the map prior calling.
          this._cancelledTicks[tick.uuid] = true;
          tick.callback();
        }
      }

      if (i === this._maxLoops) {
        throw new Error('Ran ' + this._maxLoops + ' ticks, and there are still more! ' + "Assuming we've hit an infinite recursion and bailing out...");
      }
    }
  }, {
    key: "runAllImmediates",
    value: function runAllImmediates() {
      this._checkFakeTimers(); // Only run a generous number of immediates and then bail.


      var i;

      for (i = 0; i < this._maxLoops; i++) {
        var immediate = this._immediates.shift();

        if (immediate === undefined) {
          break;
        }

        this._runImmediate(immediate);
      }

      if (i === this._maxLoops) {
        throw new Error('Ran ' + this._maxLoops + ' immediates, and there are still more! Assuming ' + "we've hit an infinite recursion and bailing out...");
      }
    }
  }, {
    key: "_runImmediate",
    value: function _runImmediate(immediate) {
      if (!this._cancelledImmediates.hasOwnProperty(immediate.uuid)) {
        // Callback may throw, so update the map prior calling.
        this._cancelledImmediates[immediate.uuid] = true;
        immediate.callback();
      }
    }
  }, {
    key: "runAllTimers",
    value: function runAllTimers() {
      this._checkFakeTimers();

      this.runAllTicks();
      this.runAllImmediates(); // Only run a generous number of timers and then bail.
      // This is just to help avoid recursive loops

      var i;

      for (i = 0; i < this._maxLoops; i++) {
        var nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!


        if (nextTimerHandle === null) {
          break;
        }

        this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued
        // during the previous handling of the timers, we should
        // run them as well.


        if (this._immediates.length) {
          this.runAllImmediates();
        }

        if (this._ticks.length) {
          this.runAllTicks();
        }
      }

      if (i === this._maxLoops) {
        throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + "Assuming we've hit an infinite recursion and bailing out...");
      }
    }
  }, {
    key: "runOnlyPendingTimers",
    value: function runOnlyPendingTimers() {
      var _this2 = this;

      // We need to hold the current shape of `this._timers` because existing
      // timers can add new ones to the map and hence would run more than necessary.
      // See https://github.com/facebook/jest/pull/4608 for details
      var timerEntries = Array.from(this._timers.entries());

      this._checkFakeTimers();

      this._immediates.forEach(this._runImmediate, this);

      timerEntries.sort(function (_ref2, _ref3) {
        var _ref4 = _slicedToArray(_ref2, 2),
            left = _ref4[1];

        var _ref5 = _slicedToArray(_ref3, 2),
            right = _ref5[1];

        return left.expiry - right.expiry;
      }).forEach(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 1),
            timerHandle = _ref7[0];

        return _this2._runTimerHandle(timerHandle);
      });
    }
  }, {
    key: "advanceTimersToNextTimer",
    value: function advanceTimersToNextTimer() {
      var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (steps < 1) {
        return;
      }

      var nextExpiry = Array.from(this._timers.values()).reduce(function (minExpiry, timer) {
        if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;
        return minExpiry;
      }, null);

      if (nextExpiry !== null) {
        this.advanceTimersByTime(nextExpiry - this._now);
        this.advanceTimersToNextTimer(steps - 1);
      }
    }
  }, {
    key: "advanceTimersByTime",
    value: function advanceTimersByTime(msToRun) {
      this._checkFakeTimers(); // Only run a generous number of timers and then bail.
      // This is just to help avoid recursive loops


      var i;

      for (i = 0; i < this._maxLoops; i++) {
        var timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!


        if (timerHandle === null) {
          break;
        }

        var timerValue = this._timers.get(timerHandle);

        if (timerValue === undefined) {
          break;
        }

        var nextTimerExpiry = timerValue.expiry;

        if (this._now + msToRun < nextTimerExpiry) {
          // There are no timers between now and the target we're running to, so
          // adjust our time cursor and quit
          this._now += msToRun;
          break;
        } else {
          msToRun -= nextTimerExpiry - this._now;
          this._now = nextTimerExpiry;

          this._runTimerHandle(timerHandle);
        }
      }

      if (i === this._maxLoops) {
        throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + "Assuming we've hit an infinite recursion and bailing out...");
      }
    }
  }, {
    key: "runWithRealTimers",
    value: function runWithRealTimers(cb) {
      var prevClearImmediate = this._global.clearImmediate;
      var prevClearInterval = this._global.clearInterval;
      var prevClearTimeout = this._global.clearTimeout;
      var prevNextTick = this._global.process.nextTick;
      var prevSetImmediate = this._global.setImmediate;
      var prevSetInterval = this._global.setInterval;
      var prevSetTimeout = this._global.setTimeout;
      this.useRealTimers();
      var cbErr = null;
      var errThrown = false;

      try {
        cb();
      } catch (e) {
        errThrown = true;
        cbErr = e;
      }

      this._global.clearImmediate = prevClearImmediate;
      this._global.clearInterval = prevClearInterval;
      this._global.clearTimeout = prevClearTimeout;
      this._global.process.nextTick = prevNextTick;
      this._global.setImmediate = prevSetImmediate;
      this._global.setInterval = prevSetInterval;
      this._global.setTimeout = prevSetTimeout;

      if (errThrown) {
        throw cbErr;
      }
    }
  }, {
    key: "useRealTimers",
    value: function useRealTimers() {
      var global = this._global;
      setGlobal(global, 'clearImmediate', this._timerAPIs.clearImmediate);
      setGlobal(global, 'clearInterval', this._timerAPIs.clearInterval);
      setGlobal(global, 'clearTimeout', this._timerAPIs.clearTimeout);
      setGlobal(global, 'setImmediate', this._timerAPIs.setImmediate);
      setGlobal(global, 'setInterval', this._timerAPIs.setInterval);
      setGlobal(global, 'setTimeout', this._timerAPIs.setTimeout);
      global.process.nextTick = this._timerAPIs.nextTick;
    }
  }, {
    key: "useFakeTimers",
    value: function useFakeTimers() {
      this._createMocks();

      var global = this._global;
      setGlobal(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);
      setGlobal(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);
      setGlobal(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);
      setGlobal(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);
      setGlobal(global, 'setInterval', this._fakeTimerAPIs.setInterval);
      setGlobal(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);
      global.process.nextTick = this._fakeTimerAPIs.nextTick;
    }
  }, {
    key: "getTimerCount",
    value: function getTimerCount() {
      this._checkFakeTimers();

      return this._timers.size + this._immediates.length + this._ticks.length;
    }
  }, {
    key: "_checkFakeTimers",
    value: function _checkFakeTimers() {
      if (this._global.setTimeout !== this._fakeTimerAPIs.setTimeout) {
        this._global.console.warn("A function to advance timers was called but the timers API is not " + "mocked with fake timers. Call `jest.useFakeTimers()` in this " + "test or enable fake timers globally by setting " + "`\"timers\": \"fake\"` in " + "the configuration file. This warning is likely a result of a " + "default configuration change in Jest 15.\n\n" + "Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\n" + "Stack Trace:\n" + (0, _jestMessageUtil().formatStackTrace)(new Error().stack, this._config, {
          noStackTrace: false
        }));
      }
    }
  }, {
    key: "_createMocks",
    value: function _createMocks() {
      var _this3 = this;

      var fn = function fn(impl // @ts-ignore TODO: figure out better typings here
      ) {
        return _this3._moduleMocker.fn().mockImplementation(impl);
      }; // TODO: add better typings; these are mocks, but typed as regular timers


      this._fakeTimerAPIs = {
        clearImmediate: fn(this._fakeClearImmediate.bind(this)),
        clearInterval: fn(this._fakeClearTimer.bind(this)),
        clearTimeout: fn(this._fakeClearTimer.bind(this)),
        nextTick: fn(this._fakeNextTick.bind(this)),
        setImmediate: fn(this._fakeSetImmediate.bind(this)),
        setInterval: fn(this._fakeSetInterval.bind(this)),
        setTimeout: fn(this._fakeSetTimeout.bind(this))
      };
    }
  }, {
    key: "_fakeClearTimer",
    value: function _fakeClearTimer(timerRef) {
      var uuid = this._timerConfig.refToId(timerRef);

      if (uuid) {
        this._timers["delete"](String(uuid));
      }
    }
  }, {
    key: "_fakeClearImmediate",
    value: function _fakeClearImmediate(uuid) {
      this._cancelledImmediates[uuid] = true;
    }
  }, {
    key: "_fakeNextTick",
    value: function _fakeNextTick(callback) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this._disposed) {
        return;
      }

      var uuid = String(this._uuidCounter++);

      this._ticks.push({
        callback: function (_callback) {
          function callback() {
            return _callback.apply(this, arguments);
          }

          callback.toString = function () {
            return _callback.toString();
          };

          return callback;
        }(function () {
          return callback.apply(null, args);
        }),
        uuid: uuid
      });

      var cancelledTicks = this._cancelledTicks;

      this._timerAPIs.nextTick(function () {
        if (!cancelledTicks.hasOwnProperty(uuid)) {
          // Callback may throw, so update the map prior calling.
          cancelledTicks[uuid] = true;
          callback.apply(null, args);
        }
      });
    }
  }, {
    key: "_fakeSetImmediate",
    value: function _fakeSetImmediate(callback) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (this._disposed) {
        return null;
      }

      var uuid = this._uuidCounter++;

      this._immediates.push({
        callback: function (_callback2) {
          function callback() {
            return _callback2.apply(this, arguments);
          }

          callback.toString = function () {
            return _callback2.toString();
          };

          return callback;
        }(function () {
          return callback.apply(null, args);
        }),
        uuid: String(uuid)
      });

      var cancelledImmediates = this._cancelledImmediates;

      this._timerAPIs.setImmediate(function () {
        if (!cancelledImmediates.hasOwnProperty(uuid)) {
          // Callback may throw, so update the map prior calling.
          cancelledImmediates[String(uuid)] = true;
          callback.apply(null, args);
        }
      });

      return uuid;
    }
  }, {
    key: "_fakeSetInterval",
    value: function _fakeSetInterval(callback, intervalDelay) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      if (this._disposed) {
        return null;
      }

      if (intervalDelay == null) {
        intervalDelay = 0;
      }

      var uuid = this._uuidCounter++;

      this._timers.set(String(uuid), {
        callback: function (_callback3) {
          function callback() {
            return _callback3.apply(this, arguments);
          }

          callback.toString = function () {
            return _callback3.toString();
          };

          return callback;
        }(function () {
          return callback.apply(null, args);
        }),
        expiry: this._now + intervalDelay,
        interval: intervalDelay,
        type: 'interval'
      });

      return this._timerConfig.idToRef(uuid);
    }
  }, {
    key: "_fakeSetTimeout",
    value: function _fakeSetTimeout(callback, delay) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      if (this._disposed) {
        return null;
      } // eslint-disable-next-line no-bitwise


      delay = Number(delay) | 0;
      var uuid = this._uuidCounter++;

      this._timers.set(String(uuid), {
        callback: function (_callback4) {
          function callback() {
            return _callback4.apply(this, arguments);
          }

          callback.toString = function () {
            return _callback4.toString();
          };

          return callback;
        }(function () {
          return callback.apply(null, args);
        }),
        expiry: this._now + delay,
        interval: undefined,
        type: 'timeout'
      });

      return this._timerConfig.idToRef(uuid);
    }
  }, {
    key: "_getNextTimerHandle",
    value: function _getNextTimerHandle() {
      var nextTimerHandle = null;
      var soonestTime = MS_IN_A_YEAR;

      this._timers.forEach(function (timer, uuid) {
        if (timer.expiry < soonestTime) {
          soonestTime = timer.expiry;
          nextTimerHandle = uuid;
        }
      });

      return nextTimerHandle;
    }
  }, {
    key: "_runTimerHandle",
    value: function _runTimerHandle(timerHandle) {
      var timer = this._timers.get(timerHandle);

      if (!timer) {
        return;
      }

      switch (timer.type) {
        case 'timeout':
          var callback = timer.callback;

          this._timers["delete"](timerHandle);

          callback();
          break;

        case 'interval':
          timer.expiry = this._now + (timer.interval || 0);
          timer.callback();
          break;

        default:
          throw new Error('Unexpected timer type: ' + timer.type);
      }
    }
  }]);

  return FakeTimers;
}();

exports["default"] = FakeTimers;