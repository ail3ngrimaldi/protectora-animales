'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _fs() {
  var data = _interopRequireDefault(require('fs'));

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  var data = require('jest-haste-map');

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var FAIL = 0;
var SUCCESS = 1;
/**
 * The TestSequencer will ultimately decide which tests should run first.
 * It is responsible for storing and reading from a local cache
 * map that stores context information for a given test, such as how long it
 * took to run during the last run and if it has failed or not.
 * Such information is used on:
 * TestSequencer.sort(tests: Array<Test>)
 * to sort the order of the provided tests.
 *
 * After the results are collected,
 * TestSequencer.cacheResults(tests: Array<Test>, results: AggregatedResult)
 * is called to store/update this information on the cache map.
 */

var TestSequencer =
/*#__PURE__*/
function () {
  function TestSequencer() {
    _classCallCheck(this, TestSequencer);

    _defineProperty(this, '_cache', new Map());
  }

  _createClass(TestSequencer, [{
    key: "_getCachePath",
    value: function _getCachePath(context) {
      var config = context.config;
      return (0, _jestHasteMap().getCacheFilePath)(config.cacheDirectory, 'perf-cache-' + config.name);
    }
  }, {
    key: "_getCache",
    value: function _getCache(test) {
      var context = test.context;

      if (!this._cache.has(context) && context.config.cache) {
        var cachePath = this._getCachePath(context);

        if (_fs()["default"].existsSync(cachePath)) {
          try {
            this._cache.set(context, JSON.parse(_fs()["default"].readFileSync(cachePath, 'utf8')));
          } catch (e) {}
        }
      }

      var cache = this._cache.get(context);

      if (!cache) {
        cache = {};

        this._cache.set(context, cache);
      }

      return cache;
    }
    /**
     * Sorting tests is very important because it has a great impact on the
     * user-perceived responsiveness and speed of the test run.
     *
     * If such information is on cache, tests are sorted based on:
     * -> Has it failed during the last run ?
     * Since it's important to provide the most expected feedback as quickly
     * as possible.
     * -> How long it took to run ?
     * Because running long tests first is an effort to minimize worker idle
     * time at the end of a long test run.
     * And if that information is not available they are sorted based on file size
     * since big test files usually take longer to complete.
     *
     * Note that a possible improvement would be to analyse other information
     * from the file other than its size.
     *
     */

  }, {
    key: "sort",
    value: function sort(tests) {
      var _this = this;

      var stats = {};

      var fileSize = function fileSize(_ref) {
        var path = _ref.path,
            hasteFS = _ref.context.hasteFS;
        return stats[path] || (stats[path] = hasteFS.getSize(path) || 0);
      };

      var hasFailed = function hasFailed(cache, test) {
        return cache[test.path] && cache[test.path][0] === FAIL;
      };

      var time = function time(cache, test) {
        return cache[test.path] && cache[test.path][1];
      };

      tests.forEach(function (test) {
        return test.duration = time(_this._getCache(test), test);
      });
      return tests.sort(function (testA, testB) {
        var cacheA = _this._getCache(testA);

        var cacheB = _this._getCache(testB);

        var failedA = hasFailed(cacheA, testA);
        var failedB = hasFailed(cacheB, testB);
        var hasTimeA = testA.duration != null;

        if (failedA !== failedB) {
          return failedA ? -1 : 1;
        } else if (hasTimeA != (testB.duration != null)) {
          // If only one of two tests has timing information, run it last
          return hasTimeA ? 1 : -1;
        } else if (testA.duration != null && testB.duration != null) {
          return testA.duration < testB.duration ? 1 : -1;
        } else {
          return fileSize(testA) < fileSize(testB) ? 1 : -1;
        }
      });
    }
  }, {
    key: "cacheResults",
    value: function cacheResults(tests, results) {
      var _this2 = this;

      var map = Object.create(null);
      tests.forEach(function (test) {
        return map[test.path] = test;
      });
      results.testResults.forEach(function (testResult) {
        if (testResult && map[testResult.testFilePath] && !testResult.skipped) {
          var cache = _this2._getCache(map[testResult.testFilePath]);

          var perf = testResult.perfStats;
          cache[testResult.testFilePath] = [testResult.numFailingTests ? FAIL : SUCCESS, perf.end - perf.start || 0];
        }
      });

      this._cache.forEach(function (cache, context) {
        return _fs()["default"].writeFileSync(_this2._getCachePath(context), JSON.stringify(cache));
      });
    }
  }]);

  return TestSequencer;
}();

exports["default"] = TestSequencer;