'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

var _base_reporter = _interopRequireDefault(require('./base_reporter'));

var _Status = _interopRequireDefault(require('./Status'));

var _get_result_header = _interopRequireDefault(require('./get_result_header'));

var _get_snapshot_status = _interopRequireDefault(require('./get_snapshot_status'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var TITLE_BULLET = _chalk()["default"].bold("\u25CF ");

var DefaultReporter =
/*#__PURE__*/
function (_base_reporter$defaul) {
  _inherits(DefaultReporter, _base_reporter$defaul);

  // ANSI clear sequence for the last printed status
  function DefaultReporter(globalConfig) {
    var _this;

    _classCallCheck(this, DefaultReporter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultReporter).call(this));

    _defineProperty(_assertThisInitialized(_this), '_clear', void 0);

    _defineProperty(_assertThisInitialized(_this), '_err', void 0);

    _defineProperty(_assertThisInitialized(_this), '_globalConfig', void 0);

    _defineProperty(_assertThisInitialized(_this), '_out', void 0);

    _defineProperty(_assertThisInitialized(_this), '_status', void 0);

    _defineProperty(_assertThisInitialized(_this), '_bufferedOutput', void 0);

    _this._globalConfig = globalConfig;
    _this._clear = '';
    _this._out = process.stdout.write.bind(process.stdout);
    _this._err = process.stderr.write.bind(process.stderr);
    _this._status = new _Status["default"]();
    _this._bufferedOutput = new Set();

    _this._wrapStdio(process.stdout);

    _this._wrapStdio(process.stderr);

    _this._status.onChange(function () {
      _this._clearStatus();

      _this._printStatus();
    });

    return _this;
  }

  _createClass(DefaultReporter, [{
    key: "_wrapStdio",
    value: function _wrapStdio(stream) {
      var _this2 = this;

      var originalWrite = stream.write;
      var buffer = [];
      var timeout = null;

      var flushBufferedOutput = function flushBufferedOutput() {
        var string = buffer.join('');
        buffer = []; // This is to avoid conflicts between random output and status text

        _this2._clearStatus();

        if (string) {
          originalWrite.call(stream, string);
        }

        _this2._printStatus();

        _this2._bufferedOutput["delete"](flushBufferedOutput);
      };

      this._bufferedOutput.add(flushBufferedOutput);

      var debouncedFlush = function debouncedFlush() {
        // If the process blows up no errors would be printed.
        // There should be a smart way to buffer stderr, but for now
        // we just won't buffer it.
        if (stream === process.stderr) {
          flushBufferedOutput();
        } else {
          if (!timeout) {
            timeout = setTimeout(function () {
              flushBufferedOutput();
              timeout = null;
            }, 100);
          }
        }
      };

      stream.write = function (chunk) {
        buffer.push(chunk);
        debouncedFlush();
        return true;
      };
    } // Don't wait for the debounced call and flush all output immediately.

  }, {
    key: "forceFlushBufferedOutput",
    value: function forceFlushBufferedOutput() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._bufferedOutput[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var flushBufferedOutput = _step.value;
          flushBufferedOutput();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_clearStatus",
    value: function _clearStatus() {
      if (_jestUtil().isInteractive) {
        if (this._globalConfig.useStderr) {
          this._err(this._clear);
        } else {
          this._out(this._clear);
        }
      }
    }
  }, {
    key: "_printStatus",
    value: function _printStatus() {
      var _this$_status$get = this._status.get(),
          content = _this$_status$get.content,
          clear = _this$_status$get.clear;

      this._clear = clear;

      if (_jestUtil().isInteractive) {
        if (this._globalConfig.useStderr) {
          this._err(content);
        } else {
          this._out(content);
        }
      }
    }
  }, {
    key: "onRunStart",
    value: function onRunStart(aggregatedResults, options) {
      this._status.runStarted(aggregatedResults, options);
    }
  }, {
    key: "onTestStart",
    value: function onTestStart(test) {
      this._status.testStarted(test.path, test.context.config);
    }
  }, {
    key: "onRunComplete",
    value: function onRunComplete() {
      this.forceFlushBufferedOutput();

      this._status.runFinished();

      process.stdout.write = this._out;
      process.stderr.write = this._err;
      (0, _jestUtil().clearLine)(process.stderr);
    }
  }, {
    key: "onTestResult",
    value: function onTestResult(test, testResult, aggregatedResults) {
      this.testFinished(test.context.config, testResult, aggregatedResults);

      if (!testResult.skipped) {
        this.printTestFileHeader(testResult.testFilePath, test.context.config, testResult);
        this.printTestFileFailureMessage(testResult.testFilePath, test.context.config, testResult);
      }

      this.forceFlushBufferedOutput();
    }
  }, {
    key: "testFinished",
    value: function testFinished(config, testResult, aggregatedResults) {
      this._status.testFinished(config, testResult, aggregatedResults);
    }
  }, {
    key: "printTestFileHeader",
    value: function printTestFileHeader(_testPath, config, result) {
      this.log((0, _get_result_header["default"])(result, this._globalConfig, config));

      if (result.console) {
        this.log('  ' + TITLE_BULLET + 'Console\n\n' + (0, _jestUtil().getConsoleOutput)(config.cwd, !!this._globalConfig.verbose, result.console));
      }
    }
  }, {
    key: "printTestFileFailureMessage",
    value: function printTestFileFailureMessage(_testPath, _config, result) {
      if (result.failureMessage) {
        this.log(result.failureMessage);
      }

      var didUpdate = this._globalConfig.updateSnapshot === 'all';
      var snapshotStatuses = (0, _get_snapshot_status["default"])(result.snapshot, didUpdate);
      snapshotStatuses.forEach(this.log);
    }
  }]);

  return DefaultReporter;
}(_base_reporter["default"]);

exports["default"] = DefaultReporter;