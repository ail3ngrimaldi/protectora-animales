'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _path() {
  var data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _istanbulLibReport() {
  var data = _interopRequireDefault(require('istanbul-lib-report'));

  _istanbulLibReport = function _istanbulLibReport() {
    return data;
  };

  return data;
}

function _istanbulReports() {
  var data = _interopRequireDefault(require('istanbul-reports'));

  _istanbulReports = function _istanbulReports() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _istanbulLibCoverage() {
  var data = _interopRequireDefault(require('istanbul-lib-coverage'));

  _istanbulLibCoverage = function _istanbulLibCoverage() {
    return data;
  };

  return data;
}

function _istanbulLibSourceMaps() {
  var data = _interopRequireDefault(require('istanbul-lib-source-maps'));

  _istanbulLibSourceMaps = function _istanbulLibSourceMaps() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = _interopRequireDefault(require('jest-worker'));

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

function _glob() {
  var data = _interopRequireDefault(require('glob'));

  _glob = function _glob() {
    return data;
  };

  return data;
}

var _base_reporter = _interopRequireDefault(require('./base_reporter'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var FAIL_COLOR = _chalk()["default"].bold.red;

var RUNNING_TEST_COLOR = _chalk()["default"].bold.dim;

var CoverageReporter =
/*#__PURE__*/
function (_base_reporter$defaul) {
  _inherits(CoverageReporter, _base_reporter$defaul);

  function CoverageReporter(globalConfig, options) {
    var _this3;

    _classCallCheck(this, CoverageReporter);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(CoverageReporter).call(this));

    _defineProperty(_assertThisInitialized(_this3), '_coverageMap', void 0);

    _defineProperty(_assertThisInitialized(_this3), '_globalConfig', void 0);

    _defineProperty(_assertThisInitialized(_this3), '_sourceMapStore', void 0);

    _defineProperty(_assertThisInitialized(_this3), '_options', void 0);

    _this3._coverageMap = _istanbulLibCoverage()["default"].createCoverageMap({});
    _this3._globalConfig = globalConfig;
    _this3._sourceMapStore = _istanbulLibSourceMaps()["default"].createSourceMapStore();
    _this3._options = options || {};
    return _this3;
  }

  _createClass(CoverageReporter, [{
    key: "onTestResult",
    value: function onTestResult(_test, testResult, _aggregatedResults) {
      var _this4 = this;

      if (testResult.coverage) {
        this._coverageMap.merge(testResult.coverage);
      }

      var sourceMaps = testResult.sourceMaps;

      if (sourceMaps) {
        Object.keys(sourceMaps).forEach(function (sourcePath) {
          var inputSourceMap;

          try {
            var coverage = _this4._coverageMap.fileCoverageFor(sourcePath);

            inputSourceMap = coverage.toJSON().inputSourceMap;
          } finally {
            if (inputSourceMap) {
              _this4._sourceMapStore.registerMap(sourcePath, inputSourceMap);
            } else {
              _this4._sourceMapStore.registerURL(sourcePath, sourceMaps[sourcePath]);
            }
          }
        });
      }
    }
  }, {
    key: "onRunComplete",
    value: function onRunComplete(contexts, aggregatedResults) {
      var _this = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this$_sourceMapStore, map, sourceFinder, reportContext, coverageReporters, tree;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this._addUntestedFiles(_this._globalConfig, contexts);

              case 2:
                _this$_sourceMapStore = _this._sourceMapStore.transformCoverage(_this._coverageMap), map = _this$_sourceMapStore.map, sourceFinder = _this$_sourceMapStore.sourceFinder;

                try {
                  reportContext = _istanbulLibReport()["default"].createContext({
                    dir: _this._globalConfig.coverageDirectory,
                    sourceFinder: sourceFinder
                  });
                  coverageReporters = _this._globalConfig.coverageReporters || [];

                  if (!_this._globalConfig.useStderr && coverageReporters.length < 1) {
                    coverageReporters.push('text-summary');
                  }

                  tree = _istanbulLibReport()["default"].summarizers.pkg(map);
                  coverageReporters.forEach(function (reporter) {
                    tree.visit(_istanbulReports()["default"].create(reporter, {}), reportContext);
                  });
                  aggregatedResults.coverageMap = map;
                } catch (e) {
                  console.error(_chalk()["default"].red("\n        Failed to write coverage reports:\n        ERROR: ".concat(e.toString(), "\n        STACK: ").concat(e.stack, "\n      ")));
                }

                _this._checkThreshold(_this._globalConfig, map);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }, {
    key: "_addUntestedFiles",
    value: function _addUntestedFiles(globalConfig, contexts) {
      var _this2 = this;

      return _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var files, worker, instrumentation;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                files = [];
                contexts.forEach(function (context) {
                  var config = context.config;

                  if (globalConfig.collectCoverageFrom && globalConfig.collectCoverageFrom.length) {
                    context.hasteFS.matchFilesWithGlob(globalConfig.collectCoverageFrom, config.rootDir).forEach(function (filePath) {
                      return files.push({
                        config: config,
                        path: filePath
                      });
                    });
                  }
                });

                if (files.length) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return");

              case 4:
                if (_jestUtil().isInteractive) {
                  process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));
                }

                if (_this2._globalConfig.maxWorkers <= 1) {
                  worker = require('./coverage_worker');
                } else {
                  worker = new (_jestWorker()["default"])(require.resolve('./coverage_worker'), {
                    exposedMethods: ['worker'],
                    maxRetries: 2,
                    numWorkers: _this2._globalConfig.maxWorkers
                  });
                }

                instrumentation = files.map(
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(fileObj) {
                    var filename, config, result;
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            filename = fileObj.path;
                            config = fileObj.config;

                            if (!(!_this2._coverageMap.data[filename] && 'worker' in worker)) {
                              _context2.next = 13;
                              break;
                            }

                            _context2.prev = 3;
                            _context2.next = 6;
                            return worker.worker({
                              config: config,
                              globalConfig: globalConfig,
                              options: _objectSpread({}, _this2._options, {
                                changedFiles: _this2._options.changedFiles && Array.from(_this2._options.changedFiles)
                              }),
                              path: filename
                            });

                          case 6:
                            result = _context2.sent;

                            if (result) {
                              _this2._coverageMap.addFileCoverage(result.coverage);

                              if (result.sourceMapPath) {
                                _this2._sourceMapStore.registerURL(filename, result.sourceMapPath);
                              }
                            }

                            _context2.next = 13;
                            break;

                          case 10:
                            _context2.prev = 10;
                            _context2.t0 = _context2["catch"](3);
                            console.error(_chalk()["default"].red(["Failed to collect coverage from ".concat(filename), "ERROR: ".concat(_context2.t0.message), "STACK: ".concat(_context2.t0.stack)].join('\n')));

                          case 13:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, null, [[3, 10]]);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context3.prev = 7;
                _context3.next = 10;
                return Promise.all(instrumentation);

              case 10:
                _context3.next = 14;
                break;

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](7);

              case 14:
                if (_jestUtil().isInteractive) {
                  (0, _jestUtil().clearLine)(process.stderr);
                }

                if (worker && 'end' in worker && typeof worker.end === 'function') {
                  worker.end();
                }

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[7, 12]]);
      }))();
    }
  }, {
    key: "_checkThreshold",
    value: function _checkThreshold(globalConfig, map) {
      if (globalConfig.coverageThreshold) {
        var check = function check(name, thresholds, actuals) {
          return ['statements', 'branches', 'lines', 'functions'].reduce(function (errors, key) {
            var actual = actuals[key].pct;
            var actualUncovered = actuals[key].total - actuals[key].covered;
            var threshold = thresholds[key];

            if (threshold != null) {
              if (threshold < 0) {
                if (threshold * -1 < actualUncovered) {
                  errors.push("Jest: Uncovered count for ".concat(key, " (").concat(actualUncovered, ")") + "exceeds ".concat(name, " threshold (").concat(-1 * threshold, ")"));
                }
              } else if (actual < threshold) {
                errors.push("Jest: \"".concat(name, "\" coverage threshold for ").concat(key, " (").concat(threshold, "%) not met: ").concat(actual, "%"));
              }
            }

            return errors;
          }, []);
        };

        var combineCoverage = function combineCoverage(filePaths) {
          return filePaths.map(function (filePath) {
            return map.fileCoverageFor(filePath);
          }).reduce(function (combinedCoverage, nextFileCoverage) {
            if (combinedCoverage === undefined || combinedCoverage === null) {
              return nextFileCoverage.toSummary();
            }

            return combinedCoverage.merge(nextFileCoverage.toSummary());
          }, undefined);
        };

        var THRESHOLD_GROUP_TYPES = {
          GLOB: 'glob',
          GLOBAL: 'global',
          PATH: 'path'
        };
        var coveredFiles = map.files();
        var thresholdGroups = Object.keys(globalConfig.coverageThreshold);
        var groupTypeByThresholdGroup = {};
        var filesByGlob = {};
        var coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce(function (files, file) {
          var pathOrGlobMatches = thresholdGroups.reduce(function (agg, thresholdGroup) {
            var absoluteThresholdGroup = _path()["default"].resolve(thresholdGroup); // The threshold group might be a path:


            if (file.indexOf(absoluteThresholdGroup) === 0) {
              groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;
              return agg.concat([[file, thresholdGroup]]);
            } // If the threshold group is not a path it might be a glob:
            // Note: glob.sync is slow. By memoizing the files matching each glob
            // (rather than recalculating it for each covered file) we save a tonne
            // of execution time.


            if (filesByGlob[absoluteThresholdGroup] === undefined) {
              filesByGlob[absoluteThresholdGroup] = _glob()["default"].sync(absoluteThresholdGroup).map(function (filePath) {
                return _path()["default"].resolve(filePath);
              });
            }

            if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {
              groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;
              return agg.concat([[file, thresholdGroup]]);
            }

            return agg;
          }, []);

          if (pathOrGlobMatches.length > 0) {
            return files.concat(pathOrGlobMatches);
          } // Neither a glob or a path? Toss it in global if there's a global threshold:


          if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {
            groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;
            return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);
          } // A covered file that doesn't have a threshold:


          return files.concat([[file, undefined]]);
        }, []);

        var getFilesInThresholdGroup = function getFilesInThresholdGroup(thresholdGroup) {
          return coveredFilesSortedIntoThresholdGroup.filter(function (fileAndGroup) {
            return fileAndGroup[1] === thresholdGroup;
          }).map(function (fileAndGroup) {
            return fileAndGroup[0];
          });
        };

        var errors = [];
        thresholdGroups.forEach(function (thresholdGroup) {
          switch (groupTypeByThresholdGroup[thresholdGroup]) {
            case THRESHOLD_GROUP_TYPES.GLOBAL:
              {
                var coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));

                if (coverage) {
                  errors = errors.concat(check(thresholdGroup, globalConfig.coverageThreshold[thresholdGroup], coverage));
                }

                break;
              }

            case THRESHOLD_GROUP_TYPES.PATH:
              {
                var _coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));

                if (_coverage) {
                  errors = errors.concat(check(thresholdGroup, globalConfig.coverageThreshold[thresholdGroup], _coverage));
                }

                break;
              }

            case THRESHOLD_GROUP_TYPES.GLOB:
              getFilesInThresholdGroup(thresholdGroup).forEach(function (fileMatchingGlob) {
                errors = errors.concat(check(fileMatchingGlob, globalConfig.coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));
              });
              break;

            default:
              // If the file specified by path is not found, error is returned.
              if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {
                errors = errors.concat("Jest: Coverage data for ".concat(thresholdGroup, " was not found."));
              }

            // Sometimes all files in the coverage data are matched by
            // PATH and GLOB threshold groups in which case, don't error when
            // the global threshold group doesn't match any files.
          }
        });
        errors = errors.filter(function (err) {
          return err !== undefined && err !== null && err.length > 0;
        });

        if (errors.length > 0) {
          this.log("".concat(FAIL_COLOR(errors.join('\n'))));

          this._setError(new Error(errors.join('\n')));
        }
      }
    } // Only exposed for the internal runner. Should not be used

  }, {
    key: "getCoverageMap",
    value: function getCoverageMap() {
      return this._coverageMap;
    }
  }]);

  return CoverageReporter;
}(_base_reporter["default"]);

exports["default"] = CoverageReporter;