'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.wrapAnsiString = exports.getSummary = exports.relativePath = exports.formatTestPath = exports.trimAndFormatPath = exports.printDisplayName = void 0;

function _path() {
  var data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var PROGRESS_BAR_WIDTH = 40;

var printDisplayName = function printDisplayName(config) {
  var displayName = config.displayName;

  var white = _chalk()["default"].reset.inverse.white;

  if (!displayName) {
    return '';
  }

  if (typeof displayName === 'string') {
    return _chalk()["default"].supportsColor ? white(" ".concat(displayName, " ")) : displayName;
  }

  var name = displayName.name,
      color = displayName.color;
  var chosenColor = _chalk()["default"].reset.inverse[color] ? _chalk()["default"].reset.inverse[color] : white;
  return _chalk()["default"].supportsColor ? chosenColor(" ".concat(name, " ")) : name;
};

exports.printDisplayName = printDisplayName;

var trimAndFormatPath = function trimAndFormatPath(pad, config, testPath, columns) {
  var maxLength = columns - pad;
  var relative = relativePath(config, testPath);
  var basename = relative.basename;
  var dirname = relative.dirname; // length is ok

  if ((dirname + _path()["default"].sep + basename).length <= maxLength) {
    return (0, _slash()["default"])(_chalk()["default"].dim(dirname + _path()["default"].sep) + _chalk()["default"].bold(basename));
  } // we can fit trimmed dirname and full basename


  var basenameLength = basename.length;

  if (basenameLength + 4 < maxLength) {
    var dirnameLength = maxLength - 4 - basenameLength;
    dirname = '...' + dirname.slice(dirname.length - dirnameLength, dirname.length);
    return (0, _slash()["default"])(_chalk()["default"].dim(dirname + _path()["default"].sep) + _chalk()["default"].bold(basename));
  }

  if (basenameLength + 4 === maxLength) {
    return (0, _slash()["default"])(_chalk()["default"].dim('...' + _path()["default"].sep) + _chalk()["default"].bold(basename));
  } // can't fit dirname, but can fit trimmed basename


  return (0, _slash()["default"])(_chalk()["default"].bold('...' + basename.slice(basename.length - maxLength - 4, basename.length)));
};

exports.trimAndFormatPath = trimAndFormatPath;

var formatTestPath = function formatTestPath(config, testPath) {
  var _relativePath = relativePath(config, testPath),
      dirname = _relativePath.dirname,
      basename = _relativePath.basename;

  return (0, _slash()["default"])(_chalk()["default"].dim(dirname + _path()["default"].sep) + _chalk()["default"].bold(basename));
};

exports.formatTestPath = formatTestPath;

var relativePath = function relativePath(config, testPath) {
  // this function can be called with ProjectConfigs or GlobalConfigs. GlobalConfigs
  // do not have config.cwd, only config.rootDir. Try using config.cwd, fallback
  // to config.rootDir. (Also, some unit just use config.rootDir, which is ok)
  testPath = _path()["default"].relative(config.cwd || config.rootDir, testPath);

  var dirname = _path()["default"].dirname(testPath);

  var basename = _path()["default"].basename(testPath);

  return {
    basename: basename,
    dirname: dirname
  };
};

exports.relativePath = relativePath;

var getSummary = function getSummary(aggregatedResults, options) {
  var runTime = (Date.now() - aggregatedResults.startTime) / 1000;

  if (options && options.roundTime) {
    runTime = Math.floor(runTime);
  }

  var estimatedTime = options && options.estimatedTime || 0;
  var snapshotResults = aggregatedResults.snapshot;
  var snapshotsAdded = snapshotResults.added;
  var snapshotsFailed = snapshotResults.unmatched;
  var snapshotsOutdated = snapshotResults.unchecked;
  var snapshotsFilesRemoved = snapshotResults.filesRemoved;
  var snapshotsDidUpdate = snapshotResults.didUpdate;
  var snapshotsPassed = snapshotResults.matched;
  var snapshotsTotal = snapshotResults.total;
  var snapshotsUpdated = snapshotResults.updated;
  var suitesFailed = aggregatedResults.numFailedTestSuites;
  var suitesPassed = aggregatedResults.numPassedTestSuites;
  var suitesPending = aggregatedResults.numPendingTestSuites;
  var suitesRun = suitesFailed + suitesPassed;
  var suitesTotal = aggregatedResults.numTotalTestSuites;
  var testsFailed = aggregatedResults.numFailedTests;
  var testsPassed = aggregatedResults.numPassedTests;
  var testsPending = aggregatedResults.numPendingTests;
  var testsTodo = aggregatedResults.numTodoTests;
  var testsTotal = aggregatedResults.numTotalTests;
  var width = options && options.width || 0;
  var suites = _chalk()["default"].bold('Test Suites: ') + (suitesFailed ? _chalk()["default"].bold.red("".concat(suitesFailed, " failed")) + ', ' : '') + (suitesPending ? _chalk()["default"].bold.yellow("".concat(suitesPending, " skipped")) + ', ' : '') + (suitesPassed ? _chalk()["default"].bold.green("".concat(suitesPassed, " passed")) + ', ' : '') + (suitesRun !== suitesTotal ? suitesRun + ' of ' + suitesTotal : suitesTotal) + " total";
  var tests = _chalk()["default"].bold('Tests:       ') + (testsFailed ? _chalk()["default"].bold.red("".concat(testsFailed, " failed")) + ', ' : '') + (testsPending ? _chalk()["default"].bold.yellow("".concat(testsPending, " skipped")) + ', ' : '') + (testsTodo ? _chalk()["default"].bold.magenta("".concat(testsTodo, " todo")) + ', ' : '') + (testsPassed ? _chalk()["default"].bold.green("".concat(testsPassed, " passed")) + ', ' : '') + "".concat(testsTotal, " total");
  var snapshots = _chalk()["default"].bold('Snapshots:   ') + (snapshotsFailed ? _chalk()["default"].bold.red("".concat(snapshotsFailed, " failed")) + ', ' : '') + (snapshotsOutdated && !snapshotsDidUpdate ? _chalk()["default"].bold.yellow("".concat(snapshotsOutdated, " obsolete")) + ', ' : '') + (snapshotsOutdated && snapshotsDidUpdate ? _chalk()["default"].bold.green("".concat(snapshotsOutdated, " removed")) + ', ' : '') + (snapshotsFilesRemoved && !snapshotsDidUpdate ? _chalk()["default"].bold.yellow((0, _jestUtil().pluralize)('file', snapshotsFilesRemoved) + ' obsolete') + ', ' : '') + (snapshotsFilesRemoved && snapshotsDidUpdate ? _chalk()["default"].bold.green((0, _jestUtil().pluralize)('file', snapshotsFilesRemoved) + ' removed') + ', ' : '') + (snapshotsUpdated ? _chalk()["default"].bold.green("".concat(snapshotsUpdated, " updated")) + ', ' : '') + (snapshotsAdded ? _chalk()["default"].bold.green("".concat(snapshotsAdded, " written")) + ', ' : '') + (snapshotsPassed ? _chalk()["default"].bold.green("".concat(snapshotsPassed, " passed")) + ', ' : '') + "".concat(snapshotsTotal, " total");
  var time = renderTime(runTime, estimatedTime, width);
  return [suites, tests, snapshots, time].join('\n');
};

exports.getSummary = getSummary;

var renderTime = function renderTime(runTime, estimatedTime, width) {
  // If we are more than one second over the estimated time, highlight it.
  var renderedTime = estimatedTime && runTime >= estimatedTime + 1 ? _chalk()["default"].bold.yellow(runTime + 's') : runTime + 's';
  var time = _chalk()["default"].bold("Time:") + "        ".concat(renderedTime);

  if (runTime < estimatedTime) {
    time += ", estimated ".concat(estimatedTime, "s");
  } // Only show a progress bar if the test run is actually going to take
  // some time.


  if (estimatedTime > 2 && runTime < estimatedTime && width) {
    var availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);
    var length = Math.min(Math.floor(runTime / estimatedTime * availableWidth), availableWidth);

    if (availableWidth >= 2) {
      time += '\n' + _chalk()["default"].green('█').repeat(length) + _chalk()["default"].white('█').repeat(availableWidth - length);
    }
  }

  return time;
}; // word-wrap a string that contains ANSI escape sequences.
// ANSI escape sequences do not add to the string length.


var wrapAnsiString = function wrapAnsiString(string, terminalWidth) {
  if (terminalWidth === 0) {
    // if the terminal width is zero, don't bother word-wrapping
    return string;
  }

  var ANSI_REGEXP = /[\u001b\u009b]\[\d{1,2}m/g;
  var tokens = [];
  var lastIndex = 0;
  var match;

  while (match = ANSI_REGEXP.exec(string)) {
    var ansi = match[0];
    var index = match['index'];

    if (index != lastIndex) {
      tokens.push(['string', string.slice(lastIndex, index)]);
    }

    tokens.push(['ansi', ansi]);
    lastIndex = index + ansi.length;
  }

  if (lastIndex != string.length - 1) {
    tokens.push(['string', string.slice(lastIndex, string.length)]);
  }

  var lastLineLength = 0;
  return tokens.reduce(function (lines, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        kind = _ref2[0],
        token = _ref2[1];

    if (kind === 'string') {
      if (lastLineLength + token.length > terminalWidth) {
        while (token.length) {
          var chunk = token.slice(0, terminalWidth - lastLineLength);
          var remaining = token.slice(terminalWidth - lastLineLength, token.length);
          lines[lines.length - 1] += chunk;
          lastLineLength += chunk.length;
          token = remaining;

          if (token.length) {
            lines.push('');
            lastLineLength = 0;
          }
        }
      } else {
        lines[lines.length - 1] += token;
        lastLineLength += token.length;
      }
    } else {
      lines[lines.length - 1] += token;
    }

    return lines;
  }, ['']).join('\n');
};

exports.wrapAnsiString = wrapAnsiString;