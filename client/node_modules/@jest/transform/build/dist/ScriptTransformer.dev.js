'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _crypto() {
  var data = _interopRequireDefault(require('crypto'));

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function _path() {
  var data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _vm() {
  var data = _interopRequireDefault(require('vm'));

  _vm = function _vm() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _gracefulFs() {
  var data = _interopRequireDefault(require('graceful-fs'));

  _gracefulFs = function _gracefulFs() {
    return data;
  };

  return data;
}

function _core() {
  var data = require('@babel/core');

  _core = function _core() {
    return data;
  };

  return data;
}

function _babelPluginIstanbul() {
  var data = _interopRequireDefault(require('babel-plugin-istanbul'));

  _babelPluginIstanbul = function _babelPluginIstanbul() {
    return data;
  };

  return data;
}

function _convertSourceMap() {
  var data = _interopRequireDefault(require('convert-source-map'));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  var data = _interopRequireDefault(require('jest-haste-map'));

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _fastJsonStableStringify() {
  var data = _interopRequireDefault(require('fast-json-stable-stringify'));

  _fastJsonStableStringify = function _fastJsonStableStringify() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _writeFileAtomic() {
  var data = _interopRequireDefault(require('write-file-atomic'));

  _writeFileAtomic = function _writeFileAtomic() {
    return data;
  };

  return data;
}

function _realpathNative() {
  var data = require('realpath-native');

  _realpathNative = function _realpathNative() {
    return data;
  };

  return data;
}

function _pirates() {
  var data = require('pirates');

  _pirates = function _pirates() {
    return data;
  };

  return data;
}

var _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));

var _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }

      _next(undefined);
    });
  };
} // Use `require` to avoid TS rootDir


var _require = require('../package.json'),
    VERSION = _require.version; // This data structure is used to avoid recalculating some data every time that
// we need to transform a file. Since ScriptTransformer is instantiated for each
// file we need to keep this object in the local scope of this module.


var projectCaches = new WeakMap(); // To reset the cache for specific changesets (rather than package version).

var CACHE_VERSION = '1';

function waitForPromiseWithCleanup(_x, _x2) {
  return _waitForPromiseWithCleanup.apply(this, arguments);
}

function _waitForPromiseWithCleanup() {
  _waitForPromiseWithCleanup = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(promise, cleanup) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return promise;

          case 3:
            _context.prev = 3;
            cleanup();
            return _context.finish(3);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0,, 3, 6]]);
  }));
  return _waitForPromiseWithCleanup.apply(this, arguments);
}

var ScriptTransformer =
/*#__PURE__*/
function () {
  function ScriptTransformer(config) {
    _classCallCheck(this, ScriptTransformer);

    _defineProperty(this, '_cache', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_transformCache', void 0);

    _defineProperty(this, '_transformConfigCache', void 0);

    this._config = config;
    this._transformCache = new Map();
    this._transformConfigCache = new Map();
    var projectCache = projectCaches.get(config);

    if (!projectCache) {
      projectCache = {
        configString: (0, _fastJsonStableStringify()["default"])(this._config),
        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),
        transformRegExp: calcTransformRegExp(this._config),
        transformedFiles: new Map()
      };
      projectCaches.set(config, projectCache);
    }

    this._cache = projectCache;
  }

  _createClass(ScriptTransformer, [{
    key: "_getCacheKey",
    value: function _getCacheKey(fileData, filename, instrument) {
      var configString = this._cache.configString;

      var transformer = this._getTransformer(filename);

      if (transformer && typeof transformer.getCacheKey === 'function') {
        return _crypto()["default"].createHash('md5').update(transformer.getCacheKey(fileData, filename, configString, {
          config: this._config,
          instrument: instrument,
          rootDir: this._config.rootDir
        })).update(CACHE_VERSION).digest('hex');
      } else {
        return _crypto()["default"].createHash('md5').update(fileData).update(configString).update(instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');
      }
    }
  }, {
    key: "_getFileCachePath",
    value: function _getFileCachePath(filename, content, instrument) {
      var baseCacheDir = _jestHasteMap()["default"].getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION);

      var cacheKey = this._getCacheKey(content, filename, instrument); // Create sub folders based on the cacheKey to avoid creating one
      // directory with many files.


      var cacheDir = _path()["default"].join(baseCacheDir, cacheKey[0] + cacheKey[1]);

      var cacheFilenamePrefix = _path()["default"].basename(filename, _path()["default"].extname(filename)).replace(/\W/g, '');

      var cachePath = (0, _slash()["default"])(_path()["default"].join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));
      (0, _jestUtil().createDirectory)(cacheDir);
      return cachePath;
    }
  }, {
    key: "_getTransformPath",
    value: function _getTransformPath(filename) {
      var transformRegExp = this._cache.transformRegExp;

      if (!transformRegExp) {
        return undefined;
      }

      for (var i = 0; i < transformRegExp.length; i++) {
        if (transformRegExp[i][0].test(filename)) {
          var transformPath = transformRegExp[i][1];

          this._transformConfigCache.set(transformPath, transformRegExp[i][2]);

          return transformPath;
        }
      }

      return undefined;
    }
  }, {
    key: "_getTransformer",
    value: function _getTransformer(filename) {
      var transform = null;

      if (!this._config.transform || !this._config.transform.length) {
        return null;
      }

      var transformPath = this._getTransformPath(filename);

      if (transformPath) {
        var transformer = this._transformCache.get(transformPath);

        if (transformer != null) {
          return transformer;
        }

        transform = require(transformPath);

        var transformerConfig = this._transformConfigCache.get(transformPath);

        if (typeof transform.createTransformer === 'function') {
          transform = transform.createTransformer(transformerConfig);
        }

        if (typeof transform.process !== 'function') {
          throw new TypeError('Jest: a transform must export a `process` function.');
        }

        this._transformCache.set(transformPath, transform);
      }

      return transform;
    }
  }, {
    key: "_instrumentFile",
    value: function _instrumentFile(filename, content) {
      var result = (0, _core().transformSync)(content, {
        auxiliaryCommentBefore: ' istanbul ignore next ',
        babelrc: false,
        caller: {
          name: '@jest/transform',
          supportsStaticESM: false
        },
        configFile: false,
        filename: filename,
        plugins: [[_babelPluginIstanbul()["default"], {
          compact: false,
          // files outside `cwd` will not be instrumented
          cwd: this._config.rootDir,
          exclude: [],
          useInlineSourceMaps: false
        }]]
      });

      if (result) {
        var code = result.code;

        if (code) {
          return code;
        }
      }

      return content;
    }
  }, {
    key: "_getRealPath",
    value: function _getRealPath(filepath) {
      try {
        return (0, _realpathNative().sync)(filepath) || filepath;
      } catch (err) {
        return filepath;
      }
    } // We don't want to expose transformers to the outside - this function is just
    // to warm up `this._transformCache`

  }, {
    key: "preloadTransformer",
    value: function preloadTransformer(filepath) {
      this._getTransformer(filepath);
    }
  }, {
    key: "transformSource",
    value: function transformSource(filepath, content, instrument) {
      var filename = this._getRealPath(filepath);

      var transform = this._getTransformer(filename);

      var cacheFilePath = this._getFileCachePath(filename, content, instrument);

      var sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)

      var code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;
      var shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation
      // logic and will handle it based on `config.collectCoverage` option

      var transformWillInstrument = shouldCallTransform && transform && transform.canInstrument; // If we handle the coverage instrumentation, we should try to map code
      // coverage against original source with any provided source map

      var mapCoverage = instrument && !transformWillInstrument;

      if (code) {
        // This is broken: we return the code, and a path for the source map
        // directly from the cache. But, nothing ensures the source map actually
        // matches that source code. They could have gotten out-of-sync in case
        // two separate processes write concurrently to the same cache files.
        return {
          code: code,
          mapCoverage: mapCoverage,
          sourceMapPath: sourceMapPath
        };
      }

      var transformed = {
        code: content,
        map: null
      };

      if (transform && shouldCallTransform) {
        var processed = transform.process(content, filename, this._config, {
          instrument: instrument
        });

        if (typeof processed === 'string') {
          transformed.code = processed;
        } else if (processed != null && typeof processed.code === 'string') {
          transformed = processed;
        } else {
          throw new TypeError("Jest: a transform's `process` function must return a string, " + 'or an object with `code` key containing this string.');
        }
      }

      if (!transformed.map) {
        //Could be a potential freeze here.
        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570
        var inlineSourceMap = _convertSourceMap()["default"].fromSource(transformed.code);

        if (inlineSourceMap) {
          transformed.map = inlineSourceMap.toJSON();
        }
      }

      if (!transformWillInstrument && instrument) {
        code = this._instrumentFile(filename, transformed.code);
      } else {
        code = transformed.code;
      }

      if (transformed.map) {
        var sourceMapContent = typeof transformed.map === 'string' ? transformed.map : JSON.stringify(transformed.map);
        writeCacheFile(sourceMapPath, sourceMapContent);
      } else {
        sourceMapPath = null;
      }

      writeCodeCacheFile(cacheFilePath, code);
      return {
        code: code,
        mapCoverage: mapCoverage,
        sourceMapPath: sourceMapPath
      };
    }
  }, {
    key: "_transformAndBuildScript",
    value: function _transformAndBuildScript(filename, options, instrument, fileSource) {
      var isInternalModule = !!(options && options.isInternalModule);
      var isCoreModule = !!(options && options.isCoreModule);
      var content = stripShebang(fileSource || _gracefulFs()["default"].readFileSync(filename, 'utf8'));
      var wrappedCode;
      var sourceMapPath = null;
      var mapCoverage = false;
      var willTransform = !isInternalModule && !isCoreModule && (this.shouldTransform(filename) || instrument);

      try {
        var extraGlobals = options && options.extraGlobals || [];

        if (willTransform) {
          var transformedSource = this.transformSource(filename, content, instrument);
          wrappedCode = wrap.apply(void 0, [transformedSource.code].concat(_toConsumableArray(extraGlobals)));
          sourceMapPath = transformedSource.sourceMapPath;
          mapCoverage = transformedSource.mapCoverage;
        } else {
          wrappedCode = wrap.apply(void 0, [content].concat(_toConsumableArray(extraGlobals)));
        }

        return {
          mapCoverage: mapCoverage,
          script: new (_vm()["default"].Script)(wrappedCode, {
            displayErrors: true,
            filename: isCoreModule ? 'jest-nodejs-core-' + filename : filename
          }),
          sourceMapPath: sourceMapPath
        };
      } catch (e) {
        if (e.codeFrame) {
          e.stack = e.message + '\n' + e.codeFrame;
        }

        if (e instanceof SyntaxError && e.message.includes('Unexpected token') && !e.message.includes(' expected')) {
          throw (0, _enhanceUnexpectedTokenMessage["default"])(e);
        }

        throw e;
      }
    }
  }, {
    key: "transform",
    value: function transform(filename, options, fileSource) {
      var scriptCacheKey = undefined;
      var instrument = false;

      if (!options.isCoreModule) {
        instrument = (0, _shouldInstrument["default"])(filename, options, this._config);
        scriptCacheKey = getScriptCacheKey(filename, instrument);

        var _result = this._cache.transformedFiles.get(scriptCacheKey);

        if (_result) {
          return _result;
        }
      }

      var result = this._transformAndBuildScript(filename, options, instrument, fileSource);

      if (scriptCacheKey) {
        this._cache.transformedFiles.set(scriptCacheKey, result);
      }

      return result;
    }
  }, {
    key: "transformJson",
    value: function transformJson(filename, options, fileSource) {
      var isInternalModule = options.isInternalModule;
      var isCoreModule = options.isCoreModule;
      var willTransform = !isInternalModule && !isCoreModule && this.shouldTransform(filename);

      if (willTransform) {
        var _this$transformSource = this.transformSource(filename, fileSource, false),
            transformedJsonSource = _this$transformSource.code;

        return transformedJsonSource;
      }

      return fileSource;
    }
  }, {
    key: "requireAndTranspileModule",
    value: function requireAndTranspileModule(moduleName, callback) {
      var _this = this;

      // Load the transformer to avoid a cycle where we need to load a
      // transformer in order to transform it in the require hooks
      this.preloadTransformer(moduleName);
      var transforming = false;
      var revertHook = (0, _pirates().addHook)(function (code, filename) {
        try {
          transforming = true;
          return _this.transformSource(filename, code, false).code || code;
        } finally {
          transforming = false;
        }
      }, {
        exts: [_path()["default"].extname(moduleName)],
        ignoreNodeModules: false,
        matcher: function matcher(filename) {
          if (transforming) {
            // Don't transform any dependency required by the transformer itself
            return false;
          }

          return _this.shouldTransform(filename);
        }
      });

      var module = require(moduleName);

      if (!callback) {
        revertHook();
        return module;
      }

      try {
        var cbResult = callback(module);

        if ((0, _jestUtil().isPromise)(cbResult)) {
          return waitForPromiseWithCleanup(cbResult, revertHook).then(function () {
            return module;
          });
        }
      } finally {
        revertHook();
      }

      return module;
    }
    /**
     * @deprecated use `this.shouldTransform` instead
     */
    // @ts-ignore: Unused and private - remove in Jest 25

  }, {
    key: "_shouldTransform",
    value: function _shouldTransform(filename) {
      return this.shouldTransform(filename);
    }
  }, {
    key: "shouldTransform",
    value: function shouldTransform(filename) {
      var ignoreRegexp = this._cache.ignorePatternsRegExp;
      var isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;
      return !!this._config.transform && !!this._config.transform.length && !isIgnored;
    }
  }]);

  return ScriptTransformer;
}();

exports["default"] = ScriptTransformer;

_defineProperty(ScriptTransformer, 'EVAL_RESULT_VARIABLE', void 0);

var removeFile = function removeFile(path) {
  try {
    _gracefulFs()["default"].unlinkSync(path);
  } catch (e) {}
};

var stripShebang = function stripShebang(content) {
  // If the file data starts with a shebang remove it. Leaves the empty line
  // to keep stack trace line numbers correct.
  if (content.startsWith('#!')) {
    return content.replace(/^#!.*/, '');
  } else {
    return content;
  }
};
/**
 * This is like `writeCacheFile` but with an additional sanity checksum. We
 * cannot use the same technique for source maps because we expose source map
 * cache file paths directly to callsites, with the expectation they can read
 * it right away. This is not a great system, because source map cache file
 * could get corrupted, out-of-sync, etc.
 */


function writeCodeCacheFile(cachePath, code) {
  var checksum = _crypto()["default"].createHash('md5').update(code).digest('hex');

  writeCacheFile(cachePath, checksum + '\n' + code);
}
/**
 * Read counterpart of `writeCodeCacheFile`. We verify that the content of the
 * file matches the checksum, in case some kind of corruption happened. This
 * could happen if an older version of `jest-runtime` writes non-atomically to
 * the same cache, for example.
 */


function readCodeCacheFile(cachePath) {
  var content = readCacheFile(cachePath);

  if (content == null) {
    return null;
  }

  var code = content.substr(33);

  var checksum = _crypto()["default"].createHash('md5').update(code).digest('hex');

  if (checksum === content.substr(0, 32)) {
    return code;
  }

  return null;
}
/**
 * Writing to the cache atomically relies on 'rename' being atomic on most
 * file systems. Doing atomic write reduces the risk of corruption by avoiding
 * two processes to write to the same file at the same time. It also reduces
 * the risk of reading a file that's being overwritten at the same time.
 */


var writeCacheFile = function writeCacheFile(cachePath, fileData) {
  try {
    _writeFileAtomic()["default"].sync(cachePath, fileData, {
      encoding: 'utf8'
    });
  } catch (e) {
    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {
      return;
    }

    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\nFailure message: ' + e.message;
    removeFile(cachePath);
    throw e;
  }
};
/**
 * On Windows, renames are not atomic, leading to EPERM exceptions when two
 * processes attempt to rename to the same target file at the same time.
 * If the target file exists we can be reasonably sure another process has
 * legitimately won a cache write race and ignore the error.
 */


var cacheWriteErrorSafeToIgnore = function cacheWriteErrorSafeToIgnore(e, cachePath) {
  return process.platform === 'win32' && e.code === 'EPERM' && _gracefulFs()["default"].existsSync(cachePath);
};

var readCacheFile = function readCacheFile(cachePath) {
  if (!_gracefulFs()["default"].existsSync(cachePath)) {
    return null;
  }

  var fileData;

  try {
    fileData = _gracefulFs()["default"].readFileSync(cachePath, 'utf8');
  } catch (e) {
    e.message = 'jest: failed to read cache file: ' + cachePath + '\nFailure message: ' + e.message;
    removeFile(cachePath);
    throw e;
  }

  if (fileData == null) {
    // We must have somehow created the file but failed to write to it,
    // let's delete it and retry.
    removeFile(cachePath);
  }

  return fileData;
};

var getScriptCacheKey = function getScriptCacheKey(filename, instrument) {
  var mtime = _gracefulFs()["default"].statSync(filename).mtime;

  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');
};

var calcIgnorePatternRegExp = function calcIgnorePatternRegExp(config) {
  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {
    return undefined;
  }

  return new RegExp(config.transformIgnorePatterns.join('|'));
};

var calcTransformRegExp = function calcTransformRegExp(config) {
  if (!config.transform.length) {
    return undefined;
  }

  var transformRegexp = [];

  for (var i = 0; i < config.transform.length; i++) {
    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);
  }

  return transformRegexp;
};

var wrap = function wrap(content) {
  for (var _len = arguments.length, extras = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    extras[_key - 1] = arguments[_key];
  }

  var globals = new Set(['module', 'exports', 'require', '__dirname', '__filename', 'global', 'jest'].concat(extras));
  return '({"' + ScriptTransformer.EVAL_RESULT_VARIABLE + "\":function(".concat(Array.from(globals).join(','), "){") + content + '\n}});';
}; // TODO: Can this be added to the static property?


ScriptTransformer.EVAL_RESULT_VARIABLE = 'Object.<anonymous>';