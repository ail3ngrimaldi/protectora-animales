'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = watch;

function _path() {
  var data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _ansiEscapes() {
  var data = _interopRequireDefault(require('ansi-escapes'));

  _ansiEscapes = function _ansiEscapes() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  var data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestValidate() {
  var data = require('jest-validate');

  _jestValidate = function _jestValidate() {
    return data;
  };

  return data;
}

function _jestResolve() {
  var data = _interopRequireDefault(require('jest-resolve'));

  _jestResolve = function _jestResolve() {
    return data;
  };

  return data;
}

function _jestWatcher() {
  var data = require('jest-watcher');

  _jestWatcher = function _jestWatcher() {
    return data;
  };

  return data;
}

var _getChangedFilesPromise = _interopRequireDefault(require('./getChangedFilesPromise'));

var _is_valid_path = _interopRequireDefault(require('./lib/is_valid_path'));

var _create_context = _interopRequireDefault(require('./lib/create_context'));

var _runJest = _interopRequireDefault(require('./runJest'));

var _update_global_config = _interopRequireDefault(require('./lib/update_global_config'));

var _SearchSource = _interopRequireDefault(require('./SearchSource'));

var _TestWatcher = _interopRequireDefault(require('./TestWatcher'));

var _FailedTestsCache = _interopRequireDefault(require('./FailedTestsCache'));

var _test_path_pattern = _interopRequireDefault(require('./plugins/test_path_pattern'));

var _test_name_pattern = _interopRequireDefault(require('./plugins/test_name_pattern'));

var _update_snapshots = _interopRequireDefault(require('./plugins/update_snapshots'));

var _update_snapshots_interactive = _interopRequireDefault(require('./plugins/update_snapshots_interactive'));

var _quit = _interopRequireDefault(require('./plugins/quit'));

var _watch_plugins_helpers = require('./lib/watch_plugins_helpers');

var _active_filters_message = _interopRequireDefault(require('./lib/active_filters_message'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var preRunMessagePrint = _jestUtil().preRunMessage.print;

var hasExitListener = false;
var INTERNAL_PLUGINS = [_test_path_pattern["default"], _test_name_pattern["default"], _update_snapshots["default"], _update_snapshots_interactive["default"], _quit["default"]];
var RESERVED_KEY_PLUGINS = new Map([[_update_snapshots["default"], {
  forbiddenOverwriteMessage: 'updating snapshots',
  key: 'u'
}], [_update_snapshots_interactive["default"], {
  forbiddenOverwriteMessage: 'updating snapshots interactively',
  key: 'i'
}], [_quit["default"], {
  forbiddenOverwriteMessage: 'quitting watch mode'
}]]);

function watch(initialGlobalConfig, contexts, outputStream, hasteMapInstances) {
  var stdin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : process.stdin;
  var hooks = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new (_jestWatcher().JestHook)();
  var filter = arguments.length > 6 ? arguments[6] : undefined;
  // `globalConfig` will be constantly updated and reassigned as a result of
  // watch mode interactions.
  var globalConfig = initialGlobalConfig;
  var activePlugin;
  globalConfig = (0, _update_global_config["default"])(globalConfig, {
    mode: globalConfig.watch ? 'watch' : 'watchAll',
    passWithNoTests: true
  });

  var updateConfigAndRun = function updateConfigAndRun() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        bail = _ref.bail,
        changedSince = _ref.changedSince,
        collectCoverage = _ref.collectCoverage,
        collectCoverageFrom = _ref.collectCoverageFrom,
        collectCoverageOnlyFrom = _ref.collectCoverageOnlyFrom,
        coverageDirectory = _ref.coverageDirectory,
        coverageReporters = _ref.coverageReporters,
        mode = _ref.mode,
        notify = _ref.notify,
        notifyMode = _ref.notifyMode,
        onlyFailures = _ref.onlyFailures,
        reporters = _ref.reporters,
        testNamePattern = _ref.testNamePattern,
        testPathPattern = _ref.testPathPattern,
        updateSnapshot = _ref.updateSnapshot,
        verbose = _ref.verbose;

    var previousUpdateSnapshot = globalConfig.updateSnapshot;
    globalConfig = (0, _update_global_config["default"])(globalConfig, {
      bail: bail,
      changedSince: changedSince,
      collectCoverage: collectCoverage,
      collectCoverageFrom: collectCoverageFrom,
      collectCoverageOnlyFrom: collectCoverageOnlyFrom,
      coverageDirectory: coverageDirectory,
      coverageReporters: coverageReporters,
      mode: mode,
      notify: notify,
      notifyMode: notifyMode,
      onlyFailures: onlyFailures,
      reporters: reporters,
      testNamePattern: testNamePattern,
      testPathPattern: testPathPattern,
      updateSnapshot: updateSnapshot,
      verbose: verbose
    });
    startRun(globalConfig);
    globalConfig = (0, _update_global_config["default"])(globalConfig, {
      // updateSnapshot is not sticky after a run.
      updateSnapshot: previousUpdateSnapshot === 'all' ? 'none' : previousUpdateSnapshot
    });
  };

  var watchPlugins = INTERNAL_PLUGINS.map(function (InternalPlugin) {
    return new InternalPlugin({
      stdin: stdin,
      stdout: outputStream
    });
  });
  watchPlugins.forEach(function (plugin) {
    var hookSubscriber = hooks.getSubscriber();

    if (plugin.apply) {
      plugin.apply(hookSubscriber);
    }
  });

  if (globalConfig.watchPlugins != null) {
    var watchPluginKeys = new Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = watchPlugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var plugin = _step.value;
        var reservedInfo = RESERVED_KEY_PLUGINS.get(plugin.constructor) || {};
        var key = reservedInfo.key || getPluginKey(plugin, globalConfig);

        if (!key) {
          continue;
        }

        var forbiddenOverwriteMessage = reservedInfo.forbiddenOverwriteMessage;
        watchPluginKeys.set(key, {
          forbiddenOverwriteMessage: forbiddenOverwriteMessage,
          overwritable: forbiddenOverwriteMessage == null,
          plugin: plugin
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = globalConfig.watchPlugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var pluginWithConfig = _step2.value;

        var _plugin = void 0;

        try {
          var ThirdPartyPlugin = require(pluginWithConfig.path);

          _plugin = new ThirdPartyPlugin({
            config: pluginWithConfig.config,
            stdin: stdin,
            stdout: outputStream
          });
        } catch (error) {
          var errorWithContext = new Error("Failed to initialize watch plugin \"".concat(_chalk()["default"].bold((0, _slash()["default"])(_path()["default"].relative(process.cwd(), pluginWithConfig.path))), "\":\n\n").concat((0, _jestMessageUtil().formatExecError)(error, contexts[0].config, {
            noStackTrace: false
          })));
          delete errorWithContext.stack;
          return Promise.reject(errorWithContext);
        }

        checkForConflicts(watchPluginKeys, _plugin, globalConfig);
        var hookSubscriber = hooks.getSubscriber();

        if (_plugin.apply) {
          _plugin.apply(hookSubscriber);
        }

        watchPlugins.push(_plugin);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var failedTestsCache = new _FailedTestsCache["default"]();
  var searchSources = contexts.map(function (context) {
    return {
      context: context,
      searchSource: new _SearchSource["default"](context)
    };
  });
  var isRunning = false;
  var testWatcher;
  var shouldDisplayWatchUsage = true;
  var isWatchUsageDisplayed = false;

  var emitFileChange = function emitFileChange() {
    if (hooks.isUsed('onFileChange')) {
      var projects = searchSources.map(function (_ref2) {
        var context = _ref2.context,
            searchSource = _ref2.searchSource;
        return {
          config: context.config,
          testPaths: searchSource.findMatchingTests('').tests.map(function (t) {
            return t.path;
          })
        };
      });
      hooks.getEmitter().onFileChange({
        projects: projects
      });
    }
  };

  emitFileChange();
  hasteMapInstances.forEach(function (hasteMapInstance, index) {
    hasteMapInstance.on('change', function (_ref3) {
      var eventsQueue = _ref3.eventsQueue,
          hasteFS = _ref3.hasteFS,
          moduleMap = _ref3.moduleMap;
      var validPaths = eventsQueue.filter(function (_ref4) {
        var filePath = _ref4.filePath;
        return (0, _is_valid_path["default"])(globalConfig, filePath);
      });

      if (validPaths.length) {
        var context = contexts[index] = (0, _create_context["default"])(contexts[index].config, {
          hasteFS: hasteFS,
          moduleMap: moduleMap
        });
        activePlugin = null;
        searchSources = searchSources.slice();
        searchSources[index] = {
          context: context,
          searchSource: new _SearchSource["default"](context)
        };
        emitFileChange();
        startRun(globalConfig);
      }
    });
  });

  if (!hasExitListener) {
    hasExitListener = true;
    process.on('exit', function () {
      if (activePlugin) {
        outputStream.write(_ansiEscapes()["default"].cursorDown());
        outputStream.write(_ansiEscapes()["default"].eraseDown);
      }
    });
  }

  var startRun = function startRun(globalConfig) {
    if (isRunning) {
      return Promise.resolve(null);
    }

    testWatcher = new _TestWatcher["default"]({
      isWatchMode: true
    });
    _jestUtil().isInteractive && outputStream.write(_jestUtil().specialChars.CLEAR);
    preRunMessagePrint(outputStream);
    isRunning = true;
    var configs = contexts.map(function (context) {
      return context.config;
    });
    var changedFilesPromise = (0, _getChangedFilesPromise["default"])(globalConfig, configs); // Clear cache for required modules

    _jestResolve()["default"].clearDefaultResolverCache();

    return (0, _runJest["default"])({
      changedFilesPromise: changedFilesPromise,
      contexts: contexts,
      failedTestsCache: failedTestsCache,
      filter: filter,
      globalConfig: globalConfig,
      jestHooks: hooks.getEmitter(),
      onComplete: function onComplete(results) {
        isRunning = false;
        hooks.getEmitter().onTestRunComplete(results); // Create a new testWatcher instance so that re-runs won't be blocked.
        // The old instance that was passed to Jest will still be interrupted
        // and prevent test runs from the previous run.

        testWatcher = new _TestWatcher["default"]({
          isWatchMode: true
        }); // Do not show any Watch Usage related stuff when running in a
        // non-interactive environment

        if (_jestUtil().isInteractive) {
          if (shouldDisplayWatchUsage) {
            outputStream.write(usage(globalConfig, watchPlugins));
            shouldDisplayWatchUsage = false; // hide Watch Usage after first run

            isWatchUsageDisplayed = true;
          } else {
            outputStream.write(showToggleUsagePrompt());
            shouldDisplayWatchUsage = false;
            isWatchUsageDisplayed = false;
          }
        } else {
          outputStream.write('\n');
        }

        failedTestsCache.setTestResults(results.testResults);
      },
      outputStream: outputStream,
      startRun: startRun,
      testWatcher: testWatcher
    })["catch"](function (error // Errors thrown inside `runJest`, e.g. by resolvers, are caught here for
    ) {
      return (// continuous watch mode execution. We need to reprint them to the
        // terminal and give just a little bit of extra space so they fit below
        // `preRunMessagePrint` message nicely.
        console.error('\n\n' + (0, _jestMessageUtil().formatExecError)(error, contexts[0].config, {
          noStackTrace: false
        }))
      );
    });
  };

  var onKeypress = function onKeypress(key) {
    if (key === _jestWatcher().KEYS.CONTROL_C || key === _jestWatcher().KEYS.CONTROL_D) {
      if (typeof stdin.setRawMode === 'function') {
        stdin.setRawMode(false);
      }

      outputStream.write('\n');
      (0, _exit()["default"])(0);
      return;
    }

    if (activePlugin != null && activePlugin.onKey) {
      // if a plugin is activate, Jest should let it handle keystrokes, so ignore
      // them here
      activePlugin.onKey(key);
      return;
    } // Abort test run


    var pluginKeys = (0, _watch_plugins_helpers.getSortedUsageRows)(watchPlugins, globalConfig).map(function (usage) {
      return Number(usage.key).toString(16);
    });

    if (isRunning && testWatcher && ['q', _jestWatcher().KEYS.ENTER, 'a', 'o', 'f'].concat(pluginKeys).includes(key)) {
      testWatcher.setState({
        interrupted: true
      });
      return;
    }

    var matchingWatchPlugin = (0, _watch_plugins_helpers.filterInteractivePlugins)(watchPlugins, globalConfig).find(function (plugin) {
      return getPluginKey(plugin, globalConfig) === key;
    });

    if (matchingWatchPlugin != null) {
      if (isRunning) {
        testWatcher.setState({
          interrupted: true
        });
        return;
      } // "activate" the plugin, which has jest ignore keystrokes so the plugin
      // can handle them


      activePlugin = matchingWatchPlugin;

      if (activePlugin.run) {
        activePlugin.run(globalConfig, updateConfigAndRun).then(function (shouldRerun) {
          activePlugin = null;

          if (shouldRerun) {
            updateConfigAndRun();
          }
        }, function () {
          activePlugin = null;
          onCancelPatternPrompt();
        });
      } else {
        activePlugin = null;
      }
    }

    switch (key) {
      case _jestWatcher().KEYS.ENTER:
        startRun(globalConfig);
        break;

      case 'a':
        globalConfig = (0, _update_global_config["default"])(globalConfig, {
          mode: 'watchAll',
          testNamePattern: '',
          testPathPattern: ''
        });
        startRun(globalConfig);
        break;

      case 'c':
        updateConfigAndRun({
          mode: 'watch',
          testNamePattern: '',
          testPathPattern: ''
        });
        break;

      case 'f':
        globalConfig = (0, _update_global_config["default"])(globalConfig, {
          onlyFailures: !globalConfig.onlyFailures
        });
        startRun(globalConfig);
        break;

      case 'o':
        globalConfig = (0, _update_global_config["default"])(globalConfig, {
          mode: 'watch',
          testNamePattern: '',
          testPathPattern: ''
        });
        startRun(globalConfig);
        break;

      case '?':
        break;

      case 'w':
        if (!shouldDisplayWatchUsage && !isWatchUsageDisplayed) {
          outputStream.write(_ansiEscapes()["default"].cursorUp());
          outputStream.write(_ansiEscapes()["default"].eraseDown);
          outputStream.write(usage(globalConfig, watchPlugins));
          isWatchUsageDisplayed = true;
          shouldDisplayWatchUsage = false;
        }

        break;
    }
  };

  var onCancelPatternPrompt = function onCancelPatternPrompt() {
    outputStream.write(_ansiEscapes()["default"].cursorHide);
    outputStream.write(_jestUtil().specialChars.CLEAR);
    outputStream.write(usage(globalConfig, watchPlugins));
    outputStream.write(_ansiEscapes()["default"].cursorShow);
  };

  if (typeof stdin.setRawMode === 'function') {
    stdin.setRawMode(true);
    stdin.resume();
    stdin.setEncoding('utf8');
    stdin.on('data', onKeypress);
  }

  startRun(globalConfig);
  return Promise.resolve();
}

var checkForConflicts = function checkForConflicts(watchPluginKeys, plugin, globalConfig) {
  var key = getPluginKey(plugin, globalConfig);

  if (!key) {
    return;
  }

  var conflictor = watchPluginKeys.get(key);

  if (!conflictor || conflictor.overwritable) {
    watchPluginKeys.set(key, {
      overwritable: false,
      plugin: plugin
    });
    return;
  }

  var error;

  if (conflictor.forbiddenOverwriteMessage) {
    error = "\n  Watch plugin ".concat(_chalk()["default"].bold.red(getPluginIdentifier(plugin)), " attempted to register key ").concat(_chalk()["default"].bold.red("<".concat(key, ">")), ",\n  that is reserved internally for ").concat(_chalk()["default"].bold.red(conflictor.forbiddenOverwriteMessage), ".\n  Please change the configuration key for this plugin.").trim();
  } else {
    var plugins = [conflictor.plugin, plugin].map(function (p) {
      return _chalk()["default"].bold.red(getPluginIdentifier(p));
    }).join(' and ');
    error = "\n  Watch plugins ".concat(plugins, " both attempted to register key ").concat(_chalk()["default"].bold.red("<".concat(key, ">")), ".\n  Please change the key configuration for one of the conflicting plugins to avoid overlap.").trim();
  }

  throw new (_jestValidate().ValidationError)('Watch plugin configuration error', error);
};

var getPluginIdentifier = function getPluginIdentifier(plugin // This breaks as `displayName` is not defined as a static, but since
// WatchPlugin is an interface, and it is my understanding interface
// static fields are not definable anymore, no idea how to circumvent
// this :-(
// @ts-ignore: leave `displayName` be.
) {
  return plugin.constructor.displayName || plugin.constructor.name;
};

var getPluginKey = function getPluginKey(plugin, globalConfig) {
  if (typeof plugin.getUsageInfo === 'function') {
    return (plugin.getUsageInfo(globalConfig) || {
      key: null
    }).key;
  }

  return null;
};

var usage = function usage(globalConfig, watchPlugins) {
  var delimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '\n';
  var messages = [(0, _active_filters_message["default"])(globalConfig), globalConfig.testPathPattern || globalConfig.testNamePattern ? _chalk()["default"].dim(" \u203A Press ") + 'c' + _chalk()["default"].dim(' to clear filters.') : null, '\n' + _chalk()["default"].bold('Watch Usage'), globalConfig.watch ? _chalk()["default"].dim(" \u203A Press ") + 'a' + _chalk()["default"].dim(' to run all tests.') : null, globalConfig.onlyFailures ? _chalk()["default"].dim(" \u203A Press ") + 'f' + _chalk()["default"].dim(' to quit "only failed tests" mode.') : _chalk()["default"].dim(" \u203A Press ") + 'f' + _chalk()["default"].dim(' to run only failed tests.'), (globalConfig.watchAll || globalConfig.testPathPattern || globalConfig.testNamePattern) && !globalConfig.noSCM ? _chalk()["default"].dim(" \u203A Press ") + 'o' + _chalk()["default"].dim(' to only run tests related to changed files.') : null].concat(_toConsumableArray((0, _watch_plugins_helpers.getSortedUsageRows)(watchPlugins, globalConfig).map(function (plugin) {
    return _chalk()["default"].dim(" \u203A Press") + ' ' + plugin.key + ' ' + _chalk()["default"].dim("to ".concat(plugin.prompt, "."));
  })), [_chalk()["default"].dim(" \u203A Press ") + 'Enter' + _chalk()["default"].dim(' to trigger a test run.')]);
  return messages.filter(function (message) {
    return !!message;
  }).join(delimiter) + '\n';
};

var showToggleUsagePrompt = function showToggleUsagePrompt() {
  return '\n' + _chalk()["default"].bold('Watch Usage: ') + _chalk()["default"].dim('Press ') + 'w' + _chalk()["default"].dim(' to show more.');
};