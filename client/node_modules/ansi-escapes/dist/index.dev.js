'use strict';

var ansiEscapes = module.exports; // TODO: remove this in the next major version

module.exports["default"] = ansiEscapes;
var ESC = "\x1B[";
var OSC = "\x1B]";
var BEL = "\x07";
var SEP = ';';
var isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

ansiEscapes.cursorTo = function (x, y) {
  if (typeof x !== 'number') {
    throw new TypeError('The `x` argument is required');
  }

  if (typeof y !== 'number') {
    return ESC + (x + 1) + 'G';
  }

  return ESC + (y + 1) + ';' + (x + 1) + 'H';
};

ansiEscapes.cursorMove = function (x, y) {
  if (typeof x !== 'number') {
    throw new TypeError('The `x` argument is required');
  }

  var ret = '';

  if (x < 0) {
    ret += ESC + -x + 'D';
  } else if (x > 0) {
    ret += ESC + x + 'C';
  }

  if (y < 0) {
    ret += ESC + -y + 'A';
  } else if (y > 0) {
    ret += ESC + y + 'B';
  }

  return ret;
};

ansiEscapes.cursorUp = function () {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  return ESC + count + 'A';
};

ansiEscapes.cursorDown = function () {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  return ESC + count + 'B';
};

ansiEscapes.cursorForward = function () {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  return ESC + count + 'C';
};

ansiEscapes.cursorBackward = function () {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  return ESC + count + 'D';
};

ansiEscapes.cursorLeft = ESC + 'G';
ansiEscapes.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + 's';
ansiEscapes.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + 'u';
ansiEscapes.cursorGetPosition = ESC + '6n';
ansiEscapes.cursorNextLine = ESC + 'E';
ansiEscapes.cursorPrevLine = ESC + 'F';
ansiEscapes.cursorHide = ESC + '?25l';
ansiEscapes.cursorShow = ESC + '?25h';

ansiEscapes.eraseLines = function (count) {
  var clear = '';

  for (var i = 0; i < count; i++) {
    clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
  }

  if (count) {
    clear += ansiEscapes.cursorLeft;
  }

  return clear;
};

ansiEscapes.eraseEndLine = ESC + 'K';
ansiEscapes.eraseStartLine = ESC + '1K';
ansiEscapes.eraseLine = ESC + '2K';
ansiEscapes.eraseDown = ESC + 'J';
ansiEscapes.eraseUp = ESC + '1J';
ansiEscapes.eraseScreen = ESC + '2J';
ansiEscapes.scrollUp = ESC + 'S';
ansiEscapes.scrollDown = ESC + 'T';
ansiEscapes.clearScreen = "\x1Bc";
ansiEscapes.clearTerminal = process.platform === 'win32' ? "".concat(ansiEscapes.eraseScreen).concat(ESC, "0f") : // 1. Erases the screen (Only done in case `2` is not supported)
// 2. Erases the whole screen including scrollback buffer
// 3. Moves cursor to the top-left position
// More info: https://www.real-world-systems.com/docs/ANSIcode.html
"".concat(ansiEscapes.eraseScreen).concat(ESC, "3J").concat(ESC, "H");
ansiEscapes.beep = BEL;

ansiEscapes.link = function (text, url) {
  return [OSC, '8', SEP, SEP, url, BEL, text, OSC, '8', SEP, SEP, BEL].join('');
};

ansiEscapes.image = function (buffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ret = "".concat(OSC, "1337;File=inline=1");

  if (options.width) {
    ret += ";width=".concat(options.width);
  }

  if (options.height) {
    ret += ";height=".concat(options.height);
  }

  if (options.preserveAspectRatio === false) {
    ret += ';preserveAspectRatio=0';
  }

  return ret + ':' + buffer.toString('base64') + BEL;
};

ansiEscapes.iTerm = {
  setCwd: function setCwd() {
    var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();
    return "".concat(OSC, "50;CurrentDir=").concat(cwd).concat(BEL);
  },
  annotation: function annotation(message) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ret = "".concat(OSC, "1337;");
    var hasX = typeof options.x !== 'undefined';
    var hasY = typeof options.y !== 'undefined';

    if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
      throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
    }

    message = message.replace(/\|/g, '');
    ret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';

    if (options.length > 0) {
      ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join('|');
    } else {
      ret += message;
    }

    return ret + BEL;
  }
};